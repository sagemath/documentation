<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" /><link rel="next" title="Finite filtered complexes" href="filtered_simplicial_complex.html" /><link rel="prev" title="Morphisms and homsets for simplicial sets" href="simplicial_set_morphism.html" />

    <meta name="generator" content="sphinx-5.2.3, furo 2022.09.29"/>
        <title>Generic cell complexes - Topology</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?digest=d81277517bee4d6b0349d71bb2661d4890b5617c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom-furo.css" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  --color-brand-primary: #0f0fff;
  --color-brand-content: #0f0fff;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZGD13B5572"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ZGD13B5572');
</script></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">Topology</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><div class="sidebar-scroll"><a class="sidebar-brand" href="../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../../_static/logo_sagemath_black.svg" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../../_static/logo_sagemath_white.svg" alt="Dark Logo"/>
  </div>
  
      <span class="sidebar-brand-text">Sage 9.8 Reference Manual</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-home">
  <div class="sidebar-tree">
    <ul><li class="toctree-l1">
      <a class="reference internal" href="../../index.html">Home - Topology</a>
    </li></ul>
  </div>
</div><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="simplicial_complex.html">Finite simplicial complexes</a></li>
<li class="toctree-l1"><a class="reference internal" href="simplicial_complex_morphism.html">Morphisms of simplicial complexes</a></li>
<li class="toctree-l1"><a class="reference internal" href="simplicial_complex_homset.html">Homsets between simplicial complexes</a></li>
<li class="toctree-l1"><a class="reference internal" href="simplicial_complex_examples.html">Examples of simplicial complexes</a></li>
<li class="toctree-l1"><a class="reference internal" href="delta_complex.html">Finite Delta-complexes</a></li>
<li class="toctree-l1"><a class="reference internal" href="cubical_complex.html">Finite cubical complexes</a></li>
<li class="toctree-l1"><a class="reference internal" href="simplicial_set.html">Simplicial sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="simplicial_set_constructions.html">Methods of constructing simplicial sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="simplicial_set_examples.html">Examples of simplicial sets.</a></li>
<li class="toctree-l1"><a class="reference internal" href="simplicial_set_catalog.html">Catalog of simplicial sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="simplicial_set_morphism.html">Morphisms and homsets for simplicial sets</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Generic cell complexes</a></li>
<li class="toctree-l1"><a class="reference internal" href="filtered_simplicial_complex.html">Finite filtered complexes</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="generic-cell-complexes">
<span id="sage-topology-cell-complex"></span><h1>Generic cell complexes<a class="headerlink" href="#generic-cell-complexes" title="Permalink to this heading">#</a></h1>
<span class="target" id="module-sage.topology.cell_complex"></span><p>AUTHORS:</p>
<ul class="simple">
<li><p>John H. Palmieri (2009-08)</p></li>
</ul>
<p>This module defines a class of abstract finite cell complexes.  This
is meant as a base class from which other classes (like
<code class="xref py py-class docutils literal notranslate"><span class="pre">SimplicialComplex</span></code>,
<code class="xref py py-class docutils literal notranslate"><span class="pre">CubicalComplex</span></code>, and
<code class="xref py py-class docutils literal notranslate"><span class="pre">DeltaComplex</span></code>) should derive.  As
such, most of its properties are not implemented.  It is meant for use
by developers producing new classes, not casual users.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Keywords for <a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.chain_complex" title="sage.topology.cell_complex.GenericCellComplex.chain_complex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">chain_complex()</span></code></a>,
<a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.homology" title="sage.topology.cell_complex.GenericCellComplex.homology"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homology()</span></code></a>, etc.: any keywords given to
the <a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.homology" title="sage.topology.cell_complex.GenericCellComplex.homology"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homology()</span></code></a> method get passed on to
the <a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.chain_complex" title="sage.topology.cell_complex.GenericCellComplex.chain_complex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">chain_complex()</span></code></a> method and also to
the constructor for chain complexes in
<code class="xref py py-class docutils literal notranslate"><span class="pre">sage.homology.chain_complex.ChainComplex_class</span></code>,
as well as its associated
<a class="reference external" href="../../../homology/sage/homology/chain_complex.html#sage.homology.chain_complex.ChainComplex_class.homology" title="(in Chain complexes and homology v9.8)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homology()</span></code></a> method.
This means that those keywords should have consistent meaning in
all of those situations.  It also means that it is easy to
implement new keywords: for example, if you implement a new
keyword for the
<a class="reference external" href="../../../homology/sage/homology/chain_complex.html#sage.homology.chain_complex.ChainComplex_class.homology" title="(in Chain complexes and homology v9.8)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.homology.chain_complex.ChainComplex_class.homology()</span></code></a> method,
then it will be automatically accessible through the
<a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.homology" title="sage.topology.cell_complex.GenericCellComplex.homology"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homology()</span></code></a> method for cell complexes –
just make sure it gets documented.</p>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="sage.topology.cell_complex.GenericCellComplex">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.topology.cell_complex.</span></span><span class="sig-name descname"><span class="pre">GenericCellComplex</span></span><a class="headerlink" href="#sage.topology.cell_complex.GenericCellComplex" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/sage_object.html#sage.structure.sage_object.SageObject" title="(in Parents and Elements v9.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">SageObject</span></code></a></p>
<p>Class of abstract cell complexes.</p>
<p>This is meant to be used by developers to produce new classes, not
by casual users.  Classes which derive from this are
<code class="xref py py-class docutils literal notranslate"><span class="pre">SimplicialComplex</span></code>,
<code class="xref py py-class docutils literal notranslate"><span class="pre">DeltaComplex</span></code>, and
<code class="xref py py-class docutils literal notranslate"><span class="pre">CubicalComplex</span></code>.</p>
<p>Most of the methods here are not implemented, but probably should
be implemented in a derived class.  Most of the other methods call
a non-implemented one; their docstrings contain examples from
derived classes in which the various methods have been defined.
For example, <a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.homology" title="sage.topology.cell_complex.GenericCellComplex.homology"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homology()</span></code></a> calls <a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.chain_complex" title="sage.topology.cell_complex.GenericCellComplex.chain_complex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">chain_complex()</span></code></a>; the
class <code class="xref py py-class docutils literal notranslate"><span class="pre">DeltaComplex</span></code>
implements
<code class="xref py py-meth docutils literal notranslate"><span class="pre">chain_complex()</span></code>,
and so the <a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.homology" title="sage.topology.cell_complex.GenericCellComplex.homology"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homology()</span></code></a> method here is illustrated with
examples involving <span class="math notranslate nohighlight">\(\Delta\)</span>-complexes.</p>
<p>EXAMPLES:</p>
<p>It’s hard to give informative examples of the base class, since
essentially nothing is implemented.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.cell_complex</span> <span class="kn">import</span> <span class="n">GenericCellComplex</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenericCellComplex</span><span class="p">()</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.cell_complex.GenericCellComplex.alexander_whitney">
<span class="sig-name descname"><span class="pre">alexander_whitney</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim_left</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.cell_complex.GenericCellComplex.alexander_whitney" title="Permalink to this definition">#</a></dt>
<dd><p>The decomposition of <code class="docutils literal notranslate"><span class="pre">cell</span></code> in this complex into left and right
factors, suitable for computing cup products. This should
provide a cellular approximation for the diagonal map <span class="math notranslate nohighlight">\(K \to K
\times K\)</span>.</p>
<p>This method is not implemented for generic cell complexes, but
must be implemented for any derived class to make cup products
work in <code class="docutils literal notranslate"><span class="pre">self.cohomology_ring()</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cell</span></code> – a cell in this complex</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dim_left</span></code> – the dimension of the left-hand factors in
the decomposition</p></li>
</ul>
<p>OUTPUT: a list containing triples <code class="docutils literal notranslate"><span class="pre">(c,</span> <span class="pre">left,</span> <span class="pre">right)</span></code>.
<code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> should be cells in this complex, and
<code class="docutils literal notranslate"><span class="pre">c</span></code> an integer. In the cellular approximation of the
diagonal map, the chain represented by <code class="docutils literal notranslate"><span class="pre">cell</span></code> should get
sent to the sum of terms <span class="math notranslate nohighlight">\(c (left \otimes right)\)</span> in the
tensor product <span class="math notranslate nohighlight">\(C(K) \otimes C(K)\)</span> of the chain complex for
this complex with itself.</p>
<p>This gets used in the method
<a class="reference external" href="../../../homology/sage/homology/homology_vector_space_with_basis.html#sage.homology.homology_vector_space_with_basis.CohomologyRing.product_on_basis" title="(in Chain complexes and homology v9.8)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">product_on_basis()</span></code></a>
for the class of cohomology rings.</p>
<p>For simplicial and cubical complexes, the decomposition can be
done at the level of individual cells: see
<code class="xref py py-meth docutils literal notranslate"><span class="pre">alexander_whitney()</span></code>
and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">alexander_whitney()</span></code>. Then
the method for simplicial complexes just calls the method for
individual simplices, and similarly for cubical complexes. For
<span class="math notranslate nohighlight">\(\Delta\)</span>-complexes and simplicial sets, the method is instead
defined at the level of the cell complex.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.cell_complex</span> <span class="kn">import</span> <span class="n">GenericCellComplex</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenericCellComplex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">alexander_whitney</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">NotImplementedError: &lt;abstract method alexander_whitney at ...&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.cell_complex.GenericCellComplex.algebraic_topological_model">
<span class="sig-name descname"><span class="pre">algebraic_topological_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_ring=Rational</span> <span class="pre">Field</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.cell_complex.GenericCellComplex.algebraic_topological_model" title="Permalink to this definition">#</a></dt>
<dd><p>Algebraic topological model for this cell complex with
coefficients in <code class="docutils literal notranslate"><span class="pre">base_ring</span></code>.</p>
<p>The term “algebraic topological model” is defined by Pilarczyk
and Réal <a class="reference internal" href="../../../references/index.html#pr2015" id="id1"><span>[PR2015]</span></a>.</p>
<p>This is not implemented for generic cell complexes. For any
classes deriving from this one, when this method is
implemented, it should essentially just call either
<a class="reference external" href="../../../homology/sage/homology/algebraic_topological_model.html#sage.homology.algebraic_topological_model.algebraic_topological_model" title="(in Chain complexes and homology v9.8)"><code class="xref py py-func docutils literal notranslate"><span class="pre">algebraic_topological_model()</span></code></a>
or
<a class="reference external" href="../../../homology/sage/homology/algebraic_topological_model.html#sage.homology.algebraic_topological_model.algebraic_topological_model_delta_complex" title="(in Chain complexes and homology v9.8)"><code class="xref py py-func docutils literal notranslate"><span class="pre">algebraic_topological_model_delta_complex()</span></code></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.cell_complex</span> <span class="kn">import</span> <span class="n">GenericCellComplex</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenericCellComplex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">algebraic_topological_model</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">NotImplementedError</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.cell_complex.GenericCellComplex.betti">
<span class="sig-name descname"><span class="pre">betti</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subcomplex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.cell_complex.GenericCellComplex.betti" title="Permalink to this definition">#</a></dt>
<dd><p>The Betti numbers of this simplicial complex as a dictionary
(or a single Betti number, if only one dimension is given):
the ith Betti number is the rank of the ith homology group.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (integer or list of integers or <code class="docutils literal notranslate"><span class="pre">None</span></code>; optional,
default <code class="docutils literal notranslate"><span class="pre">None</span></code>) – If <code class="docutils literal notranslate"><span class="pre">None</span></code>, then return every Betti number, as
a dictionary with keys the non-negative integers.  If
<code class="docutils literal notranslate"><span class="pre">dim</span></code> is an integer or list, return the Betti number for
each given dimension.  (Actually, if <code class="docutils literal notranslate"><span class="pre">dim</span></code> is a list,
return the Betti numbers, as a dictionary, in the range
from <code class="docutils literal notranslate"><span class="pre">min(dim)</span></code> to <code class="docutils literal notranslate"><span class="pre">max(dim)</span></code>.  If <code class="docutils literal notranslate"><span class="pre">dim</span></code> is a number,
return the Betti number in that dimension.)</p></li>
<li><p><strong>subcomplex</strong> (optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code>) – a subcomplex of this cell complex.  Compute
the Betti numbers of the homology relative to this subcomplex.</p></li>
</ul>
</dd>
</dl>
<p>EXAMPLES:</p>
<p>Build the two-sphere as a three-fold join of a
two-point space with itself:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">S</span><span class="p">)</span><span class="o">.</span><span class="n">betti</span><span class="p">()</span>
<span class="go">{0: 1, 1: 0, 2: 1}</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">S</span><span class="p">)</span><span class="o">.</span><span class="n">betti</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">{1: 0, 2: 1}</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">S</span><span class="p">)</span><span class="o">.</span><span class="n">betti</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Or build the two-sphere as a <span class="math notranslate nohighlight">\(\Delta\)</span>-complex:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">delta_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">betti</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">{1: 0, 2: 1}</span>
</pre></div>
</div>
<p>Or as a cubical complex:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S2c</span> <span class="o">=</span> <span class="n">cubical_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2c</span><span class="o">.</span><span class="n">betti</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.cell_complex.GenericCellComplex.cells">
<span class="sig-name descname"><span class="pre">cells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subcomplex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.cell_complex.GenericCellComplex.cells" title="Permalink to this definition">#</a></dt>
<dd><p>The cells of this cell complex, in the form of a dictionary:
the keys are integers, representing dimension, and the value
associated to an integer <span class="math notranslate nohighlight">\(d\)</span> is the set of <span class="math notranslate nohighlight">\(d\)</span>-cells.  If the
optional argument <code class="docutils literal notranslate"><span class="pre">subcomplex</span></code> is present, then return only
the cells which are <em>not</em> in the subcomplex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>subcomplex</strong> (<em>optional</em><em>, </em><em>default None</em>) – a subcomplex of this cell complex.  Return
the cells which are not in this subcomplex.</p>
</dd>
</dl>
<p>This is not implemented in general; it should be implemented
in any derived class.  When implementing, see the warning in
the <a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.dimension" title="sage.topology.cell_complex.GenericCellComplex.dimension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dimension()</span></code></a> method.</p>
<p>This method is used by various other methods, such as
<a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.n_cells" title="sage.topology.cell_complex.GenericCellComplex.n_cells"><code class="xref py py-meth docutils literal notranslate"><span class="pre">n_cells()</span></code></a> and <a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.f_vector" title="sage.topology.cell_complex.GenericCellComplex.f_vector"><code class="xref py py-meth docutils literal notranslate"><span class="pre">f_vector()</span></code></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.cell_complex</span> <span class="kn">import</span> <span class="n">GenericCellComplex</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenericCellComplex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">cells</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">NotImplementedError: &lt;abstract method cells at ...&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.cell_complex.GenericCellComplex.chain_complex">
<span class="sig-name descname"><span class="pre">chain_complex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subcomplex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">augmented</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_ring</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ZZ'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cochain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.cell_complex.GenericCellComplex.chain_complex" title="Permalink to this definition">#</a></dt>
<dd><p>This is not implemented for general cell complexes.</p>
<p>Some keywords to possibly implement in a derived class:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">subcomplex</span></code> – a subcomplex: compute the relative chain complex</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">augmented</span></code> – a bool: whether to return the augmented complex</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – a bool: whether to print informational messages as
the chain complex is being computed</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – a bool: whether to check that the each
composite of two consecutive differentials is zero</p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dimensions</span></code> – if <code class="docutils literal notranslate"><span class="pre">None</span></code>, compute the chain complex in all</dt><dd><p>dimensions.  If a list or tuple of integers, compute the
chain complex in those dimensions, setting the chain groups
in all other dimensions to zero.</p>
</dd>
</dl>
</li>
</ul>
<p>Definitely implement the following:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">base_ring</span></code> – commutative ring (optional, default ZZ)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cochain</span></code> – a bool: whether to return the cochain complex</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.cell_complex</span> <span class="kn">import</span> <span class="n">GenericCellComplex</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenericCellComplex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">chain_complex</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">NotImplementedError: &lt;abstract method chain_complex at ...&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.cell_complex.GenericCellComplex.cohomology">
<span class="sig-name descname"><span class="pre">cohomology</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_ring=Integer</span> <span class="pre">Ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subcomplex=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generators=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm='pari'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduced=True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.cell_complex.GenericCellComplex.cohomology" title="Permalink to this definition">#</a></dt>
<dd><p>The reduced cohomology of this cell complex.</p>
<p>The arguments are the same as for the <a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.homology" title="sage.topology.cell_complex.GenericCellComplex.homology"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homology()</span></code></a> method,
except that <a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.homology" title="sage.topology.cell_complex.GenericCellComplex.homology"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homology()</span></code></a> accepts a <code class="docutils literal notranslate"><span class="pre">cohomology</span></code> key
word, while this function does not: <code class="docutils literal notranslate"><span class="pre">cohomology</span></code> is
automatically true here.  Indeed, this function just calls
<a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.homology" title="sage.topology.cell_complex.GenericCellComplex.homology"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homology()</span></code></a> with <code class="docutils literal notranslate"><span class="pre">cohomology</span></code> set to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> – </p></li>
<li><p><strong>base_ring</strong> – </p></li>
<li><p><strong>subcomplex</strong> – </p></li>
<li><p><strong>algorithm</strong> – </p></li>
<li><p><strong>verbose</strong> – </p></li>
<li><p><strong>reduced</strong> – </p></li>
</ul>
</dd>
</dl>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">circle</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">circle</span><span class="o">.</span><span class="n">cohomology</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">circle</span><span class="o">.</span><span class="n">cohomology</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Z</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]])</span>   <span class="c1"># projective plane</span>
<span class="gp">sage: </span><span class="n">P2</span><span class="o">.</span><span class="n">cohomology</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">C2</span>
<span class="gp">sage: </span><span class="n">P2</span><span class="o">.</span><span class="n">cohomology</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">Vector space of dimension 1 over Finite Field of size 2</span>
<span class="gp">sage: </span><span class="n">P2</span><span class="o">.</span><span class="n">cohomology</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">Vector space of dimension 0 over Finite Field of size 3</span>

<span class="gp">sage: </span><span class="n">cubical_complexes</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span><span class="o">.</span><span class="n">cohomology</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">C2</span>
</pre></div>
</div>
<p>Relative cohomology:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">U</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">cohomology</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">subcomplex</span><span class="o">=</span><span class="n">U</span><span class="p">)</span>
<span class="go">Z</span>
</pre></div>
</div>
<p>A <span class="math notranslate nohighlight">\(\Delta\)</span>-complex example:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s5</span> <span class="o">=</span> <span class="n">delta_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s5</span><span class="o">.</span><span class="n">cohomology</span><span class="p">(</span><span class="n">base_ring</span><span class="o">=</span><span class="n">GF</span><span class="p">(</span><span class="mi">7</span><span class="p">))[</span><span class="mi">5</span><span class="p">]</span>
<span class="go">Vector space of dimension 1 over Finite Field of size 7</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.cell_complex.GenericCellComplex.cohomology_ring">
<span class="sig-name descname"><span class="pre">cohomology_ring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_ring=Rational</span> <span class="pre">Field</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.cell_complex.GenericCellComplex.cohomology_ring" title="Permalink to this definition">#</a></dt>
<dd><p>Return the unreduced cohomology with coefficients in
<code class="docutils literal notranslate"><span class="pre">base_ring</span></code> with a chosen basis.</p>
<p>This is implemented for simplicial, cubical, and
<span class="math notranslate nohighlight">\(\Delta\)</span>-complexes, not for arbitrary generic cell complexes.
The resulting elements are suitable for computing cup
products. For simplicial complexes, they should be suitable
for computing cohomology operations; so far, only mod 2
cohomology operations have been implemented.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">base_ring</span></code> – coefficient ring (optional, default
<code class="docutils literal notranslate"><span class="pre">QQ</span></code>); must be a field</p></li>
</ul>
<p>The basis elements in dimension <code class="docutils literal notranslate"><span class="pre">dim</span></code> are named ‘h^{dim,i}’
where <span class="math notranslate nohighlight">\(i\)</span> ranges between 0 and <span class="math notranslate nohighlight">\(r-1\)</span>, if <span class="math notranslate nohighlight">\(r\)</span> is the rank of
the cohomology group.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For all but the smallest complexes, this is likely to be
slower than <a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.cohomology" title="sage.topology.cell_complex.GenericCellComplex.cohomology"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cohomology()</span></code></a> (with field coefficients),
possibly by several orders of magnitude. This and its
companion <a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.homology_with_basis" title="sage.topology.cell_complex.GenericCellComplex.homology_with_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homology_with_basis()</span></code></a> carry extra
information which allows computation of cup products, for
example, but because of speed issues, you may only wish to
use these if you need that extra information.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">cohomology_ring</span><span class="p">(</span><span class="n">QQ</span><span class="p">);</span> <span class="n">H</span>
<span class="go">Cohomology ring of Minimal triangulation of the Klein bottle</span>
<span class="go"> over Rational Field</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">basis</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="go">[h^{0,0}, h^{1,0}]</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">cohomology_ring</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span> <span class="n">H</span>
<span class="go">Cohomology ring of Minimal triangulation of the Klein bottle</span>
<span class="go"> over Finite Field of size 2</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">basis</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="go">[h^{0,0}, h^{1,0}, h^{1,1}, h^{2,0}]</span>

<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">delta_complexes</span><span class="o">.</span><span class="n">SurfaceOfGenus</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">cohomology_ring</span><span class="p">(</span><span class="n">QQ</span><span class="p">);</span> <span class="n">H</span>
<span class="go">Cohomology ring of Delta complex with 3 vertices and 29 simplices</span>
<span class="go"> over Rational Field</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="go">[h^{1,0}, h^{1,1}, h^{1,2}, h^{1,3}]</span>

<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span><span class="o">.</span><span class="n">cohomology_ring</span><span class="p">(</span><span class="n">QQ</span><span class="p">);</span> <span class="n">H</span>
<span class="go">Cohomology ring of Minimal triangulation of the torus</span>
<span class="go"> over Rational Field</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">basis</span><span class="p">()[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span> <span class="n">x</span>
<span class="go">h^{1,0}</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">basis</span><span class="p">()[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">];</span> <span class="n">y</span>
<span class="go">h^{1,1}</span>
</pre></div>
</div>
<p>You can compute cup products of cohomology classes:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">cup_product</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">-h^{2,0}</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="c1"># alternate notation</span>
<span class="go">-h^{2,0}</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">cup_product</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">h^{2,0}</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">cup_product</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Cohomology operations:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RP2</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">RealProjectivePlane</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">RP2</span><span class="o">.</span><span class="n">suspension</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">set_immutable</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">cohomology_ring</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">basis</span><span class="p">()[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span> <span class="n">y</span>
<span class="go">h^{2,0}</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">Sq</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">h^{3,0}</span>
</pre></div>
</div>
<p>To compute the cohomology ring, the complex must be
“immutable”. This is only relevant for simplicial complexes,
and most simplicial complexes are immutable, but certain
constructions make them mutable. The suspension is one
example, and this is the reason for calling
<code class="docutils literal notranslate"><span class="pre">K.set_immutable()</span></code> above. Another example:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">is_immutable</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">cohomology_ring</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: this simplicial complex must be immutable; call set_immutable()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">set_immutable</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">cohomology_ring</span><span class="p">()</span>
<span class="go">Cohomology ring of Simplicial complex with 9 vertices and</span>
<span class="go">18 facets over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.cell_complex.GenericCellComplex.dimension">
<span class="sig-name descname"><span class="pre">dimension</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.cell_complex.GenericCellComplex.dimension" title="Permalink to this definition">#</a></dt>
<dd><p>The dimension of this cell complex: the maximum
dimension of its cells.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If the <a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.cells" title="sage.topology.cell_complex.GenericCellComplex.cells"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cells()</span></code></a> method calls <a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.dimension" title="sage.topology.cell_complex.GenericCellComplex.dimension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dimension()</span></code></a>,
then you’ll get an infinite loop.  So either don’t use
<a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.dimension" title="sage.topology.cell_complex.GenericCellComplex.dimension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dimension()</span></code></a> or override <a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.dimension" title="sage.topology.cell_complex.GenericCellComplex.dimension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dimension()</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">RandomComplex</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">delta_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">cubical_complexes</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.cell_complex.GenericCellComplex.disjoint_union">
<span class="sig-name descname"><span class="pre">disjoint_union</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">right</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.cell_complex.GenericCellComplex.disjoint_union" title="Permalink to this definition">#</a></dt>
<dd><p>The disjoint union of this cell complex with another one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>right</strong> – the other cell complex (the right-hand factor)</p>
</dd>
</dl>
<p>Disjoint unions are not implemented for general cell complexes.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.cell_complex</span> <span class="kn">import</span> <span class="n">GenericCellComplex</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenericCellComplex</span><span class="p">();</span> <span class="n">B</span> <span class="o">=</span> <span class="n">GenericCellComplex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">NotImplementedError: &lt;abstract method disjoint_union at ...&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.cell_complex.GenericCellComplex.euler_characteristic">
<span class="sig-name descname"><span class="pre">euler_characteristic</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.cell_complex.GenericCellComplex.euler_characteristic" title="Permalink to this definition">#</a></dt>
<dd><p>The Euler characteristic of this cell complex: the
alternating sum over <span class="math notranslate nohighlight">\(n \geq 0\)</span> of the number of
<span class="math notranslate nohighlight">\(n\)</span>-cells.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">euler_characteristic</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">delta_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">euler_characteristic</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">cubical_complexes</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span><span class="o">.</span><span class="n">euler_characteristic</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.cell_complex.GenericCellComplex.f_vector">
<span class="sig-name descname"><span class="pre">f_vector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.cell_complex.GenericCellComplex.f_vector" title="Permalink to this definition">#</a></dt>
<dd><p>The <span class="math notranslate nohighlight">\(f\)</span>-vector of this cell complex: a list whose <span class="math notranslate nohighlight">\(n^{th}\)</span>
item is the number of <span class="math notranslate nohighlight">\((n-1)\)</span>-cells.  Note that, like all
lists in Sage, this is indexed starting at 0: the 0th element
in this list is the number of <span class="math notranslate nohighlight">\((-1)\)</span>-cells (which is 1: the
empty cell is the only <span class="math notranslate nohighlight">\((-1)\)</span>-cell).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 8, 24, 16]</span>
<span class="gp">sage: </span><span class="n">delta_complexes</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 1, 3, 2]</span>
<span class="gp">sage: </span><span class="n">cubical_complexes</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 42, 84, 42]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.cell_complex.GenericCellComplex.face_poset">
<span class="sig-name descname"><span class="pre">face_poset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.cell_complex.GenericCellComplex.face_poset" title="Permalink to this definition">#</a></dt>
<dd><p>The face poset of this cell complex, the poset of
nonempty cells, ordered by inclusion.</p>
<p>This uses the <a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.cells" title="sage.topology.cell_complex.GenericCellComplex.cells"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cells()</span></code></a> method, and also assumes that for
each cell <code class="docutils literal notranslate"><span class="pre">f</span></code>, all of <code class="docutils literal notranslate"><span class="pre">f.faces()</span></code>, <code class="docutils literal notranslate"><span class="pre">tuple(f)</span></code>, and
<code class="docutils literal notranslate"><span class="pre">f.dimension()</span></code> make sense.  (If this is not the case in
some derived class, as happens with <span class="math notranslate nohighlight">\(\Delta\)</span>-complexes, then
override this method.)</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span><span class="o">.</span><span class="n">face_poset</span><span class="p">();</span> <span class="n">P</span>
<span class="go">Finite poset containing 7 elements</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
<span class="go">[(0,), (0, 1), (1,), (1, 2), (2,), (2, 3), (3,)]</span>

<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">cubical_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">face_poset</span><span class="p">()</span>
<span class="go">Finite poset containing 26 elements</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.cell_complex.GenericCellComplex.graph">
<span class="sig-name descname"><span class="pre">graph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.cell_complex.GenericCellComplex.graph" title="Permalink to this definition">#</a></dt>
<dd><p>The 1-skeleton of this cell complex, as a graph.</p>
<p>This is not implemented for general cell complexes.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.cell_complex</span> <span class="kn">import</span> <span class="n">GenericCellComplex</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenericCellComplex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">NotImplementedError</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.cell_complex.GenericCellComplex.homology">
<span class="sig-name descname"><span class="pre">homology</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_ring=Integer</span> <span class="pre">Ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subcomplex=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generators=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cohomology=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm='pari'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduced=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.cell_complex.GenericCellComplex.homology" title="Permalink to this definition">#</a></dt>
<dd><p>The (reduced) homology of this cell complex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>integer</em><em> or </em><em>list</em><em> of </em><em>integers</em><em> or </em><em>None; optional</em><em>,
</em><em>default None</em>) – If None, then return the homology in every
dimension.  If <code class="docutils literal notranslate"><span class="pre">dim</span></code> is an integer or list, return the
homology in the given dimensions.  (Actually, if <code class="docutils literal notranslate"><span class="pre">dim</span></code> is
a list, return the homology in the range from <code class="docutils literal notranslate"><span class="pre">min(dim)</span></code>
to <code class="docutils literal notranslate"><span class="pre">max(dim)</span></code>.)</p></li>
<li><p><strong>base_ring</strong> (<em>optional</em><em>, </em><em>default ZZ</em>) – commutative ring, must be ZZ or a field.</p></li>
<li><p><strong>subcomplex</strong> (<em>optional</em><em>, </em><em>default empty</em>) – a subcomplex of this simplicial complex.
Compute homology relative to this subcomplex.</p></li>
<li><p><strong>generators</strong> (<em>boolean; optional</em><em>, </em><em>default False</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, return generators for the homology
groups along with the groups.</p></li>
<li><p><strong>cohomology</strong> (<em>boolean; optional</em><em>, </em><em>default False</em>) – If True, compute cohomology rather than homology.</p></li>
<li><p><strong>algorithm</strong> (<em>string; optional</em><em>, </em><em>default 'pari'</em>) – The options are ‘auto’, ‘dhsw’, or ‘pari’.
See below for a description of what they mean.</p></li>
<li><p><strong>verbose</strong> (<em>boolean; optional</em><em>, </em><em>default False</em>) – If True, print some messages as the homology is
computed.</p></li>
<li><p><strong>reduced</strong> (boolean; optional, default <code class="docutils literal notranslate"><span class="pre">True</span></code>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, return the reduced homology.</p></li>
</ul>
</dd>
</dl>
<p>ALGORITHM:</p>
<p>Compute the chain complex of <code class="docutils literal notranslate"><span class="pre">self</span></code> and compute its homology
groups.  To do this: over a field, just compute ranks and
nullities, thus obtaining dimensions of the homology groups as
vector spaces.  Over the integers, compute Smith normal form
of the boundary matrices defining the chain complex according
to the value of <code class="docutils literal notranslate"><span class="pre">algorithm</span></code>.  If <code class="docutils literal notranslate"><span class="pre">algorithm</span></code> is
<code class="docutils literal notranslate"><span class="pre">'auto'</span></code>, then for each relatively small matrix, use the
standard Sage method, which calls the Pari package.  For any
large matrix, reduce it using the Dumas, Heckenbach, Saunders,
and Welker elimination algorithm <a class="reference internal" href="../../../references/index.html#dhsw2003" id="id2"><span>[DHSW2003]</span></a>: see
<a class="reference external" href="../../../homology/sage/homology/matrix_utils.html#sage.homology.matrix_utils.dhsw_snf" title="(in Chain complexes and homology v9.8)"><code class="xref py py-func docutils literal notranslate"><span class="pre">dhsw_snf()</span></code></a> for details.</p>
<p><code class="docutils literal notranslate"><span class="pre">'no_chomp'</span></code> is a synonym for <code class="docutils literal notranslate"><span class="pre">'auto'</span></code>, maintained for
backward-compatibility.</p>
<p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> may also be <code class="docutils literal notranslate"><span class="pre">'pari'</span></code> or <code class="docutils literal notranslate"><span class="pre">'dhsw'</span></code>, which
forces the named algorithm to be used regardless of the size
of the matrices.</p>
<p>As of this writing, <code class="docutils literal notranslate"><span class="pre">'pari'</span></code> is the fastest standard option.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">delta_complexes</span><span class="o">.</span><span class="n">RealProjectivePlane</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{0: 0, 1: C2, 2: 0}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="n">reduced</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">{0: Z, 1: C2, 2: 0}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="n">base_ring</span><span class="o">=</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">{0: Vector space of dimension 0 over Finite Field of size 2,</span>
<span class="go"> 1: Vector space of dimension 1 over Finite Field of size 2,</span>
<span class="go"> 2: Vector space of dimension 1 over Finite Field of size 2}</span>
<span class="gp">sage: </span><span class="n">S7</span> <span class="o">=</span> <span class="n">delta_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S7</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Z</span>
<span class="gp">sage: </span><span class="n">cubical_complexes</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">Vector space of dimension 2 over Finite Field of size 2</span>
</pre></div>
</div>
<p>Sage can compute generators of homology groups:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">generators</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[(Vector space of dimension 1 over Finite Field of size 2, (0, 1, 2) + (0, 1, 3) + (0, 2, 3) + (1, 2, 3))]</span>
</pre></div>
</div>
<p>When generators are computed, Sage returns a pair for each
dimension: the group and the list of generators.  For
simplicial complexes, each generator is represented as a
linear combination of simplices, as above, and for cubical
complexes, each generator is a linear combination of cubes:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S2_cub</span> <span class="o">=</span> <span class="n">cubical_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2_cub</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">generators</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(Z,</span>
<span class="go"> [0,0] x [0,1] x [0,1] - [0,1] x [0,0] x [0,1] + [0,1] x [0,1] x [0,0] - [0,1] x [0,1] x [1,1] + [0,1] x [1,1] x [0,1] - [1,1] x [0,1] x [0,1])]</span>
</pre></div>
</div>
<p>Similarly for simpicial sets:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="n">generators</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{0: [], 1: 0, 2: [(Z, sigma_2)]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.cell_complex.GenericCellComplex.homology_with_basis">
<span class="sig-name descname"><span class="pre">homology_with_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_ring=Rational</span> <span class="pre">Field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cohomology=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.cell_complex.GenericCellComplex.homology_with_basis" title="Permalink to this definition">#</a></dt>
<dd><p>Return the unreduced homology of this complex with
coefficients in <code class="docutils literal notranslate"><span class="pre">base_ring</span></code> with a chosen basis.</p>
<p>This is implemented for simplicial, cubical, and
<span class="math notranslate nohighlight">\(\Delta\)</span>-complexes, not for arbitrary generic cell complexes.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">base_ring</span></code> – coefficient ring (optional, default
<code class="docutils literal notranslate"><span class="pre">QQ</span></code>); must be a field</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cohomology</span></code> – boolean (optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code>); if
<code class="docutils literal notranslate"><span class="pre">True</span></code>, return cohomology instead of homology</p></li>
</ul>
<p>Homology basis elements are named ‘h_{dim,i}’ where i ranges
between 0 and <span class="math notranslate nohighlight">\(r-1\)</span>, if <span class="math notranslate nohighlight">\(r\)</span> is the rank of the homology
group. Cohomology basis elements are denoted <span class="math notranslate nohighlight">\(h^{dim,i}\)</span>
instead.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>If <code class="docutils literal notranslate"><span class="pre">cohomology</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, this returns the cohomology
as a graded module. For the ring structure, use
<a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.cohomology_ring" title="sage.topology.cell_complex.GenericCellComplex.cohomology_ring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cohomology_ring()</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">homology_with_basis</span><span class="p">(</span><span class="n">QQ</span><span class="p">);</span> <span class="n">H</span>
<span class="go">Homology module of Minimal triangulation of the Klein bottle</span>
<span class="go"> over Rational Field</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">basis</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="go">[h_{0,0}, h_{1,0}]</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">homology_with_basis</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span> <span class="n">H</span>
<span class="go">Homology module of Minimal triangulation of the Klein bottle</span>
<span class="go"> over Finite Field of size 2</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">basis</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="go">[h_{0,0}, h_{1,0}, h_{1,1}, h_{2,0}]</span>
</pre></div>
</div>
<p>The homology is constructed as a graded object, so for
example, you can ask for the basis in a single degree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Finite family {(1, 0): h_{1,0}, (1, 1): h_{1,1}}</span>
<span class="gp">sage: </span><span class="n">S3</span> <span class="o">=</span> <span class="n">delta_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">S3</span><span class="o">.</span><span class="n">homology_with_basis</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="n">cohomology</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">[h^{3,0}]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.cell_complex.GenericCellComplex.is_acyclic">
<span class="sig-name descname"><span class="pre">is_acyclic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_ring=Integer</span> <span class="pre">Ring</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.cell_complex.GenericCellComplex.is_acyclic" title="Permalink to this definition">#</a></dt>
<dd><p>True if the reduced homology with coefficients in <code class="docutils literal notranslate"><span class="pre">base_ring</span></code> of
this cell complex is zero.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">base_ring</span></code> – optional, default <code class="docutils literal notranslate"><span class="pre">ZZ</span></code>. Compute homology
with coefficients in this ring.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RP2</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">RealProjectivePlane</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">RP2</span><span class="o">.</span><span class="n">is_acyclic</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">RP2</span><span class="o">.</span><span class="n">is_acyclic</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This first computes the Euler characteristic: if it is not 1,
the complex cannot be acyclic. So this should return <code class="docutils literal notranslate"><span class="pre">False</span></code>
reasonably quickly on complexes with Euler characteristic not
equal to 1:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">cubical_complexes</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">cubical_complexes</span><span class="o">.</span><span class="n">Cube</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span>
<span class="go">Cubical complex with 168 vertices and 1512 cubes</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">euler_characteristic</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_acyclic</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.cell_complex.GenericCellComplex.is_connected">
<span class="sig-name descname"><span class="pre">is_connected</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.cell_complex.GenericCellComplex.is_connected" title="Permalink to this definition">#</a></dt>
<dd><p>True if this cell complex is connected.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">V</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3) and facets {(3,), (0, 1, 2)}</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">U</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">ChessboardComplex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">U</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">W</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">cubical_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">cubical_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.cell_complex.GenericCellComplex.join">
<span class="sig-name descname"><span class="pre">join</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">right</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.cell_complex.GenericCellComplex.join" title="Permalink to this definition">#</a></dt>
<dd><p>The join of this cell complex with another one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>right</strong> – the other cell complex (the right-hand factor)</p>
</dd>
</dl>
<p>Joins are not implemented for general cell complexes.  They
may be implemented in some derived classes (like simplicial
complexes).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.cell_complex</span> <span class="kn">import</span> <span class="n">GenericCellComplex</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenericCellComplex</span><span class="p">();</span> <span class="n">B</span> <span class="o">=</span> <span class="n">GenericCellComplex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">NotImplementedError: &lt;abstract method join at ...&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.cell_complex.GenericCellComplex.n_cells">
<span class="sig-name descname"><span class="pre">n_cells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subcomplex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.cell_complex.GenericCellComplex.n_cells" title="Permalink to this definition">#</a></dt>
<dd><p>List of cells of dimension <code class="docutils literal notranslate"><span class="pre">n</span></code> of this cell complex.
If the optional argument <code class="docutils literal notranslate"><span class="pre">subcomplex</span></code> is present, then
return the <code class="docutils literal notranslate"><span class="pre">n</span></code>-dimensional cells which are <em>not</em> in the
subcomplex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>non-negative integer</em>) – the dimension</p></li>
<li><p><strong>subcomplex</strong> (optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code>) – a subcomplex of this cell complex. Return
the cells which are not in this subcomplex.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The resulting list need not be sorted. If you want a sorted
list of <span class="math notranslate nohighlight">\(n\)</span>-cells, use <code class="xref py py-meth docutils literal notranslate"><span class="pre">_n_cells_sorted()</span></code>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">delta_complexes</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[(0, 0), (0, 0), (0, 0)]</span>
<span class="gp">sage: </span><span class="n">cubical_complexes</span><span class="o">.</span><span class="n">Cube</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[[1,1], [0,0]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.cell_complex.GenericCellComplex.n_chains">
<span class="sig-name descname"><span class="pre">n_chains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_ring=Integer</span> <span class="pre">Ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cochains=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.cell_complex.GenericCellComplex.n_chains" title="Permalink to this definition">#</a></dt>
<dd><p>Return the free module of chains in degree <code class="docutils literal notranslate"><span class="pre">n</span></code> over <code class="docutils literal notranslate"><span class="pre">base_ring</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – integer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">base_ring</span></code> – ring (optional, default <span class="math notranslate nohighlight">\(\ZZ\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cochains</span></code> – boolean (optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code>); if
<code class="docutils literal notranslate"><span class="pre">True</span></code>, return cochains instead</p></li>
</ul>
<p>The only difference between chains and cochains is
notation. In a simplicial complex, for example, a simplex
<code class="docutils literal notranslate"><span class="pre">(0,1,2)</span></code> is written as “(0,1,2)” in the group of chains but
as “chi_(0,1,2)” in the group of cochains.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">n_chains</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">QQ</span><span class="p">)</span>
<span class="go">Free module generated by {(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)} over Rational Field</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">n_chains</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">QQ</span><span class="p">,</span> <span class="n">cochains</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">basis</span><span class="p">())</span>
<span class="go">[(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">n_chains</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">QQ</span><span class="p">,</span> <span class="n">cochains</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">basis</span><span class="p">())</span>
<span class="go">[\chi_(0, 1), \chi_(0, 2), \chi_(0, 3), \chi_(1, 2), \chi_(1, 3), \chi_(2, 3)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.cell_complex.GenericCellComplex.n_skeleton">
<span class="sig-name descname"><span class="pre">n_skeleton</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.cell_complex.GenericCellComplex.n_skeleton" title="Permalink to this definition">#</a></dt>
<dd><p>The <span class="math notranslate nohighlight">\(n\)</span>-skeleton of this cell complex: the cell
complex obtained by discarding all of the simplices in
dimensions larger than <span class="math notranslate nohighlight">\(n\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n</strong> – non-negative integer</p>
</dd>
</dl>
<p>This is not implemented for general cell complexes.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.cell_complex</span> <span class="kn">import</span> <span class="n">GenericCellComplex</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenericCellComplex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">n_skeleton</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">NotImplementedError: &lt;abstract method n_skeleton at ...&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.cell_complex.GenericCellComplex.product">
<span class="sig-name descname"><span class="pre">product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">right</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rename_vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.cell_complex.GenericCellComplex.product" title="Permalink to this definition">#</a></dt>
<dd><p>The (Cartesian) product of this cell complex with another one.</p>
<p>Products are not implemented for general cell complexes.  They
may be implemented in some derived classes (like simplicial
complexes).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.cell_complex</span> <span class="kn">import</span> <span class="n">GenericCellComplex</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenericCellComplex</span><span class="p">();</span> <span class="n">B</span> <span class="o">=</span> <span class="n">GenericCellComplex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">NotImplementedError: &lt;abstract method product at ...&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.cell_complex.GenericCellComplex.wedge">
<span class="sig-name descname"><span class="pre">wedge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">right</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.cell_complex.GenericCellComplex.wedge" title="Permalink to this definition">#</a></dt>
<dd><p>The wedge (one-point union) of this cell complex with
another one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>right</strong> – the other cell complex (the right-hand factor)</p>
</dd>
</dl>
<p>Wedges are not implemented for general cell complexes.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.cell_complex</span> <span class="kn">import</span> <span class="n">GenericCellComplex</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenericCellComplex</span><span class="p">();</span> <span class="n">B</span> <span class="o">=</span> <span class="n">GenericCellComplex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">wedge</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">NotImplementedError: &lt;abstract method wedge at ...&gt;</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="filtered_simplicial_complex.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Finite filtered complexes</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="simplicial_set_morphism.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Morphisms and homsets for simplicial sets</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2005--2023, The Sage Development Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Generic cell complexes</a><ul>
<li><a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex"><code class="docutils literal notranslate"><span class="pre">GenericCellComplex</span></code></a><ul>
<li><a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.alexander_whitney"><code class="docutils literal notranslate"><span class="pre">alexander_whitney()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.algebraic_topological_model"><code class="docutils literal notranslate"><span class="pre">algebraic_topological_model()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.betti"><code class="docutils literal notranslate"><span class="pre">betti()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.cells"><code class="docutils literal notranslate"><span class="pre">cells()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.chain_complex"><code class="docutils literal notranslate"><span class="pre">chain_complex()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.cohomology"><code class="docutils literal notranslate"><span class="pre">cohomology()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.cohomology_ring"><code class="docutils literal notranslate"><span class="pre">cohomology_ring()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.dimension"><code class="docutils literal notranslate"><span class="pre">dimension()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.disjoint_union"><code class="docutils literal notranslate"><span class="pre">disjoint_union()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.euler_characteristic"><code class="docutils literal notranslate"><span class="pre">euler_characteristic()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.f_vector"><code class="docutils literal notranslate"><span class="pre">f_vector()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.face_poset"><code class="docutils literal notranslate"><span class="pre">face_poset()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.graph"><code class="docutils literal notranslate"><span class="pre">graph()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.homology"><code class="docutils literal notranslate"><span class="pre">homology()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.homology_with_basis"><code class="docutils literal notranslate"><span class="pre">homology_with_basis()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.is_acyclic"><code class="docutils literal notranslate"><span class="pre">is_acyclic()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.is_connected"><code class="docutils literal notranslate"><span class="pre">is_connected()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.join"><code class="docutils literal notranslate"><span class="pre">join()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.n_cells"><code class="docutils literal notranslate"><span class="pre">n_cells()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.n_chains"><code class="docutils literal notranslate"><span class="pre">n_chains()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.n_skeleton"><code class="docutils literal notranslate"><span class="pre">n_skeleton()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.product"><code class="docutils literal notranslate"><span class="pre">product()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.cell_complex.GenericCellComplex.wedge"><code class="docutils literal notranslate"><span class="pre">wedge()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/scripts/furo.js"></script>
    <script src="../../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"ZZ": "\\Bold{Z}", "NN": "\\Bold{N}", "RR": "\\Bold{R}", "CC": "\\Bold{C}", "QQ": "\\Bold{Q}", "QQbar": "\\overline{\\QQ}", "GF": ["\\Bold{F}_{#1}", 1], "Zp": ["\\Bold{Z}_{#1}", 1], "Qp": ["\\Bold{Q}_{#1}", 1], "Zmod": ["\\ZZ/#1\\ZZ", 1], "CDF": "\\Bold{C}", "CIF": "\\Bold{C}", "CLF": "\\Bold{C}", "RDF": "\\Bold{R}", "RIF": "\\Bold{I} \\Bold{R}", "RLF": "\\Bold{R}", "SL": "\\mathrm{SL}", "PSL": "\\mathrm{PSL}", "Bold": ["\\mathbf{#1}", 1]}, "inlineMath": [["$", "$"], ["\\(", "\\)"]], "maxBuffer": 51200, "autoload": {"color": [], "colorv2": ["color"]}}}</script>
    <script defer="defer" src="../../../_static/mathjax/tex-chtml.js"></script>
    </body>
</html>