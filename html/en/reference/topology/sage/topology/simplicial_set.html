<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" /><link rel="next" title="Methods of constructing simplicial sets" href="simplicial_set_constructions.html" /><link rel="prev" title="Finite cubical complexes" href="cubical_complex.html" />

    <meta name="generator" content="sphinx-5.2.3, furo 2022.09.29"/>
        <title>Simplicial sets - Topology</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?digest=d81277517bee4d6b0349d71bb2661d4890b5617c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom-furo.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom-jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom-codemirror-monokai.css" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  --color-brand-primary: #0f0fff;
  --color-brand-content: #0f0fff;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">Topology</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><div class="sidebar-scroll"><a class="sidebar-brand" href="../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../../_static/logo_sagemath_black.svg" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../../_static/logo_sagemath_white.svg" alt="Dark Logo"/>
  </div>
  
      <span class="sidebar-brand-text">Sage 10.2 Reference Manual</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-home">
  <div class="sidebar-tree">
    <ul><li class="toctree-l1">
      <a class="reference internal" href="../../index.html">Home - Topology</a>
    </li></ul>
  </div>
</div><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="simplicial_complex.html">Finite simplicial complexes</a></li>
<li class="toctree-l1"><a class="reference internal" href="simplicial_complex_morphism.html">Morphisms of simplicial complexes</a></li>
<li class="toctree-l1"><a class="reference internal" href="simplicial_complex_homset.html">Homsets between simplicial complexes</a></li>
<li class="toctree-l1"><a class="reference internal" href="simplicial_complex_examples.html">Examples of simplicial complexes</a></li>
<li class="toctree-l1"><a class="reference internal" href="delta_complex.html">Finite Delta-complexes</a></li>
<li class="toctree-l1"><a class="reference internal" href="cubical_complex.html">Finite cubical complexes</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Simplicial sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="simplicial_set_constructions.html">Methods of constructing simplicial sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="simplicial_set_examples.html">Examples of simplicial sets.</a></li>
<li class="toctree-l1"><a class="reference internal" href="simplicial_set_catalog.html">Catalog of simplicial sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="simplicial_set_morphism.html">Morphisms and homsets for simplicial sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="cell_complex.html">Generic cell complexes</a></li>
<li class="toctree-l1"><a class="reference internal" href="filtered_simplicial_complex.html">Finite filtered complexes</a></li>
<li class="toctree-l1"><a class="reference internal" href="moment_angle_complex.html">Moment-angle complexes</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="simplicial-sets">
<span id="sage-topology-simplicial-set"></span><h1>Simplicial sets<a class="headerlink" href="#simplicial-sets" title="Permalink to this heading">#</a></h1>
<span class="target" id="module-sage.topology.simplicial_set"></span><p>AUTHORS:</p>
<ul class="simple">
<li><p>John H. Palmieri (2016-07)</p></li>
</ul>
<p>This module implements simplicial sets.</p>
<p>A <em>simplicial set</em> <span class="math notranslate nohighlight">\(X\)</span> is a collection of sets <span class="math notranslate nohighlight">\(X_n\)</span> indexed by the
non-negative integers; the set <span class="math notranslate nohighlight">\(X_n\)</span> is called the set of
<span class="math notranslate nohighlight">\(n\)</span>-simplices. These sets are connected by maps</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\begin{split}d_i: X_n \to X_{n-1}, \ \ 0 \leq i \leq n \ \  \text{(face maps)} \\
s_j: X_n \to X_{n+1}, \ \ 0 \leq j \leq n \ \  \text{(degeneracy maps)}\end{split}\]</div>
</div>
<p>satisfying the <em>simplicial identities</em>:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\begin{split}d_i d_j &amp;= d_{j-1} d_i \ \  \text{if } i&lt;j \\
d_i s_j &amp;= s_{j-1} d_i \ \  \text{if } i&lt;j \\
d_j s_j &amp;= 1 = d_{j+1} s_j \\
d_i s_j &amp;= s_{j} d_{i-1} \ \  \text{if } i&gt;j+1 \\
s_i s_j &amp;= s_{j+1} s_{i} \ \  \text{if } i&lt;j+1\end{split}\]</div>
</div>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Simplicial_set">Wikipedia article Simplicial_set</a>, Peter May’s seminal book <a class="reference internal" href="../../../references/index.html#may1967" id="id1"><span>[May1967]</span></a>, or
Greg Friedman’s “Illustrated introduction” <a class="reference external" href="https://arxiv.org/abs/0809.4221">arXiv 0809.4221</a> for more
information.</p>
<p>Several simplicial sets are predefined, and users can construct others
either by hand (using <a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_finite" title="sage.topology.simplicial_set.SimplicialSet_finite"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimplicialSet_finite</span></code></a>) or from existing
ones using pushouts, pullbacks, etc.</p>
<p>EXAMPLES:</p>
<p>Some of the predefined simplicial sets:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span>
<span class="go">Torus</span>
<span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">RealProjectiveSpace</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>                                        <span class="c1"># needs sage.groups</span>
<span class="go">RP^7</span>
<span class="gp">sage: </span><span class="n">S5</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="n">S5</span>
<span class="go">S^5</span>
<span class="gp">sage: </span><span class="n">S5</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[v_0, sigma_5]</span>
</pre></div>
</div>
<p>One class of infinite simplicial sets is available: classifying spaces
of groups, or more generally, nerves of finite monoids:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sigma4</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">permutation</span><span class="o">.</span><span class="n">Symmetric</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>                                      <span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">Sigma4</span><span class="o">.</span><span class="n">nerve</span><span class="p">()</span>                                                                <span class="c1"># needs sage.groups</span>
<span class="go">Nerve of Symmetric group of order 4! as a permutation group</span>
</pre></div>
</div>
<p>The same simplicial set (albeit with a different name) can also be
constructed as</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">Sigma4</span><span class="p">)</span>                                      <span class="c1"># needs sage.groups</span>
<span class="go">Classifying space of Symmetric group of order 4! as a permutation group</span>
</pre></div>
</div>
<p>Type <code class="docutils literal notranslate"><span class="pre">simplicial_sets.</span></code> and hit the <kbd class="kbd docutils literal notranslate">Tab</kbd> key to get a full list
of the predefined simplicial sets.</p>
<p>You can construct new simplicial sets from old by taking quotients,
subsimplicial sets, disjoint unions, wedges (if they are pointed),
smash products (if they are pointed and finite), products, pushouts,
pullbacks, cones, and suspensions, most of which also have maps
associated with them. Wedges, for example:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">is_pointed</span><span class="p">()</span> <span class="ow">and</span> <span class="n">S3</span><span class="o">.</span><span class="n">is_pointed</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">wedge</span><span class="p">(</span><span class="n">S3</span><span class="p">)</span>
<span class="go">Wedge: (Torus v S^3)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">S3</span><span class="p">)</span> <span class="o">==</span> <span class="n">T</span><span class="o">.</span><span class="n">coproduct</span><span class="p">(</span><span class="n">S3</span><span class="p">)</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">wedge</span><span class="p">(</span><span class="n">S3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">W</span><span class="o">.</span><span class="n">inclusion_map</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span>
<span class="go">Torus</span>
<span class="gp">sage: </span><span class="n">W</span><span class="o">.</span><span class="n">projection_map</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span>
<span class="go">Quotient: (Wedge: (Torus v S^3)/Simplicial set with 6 non-degenerate simplices)</span>
</pre></div>
</div>
<p>If the <span class="math notranslate nohighlight">\(1\)</span>-sphere were not already available via
<code class="docutils literal notranslate"><span class="pre">simplicial_sets.Sphere(1)</span></code>, you could construct it as follows:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pt</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">edge</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">cone</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">quotient</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">n_skeleton</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">S1</span>
<span class="go">Quotient: (Cone of 0-simplex/Simplicial set with 2 non-degenerate simplices)</span>
</pre></div>
</div>
<p>At this point, <code class="docutils literal notranslate"><span class="pre">S1</span></code> is pointed: every quotient is automatically
given a base point, namely the image of the subcomplex. So its
suspension is the reduced suspension, and therefore is small:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S5</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">suspension</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S5</span>
<span class="go">Sigma^4(Quotient: (Cone of 0-simplex/Simplicial set with 2 non-degenerate simplices))</span>
<span class="gp">sage: </span><span class="n">S5</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 0, 0, 0, 0, 1]</span>
</pre></div>
</div>
<p>If we forget about the base point in <code class="docutils literal notranslate"><span class="pre">S1</span></code>, we would get the
unreduced suspension instead:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z1</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">unset_base_point</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Z1</span><span class="o">.</span><span class="n">suspension</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[2, 2, 2, 2, 1, 1]</span>
</pre></div>
</div>
<p>The cone on a pointed simplicial set is the reduced cone. The
<span class="math notranslate nohighlight">\(n\)</span>-simplex in Sage is not pointed, but the simplicial set <code class="docutils literal notranslate"><span class="pre">Point</span></code>
is.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">cone</span><span class="p">()</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[2, 1]</span>
<span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Point</span><span class="p">()</span><span class="o">.</span><span class="n">cone</span><span class="p">()</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1]</span>
</pre></div>
</div>
<p>For most simplicial sets (the <code class="docutils literal notranslate"><span class="pre">Point</span></code> is the main exception), each
time it is constructed, it gives a distinct copy, and two distinct
simplicial sets are never equal:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">==</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">==</span> <span class="n">T</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span> <span class="o">==</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Point</span><span class="p">()</span> <span class="o">==</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Point</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>You can construct subsimplicial sets by specifying a list of simplices,
and then you can define the quotient simplicial set:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">g</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">subsimplicial_set</span><span class="p">([</span><span class="n">e</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">g</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">quotient</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
</pre></div>
</div>
<p>Or equivalently:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">n_skeleton</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">quotient</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span>
<span class="go">Quotient: (2-simplex/Simplicial set with 6 non-degenerate simplices)</span>
</pre></div>
</div>
<p>Note that subsimplicial sets and quotients come equipped with
inclusion and quotient morphisms:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">inc</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">inclusion_map</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">inc</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span> <span class="o">==</span> <span class="n">Y</span> <span class="ow">and</span> <span class="n">inc</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span> <span class="o">==</span> <span class="n">X</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">quo</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">quotient_map</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">quo</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span>
<span class="go">2-simplex</span>
<span class="gp">sage: </span><span class="n">quo</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span> <span class="o">==</span> <span class="n">Z</span>
<span class="go">True</span>
</pre></div>
</div>
<p>You can compute homology groups and the fundamental group of
any simplicial set:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">eight</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">wedge</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">eight</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">()</span>                                                     <span class="c1"># needs sage.groups</span>
<span class="go">Finitely presented group &lt; e0, e1 | &gt;</span>

<span class="gp">sage: </span><span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">Sigma3</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">permutation</span><span class="o">.</span><span class="n">Symmetric</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">BSigma3</span> <span class="o">=</span> <span class="n">Sigma3</span><span class="o">.</span><span class="n">nerve</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pi</span> <span class="o">=</span> <span class="n">BSigma3</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">();</span> <span class="n">pi</span>
<span class="go">Finitely presented group &lt; e1, e2 | e2^2, e1^3, (e2*e1)^2 &gt;</span>
<span class="gp">sage: </span><span class="n">pi</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="n">pi</span><span class="o">.</span><span class="n">is_abelian</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">RP6</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">RealProjectiveSpace</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>                                  <span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">RP6</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="n">reduced</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>                                  <span class="c1"># needs sage.groups sage.modules</span>
<span class="go">{0: Vector space of dimension 1 over Finite Field of size 2,</span>
<span class="go"> 1: Vector space of dimension 1 over Finite Field of size 2,</span>
<span class="go"> 2: Vector space of dimension 1 over Finite Field of size 2,</span>
<span class="go"> 3: Vector space of dimension 1 over Finite Field of size 2,</span>
<span class="go"> 4: Vector space of dimension 1 over Finite Field of size 2,</span>
<span class="go"> 5: Vector space of dimension 1 over Finite Field of size 2,</span>
<span class="go"> 6: Vector space of dimension 1 over Finite Field of size 2}</span>
<span class="gp">sage: </span><span class="n">RP6</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="n">reduced</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">)</span>                                     <span class="c1"># needs sage.groups sage.modules</span>
<span class="go">{0: Vector space of dimension 1 over Rational Field,</span>
<span class="go"> 1: Vector space of dimension 0 over Rational Field,</span>
<span class="go"> 2: Vector space of dimension 0 over Rational Field,</span>
<span class="go"> 3: Vector space of dimension 0 over Rational Field,</span>
<span class="go"> 4: Vector space of dimension 0 over Rational Field,</span>
<span class="go"> 5: Vector space of dimension 0 over Rational Field,</span>
<span class="go"> 6: Vector space of dimension 0 over Rational Field}</span>
</pre></div>
</div>
<p>When infinite simplicial sets are involved, most computations are done
by taking an <span class="math notranslate nohighlight">\(n\)</span>-skeleton for an appropriate <span class="math notranslate nohighlight">\(n\)</span>, either implicitly or
explicitly:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">MultiplicativeAbelian</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">B3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B3</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">B3</span><span class="p">)</span><span class="o">.</span><span class="n">n_skeleton</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Disjoint union: (Simplicial set with 15 non-degenerate simplices</span>
<span class="go">                  u Simplicial set with 15 non-degenerate simplices)</span>
<span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B3</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>                                             <span class="c1"># needs sage.modules</span>
<span class="go">{0: 0, 1: Z x C3, 2: C3, 3: C3}</span>
</pre></div>
</div>
<p>Without the <code class="docutils literal notranslate"><span class="pre">range</span></code> argument, this would raise an error, since
<code class="docutils literal notranslate"><span class="pre">B3</span></code> is infinite:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B3</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>                                                     <span class="c1"># needs sage.groups sage.modules</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">NotImplementedError: this simplicial set may be infinite,</span>
<span class="go">so specify dimensions when computing homology</span>
</pre></div>
</div>
<p>It should be easy to construct many simplicial sets from the
predefined ones using pushouts, pullbacks, etc., but they can also be
constructed “by hand”: first define some simplices, then define a
simplicial set by specifying their faces:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">),</span> <span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">w</span><span class="p">)})</span>
</pre></div>
</div>
<p>Now <span class="math notranslate nohighlight">\(e\)</span> is an edge from <span class="math notranslate nohighlight">\(v\)</span> to <span class="math notranslate nohighlight">\(w\)</span> and <span class="math notranslate nohighlight">\(f\)</span> is an edge starting and
ending at <span class="math notranslate nohighlight">\(w\)</span>. Therefore the first homology group of <span class="math notranslate nohighlight">\(X\)</span> should be a
copy of the integers:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>                                                                 <span class="c1"># needs sage.modules</span>
<span class="go">Z</span>
</pre></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.AbstractSimplex">
<span class="sig-prename descclassname"><span class="pre">sage.topology.simplicial_set.</span></span><span class="sig-name descname"><span class="pre">AbstractSimplex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degeneracies</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underlying</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latex_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.AbstractSimplex" title="Permalink to this definition">#</a></dt>
<dd><p>An abstract simplex, a building block of a simplicial set.</p>
<p>In a simplicial set, a simplex either is non-degenerate or is
obtained by applying degeneracy maps to a non-degenerate simplex.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dim</span></code> – a non-negative integer, the dimension of the
underlying non-degenerate simplex.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">degeneracies</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code>) – a list or tuple of
non-negative integers, the degeneracies to be applied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">underlying</span></code> (optional) – a non-degenerate simplex to which
the degeneracies are being applied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code> (optional) – string, a name for this simplex.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">latex_name</span></code> (optional) – string, a name for this simplex to
use in the LaTeX representation.</p></li>
</ul>
<p>So to define a simplex formed by applying the degeneracy maps <span class="math notranslate nohighlight">\(s_2
s_1\)</span> to a 1-simplex, call <code class="docutils literal notranslate"><span class="pre">AbstractSimplex(1,</span> <span class="pre">(2,</span> <span class="pre">1))</span></code>.</p>
<p>Specify <code class="docutils literal notranslate"><span class="pre">underlying</span></code> if you need to keep explicit track of the
underlying non-degenerate simplex, for example when computing
faces of another simplex. This is mainly for use by the method
<a class="reference internal" href="#sage.topology.simplicial_set.AbstractSimplex_class.apply_degeneracies" title="sage.topology.simplicial_set.AbstractSimplex_class.apply_degeneracies"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AbstractSimplex_class.apply_degeneracies()</span></code></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">s_3 s_1 Delta^3</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">Delta^3</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Delta^3</span>
</pre></div>
</div>
<p>Simplices may be named (or renamed), affecting how they are printed:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Delta^0</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span>
<span class="go">v</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;w_0&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span>
<span class="go">w_0</span>
<span class="gp">sage: </span><span class="n">latex</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">w_0</span>
<span class="gp">sage: </span><span class="n">latex</span><span class="p">(</span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">latex_name</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">sigma&#39;</span><span class="p">))</span>
<span class="go">\sigma</span>
</pre></div>
</div>
<p>The simplicial identities are used to put the degeneracies in
standard decreasing form:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">x</span>
<span class="go">s_2 s_1 s_0 Delta^0</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">degeneracies</span><span class="p">()</span>
<span class="go">[2, 1, 0]</span>
</pre></div>
</div>
<p>Use of the <code class="docutils literal notranslate"><span class="pre">underlying</span></code> argument:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="n">underlying</span><span class="o">=</span><span class="n">v</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span>
<span class="go">s_0 v</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">nondegenerate</span><span class="p">()</span> <span class="ow">is</span> <span class="n">v</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">is_degenerate</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Distinct non-degenerate simplices are never equal:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,)))</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,)))</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">==</span> <span class="n">f</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">nondegenerate</span><span class="p">()</span> <span class="o">==</span> <span class="n">f</span><span class="o">.</span><span class="n">nondegenerate</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>This means that if, when defining a simplicial set, you specify
the faces of a 2-simplex as:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">(e, e, e)</span>
</pre></div>
</div>
<p>then the faces are the same degenerate vertex, but if you specify
the faces as:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">(AbstractSimplex(0, ((0,))), AbstractSimplex(0, ((0,))), AbstractSimplex(0, ((0,))))</span>
</pre></div>
</div>
<p>then the faces are three different degenerate vertices.</p>
<p>View a command like <code class="docutils literal notranslate"><span class="pre">AbstractSimplex(0,</span> <span class="pre">(2,1,0))</span></code> as first
constructing <code class="docutils literal notranslate"><span class="pre">AbstractSimplex(0)</span></code> and then applying degeneracies
to it, and you always get distinct simplices from different calls
to <code class="docutils literal notranslate"><span class="pre">AbstractSimplex(0)</span></code>. On the other hand, if you apply
degeneracies to the same non-degenerate simplex, the resulting
simplices are equal:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">apply_degeneracies</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">v</span><span class="o">.</span><span class="n">apply_degeneracies</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="n">underlying</span><span class="o">=</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="n">underlying</span><span class="o">=</span><span class="n">v</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.AbstractSimplex_class">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.topology.simplicial_set.</span></span><span class="sig-name descname"><span class="pre">AbstractSimplex_class</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degeneracies</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">underlying</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latex_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.AbstractSimplex_class" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/sage_object.html#sage.structure.sage_object.SageObject" title="(in Parents and Elements v10.2)"><code class="xref py py-class docutils literal notranslate"><span class="pre">SageObject</span></code></a></p>
<p>A simplex of dimension <code class="docutils literal notranslate"><span class="pre">dim</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dim</span></code> – integer, the dimension</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">degeneracies</span></code> (optional) – iterable, the indices of the
degeneracy maps</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">underlying</span></code> (optional) – a non-degenerate simplex</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code> (optional) – string</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">latex_name</span></code> (optional) – string</p></li>
</ul>
<p>Users should not call this directly, but instead use
<a class="reference internal" href="#sage.topology.simplicial_set.AbstractSimplex" title="sage.topology.simplicial_set.AbstractSimplex"><code class="xref py py-func docutils literal notranslate"><span class="pre">AbstractSimplex()</span></code></a>. See that function for more documentation.</p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.AbstractSimplex_class.apply_degeneracies">
<span class="sig-name descname"><span class="pre">apply_degeneracies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.AbstractSimplex_class.apply_degeneracies" title="Permalink to this definition">#</a></dt>
<dd><p>Apply the degeneracies given by the arguments <code class="docutils literal notranslate"><span class="pre">args</span></code> to this simplex.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">args</span></code> – integers</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">apply_degeneracies</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">nondegenerate</span><span class="p">()</span> <span class="o">==</span> <span class="n">v</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">apply_degeneracies</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">s_1 s_0 Delta^0</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">degeneracies</span><span class="p">()</span>
<span class="go">[1, 0]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">nondegenerate</span><span class="p">()</span> <span class="o">==</span> <span class="n">v</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">apply_degeneracies</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">s_1 s_0 Delta^0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.AbstractSimplex_class.degeneracies">
<span class="sig-name descname"><span class="pre">degeneracies</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.AbstractSimplex_class.degeneracies" title="Permalink to this definition">#</a></dt>
<dd><p>Return the list of indices for the degeneracy maps for this
simplex.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">degeneracies</span><span class="p">()</span>
<span class="go">[2, 1, 0]</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">degeneracies</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.AbstractSimplex_class.dimension">
<span class="sig-name descname"><span class="pre">dimension</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.AbstractSimplex_class.dimension" title="Permalink to this definition">#</a></dt>
<dd><p>The dimension of this simplex.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">7</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.AbstractSimplex_class.is_degenerate">
<span class="sig-name descname"><span class="pre">is_degenerate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.AbstractSimplex_class.is_degenerate" title="Permalink to this definition">#</a></dt>
<dd><p>True if this simplex is degenerate.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">is_degenerate</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">is_degenerate</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.AbstractSimplex_class.is_nondegenerate">
<span class="sig-name descname"><span class="pre">is_nondegenerate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.AbstractSimplex_class.is_nondegenerate" title="Permalink to this definition">#</a></dt>
<dd><p>True if this simplex is non-degenerate.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">is_nondegenerate</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">is_nondegenerate</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">is_nondegenerate</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.AbstractSimplex_class.nondegenerate">
<span class="sig-name descname"><span class="pre">nondegenerate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.AbstractSimplex_class.nondegenerate" title="Permalink to this definition">#</a></dt>
<dd><p>The non-degenerate simplex underlying this one.</p>
<p>Therefore return itself if this simplex is non-degenerate.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">apply_degeneracies</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sigma</span><span class="o">.</span><span class="n">nondegenerate</span><span class="p">()</span>
<span class="go">v</span>
<span class="gp">sage: </span><span class="n">tau</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">tau</span><span class="o">.</span><span class="n">nondegenerate</span><span class="p">();</span> <span class="n">x</span>
<span class="go">Delta^1</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">==</span> <span class="n">tau</span><span class="o">.</span><span class="n">nondegenerate</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">Delta^1</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="n">x</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="n">tau</span><span class="o">.</span><span class="n">nondegenerate</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.NonDegenerateSimplex">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.topology.simplicial_set.</span></span><span class="sig-name descname"><span class="pre">NonDegenerateSimplex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latex_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.NonDegenerateSimplex" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.topology.simplicial_set.AbstractSimplex_class" title="sage.topology.simplicial_set.AbstractSimplex_class"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractSimplex_class</span></code></a>, <a class="reference external" href="../../../misc/sage/misc/fast_methods.html#sage.misc.fast_methods.WithEqualityById" title="(in Utilities v10.2)"><code class="xref py py-class docutils literal notranslate"><span class="pre">WithEqualityById</span></code></a></p>
<p>A nondegenerate simplex.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dim</span></code> – non-negative integer, the dimension</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code> (optional) – string, a name for this simplex.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">latex_name</span></code> (optional) – string, a name for this simplex to
use in the LaTeX representation.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span>
<span class="go">v</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.topology.simplicial_set.NonDegenerateSimplex&#39;&gt;</span>
</pre></div>
</div>
<p>Distinct non-degenerate simplices should never be equal, even
if they have the same starting data.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">v</span> <span class="o">==</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">NonDegenerateSimplex</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">NonDegenerateSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">==</span> <span class="n">NonDegenerateSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet">
<span class="sig-prename descclassname"><span class="pre">sage.topology.simplicial_set.</span></span><span class="sig-name descname"><span class="pre">SimplicialSet</span></span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet" title="Permalink to this definition">#</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_finite" title="sage.topology.simplicial_set.SimplicialSet_finite"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimplicialSet_finite</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.topology.simplicial_set.</span></span><span class="sig-name descname"><span class="pre">SimplicialSet_arbitrary</span></span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Parents and Elements v10.2)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parent</span></code></a></p>
<p>A simplicial set.</p>
<p>A simplicial set <span class="math notranslate nohighlight">\(X\)</span> is a collection of sets <span class="math notranslate nohighlight">\(X_n\)</span>, the
<em>n-simplices</em>, indexed by the non-negative integers, together with
maps</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\begin{split}d_i: X_n \to X_{n-1}, \ \ 0 \leq i \leq n \ \  \text{(face maps)} \\
s_j: X_n \to X_{n+1}, \ \ 0 \leq j \leq n \ \  \text{(degeneracy maps)}\end{split}\]</div>
</div>
<p>satisfying the <em>simplicial identities</em>:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\begin{split}d_i d_j &amp;= d_{j-1} d_i \ \  \text{if } i&lt;j \\
d_i s_j &amp;= s_{j-1} d_i \ \  \text{if } i&lt;j \\
d_j s_j &amp;= 1 = d_{j+1} s_j \\
d_i s_j &amp;= s_{j} d_{i-1} \ \  \text{if } i&gt;j+1 \\
s_i s_j &amp;= s_{j+1} s_{i} \ \  \text{if } i&lt;j+1\end{split}\]</div>
</div>
<p>This class is not fully implemented and is not intended to be
called directly by users. It is intended instead to be used by
other classes which inherit from this one. See
<a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_finite" title="sage.topology.simplicial_set.SimplicialSet_finite"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimplicialSet_finite</span></code></a> and <code class="xref py py-class docutils literal notranslate"><span class="pre">Nerve</span></code> for two
examples. In particular, any such class must implement a method
<code class="docutils literal notranslate"><span class="pre">n_skeleton</span></code> – without this, most computations will be
impossible. It must also implement an <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method which
should also set the category, so that methods defined at the
category level, like <code class="docutils literal notranslate"><span class="pre">is_pointed</span></code> and <code class="docutils literal notranslate"><span class="pre">is_finite</span></code>, work
correctly.</p>
<p>Note that the method <a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.subsimplicial_set" title="sage.topology.simplicial_set.SimplicialSet_arbitrary.subsimplicial_set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subsimplicial_set()</span></code></a> calls
<code class="xref py py-meth docutils literal notranslate"><span class="pre">n_skeleton()</span></code>, so to avoid circularity, the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">n_skeleton()</span></code> method should call
<a class="reference internal" href="simplicial_set_constructions.html#sage.topology.simplicial_set_constructions.SubSimplicialSet" title="sage.topology.simplicial_set_constructions.SubSimplicialSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">simplicial_set_constructions.SubSimplicialSet</span></code></a> directly,
not <a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.subsimplicial_set" title="sage.topology.simplicial_set.SimplicialSet_arbitrary.subsimplicial_set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subsimplicial_set()</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.alexander_whitney">
<span class="sig-name descname"><span class="pre">alexander_whitney</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">simplex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim_left</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.alexander_whitney" title="Permalink to this definition">#</a></dt>
<dd><p>Return the ‘subdivision’ of <code class="docutils literal notranslate"><span class="pre">simplex</span></code> in this simplicial set
into a pair of simplices.</p>
<p>The left factor should have dimension <code class="docutils literal notranslate"><span class="pre">dim_left</span></code>, so the
right factor should have dimension <code class="docutils literal notranslate"><span class="pre">dim</span> <span class="pre">-</span> <span class="pre">dim_left</span></code>, if
<code class="docutils literal notranslate"><span class="pre">dim</span></code> is the dimension of the starting simplex. The results
are obtained by applying iterated face maps to
<code class="docutils literal notranslate"><span class="pre">simplex</span></code>. Writing <span class="math notranslate nohighlight">\(d\)</span> for <code class="docutils literal notranslate"><span class="pre">dim</span></code> and <span class="math notranslate nohighlight">\(j\)</span> for <code class="docutils literal notranslate"><span class="pre">dim_left</span></code>:
apply <span class="math notranslate nohighlight">\(d_{j+1} d_{j+2} ... d_{d}\)</span> to get the left factor,
<span class="math notranslate nohighlight">\(d_0 ... d_0\)</span> to get the right factor.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dim_left</span></code> – integer, the dimension of the left-hand factor</p></li>
</ul>
<p>OUTPUT: a list containing the triple <code class="docutils literal notranslate"><span class="pre">(c,</span> <span class="pre">left,</span> <span class="pre">right)</span></code>,
where <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> are the two simplices described
above. If either <code class="docutils literal notranslate"><span class="pre">left</span></code> or <code class="docutils literal notranslate"><span class="pre">right</span></code> is degenerate, <code class="docutils literal notranslate"><span class="pre">c</span></code> is
0; otherwise, <code class="docutils literal notranslate"><span class="pre">c</span></code> is 1. This is so that, when used to
compute cup products, it is easy to ignore terms which have
degenerate factors.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">alexander_whitney</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">[(1, v_0, sigma_2)]</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">alexander_whitney</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[(0, s_0 v_0, s_0 v_0)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.all_n_simplices">
<span class="sig-name descname"><span class="pre">all_n_simplices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.all_n_simplices" title="Permalink to this definition">#</a></dt>
<dd><p>Return a list of all simplices, non-degenerate and degenerate, in dimension <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">degen</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">apply_degeneracies</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">tau</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;tau&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">tau</span><span class="p">:</span> <span class="p">(</span><span class="n">degen</span><span class="p">,</span> <span class="n">degen</span><span class="p">,</span> <span class="n">degen</span><span class="p">),</span> <span class="n">w</span><span class="p">:</span> <span class="kc">None</span><span class="p">})</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Y</span></code> is the disjoint union of a 2-sphere, with vertex <code class="docutils literal notranslate"><span class="pre">v</span></code>
and non-degenerate 2-simplex <code class="docutils literal notranslate"><span class="pre">tau</span></code>, and a point <code class="docutils literal notranslate"><span class="pre">w</span></code>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">all_n_simplices</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[v, w]</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">all_n_simplices</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[s_0 v, s_0 w]</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">all_n_simplices</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[tau, s_1 s_0 v, s_1 s_0 w]</span>
</pre></div>
</div>
<p>An example involving an infinite simplicial set:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C3</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">MultiplicativeAbelian</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>                           <span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">BC3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">C3</span><span class="p">)</span>                            <span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">BC3</span><span class="o">.</span><span class="n">all_n_simplices</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>                                                <span class="c1"># needs sage.groups</span>
<span class="go">[f * f,</span>
<span class="go"> f * f^2,</span>
<span class="go"> f^2 * f,</span>
<span class="go"> f^2 * f^2, s_0 f, s_0 f^2, s_1 f, s_1 f^2, s_1 s_0 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.betti">
<span class="sig-name descname"><span class="pre">betti</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subcomplex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.betti" title="Permalink to this definition">#</a></dt>
<dd><p>The Betti numbers of this simplicial complex as a dictionary
(or a single Betti number, if only one dimension is given):
the ith Betti number is the rank of the ith homology group.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dim</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code> – If <code class="docutils literal notranslate"><span class="pre">None</span></code>, then
return the homology in every dimension.  If <code class="docutils literal notranslate"><span class="pre">dim</span></code> is an
integer or list, return the homology in the given
dimensions.  (Actually, if <code class="docutils literal notranslate"><span class="pre">dim</span></code> is a list, return the
homology in the range from <code class="docutils literal notranslate"><span class="pre">min(dim)</span></code> to <code class="docutils literal notranslate"><span class="pre">max(dim)</span></code>.)</p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">subcomplex</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code>) – a subcomplex</dt><dd><p>of this cell complex.  Compute the Betti numbers of the
homology relative to this subcomplex.</p>
</dd>
</dl>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If this simplicial set is not finite, you must specify
dimensions in which to compute Betti numbers via the
argument <code class="docutils literal notranslate"><span class="pre">dim</span></code>.</p>
</div>
<p>EXAMPLES:</p>
<p>Build the two-sphere as a three-fold join of a
two-point space with itself:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">betti</span><span class="p">()</span>                                     <span class="c1"># needs sage.modules</span>
<span class="go">{0: 1, 1: 0, 2: 0, 3: 0, 4: 0, 5: 1}</span>

<span class="gp">sage: </span><span class="n">C3</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">MultiplicativeAbelian</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>                           <span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">BC3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">C3</span><span class="p">)</span>                            <span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">BC3</span><span class="o">.</span><span class="n">betti</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>                                                   <span class="c1"># needs sage.groups sage.modules</span>
<span class="go">{0: 1, 1: 0, 2: 0, 3: 0}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.cartesian_product">
<span class="sig-name descname"><span class="pre">cartesian_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">others</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.cartesian_product" title="Permalink to this definition">#</a></dt>
<dd><p>Return the product of this simplicial set with <code class="docutils literal notranslate"><span class="pre">others</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">others</span></code> – one or several simplicial sets</p></li>
</ul>
<p>If <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> are simplicial sets, then their product <span class="math notranslate nohighlight">\(X
\times Y\)</span> is defined to be the simplicial set with
<span class="math notranslate nohighlight">\(n\)</span>-simplices <span class="math notranslate nohighlight">\(X_n \times Y_n\)</span>. See
<a class="reference internal" href="simplicial_set_constructions.html#sage.topology.simplicial_set_constructions.ProductOfSimplicialSets" title="sage.topology.simplicial_set_constructions.ProductOfSimplicialSets"><code class="xref py py-class docutils literal notranslate"><span class="pre">simplicial_set_constructions.ProductOfSimplicialSets</span></code></a>
for more information.</p>
<p>If a simplicial set is constructed as a product, the factors
are recorded and are accessible via the method
<a class="reference internal" href="simplicial_set_constructions.html#sage.topology.simplicial_set_constructions.Factors.factors" title="sage.topology.simplicial_set_constructions.Factors.factors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">simplicial_set_constructions.Factors.factors()</span></code></a>.
If each factor is finite, then you can also construct the
projection maps onto each factor, the wedge as a subcomplex,
and the fat wedge as a subcomplex.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">square</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">square</span></code> is now the standard triangulation of the square: 4
vertices, 5 edges (the four on the border and the diagonal), 2
triangles:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">square</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[4, 5, 2]</span>

<span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="n">reduced</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>                                             <span class="c1"># needs sage.modules</span>
<span class="go">{0: Z, 1: Z x Z, 2: Z}</span>
</pre></div>
</div>
<p>Since <code class="docutils literal notranslate"><span class="pre">S1</span></code> is pointed, so is <code class="docutils literal notranslate"><span class="pre">T</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S1</span><span class="o">.</span><span class="n">is_pointed</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">S1</span><span class="o">.</span><span class="n">base_point</span><span class="p">()</span>
<span class="go">v_0</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">is_pointed</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">base_point</span><span class="p">()</span>
<span class="go">(v_0, v_0)</span>

<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2xS3</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">S3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2xS3</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="n">reduced</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>                                         <span class="c1"># needs sage.modules</span>
<span class="go">{0: Z, 1: 0, 2: Z, 3: Z, 4: 0, 5: Z}</span>

<span class="gp">sage: </span><span class="n">S2xS3</span><span class="o">.</span><span class="n">factors</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="n">S2</span><span class="p">,</span> <span class="n">S3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">S2xS3</span><span class="o">.</span><span class="n">factors</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="n">S3</span><span class="p">,</span> <span class="n">S2</span><span class="p">)</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">MultiplicativeAbelian</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;RP^oo&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">S2</span><span class="p">);</span> <span class="n">X</span>
<span class="go">RP^oo x RP^oo x S^2</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">factor</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">RP^oo</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">factors</span><span class="p">()</span>
<span class="go">(RP^oo, RP^oo, S^2)</span>
</pre></div>
</div>
<p>Projection maps and wedges:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S2xS3</span><span class="o">.</span><span class="n">projection_map</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: S^2 x S^3</span>
<span class="go">  To:   S^2</span>
<span class="go">  Defn: ...</span>
<span class="gp">sage: </span><span class="n">S2xS3</span><span class="o">.</span><span class="n">wedge_as_subset</span><span class="p">()</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>                                    <span class="c1"># needs sage.modules</span>
<span class="go">{0: 0, 1: 0, 2: Z, 3: Z}</span>
</pre></div>
</div>
<p>In the case of pointed simplicial sets, there is an inclusion
of each factor into the product. These are not automatically
defined in Sage, but they are easy to construct using identity
maps and constant maps and the universal property of the
product:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">one</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">identity</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">const</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">constant_map</span><span class="p">(</span><span class="n">codomain</span><span class="o">=</span><span class="n">S3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2xS3</span><span class="o">.</span><span class="n">universal_property</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">const</span><span class="p">)</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: S^2</span>
<span class="go">  To:   S^2 x S^3</span>
<span class="go">  Defn: [v_0, sigma_2] --&gt; [(v_0, v_0), (sigma_2, s_1 s_0 v_0)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.cells">
<span class="sig-name descname"><span class="pre">cells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subcomplex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.cells" title="Permalink to this definition">#</a></dt>
<dd><p>Return a dictionary of all non-degenerate simplices.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">subcomplex</span></code> (optional) – a subsimplicial set of this
simplicial set. If <code class="docutils literal notranslate"><span class="pre">subcomplex</span></code> is specified, then return the
simplices in the quotient by the subcomplex.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_dim</span></code> – optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code>. If specified,
return the non-degenerate simplices of this dimension or
smaller. This argument is required if this simplicial set is
infinite.</p></li>
</ul>
<p>Each key is a dimension, and the corresponding value is the
list of simplices in that dimension.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S0</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">v</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="kc">None</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">S0</span><span class="o">.</span><span class="n">cells</span><span class="p">()</span>
<span class="go">{0: [Delta^0, Delta^0]}</span>

<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S0</span><span class="o">.</span><span class="n">cells</span><span class="p">()</span>
<span class="go">{0: [v, w]}</span>

<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">S1</span><span class="o">.</span><span class="n">cells</span><span class="p">()</span>
<span class="go">{0: [v], 1: [e]}</span>

<span class="gp">sage: </span><span class="n">S0</span><span class="o">.</span><span class="n">cells</span><span class="p">(</span><span class="n">S0</span><span class="o">.</span><span class="n">subsimplicial_set</span><span class="p">([</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">]))</span>
<span class="go">{0: [*]}</span>

<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">cells</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">subsimplicial_set</span><span class="p">([</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">]))</span>
<span class="go">{0: [*], 1: [e]}</span>
</pre></div>
</div>
<p>Test an infinite example:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">C3</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">MultiplicativeAbelian</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">BC3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">C3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">BC3</span><span class="o">.</span><span class="n">cells</span><span class="p">(</span><span class="n">max_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">{0: [1], 1: [f, f^2], 2: [f * f, f * f^2, f^2 * f, f^2 * f^2]}</span>
<span class="gp">sage: </span><span class="n">BC3</span><span class="o">.</span><span class="n">cells</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">NotImplementedError: this simplicial set may be infinite, so specify max_dim</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.chain_complex">
<span class="sig-name descname"><span class="pre">chain_complex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dimensions=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_ring=Integer</span> <span class="pre">Ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">augmented=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cochain=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subcomplex=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.chain_complex" title="Permalink to this definition">#</a></dt>
<dd><p>Return the normalized chain complex.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dimensions</span></code> – if <code class="docutils literal notranslate"><span class="pre">None</span></code>, compute the chain complex in all
dimensions.  If a list or tuple of integers, compute the
chain complex in those dimensions, setting the chain groups
in all other dimensions to zero.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">base_ring</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">ZZ</span></code>) – commutative ring</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">augmented</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code>) – if <code class="docutils literal notranslate"><span class="pre">True</span></code>,
return the augmented chain complex (that is, include a class
in dimension <span class="math notranslate nohighlight">\(-1\)</span> corresponding to the empty cell).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cochain</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code>) – if <code class="docutils literal notranslate"><span class="pre">True</span></code>,
return the cochain complex (that is, the dual of the chain
complex).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code>) – ignored.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">subcomplex</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code>) – if present,
compute the chain complex relative to this subcomplex.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, make
sure that the chain complex is actually a chain complex:
the differentials are composable and their product is zero.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If this simplicial set is not finite, you must specify
dimensions in which to compute its chain complex via the
argument <code class="docutils literal notranslate"><span class="pre">dimensions</span></code>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">chain_complex</span><span class="p">()</span>                             <span class="c1"># needs sage.modules</span>
<span class="go">Chain complex with at most 3 nonzero terms over Integer Ring</span>

<span class="gp">sage: </span><span class="n">C3</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">MultiplicativeAbelian</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>                           <span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">BC3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">C3</span><span class="p">)</span>                            <span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">BC3</span><span class="o">.</span><span class="n">chain_complex</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>                          <span class="c1"># needs sage.groups sage.modules</span>
<span class="go">Chain complex with at most 4 nonzero terms over Finite Field of size 3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.cohomology">
<span class="sig-name descname"><span class="pre">cohomology</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.cohomology" title="Permalink to this definition">#</a></dt>
<dd><p>Return the cohomology of this simplicial set.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dim</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code> – If <code class="docutils literal notranslate"><span class="pre">None</span></code>, then
return the homology in every dimension.  If <code class="docutils literal notranslate"><span class="pre">dim</span></code> is an
integer or list, return the homology in the given
dimensions.  (Actually, if <code class="docutils literal notranslate"><span class="pre">dim</span></code> is a list, return the
homology in the range from <code class="docutils literal notranslate"><span class="pre">min(dim)</span></code> to <code class="docutils literal notranslate"><span class="pre">max(dim)</span></code>.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">base_ring</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">ZZ</span></code>) – commutative
ring, must be <code class="docutils literal notranslate"><span class="pre">ZZ</span></code> or a field.</p></li>
</ul>
<p>Other arguments are also allowed, the same as for the
<a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.homology" title="sage.topology.simplicial_set.SimplicialSet_arbitrary.homology"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homology()</span></code></a> method – see
<a class="reference internal" href="cell_complex.html#sage.topology.cell_complex.GenericCellComplex.homology" title="sage.topology.cell_complex.GenericCellComplex.homology"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cell_complex.GenericCellComplex.homology()</span></code></a> for complete
documentation – except that <a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.homology" title="sage.topology.simplicial_set.SimplicialSet_arbitrary.homology"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homology()</span></code></a> accepts a
<code class="docutils literal notranslate"><span class="pre">cohomology</span></code> key word, while this function does not:
<code class="docutils literal notranslate"><span class="pre">cohomology</span></code> is automatically true here.  Indeed, this
function just calls <a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.homology" title="sage.topology.simplicial_set.SimplicialSet_arbitrary.homology"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homology()</span></code></a> with argument
<code class="docutils literal notranslate"><span class="pre">cohomology=True</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If this simplicial set is not finite, you must specify
dimensions in which to compute homology via the argument
<code class="docutils literal notranslate"><span class="pre">dim</span></code>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>                             <span class="c1"># needs sage.modules</span>
<span class="go">Z x C2</span>
<span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span><span class="o">.</span><span class="n">cohomology</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>                           <span class="c1"># needs sage.modules</span>
<span class="go">Z</span>
<span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span><span class="o">.</span><span class="n">cohomology</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>                           <span class="c1"># needs sage.modules</span>
<span class="go">C2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.cone">
<span class="sig-name descname"><span class="pre">cone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.cone" title="Permalink to this definition">#</a></dt>
<dd><p>Return the (reduced) cone on this simplicial set.</p>
<p>If this simplicial set <span class="math notranslate nohighlight">\(X\)</span> is not pointed, construct the
ordinary cone: add a point <span class="math notranslate nohighlight">\(v\)</span> (which will become the base
point) and for each simplex <span class="math notranslate nohighlight">\(\sigma\)</span> in <span class="math notranslate nohighlight">\(X\)</span>, add both <span class="math notranslate nohighlight">\(\sigma\)</span>
and a simplex made up of <span class="math notranslate nohighlight">\(v\)</span> and <span class="math notranslate nohighlight">\(\sigma\)</span> (topologically, form
the join of <span class="math notranslate nohighlight">\(v\)</span> and <span class="math notranslate nohighlight">\(\sigma\)</span>).</p>
<p>If this simplicial set is pointed, then construct the reduced
cone: take the quotient of the unreduced cone by the 1-simplex
connecting the old base point to the new one.</p>
<p>In either case, as long as the simplicial set is finite, it
comes equipped in Sage with a map from it into the cone.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">CX</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">cone</span><span class="p">()</span>  <span class="c1"># unreduced cone, since X not pointed</span>
<span class="gp">sage: </span><span class="n">CX</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[*, v, (v,*), e, (e,*)]</span>
<span class="gp">sage: </span><span class="n">CX</span><span class="o">.</span><span class="n">base_point</span><span class="p">()</span>
<span class="go">*</span>
</pre></div>
</div>
<p><span class="math notranslate nohighlight">\(X\)</span> as a subset of the cone, and also the map from <span class="math notranslate nohighlight">\(X\)</span>, in the
unreduced case:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">CX</span><span class="o">.</span><span class="n">base_as_subset</span><span class="p">()</span>
<span class="go">Simplicial set with 2 non-degenerate simplices</span>
<span class="gp">sage: </span><span class="n">CX</span><span class="o">.</span><span class="n">map_from_base</span><span class="p">()</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">From: Simplicial set with 2 non-degenerate simplices</span>
<span class="go">  To:   Cone of Simplicial set with 2 non-degenerate simplices</span>
<span class="go">  Defn: [v, e] --&gt; [v, e]</span>
</pre></div>
</div>
<p>In the reduced case, only the map from <span class="math notranslate nohighlight">\(X\)</span> is available:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">set_base_point</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">CX</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">cone</span><span class="p">()</span>  <span class="c1"># reduced cone</span>
<span class="gp">sage: </span><span class="n">CX</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[*, e, (e,*)]</span>
<span class="gp">sage: </span><span class="n">CX</span><span class="o">.</span><span class="n">map_from_base</span><span class="p">()</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: Simplicial set with 2 non-degenerate simplices</span>
<span class="go">  To:   Reduced cone of Simplicial set with 2 non-degenerate simplices</span>
<span class="go">  Defn: [v, e] --&gt; [*, e]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.constant_map">
<span class="sig-name descname"><span class="pre">constant_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">codomain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.constant_map" title="Permalink to this definition">#</a></dt>
<dd><p>Return a constant map with this simplicial set as its domain.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">codomain</span></code> – optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
codomain is the standard one-point space constructed by
<code class="xref py py-func docutils literal notranslate"><span class="pre">Point()</span></code>. Otherwise, either the codomain must be a
pointed simplicial set, in which case the map is constant at
the base point, or <code class="docutils literal notranslate"><span class="pre">point</span></code> must be specified.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">point</span></code> – optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code>. If specified, it
must be a 0-simplex in the codomain, and it will be the
target of the constant map.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S4</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S4</span><span class="o">.</span><span class="n">constant_map</span><span class="p">()</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: S^4</span>
<span class="go">  To:   Point</span>
<span class="go">  Defn: Constant map at *</span>
<span class="gp">sage: </span><span class="n">S0</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S4</span><span class="o">.</span><span class="n">constant_map</span><span class="p">(</span><span class="n">codomain</span><span class="o">=</span><span class="n">S0</span><span class="p">)</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: S^4</span>
<span class="go">  To:   S^0</span>
<span class="go">  Defn: Constant map at v_0</span>

<span class="gp">sage: </span><span class="n">Sigma3</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">permutation</span><span class="o">.</span><span class="n">Symmetric</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>                              <span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">Sigma3</span><span class="o">.</span><span class="n">nerve</span><span class="p">()</span><span class="o">.</span><span class="n">constant_map</span><span class="p">()</span>                                         <span class="c1"># needs sage.groups</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: Nerve of Symmetric group of order 3! as a permutation group</span>
<span class="go">  To:   Point</span>
<span class="go">  Defn: Constant map at *</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.coproduct">
<span class="sig-name descname"><span class="pre">coproduct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">others</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.coproduct" title="Permalink to this definition">#</a></dt>
<dd><p>Return the coproduct of this simplicial set with <code class="docutils literal notranslate"><span class="pre">others</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">others</span></code> – one or several simplicial sets</p></li>
</ul>
<p>If these simplicial sets are pointed, return their wedge sum;
if they are not, return their disjoint union. If some are
pointed and some are not, raise an error: it is not clear in
which category to work.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">unset_base_point</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">unset_base_point</span><span class="p">()</span>

<span class="gp">sage:</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">coproduct</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">is_pointed</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">coproduct</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="go">Wedge: (S^2 v Klein bottle)</span>
<span class="gp">sage: </span><span class="n">D3</span><span class="o">.</span><span class="n">coproduct</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span><span class="o">.</span><span class="n">is_pointed</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">D3</span><span class="o">.</span><span class="n">coproduct</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>
<span class="go">Disjoint union: (3-simplex u Simplicial set with 2 non-degenerate simplices</span>
<span class="go">                 u Simplicial set with 6 non-degenerate simplices)</span>
</pre></div>
</div>
<p>The coproduct comes equipped with an inclusion map from each
summand, as long as the summands are all finite:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">coproduct</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">inclusion_map</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: S^2</span>
<span class="go">  To:   Wedge: (S^2 v Klein bottle)</span>
<span class="go">  Defn: [v_0, sigma_2] --&gt; [*, sigma_2]</span>
<span class="gp">sage: </span><span class="n">D3</span><span class="o">.</span><span class="n">coproduct</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span><span class="o">.</span><span class="n">inclusion_map</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: Simplicial set with 6 non-degenerate simplices</span>
<span class="go">  To:   Disjoint union: (3-simplex</span>
<span class="go">                         u Simplicial set with 2 non-degenerate simplices</span>
<span class="go">                         u Simplicial set with 6 non-degenerate simplices)</span>
<span class="go">  Defn: [Delta_{0,0}, Delta_{1,0}, Delta_{1,1}, Delta_{1,2}, Delta_{2,0}, Delta_{2,1}]</span>
<span class="go">        --&gt; [Delta_{0,0}, Delta_{1,0}, Delta_{1,1}, Delta_{1,2}, Delta_{2,0}, Delta_{2,1}]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.disjoint_union">
<span class="sig-name descname"><span class="pre">disjoint_union</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">others</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.disjoint_union" title="Permalink to this definition">#</a></dt>
<dd><p>Return the disjoint union of this simplicial set with <code class="docutils literal notranslate"><span class="pre">others</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">others</span></code> – one or several simplicial sets</p></li>
</ul>
<p>As long as the factors are all finite, the inclusion map from
each factor is available. Any factors which are empty are
ignored completely: they do not appear in the list of factors,
etc.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
</pre></div>
</div>
<p>Since <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> have simplices in common, Sage uses a
copy of <code class="docutils literal notranslate"><span class="pre">Y</span></code> when constructing the disjoint union. Note the
name conflict in the list of simplices: <code class="docutils literal notranslate"><span class="pre">v</span></code> appears twice:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[v, v, w, e, f]</span>
</pre></div>
</div>
<p>Factors and inclusion maps:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">factors</span><span class="p">()</span>
<span class="go">(Torus, S^2)</span>
<span class="gp">sage: </span><span class="n">i</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">inclusion_map</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">i</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span>
<span class="go">Torus</span>
<span class="gp">sage: </span><span class="n">i</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span>
<span class="go">Disjoint union: (Torus u S^2)</span>
</pre></div>
</div>
<p>Empty factors are ignored:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set_examples</span> <span class="kn">import</span> <span class="n">Empty</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">Empty</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">S2</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">S2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">==</span> <span class="n">S2</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">S2</span><span class="p">,</span> <span class="n">S2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">factors</span><span class="p">()</span>
<span class="go">(S^2, S^2, S^2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.face">
<span class="sig-name descname"><span class="pre">face</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">simplex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.face" title="Permalink to this definition">#</a></dt>
<dd><p>Return the <span class="math notranslate nohighlight">\(i\)</span>-th face of <code class="docutils literal notranslate"><span class="pre">simplex</span></code> in this simplicial set.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">simplex</span></code> – a simplex in this simplicial set</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">i</span></code> – integer</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">v_0</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">face</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">s_0 v_0</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">face</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">v_0</span><span class="o">.</span><span class="n">apply_degeneracies</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">face</span><span class="p">(</span><span class="n">S2</span><span class="o">.</span><span class="n">face</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">v_0</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.faces">
<span class="sig-name descname"><span class="pre">faces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">simplex</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.faces" title="Permalink to this definition">#</a></dt>
<dd><p>Return the list of faces of <code class="docutils literal notranslate"><span class="pre">simplex</span></code> in this simplicial set.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">simplex</span></code> – a simplex in this simplicial set, either
degenerate or not</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">faces</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
<span class="go">(s_0 v_0, s_0 v_0, s_0 v_0)</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">faces</span><span class="p">(</span><span class="n">sigma</span><span class="o">.</span><span class="n">apply_degeneracies</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[sigma_2, sigma_2, s_1 s_0 v_0, s_1 s_0 v_0]</span>

<span class="gp">sage: </span><span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">C3</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">MultiplicativeAbelian</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">BC3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">C3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f2</span> <span class="o">=</span> <span class="n">BC3</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">];</span> <span class="n">f2</span>
<span class="go">f^2</span>
<span class="gp">sage: </span><span class="n">BC3</span><span class="o">.</span><span class="n">faces</span><span class="p">(</span><span class="n">f2</span><span class="p">)</span>
<span class="go">(1, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.graph">
<span class="sig-name descname"><span class="pre">graph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.graph" title="Permalink to this definition">#</a></dt>
<dd><p>Return the 1-skeleton of this simplicial set, as a graph.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Delta3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Delta3</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[((0,), (1,), (0, 1)),</span>
<span class="go"> ((0,), (2,), (0, 2)),</span>
<span class="go"> ((0,), (3,), (0, 3)),</span>
<span class="go"> ((1,), (2,), (1, 2)),</span>
<span class="go"> ((1,), (3,), (1, 3)),</span>
<span class="go"> ((2,), (3,), (2, 3))]</span>

<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="go">Looped multi-graph on 1 vertex</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">3</span>

<span class="gp">sage: </span><span class="c1"># needs pyparsing</span>
<span class="gp">sage: </span><span class="n">CP3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ComplexProjectiveSpace</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">CP3</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">0</span>

<span class="gp">sage: </span><span class="n">Sigma3</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">permutation</span><span class="o">.</span><span class="n">Symmetric</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>                              <span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">Sigma3</span><span class="o">.</span><span class="n">nerve</span><span class="p">()</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>                                         <span class="c1"># needs sage.groups</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.homology">
<span class="sig-name descname"><span class="pre">homology</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.homology" title="Permalink to this definition">#</a></dt>
<dd><p>Return the (reduced) homology of this simplicial set.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dim</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code> – If <code class="docutils literal notranslate"><span class="pre">None</span></code>, then
return the homology in every dimension.  If <code class="docutils literal notranslate"><span class="pre">dim</span></code> is an
integer or list, return the homology in the given
dimensions.  (Actually, if <code class="docutils literal notranslate"><span class="pre">dim</span></code> is a list, return the
homology in the range from <code class="docutils literal notranslate"><span class="pre">min(dim)</span></code> to <code class="docutils literal notranslate"><span class="pre">max(dim)</span></code>.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">base_ring</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">ZZ</span></code>) – commutative
ring, must be <code class="docutils literal notranslate"><span class="pre">ZZ</span></code> or a field.</p></li>
</ul>
<p>Other arguments are also allowed: see the documentation for
<a class="reference internal" href="cell_complex.html#sage.topology.cell_complex.GenericCellComplex.homology" title="sage.topology.cell_complex.GenericCellComplex.homology"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cell_complex.GenericCellComplex.homology()</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If this simplicial set is not finite, you must specify
dimensions in which to compute homology via the argument
<code class="docutils literal notranslate"><span class="pre">dim</span></code>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>                                  <span class="c1"># needs sage.modules</span>
<span class="go">{0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: Z}</span>

<span class="gp">sage: </span><span class="n">C3</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">MultiplicativeAbelian</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>                           <span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">BC3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">C3</span><span class="p">)</span>                            <span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">BC3</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>                               <span class="c1"># needs sage.groups sage.modules</span>
<span class="go">{0: Vector space of dimension 0 over Finite Field of size 3,</span>
<span class="go"> 1: Vector space of dimension 1 over Finite Field of size 3,</span>
<span class="go"> 2: Vector space of dimension 1 over Finite Field of size 3,</span>
<span class="go"> 3: Vector space of dimension 1 over Finite Field of size 3}</span>

<span class="gp">sage: </span><span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">C2</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">MultiplicativeAbelian</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">BC2</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">C2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">BK</span> <span class="o">=</span> <span class="n">BC2</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">BC2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">BK</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>                                                 <span class="c1"># needs sage.modules</span>
<span class="go">{0: 0, 1: C2 x C2, 2: C2, 3: C2 x C2 x C2}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.identity">
<span class="sig-name descname"><span class="pre">identity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.identity" title="Permalink to this definition">#</a></dt>
<dd><p>Return the identity map on this simplicial set.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S3</span><span class="o">.</span><span class="n">identity</span><span class="p">()</span>
<span class="go">Simplicial set endomorphism of S^3</span>
<span class="go">  Defn: Identity map</span>

<span class="gp">sage: </span><span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">C3</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">MultiplicativeAbelian</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">BC3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">C3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">one</span> <span class="o">=</span> <span class="n">BC3</span><span class="o">.</span><span class="n">identity</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">one</span><span class="p">(</span><span class="n">sigma</span><span class="p">))</span> <span class="k">for</span> <span class="n">sigma</span> <span class="ow">in</span> <span class="n">BC3</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
<span class="go">[(f * f, f * f),</span>
<span class="go"> (f * f^2, f * f^2),</span>
<span class="go"> (f^2 * f, f^2 * f),</span>
<span class="go"> (f^2 * f^2, f^2 * f^2)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.is_connected">
<span class="sig-name descname"><span class="pre">is_connected</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.is_connected" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if this simplicial set is connected.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.is_reduced">
<span class="sig-name descname"><span class="pre">is_reduced</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.is_reduced" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if this simplicial set has only one vertex.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">is_reduced</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">is_reduced</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.join">
<span class="sig-name descname"><span class="pre">join</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">others</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.join" title="Permalink to this definition">#</a></dt>
<dd><p>The join of this simplicial set with <code class="docutils literal notranslate"><span class="pre">others</span></code>.</p>
<p>Not implemented. See
<a class="reference external" href="https://ncatlab.org/nlab/show/join+of+simplicial+sets">https://ncatlab.org/nlab/show/join+of+simplicial+sets</a> for a
few descriptions, for anyone interested in implementing
this. See also P. J. Ehlers and Tim Porter, Joins for
(Augmented) Simplicial Sets, Jour. Pure Applied Algebra, 145
(2000) 37-44 <a class="reference external" href="https://arxiv.org/abs/9904039">arXiv 9904039</a>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">others</span></code> – one or several simplicial sets</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">NotImplementedError: joins are not implemented for simplicial sets</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.n_cells">
<span class="sig-name descname"><span class="pre">n_cells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subcomplex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.n_cells" title="Permalink to this definition">#</a></dt>
<dd><p>Return the list of cells of dimension <code class="docutils literal notranslate"><span class="pre">n</span></code> of this cell complex.
If the optional argument <code class="docutils literal notranslate"><span class="pre">subcomplex</span></code> is present, then
return the <code class="docutils literal notranslate"><span class="pre">n</span></code>-dimensional faces in the quotient by this
subcomplex.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – the dimension</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">subcomplex</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code>) – a subcomplex
of this cell complex. Return the cells which are in the
quotient by this subcomplex.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[sigma_3]</span>
<span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">C2</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">MultiplicativeAbelian</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>                           <span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">BC2</span> <span class="o">=</span> <span class="n">C2</span><span class="o">.</span><span class="n">nerve</span><span class="p">()</span>                                                      <span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">BC2</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>                                                        <span class="c1"># needs sage.groups</span>
<span class="go">[f * f * f]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.n_chains">
<span class="sig-name descname"><span class="pre">n_chains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_ring=Integer</span> <span class="pre">Ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cochains=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.n_chains" title="Permalink to this definition">#</a></dt>
<dd><p>Return the free module of (normalized) chains in degree <code class="docutils literal notranslate"><span class="pre">n</span></code>
over <code class="docutils literal notranslate"><span class="pre">base_ring</span></code>.</p>
<p>This is the free module on the nondegenerate simplices in the
given dimension.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – integer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">base_ring</span></code> – ring (optional, default <span class="math notranslate nohighlight">\(\ZZ\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cochains</span></code> – boolean (optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code>); if
<code class="docutils literal notranslate"><span class="pre">True</span></code>, return cochains instead</p></li>
</ul>
<p>The only difference between chains and cochains is notation:
the generator corresponding to the dual of a simplex
<code class="docutils literal notranslate"><span class="pre">sigma</span></code> is written as <code class="docutils literal notranslate"><span class="pre">&quot;\chi_sigma&quot;</span></code> in the group of
cochains.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">S3</span><span class="o">.</span><span class="n">n_chains</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">cochains</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>                                     <span class="c1"># needs sage.modules</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">basis</span><span class="p">())</span>                                                       <span class="c1"># needs sage.modules</span>
<span class="go">[\chi_sigma_3]</span>

<span class="gp">sage: </span><span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">Sigma3</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">permutation</span><span class="o">.</span><span class="n">Symmetric</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">BSigma3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">Sigma3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">BSigma3</span><span class="o">.</span><span class="n">n_chains</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">basis</span><span class="p">())</span>                                     <span class="c1"># needs sage.modules</span>
<span class="go">[(1,2), (1,2,3), (1,3), (1,3,2), (2,3)]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">BSigma3</span><span class="o">.</span><span class="n">n_chains</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cochains</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">basis</span><span class="p">())</span>                      <span class="c1"># needs sage.modules</span>
<span class="go">[\chi_(1,2), \chi_(1,2,3), \chi_(1,3), \chi_(1,3,2), \chi_(2,3)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.nondegenerate_simplices">
<span class="sig-name descname"><span class="pre">nondegenerate_simplices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.nondegenerate_simplices" title="Permalink to this definition">#</a></dt>
<dd><p>Return the sorted list of non-degenerate simplices in this simplicial set.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">max_dim</span></code> – optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code>. If specified,
return the non-degenerate simplices of this dimension or
smaller. This argument is required if this simplicial set is
infinite.</p></li>
</ul>
<p>The sorting is in increasing order of dimension, and within
each dimension, by the name (if present) of each simplex.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The sorting is done when the simplicial set is
constructed, so changing the name of a simplex after
construction will not affect the ordering.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S0</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">v</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="kc">None</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">S0</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[Delta^0, Delta^0]</span>
</pre></div>
</div>
<p>Name the vertices and reconstruct the simplicial set: they
should be ordered alphabetically:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S0</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">v</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="kc">None</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">S0</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[v, w]</span>
</pre></div>
</div>
<p>Rename but do not reconstruct the set; the ordering does not
take the new names into account:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S0</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span> <span class="c1"># old ordering is used</span>
<span class="go">[z, w]</span>

<span class="gp">sage: </span><span class="n">X0</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">v</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="kc">None</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">X0</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span> <span class="c1"># new ordering is used</span>
<span class="go">[w, z]</span>
</pre></div>
</div>
<p>Test an infinite example:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">C3</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">MultiplicativeAbelian</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">BC3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">C3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">BC3</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[1, f, f^2, f * f, f * f^2, f^2 * f, f^2 * f^2]</span>
<span class="gp">sage: </span><span class="n">BC3</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">NotImplementedError: this simplicial set may be infinite, so specify max_dim</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.product">
<span class="sig-name descname"><span class="pre">product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">others</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.product" title="Permalink to this definition">#</a></dt>
<dd><p>Return the product of this simplicial set with <code class="docutils literal notranslate"><span class="pre">others</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">others</span></code> – one or several simplicial sets</p></li>
</ul>
<p>If <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> are simplicial sets, then their product <span class="math notranslate nohighlight">\(X
\times Y\)</span> is defined to be the simplicial set with
<span class="math notranslate nohighlight">\(n\)</span>-simplices <span class="math notranslate nohighlight">\(X_n \times Y_n\)</span>. See
<a class="reference internal" href="simplicial_set_constructions.html#sage.topology.simplicial_set_constructions.ProductOfSimplicialSets" title="sage.topology.simplicial_set_constructions.ProductOfSimplicialSets"><code class="xref py py-class docutils literal notranslate"><span class="pre">simplicial_set_constructions.ProductOfSimplicialSets</span></code></a>
for more information.</p>
<p>If a simplicial set is constructed as a product, the factors
are recorded and are accessible via the method
<a class="reference internal" href="simplicial_set_constructions.html#sage.topology.simplicial_set_constructions.Factors.factors" title="sage.topology.simplicial_set_constructions.Factors.factors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">simplicial_set_constructions.Factors.factors()</span></code></a>.
If each factor is finite, then you can also construct the
projection maps onto each factor, the wedge as a subcomplex,
and the fat wedge as a subcomplex.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">square</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">square</span></code> is now the standard triangulation of the square: 4
vertices, 5 edges (the four on the border and the diagonal), 2
triangles:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">square</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[4, 5, 2]</span>

<span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="n">reduced</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>                                             <span class="c1"># needs sage.modules</span>
<span class="go">{0: Z, 1: Z x Z, 2: Z}</span>
</pre></div>
</div>
<p>Since <code class="docutils literal notranslate"><span class="pre">S1</span></code> is pointed, so is <code class="docutils literal notranslate"><span class="pre">T</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S1</span><span class="o">.</span><span class="n">is_pointed</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">S1</span><span class="o">.</span><span class="n">base_point</span><span class="p">()</span>
<span class="go">v_0</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">is_pointed</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">base_point</span><span class="p">()</span>
<span class="go">(v_0, v_0)</span>

<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2xS3</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">S3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2xS3</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="n">reduced</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>                                         <span class="c1"># needs sage.modules</span>
<span class="go">{0: Z, 1: 0, 2: Z, 3: Z, 4: 0, 5: Z}</span>

<span class="gp">sage: </span><span class="n">S2xS3</span><span class="o">.</span><span class="n">factors</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="n">S2</span><span class="p">,</span> <span class="n">S3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">S2xS3</span><span class="o">.</span><span class="n">factors</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="n">S3</span><span class="p">,</span> <span class="n">S2</span><span class="p">)</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">MultiplicativeAbelian</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;RP^oo&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">S2</span><span class="p">);</span> <span class="n">X</span>
<span class="go">RP^oo x RP^oo x S^2</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">factor</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">RP^oo</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">factors</span><span class="p">()</span>
<span class="go">(RP^oo, RP^oo, S^2)</span>
</pre></div>
</div>
<p>Projection maps and wedges:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S2xS3</span><span class="o">.</span><span class="n">projection_map</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: S^2 x S^3</span>
<span class="go">  To:   S^2</span>
<span class="go">  Defn: ...</span>
<span class="gp">sage: </span><span class="n">S2xS3</span><span class="o">.</span><span class="n">wedge_as_subset</span><span class="p">()</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>                                    <span class="c1"># needs sage.modules</span>
<span class="go">{0: 0, 1: 0, 2: Z, 3: Z}</span>
</pre></div>
</div>
<p>In the case of pointed simplicial sets, there is an inclusion
of each factor into the product. These are not automatically
defined in Sage, but they are easy to construct using identity
maps and constant maps and the universal property of the
product:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">one</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">identity</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">const</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">constant_map</span><span class="p">(</span><span class="n">codomain</span><span class="o">=</span><span class="n">S3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2xS3</span><span class="o">.</span><span class="n">universal_property</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">const</span><span class="p">)</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: S^2</span>
<span class="go">  To:   S^2 x S^3</span>
<span class="go">  Defn: [v_0, sigma_2] --&gt; [(v_0, v_0), (sigma_2, s_1 s_0 v_0)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.pullback">
<span class="sig-name descname"><span class="pre">pullback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">maps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.pullback" title="Permalink to this definition">#</a></dt>
<dd><p>Return the pullback obtained from given <code class="docutils literal notranslate"><span class="pre">maps</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">maps</span></code> – several maps of simplicial sets, each of which
has this simplicial set as its codomain</p></li>
</ul>
<p>If only a single map <span class="math notranslate nohighlight">\(f: X \to Y\)</span> is given, then return
<span class="math notranslate nohighlight">\(X\)</span>. If more than one map is given, say <span class="math notranslate nohighlight">\(f_i: X_i \to Y\)</span> for
<span class="math notranslate nohighlight">\(0 \leq i \leq m\)</span>, then return the pullback defined by those
maps. If no maps are given, return the one-point simplicial
set.</p>
<p>In addition to the defining maps <span class="math notranslate nohighlight">\(f_i\)</span> used to construct the
pullback <span class="math notranslate nohighlight">\(P\)</span>, there are also maps <span class="math notranslate nohighlight">\(\bar{f}_i: P \to X_i\)</span>,
which we refer to as <em>structure maps</em> or <em>projection
maps</em>. The pullback also has a universal property: given maps
<span class="math notranslate nohighlight">\(g_i: Z \to X_i\)</span> such that <span class="math notranslate nohighlight">\(f_i g_i = f_j g_j\)</span> for all <span class="math notranslate nohighlight">\(i\)</span>,
<span class="math notranslate nohighlight">\(j\)</span>, then there is a unique map <span class="math notranslate nohighlight">\(g: Z \to P\)</span> making the
appropriate diagram commute: that is, <span class="math notranslate nohighlight">\(\bar{f}_i g = g_i\)</span> for
all <span class="math notranslate nohighlight">\(i\)</span>. For example, given maps <span class="math notranslate nohighlight">\(f: X \to Y\)</span> and <span class="math notranslate nohighlight">\(g: X \to
Z\)</span>, there is an induced map <span class="math notranslate nohighlight">\(g: X \to Y \times Z\)</span>.</p>
<p>In Sage, a pullback is equipped with its defining maps, and as
long as the simplicial sets involved are finite, you can also
access the structure maps and the universal property.</p>
<p>EXAMPLES:</p>
<p>Construct a product as a pullback:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pt</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Point</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">pullback</span><span class="p">(</span><span class="n">S2</span><span class="o">.</span><span class="n">constant_map</span><span class="p">(),</span> <span class="n">S2</span><span class="o">.</span><span class="n">constant_map</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>                                                         <span class="c1"># needs sage.modules</span>
<span class="go">Z x Z</span>
</pre></div>
</div>
<p>If the pullback is defined via maps <span class="math notranslate nohighlight">\(f_i: X_i \to Y\)</span>, then
there are structure maps <span class="math notranslate nohighlight">\(\bar{f}_i: Y_i \to P\)</span>. The structure
maps are only available in Sage when all of the maps involved
have finite domains.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">one</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">Hom</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span><span class="o">.</span><span class="n">identity</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">pullback</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">one</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>                                                          <span class="c1"># needs sage.modules</span>
<span class="go">{0: 0, 1: 0, 2: Z}</span>

<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">defining_map</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">one</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">structure_map</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: Pullback of maps:</span>
<span class="go">  Simplicial set endomorphism of S^2</span>
<span class="go">    Defn: Identity map</span>
<span class="go">  Simplicial set endomorphism of S^2</span>
<span class="go">    Defn: Identity map</span>
<span class="go">  To:   S^2</span>
<span class="go">  Defn: [(v_0, v_0), (sigma_2, sigma_2)] --&gt; [v_0, sigma_2]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">structure_map</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span> <span class="o">==</span> <span class="n">P</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">structure_map</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span> <span class="o">==</span> <span class="n">S2</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The universal property:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">factor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">as_subset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">Hom</span><span class="p">(</span><span class="n">T</span><span class="p">)({</span><span class="n">S1</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">K</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
<span class="gp">....: </span>               <span class="n">S1</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">K</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">cone</span><span class="p">()</span>          <span class="c1"># the cone C(S^1)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">map_from_base</span><span class="p">()</span>  <span class="c1"># map from S^1 to C(S^1)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">universal_property</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span> <span class="o">==</span> <span class="n">S1</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span> <span class="o">==</span> <span class="n">P</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.pushout">
<span class="sig-name descname"><span class="pre">pushout</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">maps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.pushout" title="Permalink to this definition">#</a></dt>
<dd><p>Return the pushout obtained from given <code class="docutils literal notranslate"><span class="pre">maps</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">maps</span></code> – several maps of simplicial sets, each of which
has this simplicial set as its domain</p></li>
</ul>
<p>If only a single map <span class="math notranslate nohighlight">\(f: X \to Y\)</span> is given, then return
<span class="math notranslate nohighlight">\(Y\)</span>. If more than one map is given, say <span class="math notranslate nohighlight">\(f_i: X \to Y_i\)</span> for
<span class="math notranslate nohighlight">\(0 \leq i \leq m\)</span>, then return the pushout defined by those
maps. If no maps are given, return the empty simplicial set.</p>
<p>In addition to the defining maps <span class="math notranslate nohighlight">\(f_i\)</span> used to construct the
pushout <span class="math notranslate nohighlight">\(P\)</span>, there are also maps <span class="math notranslate nohighlight">\(\bar{f}_i: Y_i \to P\)</span>, which
we refer to as <em>structure maps</em>. The pushout also has a
universal property: given maps <span class="math notranslate nohighlight">\(g_i: Y_i \to Z\)</span> such that <span class="math notranslate nohighlight">\(g_i
f_i = g_j f_j\)</span> for all <span class="math notranslate nohighlight">\(i\)</span>, <span class="math notranslate nohighlight">\(j\)</span>, then there is a unique map
<span class="math notranslate nohighlight">\(g: P \to Z\)</span> making the appropriate diagram commute: that is,
<span class="math notranslate nohighlight">\(g \bar{f}_i = g_i\)</span> for all <span class="math notranslate nohighlight">\(i\)</span>.</p>
<p>In Sage, a pushout is equipped with its defining maps, and as
long as the simplicial sets involved are finite, you can also
access the structure maps and the universal property.</p>
<p>EXAMPLES:</p>
<p>Construct the 4-sphere as a quotient of a 4-simplex:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">n_skeleton</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S4</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">pushout</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">constant_map</span><span class="p">(),</span> <span class="n">L</span><span class="o">.</span><span class="n">inclusion_map</span><span class="p">());</span> <span class="n">S4</span>
<span class="go">Pushout of maps:</span>
<span class="go">  Simplicial set morphism:</span>
<span class="go">    From: Simplicial set with 30 non-degenerate simplices</span>
<span class="go">    To:   Point</span>
<span class="go">    Defn: Constant map at *</span>
<span class="go">  Simplicial set morphism:</span>
<span class="go">    From: Simplicial set with 30 non-degenerate simplices</span>
<span class="go">    To:   4-simplex</span>
<span class="go">    Defn: [(0,), (1,), (2,), (3,), (4,),</span>
<span class="go">           (0, 1), (0, 2), (0, 3), (0, 4), (1, 2), (1, 3), (1, 4),</span>
<span class="go">           (2, 3), (2, 4), (3, 4),</span>
<span class="go">           (0, 1, 2), (0, 1, 3), (0, 1, 4), (0, 2, 3), (0, 2, 4),</span>
<span class="go">           (0, 3, 4), (1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4),</span>
<span class="go">           (0, 1, 2, 3), (0, 1, 2, 4), (0, 1, 3, 4), (0, 2, 3, 4),</span>
<span class="go">           (1, 2, 3, 4)]</span>
<span class="go">           --&gt; [(0,), (1,), (2,), (3,), (4,),</span>
<span class="go">                (0, 1), (0, 2), (0, 3), (0, 4), (1, 2), (1, 3), (1, 4),</span>
<span class="go">                (2, 3), (2, 4), (3, 4),</span>
<span class="go">                (0, 1, 2), (0, 1, 3), (0, 1, 4), (0, 2, 3), (0, 2, 4), (0, 3, 4),</span>
<span class="go">                (1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4),</span>
<span class="go">                (0, 1, 2, 3), (0, 1, 2, 4), (0, 1, 3, 4), (0, 2, 3, 4), (1, 2, 3, 4)]</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">S4</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">())</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">S4</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>                                                        <span class="c1"># needs sage.modules</span>
<span class="go">Z</span>
</pre></div>
</div>
<p>The associated maps:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">factor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">as_subset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">wedge</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>  <span class="c1"># wedge, constructed as a pushout</span>
<span class="gp">sage: </span><span class="n">W</span><span class="o">.</span><span class="n">defining_map</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: Point</span>
<span class="go">  To:   S^1 x S^1</span>
<span class="go">  Defn: Constant map at (v_0, v_0)</span>
<span class="gp">sage: </span><span class="n">W</span><span class="o">.</span><span class="n">structure_map</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: S^1</span>
<span class="go">  To:   Wedge: (S^1 v S^1 x S^1)</span>
<span class="go">  Defn: [v_0, sigma_1] --&gt; [*, sigma_1]</span>

<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">Hom</span><span class="p">(</span><span class="n">T</span><span class="p">)({</span><span class="n">S1</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">K</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
<span class="gp">....: </span>               <span class="n">S1</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">K</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]})</span>
</pre></div>
</div>
<p>The maps <span class="math notranslate nohighlight">\(f: S^1 \to T\)</span> and <span class="math notranslate nohighlight">\(1: T \to T\)</span> induce a map <span class="math notranslate nohighlight">\(S^1 \vee T \to T\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">universal_property</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Hom</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">identity</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span> <span class="o">==</span> <span class="n">W</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span> <span class="o">==</span> <span class="n">T</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.quotient">
<span class="sig-name descname"><span class="pre">quotient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subcomplex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'*'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.quotient" title="Permalink to this definition">#</a></dt>
<dd><p>Return the quotient of this simplicial set by <code class="docutils literal notranslate"><span class="pre">subcomplex</span></code>.</p>
<p>That is, <code class="docutils literal notranslate"><span class="pre">subcomplex</span></code> is replaced by a vertex.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">subcomplex</span></code> – subsimplicial set of this simplicial set,
or a list, tuple, or set of simplices defining a
subsimplicial set.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertex_name</span></code> (optional) – string, name to be given to the new
vertex. By default, use <code class="docutils literal notranslate"><span class="pre">'*'</span></code>.</p></li>
</ul>
<p>In Sage, from a quotient simplicial set, you can recover the
ambient space, the subcomplex, and (if the ambient space is
finite) the quotient map.</p>
<p>Base points: if the original simplicial set has a base point
not contained in <code class="docutils literal notranslate"><span class="pre">subcomplex</span></code> and if the original simplicial
set is finite, then use its image as the base point for the
quotient. In all other cases, <code class="docutils literal notranslate"><span class="pre">*</span></code> is the base point.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span> <span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">quotient</span><span class="p">([</span><span class="n">f</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[*, e]</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>                                                         <span class="c1"># needs sage.modules</span>
<span class="go">Z</span>

<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">quotient</span><span class="p">([</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[*, e]</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>                                                         <span class="c1"># needs sage.modules</span>
<span class="go">Z</span>

<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">quotient</span><span class="p">([</span><span class="n">v</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[*, w, e]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">base_point</span><span class="p">()</span>
<span class="go">*</span>

<span class="gp">sage: </span><span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">RP5</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">RealProjectiveSpace</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">RP2</span> <span class="o">=</span> <span class="n">RP5</span><span class="o">.</span><span class="n">n_skeleton</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">RP5_2</span> <span class="o">=</span> <span class="n">RP5</span><span class="o">.</span><span class="n">quotient</span><span class="p">(</span><span class="n">RP2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">RP5_2</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="n">base_ring</span><span class="o">=</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>                                       <span class="c1"># needs sage.modules</span>
<span class="go">{0: Vector space of dimension 0 over Finite Field of size 2,</span>
<span class="go"> 1: Vector space of dimension 0 over Finite Field of size 2,</span>
<span class="go"> 2: Vector space of dimension 0 over Finite Field of size 2,</span>
<span class="go"> 3: Vector space of dimension 1 over Finite Field of size 2,</span>
<span class="go"> 4: Vector space of dimension 1 over Finite Field of size 2,</span>
<span class="go"> 5: Vector space of dimension 1 over Finite Field of size 2}</span>
<span class="gp">sage: </span><span class="n">RP5_2</span><span class="o">.</span><span class="n">ambient</span><span class="p">()</span>
<span class="go">RP^5</span>
<span class="gp">sage: </span><span class="n">RP5_2</span><span class="o">.</span><span class="n">subcomplex</span><span class="p">()</span>
<span class="go">Simplicial set with 3 non-degenerate simplices</span>
<span class="gp">sage: </span><span class="n">RP5_2</span><span class="o">.</span><span class="n">quotient_map</span><span class="p">()</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: RP^5</span>
<span class="go">  To:   Quotient: (RP^5/Simplicial set with 3 non-degenerate simplices)</span>
<span class="go">  Defn: [1, f, f * f, f * f * f, f * f * f * f, f * f * f * f * f]</span>
<span class="go">        --&gt; [*, s_0 *, s_1 s_0 *, f * f * f, f * f * f * f, f * f * f * f * f]</span>
</pre></div>
</div>
<p>Behavior of base points:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">is_pointed</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">subsimplicial_set</span><span class="p">([</span><span class="n">K</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[(2,), (3,), (2, 3)]</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">quotient</span><span class="p">([</span><span class="n">K</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">base_point</span><span class="p">()</span>
<span class="go">*</span>

<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">set_base_point</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">base_point</span><span class="p">()</span>
<span class="go">(0,)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">subsimplicial_set</span><span class="p">([</span><span class="n">K</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[(2,), (3,), (2, 3)]</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">quotient</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">base_point</span><span class="p">()</span>
<span class="go">(0,)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.reduce">
<span class="sig-name descname"><span class="pre">reduce</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.reduce" title="Permalink to this definition">#</a></dt>
<dd><p>Reduce this simplicial set.</p>
<p>That is, take the quotient by a spanning tree of the
1-skeleton, so that the resulting simplicial set has only one
vertex. This only makes sense if the simplicial set is
connected, so raise an error if not. If already reduced,
return itself.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">is_reduced</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">reduce</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">is_reduced</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">X</span></code> is reduced, so calling <code class="docutils literal notranslate"><span class="pre">reduce</span></code> on it again
returns <code class="docutils literal notranslate"><span class="pre">X</span></code> itself:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span> <span class="ow">is</span> <span class="n">X</span><span class="o">.</span><span class="n">reduce</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="ow">is</span> <span class="n">K</span><span class="o">.</span><span class="n">reduce</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Raise an error for disconnected simplicial sets:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S0</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S0</span><span class="o">.</span><span class="n">reduce</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: this simplicial set is not connected</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.rename_latex">
<span class="sig-name descname"><span class="pre">rename_latex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.rename_latex" title="Permalink to this definition">#</a></dt>
<dd><p>Rename or set the LaTeX name for this simplicial set.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code> – string, the LaTeX representation. Or <code class="docutils literal notranslate"><span class="pre">s</span></code> can be
<code class="docutils literal notranslate"><span class="pre">None</span></code>, in which case the LaTeX name is unset.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">v</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span> <span class="n">latex_name</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">latex</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">*</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">rename_latex</span><span class="p">(</span><span class="s1">&#39;x_0&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">latex</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">x_0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.subsimplicial_set">
<span class="sig-name descname"><span class="pre">subsimplicial_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">simplices</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.subsimplicial_set" title="Permalink to this definition">#</a></dt>
<dd><p>Return the sub-simplicial set of this simplicial set
determined by <code class="docutils literal notranslate"><span class="pre">simplices</span></code>, a set of nondegenerate simplices.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">simplices</span></code> – set, list, or tuple of nondegenerate
simplices in this simplicial set, or a simplicial
complex – see below.</p></li>
</ul>
<p>Each sub-simplicial set comes equipped with an inclusion map
to its ambient space, and you can easily recover its ambient
space.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">simplices</span></code> is a simplicial complex, then the original
simplicial set should itself have been converted from a
simplicial complex, and <code class="docutils literal notranslate"><span class="pre">simplices</span></code> should be a subcomplex
of that.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>

<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span> <span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">subsimplicial_set</span><span class="p">([</span><span class="n">e</span><span class="p">]);</span> <span class="n">Y</span>
<span class="go">Simplicial set with 3 non-degenerate simplices</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[v, w, e]</span>

<span class="gp">sage: </span><span class="n">S3</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">(</span><span class="n">S3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">tau</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">tau</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">subsimplicial_set</span><span class="p">([</span><span class="n">tau</span><span class="p">])</span>
<span class="go">Simplicial set with 15 non-degenerate simplices</span>
</pre></div>
</div>
<p>A subsimplicial set knows about its ambient space and the
inclusion map into it:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">RP4</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">RealProjectiveSpace</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">RP4</span><span class="o">.</span><span class="n">n_skeleton</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="n">M</span>
<span class="go">Simplicial set with 3 non-degenerate simplices</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">ambient_space</span><span class="p">()</span>
<span class="go">RP^4</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">inclusion_map</span><span class="p">()</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: Simplicial set with 3 non-degenerate simplices</span>
<span class="go">  To:   RP^4</span>
<span class="go">  Defn: [1, f, f * f] --&gt; [1, f, f * f]</span>
</pre></div>
</div>
<p>An infinite ambient simplicial set:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">MultiplicativeAbelian</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">BxB</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">BxB</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">5</span><span class="p">:]</span>
<span class="go">[(s_0 f, s_1 f), (s_1 f, f * f), (s_1 f, s_0 f), (s_1 s_0 1, f * f)]</span>
<span class="gp">sage: </span><span class="n">BxB</span><span class="o">.</span><span class="n">subsimplicial_set</span><span class="p">(</span><span class="n">BxB</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">5</span><span class="p">:])</span>
<span class="go">Simplicial set with 8 non-degenerate simplices</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.suspension">
<span class="sig-name descname"><span class="pre">suspension</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.suspension" title="Permalink to this definition">#</a></dt>
<dd><p>Return the (reduced) <span class="math notranslate nohighlight">\(n\)</span>-th suspension of this simplicial set.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> (optional, default 1) – integer, suspend this many
times.</p></li>
</ul>
<p>If this simplicial set <span class="math notranslate nohighlight">\(X\)</span> is not pointed, return the
suspension: the quotient <span class="math notranslate nohighlight">\(CX/X\)</span>, where <span class="math notranslate nohighlight">\(CX\)</span> is the (ordinary,
unreduced) cone on <span class="math notranslate nohighlight">\(X\)</span>. If <span class="math notranslate nohighlight">\(X\)</span> is pointed, then use the
reduced cone instead, and so return the reduced suspension.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">RP4</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">RealProjectiveSpace</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">SigmaRP4</span> <span class="o">=</span> <span class="n">RP4</span><span class="o">.</span><span class="n">suspension</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S1_smash_RP4</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">smash_product</span><span class="p">(</span><span class="n">RP4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">SigmaRP4</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span> <span class="o">==</span> <span class="n">S1_smash_RP4</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The version of the suspension obtained by the smash product is
typically less efficient than the reduced suspension produced
here:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SigmaRP4</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>                                                   <span class="c1"># needs sage.groups</span>
<span class="go">[1, 0, 1, 1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">S1_smash_RP4</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>                                               <span class="c1"># needs sage.groups</span>
<span class="go">[1, 1, 4, 6, 8, 5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_arbitrary.wedge">
<span class="sig-name descname"><span class="pre">wedge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">others</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.wedge" title="Permalink to this definition">#</a></dt>
<dd><p>Return the wedge sum of this pointed simplicial set with <code class="docutils literal notranslate"><span class="pre">others</span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">others</span></code> – one or several simplicial sets</p></li>
</ul>
<p>This constructs the quotient of the disjoint union in which
the base points of all of the simplicial sets have been
identified. This is the coproduct in the category of pointed
simplicial sets.</p>
<p>This raises an error if any of the factors is not pointed.</p>
<p>From the wedge, you can access the factors, and if the
simplicial sets involved are all finite, you can also access
the inclusion map of each factor into the wedge, as well as
the projection map onto each factor.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">)},</span> <span class="n">base_point</span><span class="o">=</span><span class="n">v</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">w</span><span class="p">)},</span> <span class="n">base_point</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">wedge</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">W</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[*, e, f]</span>
<span class="gp">sage: </span><span class="n">W</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>                                                          <span class="c1"># needs sage.modules</span>
<span class="go">{0: 0, 1: Z x Z}</span>
<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">wedge</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="n">reduced</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>                                   <span class="c1"># needs sage.modules</span>
<span class="go">{0: Z, 1: Z, 2: Z}</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">wedge</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[*, e, e]</span>

<span class="gp">sage: </span><span class="n">S3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">wedge</span><span class="p">(</span><span class="n">S3</span><span class="p">,</span> <span class="n">S2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">W</span><span class="o">.</span><span class="n">inclusion_map</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: S^2</span>
<span class="go">  To:   Wedge: (S^2 v S^3 v S^2)</span>
<span class="go">  Defn: [v_0, sigma_2] --&gt; [*, sigma_2]</span>
<span class="gp">sage: </span><span class="n">W</span><span class="o">.</span><span class="n">projection_map</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: Wedge: (S^2 v S^3 v S^2)</span>
<span class="go">  To:   Quotient: (Wedge: (S^2 v S^3 v S^2)/Simplicial set with 3 non-degenerate simplices)</span>
<span class="go">  Defn: [*, sigma_2, sigma_2, sigma_3] --&gt; [*, s_1 s_0 *, s_1 s_0 *, sigma_3]</span>
</pre></div>
</div>
<p>Note that the codomain of the projection map is not identical
to the original <code class="docutils literal notranslate"><span class="pre">S2</span></code>, but is instead a quotient of the wedge
which is isomorphic to <code class="docutils literal notranslate"><span class="pre">S2</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 0, 1]</span>
<span class="gp">sage: </span><span class="n">W</span><span class="o">.</span><span class="n">projection_map</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 0, 1]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">projection_map</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">W</span><span class="o">.</span><span class="n">inclusion_map</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">is_bijective</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_finite">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.topology.simplicial_set.</span></span><span class="sig-name descname"><span class="pre">SimplicialSet_finite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">category</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latex_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_finite" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary" title="sage.topology.simplicial_set.SimplicialSet_arbitrary"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimplicialSet_arbitrary</span></code></a>, <a class="reference internal" href="cell_complex.html#sage.topology.cell_complex.GenericCellComplex" title="sage.topology.cell_complex.GenericCellComplex"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenericCellComplex</span></code></a></p>
<p>A finite simplicial set.</p>
<p>A simplicial set <span class="math notranslate nohighlight">\(X\)</span> is a collection of sets <span class="math notranslate nohighlight">\(X_n\)</span>, the
<em>n-simplices</em>, indexed by the non-negative integers, together with
face maps <span class="math notranslate nohighlight">\(d_i\)</span> and degeneracy maps <span class="math notranslate nohighlight">\(s_j\)</span>.  A simplex is
<em>degenerate</em> if it is in the image of some <span class="math notranslate nohighlight">\(s_j\)</span>, and a simplicial
set is <em>finite</em> if there are only finitely many non-degenerate
simplices.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">data</span></code> – the data defining the simplicial set. See below for
details.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">base_point</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code>) – 0-simplex in this
simplicial set, its base point</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code>) – string, the name of the
simplicial set</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">True</span></code>) – boolean. If <code class="docutils literal notranslate"><span class="pre">True</span></code>,
check the simplicial identity on the face maps when defining the
simplicial set.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">category</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code>) – the category in
which to define this simplicial set. The default is either
finite simplicial sets or finite pointed simplicial sets,
depending on whether a base point is defined.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">latex_name</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code>) – string, the LaTeX
representation of the simplicial set.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">data</span></code> should have one of the following forms: it could be a
simplicial complex or <span class="math notranslate nohighlight">\(\Delta\)</span>-complex, in case it is converted to
a simplicial set. Alternatively, it could be a dictionary. The
keys are the nondegenerate simplices of the simplicial set, and
the value corresponding to a simplex <span class="math notranslate nohighlight">\(\sigma\)</span> is a tuple listing
the faces of <span class="math notranslate nohighlight">\(\sigma\)</span>. The 0-dimensional simplices may be omitted
from <code class="docutils literal notranslate"><span class="pre">data</span></code> if they (or their degeneracies) are faces of other
simplices; otherwise they must be included with value <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>See <a class="reference internal" href="#module-sage.topology.simplicial_set" title="sage.topology.simplicial_set"><code class="xref py py-mod docutils literal notranslate"><span class="pre">simplicial_set</span></code></a> and the methods for simplicial sets for
more information and examples.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">u</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In the following simplicial set, <code class="docutils literal notranslate"><span class="pre">u</span></code> is an isolated vertex:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">),</span> <span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">w</span><span class="p">),</span> <span class="n">u</span><span class="p">:</span> <span class="kc">None</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">X</span>
<span class="go">Simplicial set with 5 non-degenerate simplices</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span>
<span class="go">X</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">),</span> <span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">w</span><span class="p">),</span> <span class="n">u</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span>
<span class="go">Y</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_finite.algebraic_topological_model">
<span class="sig-name descname"><span class="pre">algebraic_topological_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_ring</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_finite.algebraic_topological_model" title="Permalink to this definition">#</a></dt>
<dd><p>Return the algebraic topological model for this simplicial set
with coefficients in <code class="docutils literal notranslate"><span class="pre">base_ring</span></code>.</p>
<p>The term “algebraic topological model” is defined by Pilarczyk
and Réal <a class="reference internal" href="../../../references/index.html#pr2015" id="id2"><span>[PR2015]</span></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">base_ring</span></code> - coefficient ring (optional, default
<code class="docutils literal notranslate"><span class="pre">QQ</span></code>). Must be a field.</p></li>
</ul>
<p>Denote by <span class="math notranslate nohighlight">\(C\)</span> the chain complex associated to this simplicial
set. The algebraic topological model is a chain complex <span class="math notranslate nohighlight">\(M\)</span>
with zero differential, with the same homology as <span class="math notranslate nohighlight">\(C\)</span>, along
with chain maps <span class="math notranslate nohighlight">\(\pi: C \to M\)</span> and <span class="math notranslate nohighlight">\(\iota: M \to C\)</span> satisfying
<span class="math notranslate nohighlight">\(\iota \pi = 1_M\)</span> and <span class="math notranslate nohighlight">\(\pi \iota\)</span> chain homotopic to
<span class="math notranslate nohighlight">\(1_C\)</span>. The chain homotopy <span class="math notranslate nohighlight">\(\phi\)</span> must satisfy</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\phi \phi = 0\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(\pi \phi = 0\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(\phi \iota = 0\)</span>.</p></li>
</ul>
<p>Such a chain homotopy is called a <em>chain contraction</em>.</p>
<p>OUTPUT: a pair consisting of</p>
<ul class="simple">
<li><p>chain contraction <code class="docutils literal notranslate"><span class="pre">phi</span></code> associated to <span class="math notranslate nohighlight">\(C\)</span>, <span class="math notranslate nohighlight">\(M\)</span>, <span class="math notranslate nohighlight">\(\pi\)</span>, and
<span class="math notranslate nohighlight">\(\iota\)</span></p></li>
<li><p>the chain complex <span class="math notranslate nohighlight">\(M\)</span></p></li>
</ul>
<p>Note that from the chain contraction <code class="docutils literal notranslate"><span class="pre">phi</span></code>, one can recover the
chain maps <span class="math notranslate nohighlight">\(\pi\)</span> and <span class="math notranslate nohighlight">\(\iota\)</span> via <code class="docutils literal notranslate"><span class="pre">phi.pi()</span></code> and
<code class="docutils literal notranslate"><span class="pre">phi.iota()</span></code>. Then one can recover <span class="math notranslate nohighlight">\(C\)</span> and <span class="math notranslate nohighlight">\(M\)</span> from, for
example, <code class="docutils literal notranslate"><span class="pre">phi.pi().domain()</span></code> and <code class="docutils literal notranslate"><span class="pre">phi.pi().codomain()</span></code>,
respectively.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RP2</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">RealProjectiveSpace</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>                          <span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">RP2</span><span class="o">.</span><span class="n">algebraic_topological_model</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>                       <span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>                                                          <span class="c1"># needs sage.groups sage.modules</span>
<span class="go">{0: Vector space of dimension 1 over Finite Field of size 2,</span>
<span class="go"> 1: Vector space of dimension 1 over Finite Field of size 2,</span>
<span class="go"> 2: Vector space of dimension 1 over Finite Field of size 2}</span>

<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">algebraic_topological_model</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>                            <span class="c1"># needs sage.modules</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>                                                          <span class="c1"># needs sage.modules</span>
<span class="go">{0: Vector space of dimension 1 over Rational Field,</span>
<span class="go"> 1: Vector space of dimension 2 over Rational Field,</span>
<span class="go"> 2: Vector space of dimension 1 over Rational Field}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_finite.chain_complex">
<span class="sig-name descname"><span class="pre">chain_complex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dimensions=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_ring=Integer</span> <span class="pre">Ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">augmented=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cochain=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subcomplex=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_finite.chain_complex" title="Permalink to this definition">#</a></dt>
<dd><p>Return the normalized chain complex.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dimensions</span></code> – if <code class="docutils literal notranslate"><span class="pre">None</span></code>, compute the chain complex in all
dimensions.  If a list or tuple of integers, compute the
chain complex in those dimensions, setting the chain groups
in all other dimensions to zero.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">base_ring</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">ZZ</span></code>) – commutative ring</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">augmented</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code>) – if <code class="docutils literal notranslate"><span class="pre">True</span></code>,
return the augmented chain complex (that is, include a class
in dimension <span class="math notranslate nohighlight">\(-1\)</span> corresponding to the empty cell).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cochain</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code>) – if <code class="docutils literal notranslate"><span class="pre">True</span></code>,
return the cochain complex (that is, the dual of the chain
complex).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code>) – ignored.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">subcomplex</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code>) – if present,
compute the chain complex relative to this subcomplex.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, make
sure that the chain complex is actually a chain complex:
the differentials are composable and their product is zero.</p></li>
</ul>
<p>The normalized chain complex of a simplicial set is isomorphic
to the chain complex obtained by modding out by degenerate
simplices, and the latter is what is actually constructed
here.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="c1"># needs sage.modules</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">degen</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">apply_degeneracies</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># s_1 s_0 applied to v</span>
<span class="gp">sage: </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S3</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">sigma</span><span class="p">:</span> <span class="p">(</span><span class="n">degen</span><span class="p">,</span> <span class="n">degen</span><span class="p">,</span> <span class="n">degen</span><span class="p">,</span> <span class="n">degen</span><span class="p">)})</span>  <span class="c1"># the 3-sphere</span>
<span class="gp">sage: </span><span class="n">S3</span><span class="o">.</span><span class="n">chain_complex</span><span class="p">()</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{0: Z, 3: Z}</span>
<span class="gp">sage: </span><span class="n">S3</span><span class="o">.</span><span class="n">chain_complex</span><span class="p">(</span><span class="n">augmented</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{-1: 0, 0: 0, 3: Z}</span>
<span class="gp">sage: </span><span class="n">S3</span><span class="o">.</span><span class="n">chain_complex</span><span class="p">(</span><span class="n">dimensions</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{0: Vector space of dimension 1 over Rational Field}</span>

<span class="gp">sage: </span><span class="n">RP5</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">RealProjectiveSpace</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>                          <span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">RP2</span> <span class="o">=</span> <span class="n">RP5</span><span class="o">.</span><span class="n">n_skeleton</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>                                               <span class="c1"># needs sage.groups</span>
<span class="gp">sage: </span><span class="n">RP5</span><span class="o">.</span><span class="n">chain_complex</span><span class="p">(</span><span class="n">subcomplex</span><span class="o">=</span><span class="n">RP2</span><span class="p">)</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>                          <span class="c1"># needs sage.groups sage.modules</span>
<span class="go">{0: Z, 3: C2, 4: 0, 5: Z}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_finite.euler_characteristic">
<span class="sig-name descname"><span class="pre">euler_characteristic</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_finite.euler_characteristic" title="Permalink to this definition">#</a></dt>
<dd><p>Return the Euler characteristic of this simplicial set: the
alternating sum over <span class="math notranslate nohighlight">\(n \geq 0\)</span> of the number of
nondegenerate <span class="math notranslate nohighlight">\(n\)</span>-simplices.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">RealProjectiveSpace</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">euler_characteristic</span><span class="p">()</span>         <span class="c1"># needs sage.groups</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">euler_characteristic</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span><span class="o">.</span><span class="n">euler_characteristic</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_finite.f_vector">
<span class="sig-name descname"><span class="pre">f_vector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_finite.f_vector" title="Permalink to this definition">#</a></dt>
<dd><p>Return the list of the number of non-degenerate simplices in each
dimension.</p>
<p>Unlike for some other cell complexes in Sage, this does not
include the empty simplex in dimension <span class="math notranslate nohighlight">\(-1\)</span>; thus its <span class="math notranslate nohighlight">\(i\)</span>-th
entry is the number of <span class="math notranslate nohighlight">\(i\)</span>-dimensional simplices.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S0</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">v</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="kc">None</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">S0</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[2]</span>

<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">S1</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 1]</span>
<span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 0, 0, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_finite.face_data">
<span class="sig-name descname"><span class="pre">face_data</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_finite.face_data" title="Permalink to this definition">#</a></dt>
<dd><p>Return the face-map data – a dictionary – defining this simplicial set.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">face_data</span><span class="p">()[</span><span class="n">e</span><span class="p">]</span>
<span class="go">(v, w)</span>

<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">v</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="kc">None</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="ow">in</span> <span class="n">Y</span><span class="o">.</span><span class="n">face_data</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">face_data</span><span class="p">()[</span><span class="n">v</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.SimplicialSet_finite.n_skeleton">
<span class="sig-name descname"><span class="pre">n_skeleton</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.SimplicialSet_finite.n_skeleton" title="Permalink to this definition">#</a></dt>
<dd><p>Return the <span class="math notranslate nohighlight">\(n\)</span>-skeleton of this simplicial set.</p>
<p>That is, the subsimplicial set generated by all nondegenerate
simplices of dimension at most <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – the dimension</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">degen</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">apply_degeneracies</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">tau</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;tau&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">tau</span><span class="p">:</span> <span class="p">(</span><span class="n">degen</span><span class="p">,</span> <span class="n">degen</span><span class="p">,</span> <span class="n">degen</span><span class="p">),</span> <span class="n">w</span><span class="p">:</span> <span class="kc">None</span><span class="p">})</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Y</span></code> is the disjoint union of a 2-sphere, with vertex <code class="docutils literal notranslate"><span class="pre">v</span></code>
and non-degenerate 2-simplex <code class="docutils literal notranslate"><span class="pre">tau</span></code>, and a point <code class="docutils literal notranslate"><span class="pre">w</span></code>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[v, w, tau]</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">n_skeleton</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[v, w]</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">n_skeleton</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[v, w, tau]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.all_degeneracies">
<span class="sig-prename descclassname"><span class="pre">sage.topology.simplicial_set.</span></span><span class="sig-name descname"><span class="pre">all_degeneracies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.all_degeneracies" title="Permalink to this definition">#</a></dt>
<dd><p>Return list of all composites of degeneracies (written in
“admissible” form, i.e., as a strictly decreasing sequence) of
length <span class="math notranslate nohighlight">\(l\)</span> on an <span class="math notranslate nohighlight">\(n\)</span>-simplex.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code>, <code class="docutils literal notranslate"><span class="pre">l</span></code> – integers</p></li>
</ul>
<p>On an <span class="math notranslate nohighlight">\(n\)</span>-simplex, one may apply the degeneracies <span class="math notranslate nohighlight">\(s_i\)</span> for <span class="math notranslate nohighlight">\(0
\leq i \leq n\)</span>. Then on the resulting <span class="math notranslate nohighlight">\(n+1\)</span>-simplex, one may apply
<span class="math notranslate nohighlight">\(s_i\)</span> for <span class="math notranslate nohighlight">\(0 \leq i \leq n+1\)</span>, and so on. But one also has to take
into account the simplicial identity</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[s_i s_j = s_{j+1} s_i \ \   \text{if }   i \leq j.\]</div>
</div>
<p>There are <span class="math notranslate nohighlight">\(\binom{l+n}{n}\)</span> such composites: each non-degenerate
<span class="math notranslate nohighlight">\(n\)</span>-simplex leads to <span class="math notranslate nohighlight">\(\binom{l+n}{n}\)</span> degenerate <span class="math notranslate nohighlight">\(l+n\)</span> simplices.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">all_degeneracies</span>
<span class="gp">sage: </span><span class="n">all_degeneracies</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">{(2, 1, 0)}</span>
<span class="gp">sage: </span><span class="n">all_degeneracies</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">{(0,), (1,)}</span>
<span class="gp">sage: </span><span class="n">all_degeneracies</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">{(2, 1, 0), (3, 1, 0), (3, 2, 0), (3, 2, 1)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.face_degeneracies">
<span class="sig-prename descclassname"><span class="pre">sage.topology.simplicial_set.</span></span><span class="sig-name descname"><span class="pre">face_degeneracies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.face_degeneracies" title="Permalink to this definition">#</a></dt>
<dd><p>Return the result of applying the face map <span class="math notranslate nohighlight">\(d_m\)</span> to the iterated
degeneracy <span class="math notranslate nohighlight">\(s_I = s_{i_1} s_{i_2} ... s_{i_n}\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">m</span></code> – integer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">I</span></code> – tuple <code class="docutils literal notranslate"><span class="pre">(i_1,</span> <span class="pre">i_2,</span> <span class="pre">...,</span> <span class="pre">i_n)</span></code> of integers. We assume
that this sequence is strictly decreasing.</p></li>
</ul>
<p>Using the simplicial identities (see <a class="reference internal" href="#module-sage.topology.simplicial_set" title="sage.topology.simplicial_set"><code class="xref py py-mod docutils literal notranslate"><span class="pre">simplicial_set</span></code></a>), we
can rewrite</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[d_m s_{i_1} s_{i_2} ... s_{i_n}\]</div>
</div>
<p>in one of the forms</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[s_{j_1} s_{j_2} ... s_{j_n} d_t, \quad
s_{j_1} s_{j_2} ... s_{j_{n-1}}.\]</div>
</div>
<p>OUTPUT: the pair <code class="docutils literal notranslate"><span class="pre">(J,</span> <span class="pre">t)</span></code> or <code class="docutils literal notranslate"><span class="pre">(J,</span> <span class="pre">None)</span></code>. <code class="docutils literal notranslate"><span class="pre">J</span></code> is returned as
a list.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">face_degeneracies</span>
<span class="gp">sage: </span><span class="n">face_degeneracies</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">([0], None)</span>
<span class="gp">sage: </span><span class="n">face_degeneracies</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">([0], None)</span>
<span class="gp">sage: </span><span class="n">face_degeneracies</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">([0], None)</span>
<span class="gp">sage: </span><span class="n">face_degeneracies</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">([1, 0], 1)</span>
<span class="gp">sage: </span><span class="n">face_degeneracies</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">())</span>
<span class="go">([], 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.shrink_simplicial_complex">
<span class="sig-prename descclassname"><span class="pre">sage.topology.simplicial_set.</span></span><span class="sig-name descname"><span class="pre">shrink_simplicial_complex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">K</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.shrink_simplicial_complex" title="Permalink to this definition">#</a></dt>
<dd><p>Convert the simplicial complex <code class="docutils literal notranslate"><span class="pre">K</span></code> to a “small” simplicial set.</p>
<p>First convert <code class="docutils literal notranslate"><span class="pre">K</span></code> naively, then mod out by a large contractible
subcomplex, as found by
<code class="xref py py-meth docutils literal notranslate"><span class="pre">simplicial_complex.SimplicialComplex._contractible_subcomplex()</span></code>.
This will produce a simplicial set no larger than, and sometimes
much smaller than, the initial simplicial complex.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">shrink_simplicial_complex</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">shrink_simplicial_complex</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1]</span>

<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">shrink_simplicial_complex</span><span class="p">(</span><span class="n">Y</span><span class="p">);</span> <span class="n">S2</span>
<span class="go">Quotient: (Simplicial set with</span>
<span class="go">           14 non-degenerate simplices/Simplicial set with</span>
<span class="go">                                       13 non-degenerate simplices)</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 0, 1]</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>                                                             <span class="c1"># needs sage.modules</span>
<span class="go">{0: 0, 1: 0, 2: Z}</span>

<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">SurfaceOfGenus</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 15, 57, 38]</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>                                                              <span class="c1"># needs sage.modules</span>
<span class="go">{0: 0, 1: Z^6, 2: Z}</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">shrink_simplicial_complex</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>  <span class="c1"># random</span>
<span class="go">[1, 32, 27]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>                                                              <span class="c1"># needs sage.modules</span>
<span class="go">{0: 0, 1: Z^6, 2: Z}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.standardize_degeneracies">
<span class="sig-prename descclassname"><span class="pre">sage.topology.simplicial_set.</span></span><span class="sig-name descname"><span class="pre">standardize_degeneracies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">L</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.standardize_degeneracies" title="Permalink to this definition">#</a></dt>
<dd><p>Return list of indices of degeneracy maps in standard (decreasing)
order.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">L</span></code> – list of integers, representing a composition of
degeneracies in a simplicial set.</p></li>
</ul>
<p>OUTPUT:</p>
<p>an equivalent list of degeneracies, standardized to be
written in decreasing order, using the simplicial identity</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[s_i s_j = s_{j+1} s_i \ \   \text{if }   i \leq j.\]</div>
</div>
<p>For example, <span class="math notranslate nohighlight">\(s_0 s_2 = s_3 s_0\)</span> and <span class="math notranslate nohighlight">\(s_0 s_0 = s_1 s_0\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">standardize_degeneracies</span>
<span class="gp">sage: </span><span class="n">standardize_degeneracies</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">(1, 0)</span>
<span class="gp">sage: </span><span class="n">standardize_degeneracies</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">(3, 2, 1, 0)</span>
<span class="gp">sage: </span><span class="n">standardize_degeneracies</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">(3, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.topology.simplicial_set.standardize_face_maps">
<span class="sig-prename descclassname"><span class="pre">sage.topology.simplicial_set.</span></span><span class="sig-name descname"><span class="pre">standardize_face_maps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">L</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.topology.simplicial_set.standardize_face_maps" title="Permalink to this definition">#</a></dt>
<dd><p>Return list of indices of face maps in standard (non-increasing)
order.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">L</span></code> – list of integers, representing a composition of
face maps in a simplicial set.</p></li>
</ul>
<p>OUTPUT:</p>
<p>an equivalent list of face maps, standardized to be
written in non-increasing order, using the simplicial identity</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[d_i d_j = d_{j-1} d_i \ \   \text{if }   i&lt;j.\]</div>
</div>
<p>For example, <span class="math notranslate nohighlight">\(d_0 d_2 = d_1 d_0\)</span> and <span class="math notranslate nohighlight">\(d_0 d_1 = d_0 d_0\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.topology.simplicial_set</span> <span class="kn">import</span> <span class="n">standardize_face_maps</span>
<span class="gp">sage: </span><span class="n">standardize_face_maps</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">(0, 0)</span>
<span class="gp">sage: </span><span class="n">standardize_face_maps</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">(1, 0)</span>
<span class="gp">sage: </span><span class="n">standardize_face_maps</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">(3, 2, 1)</span>
</pre></div>
</div>
</dd></dl>

</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="simplicial_set_constructions.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Methods of constructing simplicial sets</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="cubical_complex.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Finite cubical complexes</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2005--2023, The Sage Development Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Simplicial sets</a><ul>
<li><a class="reference internal" href="#sage.topology.simplicial_set.AbstractSimplex"><code class="docutils literal notranslate"><span class="pre">AbstractSimplex()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.AbstractSimplex_class"><code class="docutils literal notranslate"><span class="pre">AbstractSimplex_class</span></code></a><ul>
<li><a class="reference internal" href="#sage.topology.simplicial_set.AbstractSimplex_class.apply_degeneracies"><code class="docutils literal notranslate"><span class="pre">apply_degeneracies()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.AbstractSimplex_class.degeneracies"><code class="docutils literal notranslate"><span class="pre">degeneracies()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.AbstractSimplex_class.dimension"><code class="docutils literal notranslate"><span class="pre">dimension()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.AbstractSimplex_class.is_degenerate"><code class="docutils literal notranslate"><span class="pre">is_degenerate()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.AbstractSimplex_class.is_nondegenerate"><code class="docutils literal notranslate"><span class="pre">is_nondegenerate()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.AbstractSimplex_class.nondegenerate"><code class="docutils literal notranslate"><span class="pre">nondegenerate()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.NonDegenerateSimplex"><code class="docutils literal notranslate"><span class="pre">NonDegenerateSimplex</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet"><code class="docutils literal notranslate"><span class="pre">SimplicialSet</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary"><code class="docutils literal notranslate"><span class="pre">SimplicialSet_arbitrary</span></code></a><ul>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.alexander_whitney"><code class="docutils literal notranslate"><span class="pre">alexander_whitney()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.all_n_simplices"><code class="docutils literal notranslate"><span class="pre">all_n_simplices()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.betti"><code class="docutils literal notranslate"><span class="pre">betti()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.cartesian_product"><code class="docutils literal notranslate"><span class="pre">cartesian_product()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.cells"><code class="docutils literal notranslate"><span class="pre">cells()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.chain_complex"><code class="docutils literal notranslate"><span class="pre">chain_complex()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.cohomology"><code class="docutils literal notranslate"><span class="pre">cohomology()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.cone"><code class="docutils literal notranslate"><span class="pre">cone()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.constant_map"><code class="docutils literal notranslate"><span class="pre">constant_map()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.coproduct"><code class="docutils literal notranslate"><span class="pre">coproduct()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.disjoint_union"><code class="docutils literal notranslate"><span class="pre">disjoint_union()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.face"><code class="docutils literal notranslate"><span class="pre">face()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.faces"><code class="docutils literal notranslate"><span class="pre">faces()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.graph"><code class="docutils literal notranslate"><span class="pre">graph()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.homology"><code class="docutils literal notranslate"><span class="pre">homology()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.identity"><code class="docutils literal notranslate"><span class="pre">identity()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.is_connected"><code class="docutils literal notranslate"><span class="pre">is_connected()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.is_reduced"><code class="docutils literal notranslate"><span class="pre">is_reduced()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.join"><code class="docutils literal notranslate"><span class="pre">join()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.n_cells"><code class="docutils literal notranslate"><span class="pre">n_cells()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.n_chains"><code class="docutils literal notranslate"><span class="pre">n_chains()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.nondegenerate_simplices"><code class="docutils literal notranslate"><span class="pre">nondegenerate_simplices()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.product"><code class="docutils literal notranslate"><span class="pre">product()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.pullback"><code class="docutils literal notranslate"><span class="pre">pullback()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.pushout"><code class="docutils literal notranslate"><span class="pre">pushout()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.quotient"><code class="docutils literal notranslate"><span class="pre">quotient()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.reduce"><code class="docutils literal notranslate"><span class="pre">reduce()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.rename_latex"><code class="docutils literal notranslate"><span class="pre">rename_latex()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.subsimplicial_set"><code class="docutils literal notranslate"><span class="pre">subsimplicial_set()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.suspension"><code class="docutils literal notranslate"><span class="pre">suspension()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_arbitrary.wedge"><code class="docutils literal notranslate"><span class="pre">wedge()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_finite"><code class="docutils literal notranslate"><span class="pre">SimplicialSet_finite</span></code></a><ul>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_finite.algebraic_topological_model"><code class="docutils literal notranslate"><span class="pre">algebraic_topological_model()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_finite.chain_complex"><code class="docutils literal notranslate"><span class="pre">chain_complex()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_finite.euler_characteristic"><code class="docutils literal notranslate"><span class="pre">euler_characteristic()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_finite.f_vector"><code class="docutils literal notranslate"><span class="pre">f_vector()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_finite.face_data"><code class="docutils literal notranslate"><span class="pre">face_data()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.SimplicialSet_finite.n_skeleton"><code class="docutils literal notranslate"><span class="pre">n_skeleton()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.all_degeneracies"><code class="docutils literal notranslate"><span class="pre">all_degeneracies()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.face_degeneracies"><code class="docutils literal notranslate"><span class="pre">face_degeneracies()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.shrink_simplicial_complex"><code class="docutils literal notranslate"><span class="pre">shrink_simplicial_complex()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.standardize_degeneracies"><code class="docutils literal notranslate"><span class="pre">standardize_degeneracies()</span></code></a></li>
<li><a class="reference internal" href="#sage.topology.simplicial_set.standardize_face_maps"><code class="docutils literal notranslate"><span class="pre">standardize_face_maps()</span></code></a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/scripts/furo.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"ZZ": "\\Bold{Z}", "NN": "\\Bold{N}", "RR": "\\Bold{R}", "CC": "\\Bold{C}", "QQ": "\\Bold{Q}", "QQbar": "\\overline{\\QQ}", "GF": ["\\Bold{F}_{#1}", 1], "Zp": ["\\Bold{Z}_{#1}", 1], "Qp": ["\\Bold{Q}_{#1}", 1], "Zmod": ["\\ZZ/#1\\ZZ", 1], "CDF": "\\Bold{C}", "CIF": "\\Bold{C}", "CLF": "\\Bold{C}", "RDF": "\\Bold{R}", "RIF": "\\Bold{I} \\Bold{R}", "RLF": "\\Bold{R}", "SL": "\\mathrm{SL}", "PSL": "\\mathrm{PSL}", "lcm": "\\mathop{\\operatorname{lcm}}", "Bold": ["\\mathbf{#1}", 1]}, "inlineMath": [["$", "$"], ["\\(", "\\)"]], "maxBuffer": 51200, "autoload": {"color": [], "colorv2": ["color"]}}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    <script src="../../../_static/jupyter-sphinx-furo.js"></script>
    </body>
</html>