<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<link rel="index" title="Index" href="../../../../genindex.html" /><link rel="search" title="Search" href="../../../../search.html" /><link rel="next" title="Hard Lattice Generator" href="../lattice.html" /><link rel="prev" title="Small Scale Variants of the AES (SR) Polynomial System Generator" href="sr.html" />

    <meta name="generator" content="sphinx-5.2.3, furo 2022.09.29"/>
        <title>Rijndael-GF - Cryptography</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/styles/furo.css?digest=d81277517bee4d6b0349d71bb2661d4890b5617c" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/custom-furo.css" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  --color-brand-primary: #0f0fff;
  --color-brand-content: #0f0fff;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZGD13B5572"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ZGD13B5572');
</script></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">Cryptography</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><div class="sidebar-scroll"><a class="sidebar-brand" href="../../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../../../_static/logo_sagemath_black.svg" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../../../_static/logo_sagemath_white.svg" alt="Dark Logo"/>
  </div>
  
      <span class="sidebar-brand-text">Sage 9.8 Reference Manual</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../../search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-home">
  <div class="sidebar-tree">
    <ul><li class="toctree-l1">
      <a class="reference internal" href="../../../index.html">Home - Cryptography</a>
    </li></ul>
  </div>
</div><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../cryptosystem.html">Cryptosystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cipher.html">Ciphers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../classical.html">Classical Cryptosystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../classical_cipher.html">Classical Ciphers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block_cipher/sdes.html">Simplified DES</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block_cipher/miniaes.html">Mini-AES</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block_cipher/des.html">DES</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block_cipher/present.html">PRESENT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../public_key/blum_goldwasser.html">Blum-Goldwasser Probabilistic Encryption</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stream.html">Stream Cryptosystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stream_cipher.html">Stream Ciphers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lfsr.html">Linear feedback shift register (LFSR) sequence commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../util.html">Utility Functions for Cryptography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../boolean_function.html">Boolean functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sbox.html">S-Boxes and Their Algebraic Representations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sboxes.html">S-Boxes used in cryptographic schemes</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpolynomialsystemgenerator.html">Abstract base class for generators of polynomial systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="sr.html">Small Scale Variants of the AES (SR) Polynomial System Generator</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Rijndael-GF</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lattice.html">Hard Lattice Generator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lwe.html">(Ring-)LWE oracle generators</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="rijndael-gf">
<span id="sage-crypto-mq-rijndael-gf"></span><h1>Rijndael-GF<a class="headerlink" href="#rijndael-gf" title="Permalink to this heading">#</a></h1>
<span class="target" id="module-sage.crypto.mq.rijndael_gf"></span><p>Rijndael-GF is an algebraic implementation of the AES cipher which seeks to
provide a fully generalized algebraic representation of both the whole AES
cipher as well as its individual components.</p>
<p>This class is an algebraic implementation of the Rijndael-GF extension of the
AES cipher, as described in <a class="reference internal" href="../../../../references/index.html#dr2002" id="id1"><span>[DR2002]</span></a>. The AES cipher itself is defined to
operate on a state in <span class="math notranslate nohighlight">\((\GF{2})^{8 n_t}\)</span> where
<span class="math notranslate nohighlight">\(n_t \in \{16, 20, 24, 28, 32\}\)</span>. Rijndael-GF is a generalization of AES which
allows for operations in <span class="math notranslate nohighlight">\((\GF{2^8})^{n_t}\)</span>, enabling more algebraically
sophisticated study of AES and its variants. This implementation of
Rijndael-GF is suitable for learning purposes, for comparison to other
algebraic ciphers, and for studying various techniques of algebraic
cryptanalysis of AES. This cipher is different from
<a class="reference internal" href="../block_cipher/miniaes.html#module-sage.crypto.block_cipher.miniaes" title="sage.crypto.block_cipher.miniaes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Mini-AES</span></code></a>, which is a
teaching tool for beginners to understand the basic structure of AES.</p>
<p>An algebraic implementation of Rijndael-GF is achieved by recognizing that
for each round component function <span class="math notranslate nohighlight">\(\phi\)</span> of AES (SubBytes, ShiftRows, etc.)
operating on state matrices, every entry of the output matrix <span class="math notranslate nohighlight">\(B = \phi(A)\)</span> is
representable as a polynomial with variables being the entries of the input
state matrix <span class="math notranslate nohighlight">\(A\)</span>. Correspondingly, this implementation of Rijndael-GF provides
a <code class="docutils literal notranslate"><span class="pre">RijndaelGF.Round_Component_Poly_Constr</span></code> class which allows for creation
of these such polynomials. For each round component function <span class="math notranslate nohighlight">\(\phi\)</span> of
Rijndael-GF there exists a <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object with a
<code class="docutils literal notranslate"><span class="pre">__call__</span></code> method of the form <code class="docutils literal notranslate"><span class="pre">__call__(i,</span> <span class="pre">j)</span></code> which returns a polynomial
representing <span class="math notranslate nohighlight">\(\phi(A)_{i,j}\)</span> in terms of the entries of <span class="math notranslate nohighlight">\(A\)</span>.
There additionally are various methods provided which allow for easy polynomial
evaluation and for simple creation of <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> objects
representing more complex aspects of the cipher.</p>
<p>This approach to implementing Rijndael-GF bears some similarity to the
multivariate quadratic (MQ) systems utilized in <a class="reference internal" href="sr.html#module-sage.crypto.mq.sr" title="sage.crypto.mq.sr"><code class="xref py py-mod docutils literal notranslate"><span class="pre">SR</span></code></a>,
in that the MQ systems also seek to describe the AES cipher as a system of
algebraic equations. Despite this initial similarity though, Rijndael-GF and
<a class="reference internal" href="sr.html#module-sage.crypto.mq.sr" title="sage.crypto.mq.sr"><code class="xref py py-mod docutils literal notranslate"><span class="pre">SR</span></code></a> are quite different as this implementation
seeks to provide a fully generalized algebraic representation of both the
whole AES cipher as well as its individual components, while
<a class="reference internal" href="sr.html#module-sage.crypto.mq.sr" title="sage.crypto.mq.sr"><code class="xref py py-mod docutils literal notranslate"><span class="pre">SR</span></code></a> is instead a family of parameterizable variants
of the AES suitable as a framework for comparing different cryptanalytic
techniques that can be brought to bear on the AES.</p>
<p>AUTHORS:</p>
<ul class="simple">
<li><p>Thomas Gagne (2015-06): initial version</p></li>
</ul>
<p>EXAMPLES:</p>
<p>We build Rijndael-GF with a block length of 4 and a key length of 6:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.crypto.mq.rijndael_gf</span> <span class="kn">import</span> <span class="n">RijndaelGF</span>
<span class="gp">sage: </span><span class="n">rgf</span> <span class="o">=</span> <span class="n">RijndaelGF</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<p>We can encrypt plaintexts and decrypt and ciphertexts by calling the
<code class="docutils literal notranslate"><span class="pre">encrypt</span></code> and <code class="docutils literal notranslate"><span class="pre">decrypt</span></code> methods or by calling the Rijndael-GF object
explicitly. Note that the default input format is a hex string.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">plaintext</span> <span class="o">=</span> <span class="s1">&#39;00112233445566778899aabbccddeeff&#39;</span>
<span class="gp">sage: </span><span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;000102030405060708090a0b0c0d0e0f1011121314151617&#39;</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">encrypt</span><span class="p">(</span><span class="n">plaintext</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="go">&#39;dda97ca4864cdfe06eaf70a0ec0d7191&#39;</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">decrypt</span><span class="p">(</span><span class="s1">&#39;dda97ca4864cdfe06eaf70a0ec0d7191&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="go">&#39;00112233445566778899aabbccddeeff&#39;</span>
</pre></div>
</div>
<p>We can also use binary strings as input and output.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">plain</span> <span class="o">=</span> <span class="s1">&#39;11101011100111110000000111001100&#39;</span> <span class="o">*</span> <span class="mi">4</span>
<span class="gp">sage: </span><span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;01100010111101101000110010111010&#39;</span> <span class="o">*</span> <span class="mi">6</span>
<span class="gp">sage: </span><span class="n">ciphertext</span> <span class="o">=</span> <span class="n">rgf</span><span class="p">(</span><span class="n">plain</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;binary&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ciphertext</span>
<span class="go">&#39;11010011000010011010110001000011101110110100110100110010011011111100011011100111110011100111010011001110110100011100000011111011&#39;</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;decrypt&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;binary&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">plain</span>
<span class="go">True</span>
</pre></div>
</div>
<p><a class="reference internal" href="../../../../references/index.html#dr2002" id="id2"><span>[DR2002]</span></a> demonstrates an example of encryption which takes the plaintext
‘3243f6a8885a308d313198a2e0370734’ and the key
‘2b7e151628aed2a6abf7158809cf4f3c’ and returns the ciphertext
‘3902dc1925dc116a8409850b1dfb9732’. We can use this example to demonstrate
the correctness of this implementation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">rgf</span> <span class="o">=</span> <span class="n">RijndaelGF</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="c1"># change dimensions for this example</span>
<span class="gp">sage: </span><span class="n">plain</span> <span class="o">=</span> <span class="s1">&#39;3243f6a8885a308d313198a2e0370734&#39;</span>
<span class="gp">sage: </span><span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;2b7e151628aed2a6abf7158809cf4f3c&#39;</span>
<span class="gp">sage: </span><span class="n">expected_ciphertext</span> <span class="o">=</span> <span class="s1">&#39;3925841d02dc09fbdc118597196a0b32&#39;</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">encrypt</span><span class="p">(</span><span class="n">plain</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">expected_ciphertext</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">rgf</span> <span class="o">=</span> <span class="n">RijndaelGF</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="c1"># revert to previous dimensions</span>
</pre></div>
</div>
<p>To build polynomials representing entries of the output matrix <span class="math notranslate nohighlight">\(B = \phi(A)\)</span>
for any round component function <span class="math notranslate nohighlight">\(\phi\)</span>, each of the round component functions
(SubBytes, ShiftRows, and MixColumns) have a <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code>
object associated with it for building polynomials. These objects can be
accessed by calling their getter functions: <code class="docutils literal notranslate"><span class="pre">rgf.sub_bytes_poly()</span></code>,
<code class="docutils literal notranslate"><span class="pre">rgf.shift_rows_poly()</span></code>, and <code class="docutils literal notranslate"><span class="pre">rgf.mix_columns_poly()</span></code>. Each returned
object has a <code class="docutils literal notranslate"><span class="pre">__call__</span></code> method which takes an index <code class="docutils literal notranslate"><span class="pre">i,j</span></code> and an
<code class="docutils literal notranslate"><span class="pre">algorithm</span></code> flag (‘encrypt’ or ‘decrypt’) and returns a polynomial
representing <span class="math notranslate nohighlight">\(\phi(A)_{i,j}\)</span> in terms of the entries of <span class="math notranslate nohighlight">\(A\)</span>, where <span class="math notranslate nohighlight">\(A\)</span> is an
arbitrary state matrix and <span class="math notranslate nohighlight">\(\phi\)</span> is the round component function associated
with that particular <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object. Some of these
objects’ <code class="docutils literal notranslate"><span class="pre">__call__</span></code> methods also have additional keywords to modify their
behavior, and so we describe the usage of each object below.</p>
<p><code class="docutils literal notranslate"><span class="pre">rgf.shift_rows_poly()</span></code> and <code class="docutils literal notranslate"><span class="pre">rgf.mix_columns_poly()</span></code> do not have any
additional keywords for their <code class="docutils literal notranslate"><span class="pre">__call__</span></code> methods and we can call them as
such:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">sr_pc</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">shift_rows_poly_constr</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">sr_pc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">a13</span>
<span class="gp">sage: </span><span class="n">sr_pc</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;decrypt&#39;</span><span class="p">)</span>
<span class="go">a21</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">mc_pc</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">mix_columns_poly_constr</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">mc_pc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">a02 + x*a12 + (x + 1)*a22 + a32</span>
<span class="gp">sage: </span><span class="n">mc_pc</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;decrypt&#39;</span><span class="p">)</span>
<span class="go">(x^3 + x^2 + 1)*a03 + (x^3 + 1)*a13 + (x^3 + x^2 + x)*a23 + (x^3 + x + 1)*a33</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">rgf.sub_bytes_poly()</span></code> has a single keyword <code class="docutils literal notranslate"><span class="pre">no_inversion=False</span></code>, which
when set to <code class="docutils literal notranslate"><span class="pre">True</span></code> returns only the affine transformation step of SubBytes.
Below describes the usage of <code class="docutils literal notranslate"><span class="pre">rgf.sub_bytes_poly()</span></code></p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">sb_pc</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">sub_bytes_poly_constr</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">sb_pc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">(x^2 + 1)*a12^254 +</span>
<span class="go">(x^3 + 1)*a12^253 +</span>
<span class="go">(x^7 + x^6 + x^5 + x^4 + x^3 + 1)*a12^251 +</span>
<span class="go">(x^5 + x^2 + 1)*a12^247 +</span>
<span class="go">(x^7 + x^6 + x^5 + x^4 + x^2)*a12^239 +</span>
<span class="go">a12^223 +</span>
<span class="go">(x^7 + x^5 + x^4 + x^2 + 1)*a12^191 +</span>
<span class="go">(x^7 + x^3 + x^2 + x + 1)*a12^127 +</span>
<span class="go">(x^6 + x^5 + x + 1)</span>
<span class="gp">sage: </span><span class="n">sb_pc</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">no_inversion</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(x^7 + x^3 + x^2 + x + 1)*a23^128 +</span>
<span class="go">(x^7 + x^5 + x^4 + x^2 + 1)*a23^64 +</span>
<span class="go">a23^32 +</span>
<span class="go">(x^7 + x^6 + x^5 + x^4 + x^2)*a23^16 +</span>
<span class="go">(x^5 + x^2 + 1)*a23^8 +</span>
<span class="go">(x^7 + x^6 + x^5 + x^4 + x^3 + 1)*a23^4 +</span>
<span class="go">(x^3 + 1)*a23^2 +</span>
<span class="go">(x^2 + 1)*a23 +</span>
<span class="go">(x^6 + x^5 + x + 1)</span>
</pre></div>
</div>
<p>Because of the order of the affine transformation and the inversion step in
SubBytes, calling <code class="docutils literal notranslate"><span class="pre">rgf.sub_bytes_poly()(i,</span> <span class="pre">j,</span> <span class="pre">algorithm='decrypt')</span></code> results
in a polynomial with thousands of terms which takes a very long time to
compute. Hence, when using the decryption version of <code class="docutils literal notranslate"><span class="pre">rgf.sub_bytes_poly()</span></code>
with the intention of evaluating the polynomials it constructs, it is
recommended to first call <code class="docutils literal notranslate"><span class="pre">rgf.sub_bytes_poly()(i,</span> <span class="pre">j,</span> <span class="pre">algorithm='decrypt',</span>
<span class="pre">no_inversion=True)</span></code> to get a polynomial representing only the inverse affine
transformation, evaluate this polynomial for a particular input block, then
finally perform the inversion step after the affine transformation polynomial
has been evaluated.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">inv_affine</span> <span class="o">=</span> <span class="n">sb_pc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;decrypt&#39;</span><span class="p">,</span>
<span class="gp">....: </span><span class="n">no_inversion</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">state</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">_hex_to_GF</span><span class="p">(</span><span class="s1">&#39;ff87968431d86a51645151fa773ad009&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">evaluated</span> <span class="o">=</span> <span class="n">inv_affine</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">result</span> <span class="o">=</span> <span class="n">evaluated</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">_GF_to_hex</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">&#39;79&#39;</span>
</pre></div>
</div>
<p>We can see how the variables of these polynomials are organized in <span class="math notranslate nohighlight">\(A\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">state_vrs</span>
<span class="go">[a00 a01 a02 a03]</span>
<span class="go">[a10 a11 a12 a13]</span>
<span class="go">[a20 a21 a22 a23]</span>
<span class="go">[a30 a31 a32 a33]</span>
</pre></div>
</div>
<p>The final <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object we have not discussed yet is
<code class="docutils literal notranslate"><span class="pre">add_round_key_poly</span></code>, which corresponds to the AddRoundKey round component
function. This object differs from the other <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code>
objects in that it returns polynomials with variables being entries of an
input state <span class="math notranslate nohighlight">\(A\)</span> as well as entries of various subkeys. Since there are <span class="math notranslate nohighlight">\(N_r\)</span>
subkeys to choose from, <code class="docutils literal notranslate"><span class="pre">add_round_key_poly</span></code> has a keyword of <code class="docutils literal notranslate"><span class="pre">round=0</span></code> to
select which subkey to use variables from.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ark_pc</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">add_round_key_poly_constr</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ark_pc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">a12 + k012</span>
<span class="gp">sage: </span><span class="n">ark_pc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;decrypt&#39;</span><span class="p">)</span>
<span class="go">a12 + k012</span>
<span class="gp">sage: </span><span class="n">ark_pc</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="go">a23 + k723</span>
</pre></div>
</div>
<p>We can see how key variables are organized in the original key (the key used
to build the rest of the subkeys) below. Note that because key variables are
subkey entries, if the key length is longer than the block length we will have
entries from multiple subkeys in the original key matrix.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">key_vrs</span>
<span class="go">[k000 k001 k002 k003 k100 k101]</span>
<span class="go">[k010 k011 k012 k013 k110 k111]</span>
<span class="go">[k020 k021 k022 k023 k120 k121]</span>
<span class="go">[k030 k031 k032 k033 k130 k131]</span>
</pre></div>
</div>
<p>We can evaluate any of these constructed polynomials for a particular input
state (in essence, calculate <span class="math notranslate nohighlight">\(\phi(A)_{i,j}\)</span>) as such:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">rgf</span> <span class="o">=</span> <span class="n">RijndaelGF</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">state</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">_hex_to_GF</span><span class="p">(</span><span class="s1">&#39;fe7b5170fe7c8e93477f7e4bf6b98071&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">poly</span> <span class="o">=</span> <span class="n">mc_pc</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;decrypt&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">poly</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
<span class="go">x^7 + x^6 + x^5 + x^2 + x</span>
</pre></div>
</div>
<p>We can use the <code class="docutils literal notranslate"><span class="pre">apply_poly</span></code> method to build a matrix whose <span class="math notranslate nohighlight">\(i,j\)</span> th
entry equals the polynomial <code class="docutils literal notranslate"><span class="pre">phi_poly(i,</span> <span class="pre">j)</span></code> evaluated for a particular input
state, where <code class="docutils literal notranslate"><span class="pre">phi_poly</span></code> is the <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object
associated with the round component function <span class="math notranslate nohighlight">\(\phi\)</span>. Essentially,
<code class="docutils literal notranslate"><span class="pre">apply_poly</span></code> calculates <span class="math notranslate nohighlight">\(\phi(A)\)</span>, where <span class="math notranslate nohighlight">\(A\)</span> is our input state.
Calling <code class="docutils literal notranslate"><span class="pre">apply_poly</span></code> is equivalent to applying the round component function
associated this <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object to <span class="math notranslate nohighlight">\(A\)</span>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">state</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">_hex_to_GF</span><span class="p">(</span><span class="s1">&#39;c4cedcabe694694e4b23bfdd6fb522fa&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">apply_poly</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">rgf</span><span class="o">.</span><span class="n">sub_bytes_poly_constr</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">_GF_to_hex</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">&#39;1c8b86628e22f92fb32608c1a8d5932d&#39;</span>
<span class="gp">sage: </span><span class="n">result</span> <span class="o">==</span> <span class="n">rgf</span><span class="o">.</span><span class="n">sub_bytes</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Alternatively, we can pass a matrix of polynomials as input to <code class="docutils literal notranslate"><span class="pre">apply_poly</span></code>,
which will then return another matrix of polynomials. For example,
<code class="docutils literal notranslate"><span class="pre">rgf.state_vrs</span></code> can be used as input to make each <code class="docutils literal notranslate"><span class="pre">i,j</span></code> th entry of the
output matrix equal <code class="docutils literal notranslate"><span class="pre">phi_poly_constr(i,</span> <span class="pre">j)</span></code>, where <code class="docutils literal notranslate"><span class="pre">phi_poly_constr</span></code> is
our inputted <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object. This matrix can then be
passed through again and so on, demonstrating how one could potentially build
a matrix of polynomials representing the entire cipher.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">state</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">apply_poly</span><span class="p">(</span><span class="n">rgf</span><span class="o">.</span><span class="n">state_vrs</span><span class="p">,</span> <span class="n">rgf</span><span class="o">.</span><span class="n">shift_rows_poly_constr</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">state</span>
<span class="go">[a00 a01 a02 a03]</span>
<span class="go">[a11 a12 a13 a10]</span>
<span class="go">[a22 a23 a20 a21]</span>
<span class="go">[a33 a30 a31 a32]</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">apply_poly</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">rgf</span><span class="o">.</span><span class="n">add_round_key_poly_constr</span><span class="p">())</span>
<span class="go">[a00 + k000 a01 + k001 a02 + k002 a03 + k003]</span>
<span class="go">[a11 + k010 a12 + k011 a13 + k012 a10 + k013]</span>
<span class="go">[a22 + k020 a23 + k021 a20 + k022 a21 + k023]</span>
<span class="go">[a33 + k030 a30 + k031 a31 + k032 a32 + k033]</span>
</pre></div>
</div>
<p>For any of these <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> objects, we can change the
keywords of its <code class="docutils literal notranslate"><span class="pre">__call__</span></code> method when <code class="docutils literal notranslate"><span class="pre">apply_poly</span></code> invokes it by passing
<code class="docutils literal notranslate"><span class="pre">apply_poly</span></code> a dictionary mapping keywords to their values.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">apply_poly</span><span class="p">(</span><span class="n">rgf</span><span class="o">.</span><span class="n">state_vrs</span><span class="p">,</span> <span class="n">rgf</span><span class="o">.</span><span class="n">add_round_key_poly_constr</span><span class="p">(),</span>
<span class="gp">....: </span><span class="n">poly_constr_attr</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;round&#39;</span> <span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
<span class="go">[a00 + k500 a01 + k501 a02 + k502 a03 + k503]</span>
<span class="go">[a10 + k510 a11 + k511 a12 + k512 a13 + k513]</span>
<span class="go">[a20 + k520 a21 + k521 a22 + k522 a23 + k523]</span>
<span class="go">[a30 + k530 a31 + k531 a32 + k532 a33 + k533]</span>
</pre></div>
</div>
<p>We can build our own <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> objects which correspond
to the composition of multiple round component functions with the <code class="docutils literal notranslate"><span class="pre">compose</span></code>
method. To do this, if we pass two <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> objects
to <code class="docutils literal notranslate"><span class="pre">compose</span></code> where the first object corresponds to the round component
function <span class="math notranslate nohighlight">\(f\)</span> and the second to the round component function <span class="math notranslate nohighlight">\(g\)</span>, <code class="docutils literal notranslate"><span class="pre">compose</span></code>
will return a new <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object corresponding to the
function <span class="math notranslate nohighlight">\(g \circ f\)</span>. This returned <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object
will have the arguments of <code class="docutils literal notranslate"><span class="pre">__call__(row,</span> <span class="pre">col,</span> <span class="pre">algorithm='encrypt')</span></code> and
when passed an index <code class="docutils literal notranslate"><span class="pre">i,j</span></code> will return <span class="math notranslate nohighlight">\(g(f(A))_{i,j}\)</span> in terms of the
entries of <span class="math notranslate nohighlight">\(A\)</span>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">rcpc</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">rgf</span><span class="o">.</span><span class="n">shift_rows_poly_constr</span><span class="p">(),</span>
<span class="gp">....: </span><span class="n">rgf</span><span class="o">.</span><span class="n">mix_columns_poly_constr</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">rcpc</span>
<span class="go">A polynomial constructor of a round component of Rijndael-GF block cipher with block length 4, key length 6, and 12 rounds.</span>
<span class="gp">sage: </span><span class="n">rcpc</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">a01 + a12 + x*a23 + (x + 1)*a30</span>

<span class="gp">sage: </span><span class="n">state</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">_hex_to_GF</span><span class="p">(</span><span class="s1">&#39;afb73eeb1cd1b85162280f27fb20d585&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">apply_poly</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">rcpc</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">new_state</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">shift_rows</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">new_state</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">mix_columns</span><span class="p">(</span><span class="n">new_state</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result</span> <span class="o">==</span> <span class="n">new_state</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">rcpc</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">rgf</span><span class="o">.</span><span class="n">mix_columns_poly_constr</span><span class="p">(),</span>
<span class="gp">....: </span><span class="n">rgf</span><span class="o">.</span><span class="n">shift_rows_poly_constr</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">result</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">apply_poly</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">rcpc</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;decrypt&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">new_state</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">mix_columns</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;decrypt&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">new_state</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">shift_rows</span><span class="p">(</span><span class="n">new_state</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;decrypt&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">new_state</span> <span class="o">==</span> <span class="n">result</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Alternatively, we can use <code class="docutils literal notranslate"><span class="pre">compose</span></code> to build the polynomial output of
a <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object corresponding to the composition of
multiple round functions like above without having to explicitly build our
own <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object. To do this, we simply make the
first input a <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object corresponding to a
round component function <span class="math notranslate nohighlight">\(f\)</span> and make the second input a polynomial
representing <span class="math notranslate nohighlight">\(g(A)_{i,j}\)</span> for a round component function <span class="math notranslate nohighlight">\(g\)</span>. Given this,
<code class="docutils literal notranslate"><span class="pre">compose</span></code> will return a polynomial representing <span class="math notranslate nohighlight">\(g(f(A))_{i,j}\)</span> in terms
of the entries of <span class="math notranslate nohighlight">\(A\)</span>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">poly</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">mix_columns_poly_constr</span><span class="p">()(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">poly</span>
<span class="go">x*a03 + (x + 1)*a13 + a23 + a33</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">rgf</span><span class="o">.</span><span class="n">sub_bytes_poly_constr</span><span class="p">(),</span> <span class="n">poly</span><span class="p">)</span>
<span class="go">(x^3 + x)*a03^254 +</span>
<span class="go">(x^3 + x^2 + x + 1)*a13^254 +</span>
<span class="go">(x^2 + 1)*a23^254 +</span>
<span class="go">(x^2 + 1)*a33^254 +</span>
<span class="go">(x^4 + x)*a03^253 +</span>
<span class="go">(x^4 + x^3 + x + 1)*a13^253 +</span>
<span class="go">(x^3 + 1)*a23^253 +</span>
<span class="go">(x^3 + 1)*a33^253 +</span>
<span class="go">(x^7 + x^6 + x^5 + x^3 + 1)*a03^251 +</span>
<span class="go">(x^4)*a13^251 +</span>
<span class="go">(x^7 + x^6 + x^5 + x^4 + x^3 + 1)*a23^251 +</span>
<span class="go">(x^7 + x^6 + x^5 + x^4 + x^3 + 1)*a33^251 +</span>
<span class="go">(x^6 + x^3 + x)*a03^247 +</span>
<span class="go">(x^6 + x^5 + x^3 + x^2 + x + 1)*a13^247 +</span>
<span class="go">(x^5 + x^2 + 1)*a23^247 +</span>
<span class="go">(x^5 + x^2 + 1)*a33^247 +</span>
<span class="go">(x^7 + x^6 + x^5 + x^4 + x + 1)*a03^239 +</span>
<span class="go">(x^2 + x + 1)*a13^239 +</span>
<span class="go">(x^7 + x^6 + x^5 + x^4 + x^2)*a23^239 +</span>
<span class="go">(x^7 + x^6 + x^5 + x^4 + x^2)*a33^239 +</span>
<span class="go">x*a03^223 +</span>
<span class="go">(x + 1)*a13^223 +</span>
<span class="go">a23^223 +</span>
<span class="go">a33^223 +</span>
<span class="go">(x^6 + x^5 + x^4 + 1)*a03^191 +</span>
<span class="go">(x^7 + x^6 + x^2)*a13^191 +</span>
<span class="go">(x^7 + x^5 + x^4 + x^2 + 1)*a23^191 +</span>
<span class="go">(x^7 + x^5 + x^4 + x^2 + 1)*a33^191 +</span>
<span class="go">(x^2 + 1)*a03^127 +</span>
<span class="go">(x^7 + x^3 + x)*a13^127 +</span>
<span class="go">(x^7 + x^3 + x^2 + x + 1)*a23^127 +</span>
<span class="go">(x^7 + x^3 + x^2 + x + 1)*a33^127 +</span>
<span class="go">(x^6 + x^5 + x + 1)</span>
</pre></div>
</div>
<p>If we use <code class="docutils literal notranslate"><span class="pre">algorithm='decrypt'</span></code> as an argument to <code class="docutils literal notranslate"><span class="pre">compose</span></code>, then the
value of <code class="docutils literal notranslate"><span class="pre">algorithm</span></code> will be passed directly to the first argument of
<code class="docutils literal notranslate"><span class="pre">compose</span></code> (a <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object) when it is called,
provided the second argument is a polynomial. Setting this flag does nothing
if both arguments are <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> objects, since the
returned <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object’s <code class="docutils literal notranslate"><span class="pre">__call__</span></code> method must have
its own <code class="docutils literal notranslate"><span class="pre">algorithm</span></code> keyword defaulted to ‘encrypt’.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">poly</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">shift_rows_poly_constr</span><span class="p">()(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">rgf</span><span class="o">.</span><span class="n">mix_columns_poly_constr</span><span class="p">(),</span> <span class="n">poly</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;decrypt&#39;</span><span class="p">)</span>
<span class="go">(x^3 + x^2 + 1)*a03 + (x^3 + 1)*a13 + (x^3 + x^2 + x)*a23 + (x^3 + x + 1)*a33</span>

<span class="gp">sage: </span><span class="n">state</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">_hex_to_GF</span><span class="p">(</span><span class="s1">&#39;80121e0776fd1d8a8d8c31bc965d1fee&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">with_decrypt</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">rgf</span><span class="o">.</span><span class="n">sub_bytes_poly_constr</span><span class="p">(),</span>
<span class="gp">....: </span><span class="n">rgf</span><span class="o">.</span><span class="n">shift_rows_poly_constr</span><span class="p">(),</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;decrypt&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result_wd</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">apply_poly</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">with_decrypt</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">no_decrypt</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">rgf</span><span class="o">.</span><span class="n">sub_bytes_poly_constr</span><span class="p">(),</span>
<span class="gp">....: </span><span class="n">rgf</span><span class="o">.</span><span class="n">shift_rows_poly_constr</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">result_nd</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">apply_poly</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">no_decrypt</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result_wd</span> <span class="o">==</span> <span class="n">result_nd</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We can also pass keyword dictionaries of <code class="docutils literal notranslate"><span class="pre">f_attr</span></code> and <code class="docutils literal notranslate"><span class="pre">g_attr</span></code> to
<code class="docutils literal notranslate"><span class="pre">compose</span></code> to make <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code> use those keywords during polynomial
creation.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">rcpc</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">rgf</span><span class="o">.</span><span class="n">add_round_key_poly_constr</span><span class="p">(),</span>
<span class="gp">....: </span><span class="n">rgf</span><span class="o">.</span><span class="n">add_round_key_poly_constr</span><span class="p">(),</span>
<span class="gp">....: </span><span class="n">f_attr</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;round&#39;</span> <span class="p">:</span> <span class="mi">4</span><span class="p">},</span> <span class="n">g_attr</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;round&#39;</span> <span class="p">:</span> <span class="mi">7</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">rcpc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">a12 + k412 + k712</span>
</pre></div>
</div>
<p>In addition to building polynomial representations of state matrices, we can
also build polynomial representations of elements of the expanded key with the
<code class="docutils literal notranslate"><span class="pre">expand_key_poly</span></code> method. However, since the key schedule is defined
recursively, it is impossible to build polynomials for the key schedule in
the same manner as we do for the round component functions. Consequently,
<code class="docutils literal notranslate"><span class="pre">expand_round_key_poly()</span></code> is not a <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object.
Instead, <code class="docutils literal notranslate"><span class="pre">expand_key_poly</span></code> is a method which takes an index <code class="docutils literal notranslate"><span class="pre">i,j</span></code> and a
round number <code class="docutils literal notranslate"><span class="pre">round</span></code>, and returns a polynomial representing the <span class="math notranslate nohighlight">\(i,j\)</span> th
entry of the <code class="docutils literal notranslate"><span class="pre">round</span></code> th round key. This polynomial’s variables are entries
of the original key we built above.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">expand_key_poly</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">k012</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">expand_key_poly</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">k111</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">expand_key_poly</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">(x^2 + 1)*k121^254 +</span>
<span class="go">(x^3 + 1)*k121^253 +</span>
<span class="go">(x^7 + x^6 + x^5 + x^4 + x^3 + 1)*k121^251 +</span>
<span class="go">(x^5 + x^2 + 1)*k121^247 +</span>
<span class="go">(x^7 + x^6 + x^5 + x^4 + x^2)*k121^239 +</span>
<span class="go">k121^223 +</span>
<span class="go">(x^7 + x^5 + x^4 + x^2 + 1)*k121^191 +</span>
<span class="go">(x^7 + x^3 + x^2 + x + 1)*k121^127 +</span>
<span class="go">k010 +</span>
<span class="go">(x^6 + x^5 + x)</span>
</pre></div>
</div>
<p>Since <code class="docutils literal notranslate"><span class="pre">expand_key_poly</span></code> is not actually a
<code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object, we cannot use it as input to
<code class="docutils literal notranslate"><span class="pre">apply_poly</span></code> or <code class="docutils literal notranslate"><span class="pre">compose</span></code>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">apply_poly</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">rgf</span><span class="o">.</span><span class="n">expand_key_poly</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: keyword &#39;poly_constr&#39; must be a Round_Component_Poly_Constr</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">rgf</span><span class="o">.</span><span class="n">expand_key_poly</span><span class="p">,</span> <span class="n">rgf</span><span class="o">.</span><span class="n">sub_bytes_poly_constr</span><span class="p">())</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: keyword &#39;f&#39; must be a Round_Component_Poly_Constr</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="sage.crypto.mq.rijndael_gf.RijndaelGF">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.crypto.mq.rijndael_gf.</span></span><span class="sig-name descname"><span class="pre">RijndaelGF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Nb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_chr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'a'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key_chr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'k'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.crypto.mq.rijndael_gf.RijndaelGF" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../structure/sage/structure/sage_object.html#sage.structure.sage_object.SageObject" title="(in Parents and Elements v9.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">SageObject</span></code></a></p>
<p>An algebraically generalized version of the AES cipher.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Nb</span></code> – The block length of this instantiation. Must be between 4
and 8.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Nk</span></code> – The key length of this instantiation. Must be between 4 and 8.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">state_chr</span></code> – The variable name for polynomials representing
elements from state matrices.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">key_chr</span></code> – The variable name for polynomials representing
elements of the key schedule.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.crypto.mq.rijndael_gf</span> <span class="kn">import</span> <span class="n">RijndaelGF</span>
<span class="gp">sage: </span><span class="n">rgf</span> <span class="o">=</span> <span class="n">RijndaelGF</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">rgf</span>
<span class="go">Rijndael-GF block cipher with block length 6, key length 8, and 14 rounds.</span>
</pre></div>
</div>
<p>By changing <code class="docutils literal notranslate"><span class="pre">state_chr</span></code> we can alter the names of variables in
polynomials representing elements from state matrices.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">rgf</span> <span class="o">=</span> <span class="n">RijndaelGF</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">state_chr</span><span class="o">=</span><span class="s1">&#39;myChr&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">mix_columns_poly_constr</span><span class="p">()(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">(x + 1)*myChr02 + myChr12 + myChr22 + x*myChr32</span>
</pre></div>
</div>
<p>We can also alter the name of variables in polynomials representing
elements from round keys by changing <code class="docutils literal notranslate"><span class="pre">key_chr</span></code>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">rgf</span> <span class="o">=</span> <span class="n">RijndaelGF</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">key_chr</span><span class="o">=</span><span class="s1">&#39;myKeyChr&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">expand_key_poly</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">(x^2 + 1)*myKeyChr121^254 +</span>
<span class="go">(x^3 + 1)*myKeyChr121^253 +</span>
<span class="go">(x^7 + x^6 + x^5 + x^4 + x^3 + 1)*myKeyChr121^251 +</span>
<span class="go">(x^5 + x^2 + 1)*myKeyChr121^247 +</span>
<span class="go">(x^7 + x^6 + x^5 + x^4 + x^2)*myKeyChr121^239 +</span>
<span class="go">myKeyChr121^223 +</span>
<span class="go">(x^7 + x^5 + x^4 + x^2 + 1)*myKeyChr121^191 +</span>
<span class="go">(x^7 + x^3 + x^2 + x + 1)*myKeyChr121^127 +</span>
<span class="go">myKeyChr010 +</span>
<span class="go">(x^6 + x^5 + x)</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="sage.crypto.mq.rijndael_gf.RijndaelGF.Round_Component_Poly_Constr">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Round_Component_Poly_Constr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">polynomial_constr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">round_component_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.Round_Component_Poly_Constr" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../structure/sage/structure/sage_object.html#sage.structure.sage_object.SageObject" title="(in Parents and Elements v9.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">SageObject</span></code></a></p>
<p>An object which constructs polynomials representing round
component functions of a RijndaelGF object.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">polynomial_constr</span></code> – A function which takes an index
<code class="docutils literal notranslate"><span class="pre">row,col</span></code> and returns a polynomial representing the <code class="docutils literal notranslate"><span class="pre">row,col</span></code>
th entry of a matrix after a specific round component function
has been applied to it. This polynomial must be in terms of
entries of the input matrix to that round component function and
of entries of various subkeys. <code class="docutils literal notranslate"><span class="pre">polynomial_constr</span></code> must have
arguments of the form <code class="docutils literal notranslate"><span class="pre">polynomial_constr(row,</span> <span class="pre">col,</span>
<span class="pre">algorithm='encrypt',</span> <span class="pre">**kwargs)</span></code> and  must be able to be called
as <code class="docutils literal notranslate"><span class="pre">polynomial_constr(row,</span> <span class="pre">col)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rgf</span></code> – The RijndaelGF object whose state entries are
represented by polynomials returned from <code class="docutils literal notranslate"><span class="pre">polynomial_constr</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">round_component_name</span></code> – The name of the round component
function this object corresponds to as a string. Used solely
for display purposes.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.crypto.mq.rijndael_gf</span> <span class="kn">import</span> \
<span class="gp">....: </span><span class="n">RijndaelGF</span>
<span class="gp">sage: </span><span class="n">rgf</span> <span class="o">=</span> <span class="n">RijndaelGF</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">rcpc</span> <span class="o">=</span> <span class="n">RijndaelGF</span><span class="o">.</span><span class="n">Round_Component_Poly_Constr</span><span class="p">(</span>
<span class="gp">....: </span><span class="n">rgf</span><span class="o">.</span><span class="n">_shift_rows_pc</span><span class="p">,</span> <span class="n">rgf</span><span class="p">,</span> <span class="s2">&quot;Shift Rows&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">rcpc</span>
<span class="go">A polynomial constructor for the function &#39;Shift Rows&#39; of Rijndael-GF block cipher with block length 4, key length 4, and 10 rounds.</span>
</pre></div>
</div>
<p>If <span class="math notranslate nohighlight">\(\phi\)</span> is the round component function to which this object
corresponds to, then <code class="docutils literal notranslate"><span class="pre">__call__(i,j)</span></code> <span class="math notranslate nohighlight">\(= \phi(A)_{i,j}\)</span>, where
<span class="math notranslate nohighlight">\(A\)</span> is an arbitrary input matrix. Note that the polynomial returned
by <code class="docutils literal notranslate"><span class="pre">__call__(i,j)</span></code> will be in terms of the entries of <span class="math notranslate nohighlight">\(A\)</span>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">rcpc</span> <span class="o">=</span> <span class="n">RijndaelGF</span><span class="o">.</span><span class="n">Round_Component_Poly_Constr</span><span class="p">(</span>
<span class="gp">....: </span><span class="n">rgf</span><span class="o">.</span><span class="n">_mix_columns_pc</span><span class="p">,</span> <span class="n">rgf</span><span class="p">,</span> <span class="s2">&quot;Mix Columns&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">poly</span> <span class="o">=</span> <span class="n">rcpc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="n">poly</span>
<span class="go">a02 + x*a12 + (x + 1)*a22 + a32</span>
<span class="gp">sage: </span><span class="n">state</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">_hex_to_GF</span><span class="p">(</span><span class="s1">&#39;d1876c0f79c4300ab45594add66ff41f&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">mix_columns</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">poly</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Invoking this objects <code class="docutils literal notranslate"><span class="pre">__call__</span></code> method passes its arguments
directly to <code class="docutils literal notranslate"><span class="pre">polynomial_constr</span></code> and returns the result. In a
sense, <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> acts as a wrapper for
the <code class="docutils literal notranslate"><span class="pre">polynomial_constr</span></code> method and helps ensure that each
<code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object will act similarly.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">rgf</span><span class="o">.</span><span class="n">_mix_columns_pc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="n">rcpc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
<span class="gp">....: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Since all keyword arguments of <code class="docutils literal notranslate"><span class="pre">polynomial_constr</span></code> must have a
default value except for <code class="docutils literal notranslate"><span class="pre">row</span></code> and <code class="docutils literal notranslate"><span class="pre">col</span></code>, we can always call
a <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object by <code class="docutils literal notranslate"><span class="pre">__call__(row,</span> <span class="pre">col)</span></code>.
Because of this, methods such as <code class="docutils literal notranslate"><span class="pre">apply_poly</span></code> and <code class="docutils literal notranslate"><span class="pre">compose</span></code>
will only call <code class="docutils literal notranslate"><span class="pre">__call__(row,</span> <span class="pre">col)</span></code> when passed a
<code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object. In order to change this
object’s behavior and force methods such as <code class="docutils literal notranslate"><span class="pre">apply_poly</span></code> to use
non-default values for keywords we can pass dictionaries mapping
keywords to non-default values as input to <code class="docutils literal notranslate"><span class="pre">apply_poly</span></code> and
<code class="docutils literal notranslate"><span class="pre">compose</span></code>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">apply_poly</span><span class="p">(</span><span class="n">rgf</span><span class="o">.</span><span class="n">state_vrs</span><span class="p">,</span>
<span class="gp">....: </span><span class="n">rgf</span><span class="o">.</span><span class="n">add_round_key_poly_constr</span><span class="p">(),</span>
<span class="gp">....: </span><span class="n">poly_constr_attr</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;round&#39;</span> <span class="p">:</span> <span class="mi">9</span><span class="p">})</span>
<span class="go">[a00 + k900 a01 + k901 a02 + k902 a03 + k903]</span>
<span class="go">[a10 + k910 a11 + k911 a12 + k912 a13 + k913]</span>
<span class="go">[a20 + k920 a21 + k921 a22 + k922 a23 + k923]</span>
<span class="go">[a30 + k930 a31 + k931 a32 + k932 a33 + k933]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">fn</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">rgf</span><span class="o">.</span><span class="n">add_round_key_poly_constr</span><span class="p">(),</span>
<span class="gp">....: </span><span class="n">rgf</span><span class="o">.</span><span class="n">add_round_key_poly_constr</span><span class="p">(),</span>
<span class="gp">....: </span><span class="n">f_attr</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;round&#39;</span> <span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="n">g_attr</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;round&#39;</span> <span class="p">:</span> <span class="mi">7</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">fn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">a23 + k323 + k723</span>
</pre></div>
</div>
<p>Because all <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> objects are callable
as <code class="docutils literal notranslate"><span class="pre">__call__(row,</span> <span class="pre">col,</span> <span class="pre">algorithm)</span></code>, <code class="docutils literal notranslate"><span class="pre">__call__</span></code> will check
the validity of these three arguments automatically. Any other
keywords, however, must be checked in <code class="docutils literal notranslate"><span class="pre">polynomial_constr</span></code>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">my_poly_constr</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;encrypt&#39;</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">rgf</span><span class="o">.</span><span class="n">_F</span><span class="o">.</span><span class="n">one</span><span class="p">()</span> <span class="c1"># example body with no checks</span>
<span class="gp">sage: </span><span class="n">rcpc</span> <span class="o">=</span> <span class="n">RijndaelGF</span><span class="o">.</span><span class="n">Round_Component_Poly_Constr</span><span class="p">(</span>
<span class="gp">....: </span><span class="n">my_poly_constr</span><span class="p">,</span> <span class="n">rgf</span><span class="p">,</span> <span class="s2">&quot;My Poly Constr&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">rcpc</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: keyword &#39;row&#39; must be in range 0 - 3</span>
<span class="gp">sage: </span><span class="n">rcpc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: keyword &#39;algorithm&#39; must be either &#39;encrypt&#39; or &#39;decrypt&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.crypto.mq.rijndael_gf.RijndaelGF.add_round_key">
<span class="sig-name descname"><span class="pre">add_round_key</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">round_key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.add_round_key" title="Permalink to this definition">#</a></dt>
<dd><p>Return the round-key addition of matrices <code class="docutils literal notranslate"><span class="pre">state</span></code> and <code class="docutils literal notranslate"><span class="pre">round_key</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">state</span></code> – The state matrix to have <code class="docutils literal notranslate"><span class="pre">round_key</span></code> added to.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">round_key</span></code> – The round key to add to <code class="docutils literal notranslate"><span class="pre">state</span></code>.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>A state matrix which is the round key addition of <code class="docutils literal notranslate"><span class="pre">state</span></code> and
<code class="docutils literal notranslate"><span class="pre">round_key</span></code>. This transformation is simply the entrywise addition
of these two matrices.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.crypto.mq.rijndael_gf</span> <span class="kn">import</span> <span class="n">RijndaelGF</span>
<span class="gp">sage: </span><span class="n">rgf</span> <span class="o">=</span> <span class="n">RijndaelGF</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">state</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">_hex_to_GF</span><span class="p">(</span><span class="s1">&#39;36339d50f9b539269f2c092dc4406d23&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">key</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">_hex_to_GF</span><span class="p">(</span><span class="s1">&#39;7CC78D0E22754E667E24573F454A6531&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">key_schedule</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">expand_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">add_round_key</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">key_schedule</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">_GF_to_hex</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">&#39;4af4105edbc07740e1085e12810a0812&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.crypto.mq.rijndael_gf.RijndaelGF.add_round_key_poly_constr">
<span class="sig-name descname"><span class="pre">add_round_key_poly_constr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.add_round_key_poly_constr" title="Permalink to this definition">#</a></dt>
<dd><p>Return the <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object corresponding to
AddRoundKey.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.crypto.mq.rijndael_gf</span> <span class="kn">import</span> <span class="n">RijndaelGF</span>
<span class="gp">sage: </span><span class="n">rgf</span> <span class="o">=</span> <span class="n">RijndaelGF</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ark_pc</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">add_round_key_poly_constr</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ark_pc</span>
<span class="go">A polynomial constructor for the function &#39;Add Round Key&#39; of Rijndael-GF block cipher with block length 4, key length 4, and 10 rounds.</span>
<span class="gp">sage: </span><span class="n">ark_pc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">a01 + k001</span>
</pre></div>
</div>
<p>When invoking the returned object’s <code class="docutils literal notranslate"><span class="pre">__call__</span></code> method, changing the
value of <code class="docutils literal notranslate"><span class="pre">algorithm='encrypt'</span></code> does nothing, since the AddRoundKey
round component function is its own inverse.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">with_encrypt</span> <span class="o">=</span> <span class="n">ark_pc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;encrypt&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">with_decrypt</span> <span class="o">=</span> <span class="n">ark_pc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;decrypt&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">with_encrypt</span> <span class="o">==</span> <span class="n">with_decrypt</span>
<span class="go">True</span>
</pre></div>
</div>
<p>When invoking the returned object’s <code class="docutils literal notranslate"><span class="pre">__call__</span></code> method, one can change
the round subkey used in the returned polynomial by changing the
<code class="docutils literal notranslate"><span class="pre">round=0</span></code> keyword.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ark_pc</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="go">a21 + k721</span>
</pre></div>
</div>
<p>When passing the returned object to methods such as <code class="docutils literal notranslate"><span class="pre">apply_poly</span></code> and
<code class="docutils literal notranslate"><span class="pre">compose</span></code>, we can make these methods use a non-default value for
<code class="docutils literal notranslate"><span class="pre">round=0</span></code> by passing in a dictionary mapping <code class="docutils literal notranslate"><span class="pre">round</span></code> to a different
value.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">apply_poly</span><span class="p">(</span><span class="n">rgf</span><span class="o">.</span><span class="n">state_vrs</span><span class="p">,</span> <span class="n">ark_pc</span><span class="p">,</span>
<span class="gp">....: </span><span class="n">poly_constr_attr</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;round&#39;</span> <span class="p">:</span> <span class="mi">6</span><span class="p">})</span>
<span class="go">[a00 + k600 a01 + k601 a02 + k602 a03 + k603]</span>
<span class="go">[a10 + k610 a11 + k611 a12 + k612 a13 + k613]</span>
<span class="go">[a20 + k620 a21 + k621 a22 + k622 a23 + k623]</span>
<span class="go">[a30 + k630 a31 + k631 a32 + k632 a33 + k633]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">rcpc</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">ark_pc</span><span class="p">,</span> <span class="n">ark_pc</span><span class="p">,</span>
<span class="gp">....: </span><span class="n">f_attr</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;round&#39;</span> <span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="n">g_attr</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;round&#39;</span> <span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">rcpc</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">a31 + k331 + k531</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.crypto.mq.rijndael_gf.RijndaelGF.apply_poly">
<span class="sig-name descname"><span class="pre">apply_poly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_constr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'encrypt'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_constr_attr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.apply_poly" title="Permalink to this definition">#</a></dt>
<dd><p>Return a state matrix where <code class="docutils literal notranslate"><span class="pre">poly_method</span></code> is applied to each entry.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">state</span></code> – The state matrix over <span class="math notranslate nohighlight">\(\GF{2^8}\)</span> to which
<code class="docutils literal notranslate"><span class="pre">poly_method</span></code> is applied to.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">poly_constr</span></code> – The <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object to
build polynomials during evaluation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – (default: “encrypt”) Passed directly to
<code class="docutils literal notranslate"><span class="pre">rcpc</span></code> to select encryption or decryption. The
encryption flag is “encrypt” and the decrypt flag is “decrypt”.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">keys</span></code> – (default: None) An array of <span class="math notranslate nohighlight">\(N_r\)</span> subkey matrices to
replace any key variables in any polynomials returned by
<code class="docutils literal notranslate"><span class="pre">poly_method</span></code>. Must be identical to the format returned by
<code class="docutils literal notranslate"><span class="pre">expand_key</span></code>. If any polynomials have key variables and <code class="docutils literal notranslate"><span class="pre">keys</span></code>
is not supplied, the key variables will remain as-is.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">poly_constr_attr</span></code> – (default:None) A dictionary of keyword
attributes to pass to <code class="docutils literal notranslate"><span class="pre">rcpc</span></code> when it is called.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>A state matrix in <span class="math notranslate nohighlight">\(\GF{2^8}\)</span> whose <span class="math notranslate nohighlight">\(i,j\)</span> th entry equals the
polynomial <code class="docutils literal notranslate"><span class="pre">poly_constr(i,</span> <span class="pre">j,</span> <span class="pre">algorithm,</span> <span class="pre">**poly_constr_attr)</span></code>
evaluated by setting its variables equal to the corresponding
entries of <code class="docutils literal notranslate"><span class="pre">state</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.crypto.mq.rijndael_gf</span> <span class="kn">import</span> <span class="n">RijndaelGF</span>
<span class="gp">sage: </span><span class="n">rgf</span> <span class="o">=</span> <span class="n">RijndaelGF</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">state</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">_hex_to_GF</span><span class="p">(</span><span class="s1">&#39;3b59cb73fcd90ee05774222dc067fb68&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">apply_poly</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">rgf</span><span class="o">.</span><span class="n">shift_rows_poly_constr</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">_GF_to_hex</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">&#39;3bd92268fc74fb735767cbe0c0590e2d&#39;</span>
</pre></div>
</div>
<p>Calling <code class="docutils literal notranslate"><span class="pre">apply_poly</span></code> with the <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object
of a round component (e.g. <code class="docutils literal notranslate"><span class="pre">sub_bytes_poly</span></code>) is identical to
calling that round component function itself.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">state</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">_hex_to_GF</span><span class="p">(</span><span class="s1">&#39;4915598f55e5d7a0daca94fa1f0a63f7&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">apply_poly_result</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">apply_poly</span><span class="p">(</span><span class="n">state</span><span class="p">,</span>
<span class="gp">....: </span><span class="n">rgf</span><span class="o">.</span><span class="n">sub_bytes_poly_constr</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">direct_result</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">sub_bytes</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">direct_result</span> <span class="o">==</span> <span class="n">apply_poly_result</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If the <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object’s <code class="docutils literal notranslate"><span class="pre">__call__</span></code> method
returns a polynomial with state variables as well as key variables, we
can supply a list of <span class="math notranslate nohighlight">\(N_r\)</span> round keys <code class="docutils literal notranslate"><span class="pre">keys</span></code> whose elements are
evaluated as the key variables. If this is not provided, the key
variables will remain as is.:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">state</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">_hex_to_GF</span><span class="p">(</span><span class="s1">&#39;14f9701ae35fe28c440adf4d4ea9c026&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">key</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">_hex_to_GF</span><span class="p">(</span><span class="s1">&#39;54d990a16ba09ab596bbf40ea111702f&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">keys</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">expand_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">apply_poly</span><span class="p">(</span><span class="n">state</span><span class="p">,</span>
<span class="gp">....: </span><span class="n">rgf</span><span class="o">.</span><span class="n">add_round_key_poly_constr</span><span class="p">(),</span> <span class="n">keys</span><span class="o">=</span><span class="n">keys</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result</span> <span class="o">==</span> <span class="n">rgf</span><span class="o">.</span><span class="n">add_round_key</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">apply_poly</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">rgf</span><span class="o">.</span><span class="n">add_round_key_poly_constr</span><span class="p">())[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">k000 + (x^4 + x^2)</span>
</pre></div>
</div>
<p>We can change the value of the keywords of <code class="docutils literal notranslate"><span class="pre">poly_constr</span></code> ‘s
<code class="docutils literal notranslate"><span class="pre">__call__</span></code> method when <code class="docutils literal notranslate"><span class="pre">apply_poly</span></code> calls it by passing in a
dictionary <code class="docutils literal notranslate"><span class="pre">poly_constr_attr</span></code> mapping keywords to their values.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">apply_poly</span><span class="p">(</span><span class="n">rgf</span><span class="o">.</span><span class="n">state_vrs</span><span class="p">,</span>
<span class="gp">....: </span><span class="n">rgf</span><span class="o">.</span><span class="n">add_round_key_poly_constr</span><span class="p">(),</span>
<span class="gp">....: </span><span class="n">poly_constr_attr</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;round&#39;</span> <span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
<span class="go">[a00 + k500 a01 + k501 a02 + k502 a03 + k503]</span>
<span class="go">[a10 + k510 a11 + k511 a12 + k512 a13 + k513]</span>
<span class="go">[a20 + k520 a21 + k521 a22 + k522 a23 + k523]</span>
<span class="go">[a30 + k530 a31 + k531 a32 + k532 a33 + k533]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.crypto.mq.rijndael_gf.RijndaelGF.block_length">
<span class="sig-name descname"><span class="pre">block_length</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.block_length" title="Permalink to this definition">#</a></dt>
<dd><p>Return the block length of this instantiation of Rijndael-GF.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.crypto.mq.rijndael_gf</span> <span class="kn">import</span> <span class="n">RijndaelGF</span>
<span class="gp">sage: </span><span class="n">rgf</span> <span class="o">=</span> <span class="n">RijndaelGF</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">block_length</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.crypto.mq.rijndael_gf.RijndaelGF.compose">
<span class="sig-name descname"><span class="pre">compose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'encrypt'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_attr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g_attr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.compose" title="Permalink to this definition">#</a></dt>
<dd><p>Return a <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object corresponding to
<span class="math notranslate nohighlight">\(g \circ f\)</span> or the polynomial output of this object’s <code class="docutils literal notranslate"><span class="pre">__call__</span></code>
method.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">f</span></code> – A <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object corresponding to
a round component function <span class="math notranslate nohighlight">\(f\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">g</span></code> – A <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object corresponding to
a round component function <span class="math notranslate nohighlight">\(g\)</span> or a polynomial output of this
object’s <code class="docutils literal notranslate"><span class="pre">__call__</span></code> method.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – (default: “encrypt”) Whether <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code>
should use their encryption transformations or their decryption
transformations. Does nothing if <code class="docutils literal notranslate"><span class="pre">g</span></code> is a
<code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object. The encryption flag is
“encrypt” and the decryption flag is “decrypt”.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">f_attr</span></code> – (default: None) A dictionary of keyword attributes to
pass to <code class="docutils literal notranslate"><span class="pre">f</span></code> when it is called.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">g_attr</span></code> – (default: None) A dictionary of keyword attributes to
pass to <code class="docutils literal notranslate"><span class="pre">g</span></code> when it is called. Does nothing if <code class="docutils literal notranslate"><span class="pre">g</span></code> is a
polynomial.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">g</span></code> is a <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object corresponding
to a round component function <span class="math notranslate nohighlight">\(g\)</span>, then <code class="docutils literal notranslate"><span class="pre">compose</span></code> returns a
<code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> corresponding to the round
component function <span class="math notranslate nohighlight">\(g \circ f\)</span>, where <span class="math notranslate nohighlight">\(f\)</span> is the round component
function corresponding to the first argument <code class="docutils literal notranslate"><span class="pre">f</span></code>. On the other
hand, if <code class="docutils literal notranslate"><span class="pre">g</span></code> <span class="math notranslate nohighlight">\(= g(A)_{i,j}\)</span> for a round component function <span class="math notranslate nohighlight">\(g\)</span>,
then <code class="docutils literal notranslate"><span class="pre">compose</span></code> returns <span class="math notranslate nohighlight">\(g(f(A))_{i,j}\)</span>, where <span class="math notranslate nohighlight">\(A\)</span> is an
arbitrary input state matrix.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>This function allows us to determine the polynomial representations
of entries across multiple round functions. For example, if we
wanted a polynomial representing the <code class="docutils literal notranslate"><span class="pre">1,3</span></code> entry of a matrix after
we first apply ShiftRows and then MixColumns to that matrix, we do:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.crypto.mq.rijndael_gf</span> <span class="kn">import</span> <span class="n">RijndaelGF</span>
<span class="gp">sage: </span><span class="n">rgf</span> <span class="o">=</span> <span class="n">RijndaelGF</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">mcp</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">mix_columns_poly_constr</span><span class="p">()(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="n">mcp</span>
<span class="go">a03 + x*a13 + (x + 1)*a23 + a33</span>
<span class="gp">sage: </span><span class="n">result</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">rgf</span><span class="o">.</span><span class="n">shift_rows_poly_constr</span><span class="p">(),</span> <span class="n">mcp</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result</span>
<span class="go">a03 + x*a10 + (x + 1)*a21 + a32</span>
</pre></div>
</div>
<p>We can test the correctness of this:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">state</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">_hex_to_GF</span><span class="p">(</span><span class="s1">&#39;fa636a2825b339c940668a3157244d17&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">new_state</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">shift_rows</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">new_state</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">mix_columns</span><span class="p">(</span><span class="n">new_state</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">list</span><span class="p">())</span> <span class="o">==</span> <span class="n">new_state</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We can also use <code class="docutils literal notranslate"><span class="pre">compose</span></code> to build a new
<code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object corresponding to the composition
of multiple round functions as such:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">fn</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">rgf</span><span class="o">.</span><span class="n">shift_rows_poly_constr</span><span class="p">(),</span>
<span class="gp">....: </span><span class="n">rgf</span><span class="o">.</span><span class="n">mix_columns_poly_constr</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">fn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">a03 + x*a10 + (x + 1)*a21 + a32</span>
</pre></div>
</div>
<p>If we use <code class="docutils literal notranslate"><span class="pre">compose</span></code> to make a new <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code>
object, we can use that object as input to <code class="docutils literal notranslate"><span class="pre">apply_poly</span></code> and
<code class="docutils literal notranslate"><span class="pre">compose</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">state</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">_hex_to_GF</span><span class="p">(</span><span class="s1">&#39;36400926f9336d2d9fb59d23c42c3950&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">apply_poly</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">fn</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">_GF_to_hex</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">&#39;f4bcd45432e554d075f1d6c51dd03b3c&#39;</span>

<span class="gp">sage: </span><span class="n">new_state</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">shift_rows</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">new_state</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">mix_columns</span><span class="p">(</span><span class="n">new_state</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result</span> <span class="o">==</span> <span class="n">new_state</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">fn2</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">rgf</span><span class="o">.</span><span class="n">sub_bytes_poly_constr</span><span class="p">(),</span> <span class="n">fn</span><span class="p">)</span>
</pre></div>
</div>
<p>If the second argument is a polynomial, then the value of <code class="docutils literal notranslate"><span class="pre">algorithm</span></code>
is passed directly to the first argument <span class="math notranslate nohighlight">\(f\)</span> during evaluation.
However, if the second argument is a <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code>
object, changing <code class="docutils literal notranslate"><span class="pre">algorithm</span></code> does nothing since the returned object
has its own <code class="docutils literal notranslate"><span class="pre">algorithm='encrypt'</span></code> keyword.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">rgf</span><span class="o">.</span><span class="n">sub_bytes_poly_constr</span><span class="p">(),</span>
<span class="gp">....: </span><span class="n">rgf</span><span class="o">.</span><span class="n">mix_columns_poly_constr</span><span class="p">(),</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;decrypt&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">rgf</span><span class="o">.</span><span class="n">sub_bytes_poly_constr</span><span class="p">(),</span>
<span class="gp">....: </span><span class="n">rgf</span><span class="o">.</span><span class="n">mix_columns_poly_constr</span><span class="p">())</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="n">g</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We can change the keyword attributes of the <code class="docutils literal notranslate"><span class="pre">__call__</span></code> methods of
<code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code> by passing dictionaries <code class="docutils literal notranslate"><span class="pre">f_attr</span></code> and <code class="docutils literal notranslate"><span class="pre">g_attr</span></code> to
<code class="docutils literal notranslate"><span class="pre">compose</span></code>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">fn</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">rgf</span><span class="o">.</span><span class="n">add_round_key_poly_constr</span><span class="p">(),</span>
<span class="gp">....: </span><span class="n">rgf</span><span class="o">.</span><span class="n">add_round_key_poly_constr</span><span class="p">(),</span>
<span class="gp">....: </span><span class="n">f_attr</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;round&#39;</span> <span class="p">:</span> <span class="mi">4</span><span class="p">},</span> <span class="n">g_attr</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;round&#39;</span> <span class="p">:</span> <span class="mi">7</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">fn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">a12 + k412 + k712</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.crypto.mq.rijndael_gf.RijndaelGF.decrypt">
<span class="sig-name descname"><span class="pre">decrypt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ciphertext</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hex'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.decrypt" title="Permalink to this definition">#</a></dt>
<dd><p>Return the ciphertext <code class="docutils literal notranslate"><span class="pre">ciphertext</span></code> decrypted with the key <code class="docutils literal notranslate"><span class="pre">key</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ciphertext</span></code> – The ciphertext to be decrypted.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">key</span></code> – The key to decrypt <code class="docutils literal notranslate"><span class="pre">ciphertext</span></code> with.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">format</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">hex</span></code>) The string format that both
<code class="docutils literal notranslate"><span class="pre">ciphertext</span></code> and <code class="docutils literal notranslate"><span class="pre">key</span></code> must be in, either “hex” or “binary”.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>A string in the format <code class="docutils literal notranslate"><span class="pre">format</span></code> of <code class="docutils literal notranslate"><span class="pre">ciphertext</span></code> decrypted with
key <code class="docutils literal notranslate"><span class="pre">key</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.crypto.mq.rijndael_gf</span> <span class="kn">import</span> <span class="n">RijndaelGF</span>
<span class="gp">sage: </span><span class="n">rgf</span> <span class="o">=</span> <span class="n">RijndaelGF</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;2dfb02343f6d12dd09337ec75b36e3f0&#39;</span>
<span class="gp">sage: </span><span class="n">ciphertext</span> <span class="o">=</span> <span class="s1">&#39;54d990a16ba09ab596bbf40ea111702f&#39;</span>
<span class="gp">sage: </span><span class="n">expected_plaintext</span> <span class="o">=</span> <span class="s1">&#39;1e1d913b7274ad9b5a4ab1a5f9133b93&#39;</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">decrypt</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">expected_plaintext</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We can also decrypt messages using binary strings.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;00011010000011100011000000111101&#39;</span> <span class="o">*</span> <span class="mi">4</span>
<span class="gp">sage: </span><span class="n">ciphertext</span> <span class="o">=</span> <span class="s1">&#39;00110010001110000111110110000001&#39;</span> <span class="o">*</span> <span class="mi">4</span>
<span class="gp">sage: </span><span class="n">expected_plaintext</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;101111111010011100111100101010100111&#39;</span>
<span class="gp">....: </span><span class="s1">&#39;1111010000101101100001101000000000000000010000000100111011&#39;</span>
<span class="gp">....: </span><span class="s1">&#39;0100001111100011010001101101001011&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">decrypt</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;binary&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result</span> <span class="o">==</span> <span class="n">expected_plaintext</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.crypto.mq.rijndael_gf.RijndaelGF.encrypt">
<span class="sig-name descname"><span class="pre">encrypt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">plain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hex'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.encrypt" title="Permalink to this definition">#</a></dt>
<dd><p>Return the plaintext <code class="docutils literal notranslate"><span class="pre">plain</span></code> encrypted with the key <code class="docutils literal notranslate"><span class="pre">key</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">plain</span></code> – The plaintext to be encrypted.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">key</span></code> – The key to encrypt <code class="docutils literal notranslate"><span class="pre">plain</span></code> with.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">format</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">hex</span></code>) The string format of <code class="docutils literal notranslate"><span class="pre">key</span></code> and
<code class="docutils literal notranslate"><span class="pre">plain</span></code>, either “hex” or “binary”.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>A string of the plaintext <code class="docutils literal notranslate"><span class="pre">plain</span></code> encrypted with the key <code class="docutils literal notranslate"><span class="pre">key</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.crypto.mq.rijndael_gf</span> <span class="kn">import</span> <span class="n">RijndaelGF</span>
<span class="gp">sage: </span><span class="n">rgf</span> <span class="o">=</span> <span class="n">RijndaelGF</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;c81677bc9b7ac93b25027992b0261996&#39;</span>
<span class="gp">sage: </span><span class="n">plain</span> <span class="o">=</span> <span class="s1">&#39;fde3bad205e5d0d73547964ef1fe37f1&#39;</span>
<span class="gp">sage: </span><span class="n">expected_ciphertext</span> <span class="o">=</span> <span class="s1">&#39;e767290ddfc6414e3c50a444bec081f0&#39;</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">encrypt</span><span class="p">(</span><span class="n">plain</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">expected_ciphertext</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We can encrypt binary strings as well.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;10010111110000011111011011010001&#39;</span> <span class="o">*</span> <span class="mi">4</span>
<span class="gp">sage: </span><span class="n">plain</span> <span class="o">=</span> <span class="s1">&#39;00000000101000000000000001111011&#39;</span> <span class="o">*</span> <span class="mi">4</span>
<span class="gp">sage: </span><span class="n">expected_ciphertext</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;11010111100100001010001011110010111&#39;</span>
<span class="gp">....: </span><span class="s1">&#39;1110011000000011111100100011011100101000000001000111000010&#39;</span>
<span class="gp">....: </span><span class="s1">&#39;00100111011011001000111101111110100&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">encrypt</span><span class="p">(</span><span class="n">plain</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;binary&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result</span> <span class="o">==</span> <span class="n">expected_ciphertext</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.crypto.mq.rijndael_gf.RijndaelGF.expand_key">
<span class="sig-name descname"><span class="pre">expand_key</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.expand_key" title="Permalink to this definition">#</a></dt>
<dd><p>Return the expanded key schedule from <code class="docutils literal notranslate"><span class="pre">key</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">key</span></code> – The key to build a key schedule from. Must be a matrix
over <span class="math notranslate nohighlight">\(\GF{2^8}\)</span> of dimensions <span class="math notranslate nohighlight">\(4 \times N_k\)</span>.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>A length <span class="math notranslate nohighlight">\(Nr\)</span> list of <span class="math notranslate nohighlight">\(4 \times N_b\)</span> matrices corresponding to the
expanded key. The <span class="math notranslate nohighlight">\(n\)</span> th entry of the list corresponds to the matrix
used in the <code class="docutils literal notranslate"><span class="pre">add_round_key</span></code> step of the <span class="math notranslate nohighlight">\(n\)</span> th round.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.crypto.mq.rijndael_gf</span> <span class="kn">import</span> <span class="n">RijndaelGF</span>
<span class="gp">sage: </span><span class="n">rgf</span> <span class="o">=</span> <span class="n">RijndaelGF</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;331D0084B176C3FB59CAA0EDA271B565BB5D9A2D1E4B2892&#39;</span>
<span class="gp">sage: </span><span class="n">key_state</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">_hex_to_GF</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">key_schedule</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">expand_key</span><span class="p">(</span><span class="n">key_state</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">_GF_to_hex</span><span class="p">(</span><span class="n">key_schedule</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&#39;331d0084b176c3fb59caa0eda271b565&#39;</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">_GF_to_hex</span><span class="p">(</span><span class="n">key_schedule</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>
<span class="go">&#39;5c5d51c4121f018d0f4f3e408ae9f78c&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.crypto.mq.rijndael_gf.RijndaelGF.expand_key_poly">
<span class="sig-name descname"><span class="pre">expand_key_poly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">row</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">round</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.expand_key_poly" title="Permalink to this definition">#</a></dt>
<dd><p>Return a polynomial representing the <code class="docutils literal notranslate"><span class="pre">row,col</span></code> th entry of the
<code class="docutils literal notranslate"><span class="pre">round</span></code> th round key.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">row</span></code> – The row position of the element represented by this
polynomial.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">col</span></code> – The column position of the element represented by this
polynomial.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>A polynomial representing the <code class="docutils literal notranslate"><span class="pre">row,col</span></code> th entry of the <code class="docutils literal notranslate"><span class="pre">round</span></code>
th round key in terms of entries of the input key.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.crypto.mq.rijndael_gf</span> <span class="kn">import</span> <span class="n">RijndaelGF</span>
<span class="gp">sage: </span><span class="n">rgf</span> <span class="o">=</span> <span class="n">RijndaelGF</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">expand_key_poly</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">k012</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">expand_key_poly</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">(x^2 + 1)*k023^254 +</span>
<span class="go">(x^3 + 1)*k023^253 +</span>
<span class="go">(x^7 + x^6 + x^5 + x^4 + x^3 + 1)*k023^251 +</span>
<span class="go">(x^5 + x^2 + 1)*k023^247 +</span>
<span class="go">(x^7 + x^6 + x^5 + x^4 + x^2)*k023^239 +</span>
<span class="go">k023^223 +</span>
<span class="go">(x^7 + x^5 + x^4 + x^2 + 1)*k023^191 +</span>
<span class="go">(x^7 + x^3 + x^2 + x + 1)*k023^127 +</span>
<span class="go">k010 +</span>
<span class="go">k011 +</span>
<span class="go">k012 +</span>
<span class="go">(x^6 + x^5 + x)</span>
</pre></div>
</div>
<p>It should be noted that <code class="docutils literal notranslate"><span class="pre">expand_key_poly</span></code> cannot be used with
<code class="docutils literal notranslate"><span class="pre">apply_poly</span></code> or <code class="docutils literal notranslate"><span class="pre">compose</span></code>, since <code class="docutils literal notranslate"><span class="pre">expand_key_poly</span></code> is not a
<code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">rgf</span><span class="o">.</span><span class="n">sub_bytes_poly_constr</span><span class="p">(),</span> <span class="n">rgf</span><span class="o">.</span><span class="n">expand_key_poly</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: keyword &#39;g&#39; must be a Round_Component_Poly_Constr or a polynomial over Finite Field in x of size 2^8</span>

<span class="gp">sage: </span><span class="n">state</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">_hex_to_GF</span><span class="p">(</span><span class="s1">&#39;00000000000000000000000000000000&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">apply_poly</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">rgf</span><span class="o">.</span><span class="n">expand_key_poly</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: keyword &#39;poly_constr&#39; must be a Round_Component_Poly_Constr</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.crypto.mq.rijndael_gf.RijndaelGF.key_length">
<span class="sig-name descname"><span class="pre">key_length</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.key_length" title="Permalink to this definition">#</a></dt>
<dd><p>Return the key length of this instantiation of Rijndael-GF.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.crypto.mq.rijndael_gf</span> <span class="kn">import</span> <span class="n">RijndaelGF</span>
<span class="gp">sage: </span><span class="n">rgf</span> <span class="o">=</span> <span class="n">RijndaelGF</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">key_length</span><span class="p">()</span>
<span class="go">8</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.crypto.mq.rijndael_gf.RijndaelGF.mix_columns">
<span class="sig-name descname"><span class="pre">mix_columns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'encrypt'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.mix_columns" title="Permalink to this definition">#</a></dt>
<dd><p>Return the application of MixColumns to the state matrix <code class="docutils literal notranslate"><span class="pre">state</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">state</span></code> – The state matrix to apply MixColumns to.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – (default: “encrypt”) Whether to perform the
encryption version of MixColumns, or its decryption inverse. The
encryption flag is “encrypt” and the decryption flag is “decrypt”.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The state matrix over <span class="math notranslate nohighlight">\(\GF{2^8}\)</span> which is the result of applying
MixColumns to <code class="docutils literal notranslate"><span class="pre">state</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.crypto.mq.rijndael_gf</span> <span class="kn">import</span> <span class="n">RijndaelGF</span>
<span class="gp">sage: </span><span class="n">rgf</span> <span class="o">=</span> <span class="n">RijndaelGF</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">state</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">_hex_to_GF</span><span class="p">(</span><span class="s1">&#39;cd54c7283864c0c55d4c727e90c9a465&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">mix_columns</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">_GF_to_hex</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">&#39;921f748fd96e937d622d7725ba8ba50c&#39;</span>
<span class="gp">sage: </span><span class="n">decryption</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">mix_columns</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;decrypt&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">decryption</span> <span class="o">==</span> <span class="n">state</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.crypto.mq.rijndael_gf.RijndaelGF.mix_columns_poly_constr">
<span class="sig-name descname"><span class="pre">mix_columns_poly_constr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.mix_columns_poly_constr" title="Permalink to this definition">#</a></dt>
<dd><p>Return a <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object corresponding to
MixColumns.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.crypto.mq.rijndael_gf</span> <span class="kn">import</span> <span class="n">RijndaelGF</span>
<span class="gp">sage: </span><span class="n">rgf</span> <span class="o">=</span> <span class="n">RijndaelGF</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">mc_pc</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">mix_columns_poly_constr</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">mc_pc</span>
<span class="go">A polynomial constructor for the function &#39;Mix Columns&#39; of Rijndael-GF block cipher with block length 4, key length 4, and 10 rounds.</span>
<span class="gp">sage: </span><span class="n">mc_pc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">a02 + x*a12 + (x + 1)*a22 + a32</span>
<span class="gp">sage: </span><span class="n">mc_pc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;decrypt&#39;</span><span class="p">)</span>
<span class="go">(x^3 + 1)*a00 + (x^3 + x^2 + x)*a10 + (x^3 + x + 1)*a20 + (x^3 + x^2 + 1)*a30</span>
</pre></div>
</div>
<p>The returned object’s <code class="docutils literal notranslate"><span class="pre">__call__</span></code> method has no additional keywords,
unlike <code class="docutils literal notranslate"><span class="pre">sub_bytes_poly_constr()</span></code> and <code class="docutils literal notranslate"><span class="pre">add_round_key_poly_constr()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.crypto.mq.rijndael_gf.RijndaelGF.number_rounds">
<span class="sig-name descname"><span class="pre">number_rounds</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.number_rounds" title="Permalink to this definition">#</a></dt>
<dd><p>Return the number of rounds used in this instantiation of Rijndael-GF.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.crypto.mq.rijndael_gf</span> <span class="kn">import</span> <span class="n">RijndaelGF</span>
<span class="gp">sage: </span><span class="n">rgf</span> <span class="o">=</span> <span class="n">RijndaelGF</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">number_rounds</span><span class="p">()</span>
<span class="go">11</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.crypto.mq.rijndael_gf.RijndaelGF.shift_rows">
<span class="sig-name descname"><span class="pre">shift_rows</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'encrypt'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.shift_rows" title="Permalink to this definition">#</a></dt>
<dd><p>Return the application of ShiftRows to the state matrix <code class="docutils literal notranslate"><span class="pre">state</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">state</span></code> – A state matrix over <span class="math notranslate nohighlight">\(\GF{2^8}\)</span> to which ShiftRows is
applied to.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – (default: “encrypt”) Whether to perform the
encryption version of ShiftRows or its decryption inverse. The
encryption flag is “encrypt” and the decryption flag is “decrypt”.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>A state matrix over <span class="math notranslate nohighlight">\(\GF{2^8}\)</span> which is the application of ShiftRows
to <code class="docutils literal notranslate"><span class="pre">state</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.crypto.mq.rijndael_gf</span> <span class="kn">import</span> <span class="n">RijndaelGF</span>
<span class="gp">sage: </span><span class="n">rgf</span> <span class="o">=</span> <span class="n">RijndaelGF</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">state</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">_hex_to_GF</span><span class="p">(</span><span class="s1">&#39;adcb0f257e9c63e0bc557e951c15ef01&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">shift_rows</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">_GF_to_hex</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">&#39;ad9c7e017e55ef25bc150fe01ccb6395&#39;</span>
<span class="gp">sage: </span><span class="n">decryption</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">shift_rows</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;decrypt&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">decryption</span> <span class="o">==</span> <span class="n">state</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.crypto.mq.rijndael_gf.RijndaelGF.shift_rows_poly_constr">
<span class="sig-name descname"><span class="pre">shift_rows_poly_constr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.shift_rows_poly_constr" title="Permalink to this definition">#</a></dt>
<dd><p>Return a <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object corresponding to
ShiftRows.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.crypto.mq.rijndael_gf</span> <span class="kn">import</span> <span class="n">RijndaelGF</span>
<span class="gp">sage: </span><span class="n">rgf</span> <span class="o">=</span> <span class="n">RijndaelGF</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sr_pc</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">shift_rows_poly_constr</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">sr_pc</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">a33</span>
<span class="gp">sage: </span><span class="n">sr_pc</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;decrypt&#39;</span><span class="p">)</span>
<span class="go">a23</span>
</pre></div>
</div>
<p>The returned object’s <code class="docutils literal notranslate"><span class="pre">__call__</span></code> method has no additional keywords,
unlike <code class="docutils literal notranslate"><span class="pre">sub_bytes_poly_constr()</span></code> and <code class="docutils literal notranslate"><span class="pre">add_round_key_poly_constr</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.crypto.mq.rijndael_gf.RijndaelGF.sub_bytes">
<span class="sig-name descname"><span class="pre">sub_bytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'encrypt'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.sub_bytes" title="Permalink to this definition">#</a></dt>
<dd><p>Return the application of SubBytes to the state matrix <code class="docutils literal notranslate"><span class="pre">state</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">state</span></code> – The state matrix to apply SubBytes to.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – (default: “encrypt”) Whether to apply the
encryption step of SubBytes or its decryption inverse. The encryption
flag is “encrypt” and the decryption flag is “decrypt”.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The state matrix over <span class="math notranslate nohighlight">\(\GF{2^8}\)</span> where SubBytes has been applied
to every entry of <code class="docutils literal notranslate"><span class="pre">state</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.crypto.mq.rijndael_gf</span> <span class="kn">import</span> <span class="n">RijndaelGF</span>
<span class="gp">sage: </span><span class="n">rgf</span> <span class="o">=</span> <span class="n">RijndaelGF</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">state</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">_hex_to_GF</span><span class="p">(</span><span class="s1">&#39;d1c4941f7955f40fb46f6c0ad68730ad&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">sub_bytes</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">_GF_to_hex</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">&#39;3e1c22c0b6fcbf768da85067f6170495&#39;</span>
<span class="gp">sage: </span><span class="n">decryption</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">sub_bytes</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;decrypt&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">decryption</span> <span class="o">==</span> <span class="n">state</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.crypto.mq.rijndael_gf.RijndaelGF.sub_bytes_poly_constr">
<span class="sig-name descname"><span class="pre">sub_bytes_poly_constr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.sub_bytes_poly_constr" title="Permalink to this definition">#</a></dt>
<dd><p>Return the <code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code> object corresponding to
SubBytes.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.crypto.mq.rijndael_gf</span> <span class="kn">import</span> <span class="n">RijndaelGF</span>
<span class="gp">sage: </span><span class="n">rgf</span> <span class="o">=</span> <span class="n">RijndaelGF</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sb_pc</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">sub_bytes_poly_constr</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">sb_pc</span>
<span class="go">A polynomial constructor for the function &#39;SubBytes&#39; of Rijndael-GF block cipher with block length 4, key length 4, and 10 rounds.</span>
<span class="gp">sage: </span><span class="n">sb_pc</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">(x^2 + 1)*a23^254 +</span>
<span class="go">(x^3 + 1)*a23^253 +</span>
<span class="go">(x^7 + x^6 + x^5 + x^4 + x^3 + 1)*a23^251 +</span>
<span class="go">(x^5 + x^2 + 1)*a23^247 +</span>
<span class="go">(x^7 + x^6 + x^5 + x^4 + x^2)*a23^239 +</span>
<span class="go">a23^223 +</span>
<span class="go">(x^7 + x^5 + x^4 + x^2 + 1)*a23^191 +</span>
<span class="go">(x^7 + x^3 + x^2 + x + 1)*a23^127 +</span>
<span class="go">(x^6 + x^5 + x + 1)</span>
</pre></div>
</div>
<p>The returned object’s <code class="docutils literal notranslate"><span class="pre">__call__</span></code> method has an additional keyword
of <code class="docutils literal notranslate"><span class="pre">no_inversion=False</span></code>, which causes the returned polynomial to
represent only the affine transformation step of SubBytes.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">sb_pc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">no_inversion</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(x^7 + x^3 + x^2 + x + 1)*a10^128 +</span>
<span class="go">(x^7 + x^5 + x^4 + x^2 + 1)*a10^64 +</span>
<span class="go">a10^32 +</span>
<span class="go">(x^7 + x^6 + x^5 + x^4 + x^2)*a10^16 +</span>
<span class="go">(x^5 + x^2 + 1)*a10^8 +</span>
<span class="go">(x^7 + x^6 + x^5 + x^4 + x^3 + 1)*a10^4 +</span>
<span class="go">(x^3 + 1)*a10^2 +</span>
<span class="go">(x^2 + 1)*a10 +</span>
<span class="go">(x^6 + x^5 + x + 1)</span>
</pre></div>
</div>
<p>We can build a polynomial representing the inverse transformation
by setting the keyword <code class="docutils literal notranslate"><span class="pre">algorithm='decrypt'</span></code>. However, the order of
the affine transformation and the inversion step in SubBytes means that
this polynomial has thousands of terms and is very slow to compute.
Hence, if one wishes to build the decryption polynomial with the
intention of evaluating that polynomial for a particular input, it is
strongly recommended to first call
<code class="docutils literal notranslate"><span class="pre">sb_pc(i,</span> <span class="pre">j,</span> <span class="pre">algorithm='decrypt',</span> <span class="pre">no_inversion=True)</span></code> to build a
polynomial representing only the inverse affine transformation,
evaluate this polynomial for your intended input, then finally
calculate the inverse of the result.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">poly</span> <span class="o">=</span> <span class="n">sb_pc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;decrypt&#39;</span><span class="p">,</span> <span class="n">no_inversion</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">state</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">_hex_to_GF</span><span class="p">(</span><span class="s1">&#39;39daee38f4f1a82aaf432410c36d45b9&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result</span> <span class="o">=</span> <span class="n">poly</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">_GF_to_hex</span><span class="p">(</span><span class="n">result</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;49&#39;</span>
</pre></div>
</div>
<p>When passing the returned object to <code class="docutils literal notranslate"><span class="pre">apply_poly</span></code> and <code class="docutils literal notranslate"><span class="pre">compose</span></code>, we
can make those methods change the keyword <code class="docutils literal notranslate"><span class="pre">no_inversion</span></code> of this
object’s <code class="docutils literal notranslate"><span class="pre">__call__</span></code> method by passing the dictionary
<code class="docutils literal notranslate"><span class="pre">{'no_inversion'</span> <span class="pre">:</span> <span class="pre">True}</span></code> to them.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">result</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">apply_poly</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">sb_pc</span><span class="p">,</span>
<span class="gp">....: </span><span class="n">poly_constr_attr</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;no_inversion&#39;</span> <span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">rgf</span><span class="o">.</span><span class="n">_GF_to_hex</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">&#39;961c72894526f746aa85fc920adcc719&#39;</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">rcpc</span> <span class="o">=</span> <span class="n">rgf</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">sb_pc</span><span class="p">,</span> <span class="n">rgf</span><span class="o">.</span><span class="n">shift_rows_poly_constr</span><span class="p">(),</span>
<span class="gp">....: </span><span class="n">f_attr</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;no_inversion&#39;</span> <span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
</pre></div>
</div>
<p>Note that if we set <code class="docutils literal notranslate"><span class="pre">algorithm='decrypt'</span></code> for <code class="docutils literal notranslate"><span class="pre">apply_poly</span></code>, it
will perform the necessary performance enhancement described above
automatically. The structure of <code class="docutils literal notranslate"><span class="pre">compose</span></code>, however, unfortunately
does not allow this enhancement to be employed.</p>
</dd></dl>

</dd></dl>

</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="../lattice.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Hard Lattice Generator</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="sr.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Small Scale Variants of the AES (SR) Polynomial System Generator</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2005--2023, The Sage Development Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Rijndael-GF</a><ul>
<li><a class="reference internal" href="#sage.crypto.mq.rijndael_gf.RijndaelGF"><code class="docutils literal notranslate"><span class="pre">RijndaelGF</span></code></a><ul>
<li><a class="reference internal" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.Round_Component_Poly_Constr"><code class="docutils literal notranslate"><span class="pre">Round_Component_Poly_Constr</span></code></a></li>
<li><a class="reference internal" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.add_round_key"><code class="docutils literal notranslate"><span class="pre">add_round_key()</span></code></a></li>
<li><a class="reference internal" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.add_round_key_poly_constr"><code class="docutils literal notranslate"><span class="pre">add_round_key_poly_constr()</span></code></a></li>
<li><a class="reference internal" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.apply_poly"><code class="docutils literal notranslate"><span class="pre">apply_poly()</span></code></a></li>
<li><a class="reference internal" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.block_length"><code class="docutils literal notranslate"><span class="pre">block_length()</span></code></a></li>
<li><a class="reference internal" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.compose"><code class="docutils literal notranslate"><span class="pre">compose()</span></code></a></li>
<li><a class="reference internal" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.decrypt"><code class="docutils literal notranslate"><span class="pre">decrypt()</span></code></a></li>
<li><a class="reference internal" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.encrypt"><code class="docutils literal notranslate"><span class="pre">encrypt()</span></code></a></li>
<li><a class="reference internal" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.expand_key"><code class="docutils literal notranslate"><span class="pre">expand_key()</span></code></a></li>
<li><a class="reference internal" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.expand_key_poly"><code class="docutils literal notranslate"><span class="pre">expand_key_poly()</span></code></a></li>
<li><a class="reference internal" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.key_length"><code class="docutils literal notranslate"><span class="pre">key_length()</span></code></a></li>
<li><a class="reference internal" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.mix_columns"><code class="docutils literal notranslate"><span class="pre">mix_columns()</span></code></a></li>
<li><a class="reference internal" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.mix_columns_poly_constr"><code class="docutils literal notranslate"><span class="pre">mix_columns_poly_constr()</span></code></a></li>
<li><a class="reference internal" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.number_rounds"><code class="docutils literal notranslate"><span class="pre">number_rounds()</span></code></a></li>
<li><a class="reference internal" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.shift_rows"><code class="docutils literal notranslate"><span class="pre">shift_rows()</span></code></a></li>
<li><a class="reference internal" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.shift_rows_poly_constr"><code class="docutils literal notranslate"><span class="pre">shift_rows_poly_constr()</span></code></a></li>
<li><a class="reference internal" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.sub_bytes"><code class="docutils literal notranslate"><span class="pre">sub_bytes()</span></code></a></li>
<li><a class="reference internal" href="#sage.crypto.mq.rijndael_gf.RijndaelGF.sub_bytes_poly_constr"><code class="docutils literal notranslate"><span class="pre">sub_bytes_poly_constr()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/sphinx_highlight.js"></script>
    <script src="../../../../_static/scripts/furo.js"></script>
    <script src="../../../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"ZZ": "\\Bold{Z}", "NN": "\\Bold{N}", "RR": "\\Bold{R}", "CC": "\\Bold{C}", "QQ": "\\Bold{Q}", "QQbar": "\\overline{\\QQ}", "GF": ["\\Bold{F}_{#1}", 1], "Zp": ["\\Bold{Z}_{#1}", 1], "Qp": ["\\Bold{Q}_{#1}", 1], "Zmod": ["\\ZZ/#1\\ZZ", 1], "CDF": "\\Bold{C}", "CIF": "\\Bold{C}", "CLF": "\\Bold{C}", "RDF": "\\Bold{R}", "RIF": "\\Bold{I} \\Bold{R}", "RLF": "\\Bold{R}", "SL": "\\mathrm{SL}", "PSL": "\\mathrm{PSL}", "Bold": ["\\mathbf{#1}", 1]}, "inlineMath": [["$", "$"], ["\\(", "\\)"]], "maxBuffer": 51200, "autoload": {"color": [], "colorv2": ["color"]}}}</script>
    <script defer="defer" src="../../../../_static/mathjax/tex-chtml.js"></script>
    </body>
</html>