<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Class file for computing sums over zeros of motivic L-functions. &mdash; Sage Reference Manual v7.2: L-Functions</title>
    
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '7.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v7.2: L-Functions" href="../../index.html" />
    <link rel="prev" title="Dokchitser’s L-functions Calculator" href="dokchitser.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dokchitser.html" title="Dokchitser’s L-functions Calculator"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">L-Functions</a> &raquo;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="class-file-for-computing-sums-over-zeros-of-motivic-l-functions">
<span id="sage-lfunctions-zero-sums"></span><h1>Class file for computing sums over zeros of motivic L-functions.<a class="headerlink" href="#class-file-for-computing-sums-over-zeros-of-motivic-l-functions" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.lfunctions.zero_sums"></span><p>All computations are done to double precision.</p>
<p>AUTHORS:</p>
<ul class="simple">
<li>Simon Spicer (2014-10): first version</li>
</ul>
<dl class="function">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum">
<code class="descclassname">sage.lfunctions.zero_sums.</code><code class="descname">LFunctionZeroSum</code><span class="sig-paren">(</span><em>X</em>, <em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for the LFunctionZeroSum class.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">X</span></code> &#8211; A motivic object. Currently only implemented for X = an elliptic curve
over the rational numbers.</li>
</ul>
<p>OUTPUT:</p>
<p>An LFunctionZeroSum object.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="s2">&quot;389a&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">);</span> <span class="n">Z</span>
<span class="go">Zero sum estimator for L-function attached to Elliptic Curve defined by y^2 + y = x^3 + x^2 - 2*x over Rational Field</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">([</span><span class="mf">1.2</span><span class="p">,</span><span class="mf">3.8</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">Currently only implemented for elliptic curves over QQ</span>

<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">Newforms</span><span class="p">(</span><span class="mi">46</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">Currently only implemented for elliptic curves over QQ</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_EllipticCurve">
<em class="property">class </em><code class="descclassname">sage.lfunctions.zero_sums.</code><code class="descname">LFunctionZeroSum_EllipticCurve</code><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_EllipticCurve" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_abstract" title="sage.lfunctions.zero_sums.LFunctionZeroSum_abstract"><code class="xref py py-class docutils literal"><span class="pre">sage.lfunctions.zero_sums.LFunctionZeroSum_abstract</span></code></a></p>
<p>Subclass for computing certain sums over zeros of an elliptic curve L-function
without having to determine the zeros themselves.</p>
<dl class="method">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_EllipticCurve.analytic_rank_upper_bound">
<code class="descname">analytic_rank_upper_bound</code><span class="sig-paren">(</span><em>max_Delta=None</em>, <em>adaptive=True</em>, <em>root_number='compute'</em>, <em>bad_primes=None</em>, <em>ncpus=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_EllipticCurve.analytic_rank_upper_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an upper bound for the analytic rank of the L-function
<span class="math">\(L_E(s)\)</span> attached to self, conditional on the Generalized Riemann
Hypothesis, via computing the zero sum <span class="math">\(\sum_{\gamma} f(\Delta\gamma)\)</span>,
where <span class="math">\(\gamma\)</span> ranges over the imaginary parts of the zeros of <span class="math">\(L(E,s)\)</span>
along the critical strip, <span class="math">\(f(x) = \left(\frac{\sin(\pi x)}{\pi x}\right)^2\)</span>,
and <span class="math">\(\Delta\)</span> is the tightness parameter whose maximum value is
specified by max_Delta. This computation can be run on curves with
very large conductor (so long as the conductor is known or quickly
computable) when Delta is not too large (see below).</p>
<p>Uses Bober&#8217;s rank bounding method as described in <a class="reference internal" href="#bob-13" id="id1">[Bob-13]</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">max_Delta</span></code> &#8211; (default: None) If not None, a positive real value
specifying the maximum Delta value used in the zero sum; larger
values of Delta yield better bounds - but runtime is exponential in
Delta. If left as None, Delta is set
to <span class="math">\(\min\left\{\frac{1}{\pi}\left(\log(N+1000)/2-\log(2\pi)-\eta\right), 2.5\right\}\)</span>,
where <span class="math">\(N\)</span> is the conductor of the curve attached to self, and <span class="math">\(\eta\)</span>
is the Euler-Mascheroni constant <span class="math">\(= 0.5772...\)</span>; the crossover
point is at conductor ~8.3*10^8. For the former value, empirical
results show that for about 99.7% of all curves the returned value
is the actual analytic rank.</li>
<li><code class="docutils literal"><span class="pre">adaptive</span></code> &#8211; (default: True) Boolean<ul>
<li>If True, the computation is first run with small and then
successively larger Delta values up to max_Delta. If at any
point the computed bound is 0 (or 1 when when root_number is -1
or True), the computation halts and that value is returned;
otherwise the minimum of the computed bounds is returned.</li>
<li>If False, the computation is run a single time with
Delta=max_Delta, and the resulting bound returned.</li>
</ul>
</li>
<li><code class="docutils literal"><span class="pre">root_number</span></code> &#8211; (default: &#8220;compute&#8221;) String or integer<ul>
<li><code class="docutils literal"><span class="pre">&quot;compute&quot;</span></code> &#8211; the root number of self is computed and used to
(possibly) lower ther analytic rank estimate by 1.</li>
<li><code class="docutils literal"><span class="pre">&quot;ignore&quot;</span></code> &#8211; the above step is omitted</li>
<li><code class="docutils literal"><span class="pre">1</span></code> &#8211; this value is assumed to be the root number of
self. This is passable so that rank estimation can be done for
curves whose root number has been precomputed.</li>
<li><code class="docutils literal"><span class="pre">-1</span></code> &#8211; this value is assumed to be the root number of
self. This is passable so that rank estimation can be done for
curves whose root number has been precomputed.</li>
</ul>
</li>
<li><code class="docutils literal"><span class="pre">bad_primes</span></code> &#8211; (default: None) If not None, a list of the primes
of bad reduction for the curve attached to self. This is passable
so that rank estimation can be done for curves of large conductor
whose bad primes have been precomputed.</li>
<li><code class="docutils literal"><span class="pre">ncpus</span></code> &#8211; (default: None) If not None, a positive integer
defining the maximum number of CPUs to be used for the computation.
If left as None, the maximum available number of CPUs will be used.
Note: Multiple processors will only be used for Delta values &gt;= 1.75.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Output will be incorrect if the incorrect root number is specified.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Zero sum computation time is exponential in the tightness parameter
<span class="math">\(\Delta\)</span>, roughly doubling for every increase of 0.1 thereof.
Using <span class="math">\(\Delta=1\)</span> (and adaptive=False) will yield a runtime of a few
milliseconds; <span class="math">\(\Delta=2\)</span> takes a few seconds, and <span class="math">\(\Delta=3\)</span> may
take upwards of an hour. Increase beyond this at your own risk!</p>
</div>
<p>OUTPUT:</p>
<p>A non-negative integer greater than or equal to the analytic rank of
self. If the returned value is 0 or 1 (the latter if parity is not
False), then this is the true analytic rank of self.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you use set_verbose(1), extra information about the computation
will be printed.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.lfunctions.zero_sums.LFunctionZeroSum" title="sage.lfunctions.zero_sums.LFunctionZeroSum"><code class="xref py py-func docutils literal"><span class="pre">LFunctionZeroSum()</span></code></a>
<code class="xref py py-meth docutils literal"><span class="pre">EllipticCurve.root_number()</span></code>
<a class="reference external" href="../../../misc/sage/misc/misc.html#sage.misc.misc.set_verbose" title="(in Sage Reference Manual: Utilities v7.2)"><code class="xref py py-func docutils literal"><span class="pre">set_verbose()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<p>For most elliptic curves with small conductor the central zero(s)
of <span class="math">\(L_E(s)\)</span> are fairly isolated, so small values of <span class="math">\(\Delta\)</span>
will yield tight rank estimates.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="s2">&quot;11a&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">analytic_rank_upper_bound</span><span class="p">(</span><span class="n">max_Delta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">ncpus</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>

<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">([</span><span class="o">-</span><span class="mi">39</span><span class="p">,</span><span class="mi">123</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">analytic_rank_upper_bound</span><span class="p">(</span><span class="n">max_Delta</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>This is especially true for elliptic curves with large rank.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">):</span>
<span class="go">....:     E = elliptic_curves.rank(r)[0]</span>
<span class="go">....:     print(r,E.analytic_rank_upper_bound(max_Delta=1,</span>
<span class="go">....:     adaptive=False,root_number=&quot;ignore&quot;))</span>
<span class="go">....:</span>
<span class="go">(0, 0)</span>
<span class="go">(1, 1)</span>
<span class="go">(2, 2)</span>
<span class="go">(3, 3)</span>
<span class="go">(4, 4)</span>
<span class="go">(5, 5)</span>
<span class="go">(6, 6)</span>
<span class="go">(7, 7)</span>
<span class="go">(8, 8)</span>
</pre></div>
</div>
<p>However, some curves have <span class="math">\(L\)</span>-functions with low-lying zeroes, and for these
larger values of <span class="math">\(\Delta\)</span> must be used to get tight estimates.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="s2">&quot;974b1&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">rank</span><span class="p">();</span> <span class="n">r</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">analytic_rank_upper_bound</span><span class="p">(</span><span class="n">max_Delta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">root_number</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">analytic_rank_upper_bound</span><span class="p">(</span><span class="n">max_Delta</span><span class="o">=</span><span class="mf">1.3</span><span class="p">,</span><span class="n">root_number</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Knowing the root number of E allows us to use smaller Delta values
to get tight bounds, thus speeding up runtime considerably.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">analytic_rank_upper_bound</span><span class="p">(</span><span class="n">max_Delta</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span><span class="n">root_number</span><span class="o">=</span><span class="s2">&quot;compute&quot;</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>The are a small number of curves which have pathologically low-lying
zeroes. For these curves, this method will produce a bound that is
strictly larger than the analytic rank, unless very large values of
Delta are used. The following curve (&#8220;256944c1&#8221; in the Cremona tables)
is a rank 0 curve with a zero at 0.0256...; the smallest Delta value
for which the zero sum is strictly less than 2 is ~2.815.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">7460362000712</span><span class="p">,</span> <span class="o">-</span><span class="mi">7842981500851012704</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">N</span><span class="p">,</span><span class="n">r</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">conductor</span><span class="p">(),</span><span class="n">E</span><span class="o">.</span><span class="n">analytic_rank</span><span class="p">();</span> <span class="n">N</span><span class="p">,</span> <span class="n">r</span>
<span class="go">(256944, 0)</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">analytic_rank_upper_bound</span><span class="p">(</span><span class="n">max_Delta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">adaptive</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">analytic_rank_upper_bound</span><span class="p">(</span><span class="n">max_Delta</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">adaptive</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>This method is can be called on curves with large conductor.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">([</span><span class="o">-</span><span class="mi">2934</span><span class="p">,</span><span class="mi">19238</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">analytic_rank_upper_bound</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
<p>And it can bound rank on curves with <em>very</em> large conductor, so long as
you know beforehand/can easily compute the conductor and primes of bad
reduction less than <span class="math">\(e^{2\pi\Delta}\)</span>. The example below is of the rank
28 curve discovered by Elkies that is the elliptic curve of (currently)
largest known rank.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a4</span> <span class="o">=</span> <span class="o">-</span><span class="mi">20067762415575526585033208209338542750930230312178956502</span>
<span class="gp">sage: </span><span class="n">a6</span> <span class="o">=</span> <span class="mi">34481611795030556467032985690390720374855944359319180361266008296291939448732243429</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">a4</span><span class="p">,</span><span class="n">a6</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">bad_primes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">19</span><span class="p">,</span><span class="mi">48463</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="mi">3455601108357547341532253864901605231198511505793733138900595189472144724781456635380154149870961231592352897621963802238155192936274322687070</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">analytic_rank_upper_bound</span><span class="p">(</span><span class="n">max_Delta</span><span class="o">=</span><span class="mf">2.37</span><span class="p">,</span><span class="n">adaptive</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="c1"># long time</span>
<span class="go">....: root_number=1,bad_primes=bad_primes,ncpus=2)               # long time</span>
<span class="go">32</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="bob-13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[Bob-13]</a></td><td>J.W. Bober. Conditionally bounding analytic ranks of elliptic curves.
ANTS 10. <a class="reference external" href="http://msp.org/obs/2013/1-1/obs-v1-n1-p07-s.pdf">http://msp.org/obs/2013/1-1/obs-v1-n1-p07-s.pdf</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_EllipticCurve.cn">
<code class="descname">cn</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_EllipticCurve.cn" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the nth Dirichlet coefficient of the logarithmic
derivative of the L-function attached to self, shifted so that
the critical line lies on the imaginary axis. The returned value is
zero if <span class="math">\(n\)</span> is not a perfect prime power;
when <span class="math">\(n=p^e\)</span> for <span class="math">\(p\)</span> a prime of bad reduction it is <span class="math">\(-a_p^e log(p)/p^e\)</span>,
where <span class="math">\(a_p\)</span> is <span class="math">\(+1, -1\)</span> or <span class="math">\(0\)</span> according to the reduction type of <span class="math">\(p\)</span>;
and when <span class="math">\(n=p^e\)</span> for a prime <span class="math">\(p\)</span> of good reduction, the value
is <span class="math">\(-(\alpha_p^e + \beta_p^e) \log(p)/p^e\)</span>, where <span class="math">\(\alpha_p\)</span>
and <span class="math">\(\beta_p\)</span> are the two complex roots of the characteristic equation
of Frobenius at <span class="math">\(p\)</span> on <span class="math">\(E\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">n</span></code> &#8211; non-negative integer</li>
</ul>
<p>OUTPUT:</p>
<p>A real number which (by Hasse&#8217;s Theorem) is at
most <span class="math">\(2\frac{log(n)}{\sqrt{n}}\)</span> in magnitude.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="s2">&quot;11a&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">):</span> <span class="k">print</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">Z</span><span class="o">.</span><span class="n">cn</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">(0, 0.0)</span>
<span class="go">(1, 0.0)</span>
<span class="go">(2, 0.6931471805599453)</span>
<span class="go">(3, 0.3662040962227033)</span>
<span class="go">(4, 0.0)</span>
<span class="go">(5, -0.32188758248682003)</span>
<span class="go">(6, 0.0)</span>
<span class="go">(7, 0.555974328301518)</span>
<span class="go">(8, -0.34657359027997264)</span>
<span class="go">(9, 0.6103401603711721)</span>
<span class="go">(10, 0.0)</span>
<span class="go">(11, -0.21799047934530644)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_EllipticCurve.elliptic_curve">
<code class="descname">elliptic_curve</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_EllipticCurve.elliptic_curve" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the elliptic curve associated with self.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">([</span><span class="mi">23</span><span class="p">,</span><span class="mi">100</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">elliptic_curve</span><span class="p">()</span>
<span class="go">Elliptic Curve defined by y^2 = x^3 + 23*x + 100 over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_EllipticCurve.lseries">
<code class="descname">lseries</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_EllipticCurve.lseries" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <span class="math">\(L\)</span>-series associated with self.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">([</span><span class="mi">23</span><span class="p">,</span><span class="mi">100</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">lseries</span><span class="p">()</span>
<span class="go">Complex L-series of the Elliptic Curve defined by y^2 = x^3 + 23*x + 100 over Rational Field</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_abstract">
<em class="property">class </em><code class="descclassname">sage.lfunctions.zero_sums.</code><code class="descname">LFunctionZeroSum_abstract</code><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_abstract" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/sage_object.html#sage.structure.sage_object.SageObject" title="(in Sage Reference Manual: Basic Structures v7.2)"><code class="xref py py-class docutils literal"><span class="pre">sage.structure.sage_object.SageObject</span></code></a></p>
<p>Abstract class for computing certain sums over zeros of a motivic L-function
without having to determine the zeros themselves.</p>
<dl class="method">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.C0">
<code class="descname">C0</code><span class="sig-paren">(</span><em>include_euler_gamma=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.C0" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the constant term of the logarithmic derivative of the
completed <span class="math">\(L\)</span>-function attached to self. This is equal to
<span class="math">\(-\eta + \log(N)/2 - \log(2\pi)\)</span>, where <span class="math">\(\eta\)</span> is the
Euler-Mascheroni constant <span class="math">\(= 0.5772...\)</span>
and <span class="math">\(N\)</span> is the level of the form attached to self.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">include_euler_gamma</span></code> &#8211; bool (default: True); if set to
False, return the constant <span class="math">\(\log(N)/2 - \log(2\pi)\)</span>, i.e., do
not subtract off the Euler-Mascheroni constant.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="s2">&quot;389a&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">C0</span><span class="p">()</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">0.5666969404983447</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">C0</span><span class="p">(</span><span class="n">include_euler_gamma</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">1.1439126053998776</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.cnlist">
<code class="descname">cnlist</code><span class="sig-paren">(</span><em>n</em>, <em>python_floats=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.cnlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of Dirichlet coefficient of the logarithmic
derivative of the <span class="math">\(L\)</span>-function attached to self, shifted so that
the critical line lies on the imaginary axis, up to and
including n. The i-th element of the return list is a[i].</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">n</span></code> &#8211; non-negative integer</li>
<li><code class="docutils literal"><span class="pre">python_floats</span></code> &#8211; bool (default: False); if True return a list of
Python floats instead of Sage Real Double Field elements.</li>
</ul>
<p>OUTPUT:</p>
<p>A list of real numbers</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_EllipticCurve.cn" title="sage.lfunctions.zero_sums.LFunctionZeroSum_EllipticCurve.cn"><code class="xref py py-meth docutils literal"><span class="pre">cn()</span></code></a></p>
</div>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">Speed this up; make more efficient</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="s2">&quot;11a&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">cnlist</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">cnlist</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">):</span> <span class="k">print</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">cnlist</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">(0, 0.0)</span>
<span class="go">(1, 0.0)</span>
<span class="go">(2, 0.6931471805599453)</span>
<span class="go">(3, 0.3662040962227033)</span>
<span class="go">(4, 0.0)</span>
<span class="go">(5, -0.32188758248682003)</span>
<span class="go">(6, 0.0)</span>
<span class="go">(7, 0.555974328301518)</span>
<span class="go">(8, -0.34657359027997264)</span>
<span class="go">(9, 0.6103401603711721)</span>
<span class="go">(10, 0.0)</span>
<span class="go">(11, -0.21799047934530644)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.completed_logarithmic_derivative">
<code class="descname">completed_logarithmic_derivative</code><span class="sig-paren">(</span><em>s</em>, <em>num_terms=10000</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.completed_logarithmic_derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the value of the completed logarithmic derivative
<span class="math">\(\frac{\Lambda^{\prime}}{\Lambda}\)</span> at the point s to <em>low</em>
precision, where <span class="math">\(\Lambda = N^{s/2}(2\pi)^s \Gamma(s) L(s)\)</span>
and <span class="math">\(L\)</span> is the <span class="math">\(L\)</span>-function attached to self.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This is computed naively by evaluating the Dirichlet series
for <span class="math">\(\frac{L^{\prime}}{L}\)</span>; the convergence thereof is
controlled by the distance of s from the critical strip
<span class="math">\(0.5&lt;=\Re(s)&lt;=1.5\)</span>.
You may use this method to attempt to compute values inside the
critical strip; however, results are then <em>not</em> guaranteed
to be correct to any number of digits.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">s</span></code> &#8211; Real or complex value</li>
<li><code class="docutils literal"><span class="pre">num_terms</span></code> &#8211; (default: 10000) the maximum number of terms
summed in the Dirichlet series.</li>
</ul>
<p>OUTPUT:</p>
<p>A tuple (z,err), where z is the computed value, and err is an
upper bound on the truncation error in this value introduced
by truncating the Dirichlet sum.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For the default term cap of 10000, a value accurate to all 53
bits of a double precision floating point number is only
guaranteed when <span class="math">\(|\Re(s-1)|&gt;4.58\)</span>, although in practice inputs
closer to the critical strip will still yield computed values
close to the true value.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">logarithmic_derivative()</span></code></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">([</span><span class="mi">23</span><span class="p">,</span><span class="mi">100</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">completed_logarithmic_derivative</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">(6.64372066048195, 6.584671359095225e-06)</span>
</pre></div>
</div>
<p>Complex values are handled. The function is odd about s=1, so
the value at 2-s should be minus the value at s.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">completed_logarithmic_derivative</span><span class="p">(</span><span class="nb">complex</span><span class="p">(</span><span class="o">-</span><span class="mf">2.2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">(-6.898080633125154 + 0.22557015394248361*I, 5.623853049808912e-11)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">completed_logarithmic_derivative</span><span class="p">(</span><span class="nb">complex</span><span class="p">(</span><span class="mf">4.2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">(6.898080633125154 - 0.22557015394248361*I, 5.623853049808912e-11)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.digamma">
<code class="descname">digamma</code><span class="sig-paren">(</span><em>s</em>, <em>include_constant_term=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.digamma" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the digamma function <span class="math">\(\digamma(s)\)</span> on the complex input s, given by
<span class="math">\(\digamma(s) = -\eta + \sum_{k=1}^{\infty} \frac{s-1}{k(k+s-1)}\)</span>,
where <span class="math">\(\eta\)</span> is the Euler-Mascheroni constant <span class="math">\(=0.5772156649\ldots\)</span>.
This function is needed in the computing the logarithmic derivative
of the <span class="math">\(L\)</span>-function attached to self.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">s</span></code> &#8211; A complex number</li>
<li><code class="docutils literal"><span class="pre">include_constant_term</span></code> &#8211; (default: True) boolean; if set False,
only the value of the sum over <span class="math">\(k\)</span> is returned without subtracting
off the Euler-Mascheroni constant, i.e. the returned value is
equal to <span class="math">\(\sum_{k=1}^{\infty} \frac{s-1}{k(k+s-1)}\)</span>.</li>
</ul>
<p>OUTPUT:</p>
<p>A real double precision number if the input is real and not a negative
integer; Infinity if the input is a negative integer, and a complex
number otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">EllipticCurve</span><span class="p">(</span><span class="s2">&quot;37a&quot;</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">digamma</span><span class="p">(</span><span class="mf">3.2</span><span class="p">)</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">0.9988388912865993</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">digamma</span><span class="p">(</span><span class="mf">3.2</span><span class="p">,</span><span class="n">include_constant_term</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">1.576054556188132</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">digamma</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">I</span><span class="p">)</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">0.09465032062247625 + 1.076674047468581*I</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">digamma</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">+Infinity</span>
</pre></div>
</div>
<p>Evaluating the sum without the constant term at the positive integers n
returns the (n-1)th harmonic number.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">digamma</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">include_constant_term</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">1.5</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">digamma</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="n">include_constant_term</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">2.283333333333333</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.level">
<code class="descname">level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.level" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the level of the form attached to self. If self was constructed
from an elliptic curve, then this is equal to the conductor of <span class="math">\(E\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="s2">&quot;389a&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">level</span><span class="p">()</span>
<span class="go">389</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.logarithmic_derivative">
<code class="descname">logarithmic_derivative</code><span class="sig-paren">(</span><em>s</em>, <em>num_terms=10000</em>, <em>as_interval=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.logarithmic_derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the value of the logarithmic derivative
<span class="math">\(\frac{L^{\prime}}{L}\)</span> at the point s to <em>low</em> precision, where <span class="math">\(L\)</span>
is the <span class="math">\(L\)</span>-function attached to self.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The value is computed naively by evaluating the Dirichlet series
for <span class="math">\(\frac{L^{\prime}}{L}\)</span>; convergence is controlled by the
distance of s from the critical strip <span class="math">\(0.5&lt;=\Re(s)&lt;=1.5\)</span>.
You may use this method to attempt to compute values inside the
critical strip; however, results are then <em>not</em> guaranteed
to be correct to any number of digits.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">s</span></code> &#8211; Real or complex value</li>
<li><code class="docutils literal"><span class="pre">num_terms</span></code> &#8211; (default: 10000) the maximum number of terms
summed in the Dirichlet series.</li>
</ul>
<p>OUTPUT:</p>
<p>A tuple (z,err), where z is the computed value, and err is an
upper bound on the truncation error in this value introduced
by truncating the Dirichlet sum.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For the default term cap of 10000, a value accurate to all 53
bits of a double precision floating point number is only
guaranteed when <span class="math">\(|\Re(s-1)|&gt;4.58\)</span>, although in practice inputs
closer to the critical strip will still yield computed values
close to the true value.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">([</span><span class="mi">23</span><span class="p">,</span><span class="mi">100</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">logarithmic_derivative</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">(5.648066742632698e-05, 1.0974102859764345e-34)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">logarithmic_derivative</span><span class="p">(</span><span class="mf">2.2</span><span class="p">)</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">(0.5751257063594758, 0.024087912696974387)</span>
</pre></div>
</div>
<p>Increasing the number of terms should see the truncation error
decrease.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">logarithmic_derivative</span><span class="p">(</span><span class="mf">2.2</span><span class="p">,</span><span class="n">num_terms</span><span class="o">=</span><span class="mi">50000</span><span class="p">)</span> <span class="c1"># long time # rel tol 1.0e-14</span>
<span class="go">(0.5751579645060139, 0.008988775519160675)</span>
</pre></div>
</div>
<p>Attempting to compute values inside the critical strip
gives infinite error.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">logarithmic_derivative</span><span class="p">(</span><span class="mf">1.3</span><span class="p">)</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">(5.442994413920786, +Infinity)</span>
</pre></div>
</div>
<p>Complex inputs and inputs to the left of the critical strip
are allowed.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">logarithmic_derivative</span><span class="p">(</span><span class="nb">complex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">(0.04764548578052381 + 0.16513832809989326*I, 6.584671359095225e-06)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">logarithmic_derivative</span><span class="p">(</span><span class="nb">complex</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mf">1.1</span><span class="p">))</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">(-13.908452173241546 + 2.591443099074753*I, 2.7131584736258447e-14)</span>
</pre></div>
</div>
<p>The logarithmic derivative has poles at the negative integers.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">logarithmic_derivative</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">(-Infinity, 2.7131584736258447e-14)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.ncpus">
<code class="descname">ncpus</code><span class="sig-paren">(</span><em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.ncpus" title="Permalink to this definition">¶</a></dt>
<dd><p>Set or return the number of CPUs to be used in parallel computations.
If called with no input, the number of CPUs currently set is returned;
else this value is set to n. If n is 0 then the number of CPUs is set
to the max available.</p>
<p>INPUT:</p>
<p><code class="docutils literal"><span class="pre">n</span></code> &#8211; (default: None) If not None, a nonnegative integer</p>
<p>OUTPUT:</p>
<p>If n is not None, returns a positive integer</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">EllipticCurve</span><span class="p">(</span><span class="s2">&quot;389a&quot;</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">ncpus</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">ncpus</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">ncpus</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
<p>The following output will depend on the system that Sage is running on.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">ncpus</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">ncpus</span><span class="p">()</span>            <span class="c1"># random</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.weight">
<code class="descname">weight</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.weight" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the weight of the form attached to self. If self was constructed
from an elliptic curve, then this is 2.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="s2">&quot;389a&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">weight</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.zerosum">
<code class="descname">zerosum</code><span class="sig-paren">(</span><em>Delta=1</em>, <em>tau=0</em>, <em>function='sincsquared_fast'</em>, <em>ncpus=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.zerosum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bound from above the analytic rank of the form attached to self
by computing <span class="math">\(\sum_{\gamma} f(\Delta(\gamma-\tau))\)</span>, where
<span class="math">\(\gamma\)</span> ranges over the imaginary parts of the zeros of <span class="math">\(L_E(s)\)</span>
along the critical strip, and <span class="math">\(f(x)\)</span> is an appropriate even continuous
<span class="math">\(L_2\)</span> function such that <span class="math">\(f(0)=1\)</span>.</p>
<p>If <span class="math">\(\tau=0\)</span>, then as <span class="math">\(\Delta\)</span> increases this sum converges from above to
the analytic rank of the <span class="math">\(L\)</span>-function, as <span class="math">\(f(0) = 1\)</span> is counted with
multiplicity <span class="math">\(r\)</span>, and the other terms all go to 0 uniformly.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">Delta</span></code> &#8211; positive real number (default: 1) parameter denoting the
tightness of the zero sum.</li>
<li><code class="docutils literal"><span class="pre">tau</span></code> &#8211; real parameter (default: 0) denoting the offset of the sum
to be computed. When <span class="math">\(\tau=0\)</span> the sum will converge to the analytic rank
of the <span class="math">\(L\)</span>-function as <span class="math">\(\Delta\)</span> is increased. If <span class="math">\(\tau\)</span> is the value
of the imaginary part of a noncentral zero, the limit will be 1
(assuming the zero is simple); otherwise, the limit will be 0.
Currently only implemented for the sincsquared and cauchy functions;
otherwise ignored.</li>
<li><code class="docutils literal"><span class="pre">function</span></code> &#8211; string (default: &#8220;sincsquared_fast&#8221;) - the function
<span class="math">\(f(x)\)</span> as described above. Currently implemented options for <span class="math">\(f\)</span> are<ul>
<li><code class="docutils literal"><span class="pre">sincquared</span></code> &#8211; <span class="math">\(f(x) = \left(\frac{\sin(\pi x)}{\pi x}\right)^2\)</span></li>
<li><code class="docutils literal"><span class="pre">gaussian</span></code>   &#8211; <span class="math">\(f(x) = e^{-x^2}\)</span></li>
<li><code class="docutils literal"><span class="pre">sincquared_fast</span></code> &#8211; Same as &#8220;sincsquared&#8221;, but implementation
optimized for elliptic curve <span class="math">\(L\)</span>-functions, and tau must be 0. self
must be attached to an elliptic curve over <span class="math">\(\QQ\)</span> given by its global
minimal model, otherwise the returned result will be incorrect.</li>
<li><code class="docutils literal"><span class="pre">sincquared_parallel</span></code> &#8211; Same as &#8220;sincsquared_fast&#8221;, but optimized
for parallel computation with large (&gt;2.0) <span class="math">\(\Delta\)</span> values. self must
be attached to an elliptic curve over <span class="math">\(\QQ\)</span> given by its global minimal
model, otherwise the returned result will be incorrect.</li>
<li><code class="docutils literal"><span class="pre">cauchy</span></code> &#8211; <span class="math">\(f(x) = \frac{1}{1+x^2}\)</span>; this is only computable to
low precision, and only when <span class="math">\(\Delta &lt; 2\)</span>.</li>
</ul>
</li>
<li><code class="docutils literal"><span class="pre">ncpus</span></code> - (default: None) If not None, a positive integer
defining the number of CPUs to be used for the computation. If left as
None, the maximum available number of CPUs will be used.
Only implemented for algorithm=&#8221;sincsquared_parallel&#8221;; ignored
otherwise.</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Computation time is exponential in <span class="math">\(\Delta\)</span>, roughly doubling for
every increase of 0.1 thereof. Using <span class="math">\(\Delta=1\)</span> will yield a
computation time of a few milliseconds; <span class="math">\(\Delta=2\)</span> takes a few
seconds, and <span class="math">\(\Delta=3\)</span> takes upwards of an hour. Increase at your
own risk beyond this!</p>
</div>
<p>OUTPUT:</p>
<p>A positive real number that bounds from above the number of zeros with
imaginary part equal to <span class="math">\(\tau\)</span>. When <span class="math">\(\tau=0\)</span> this is an upper bound for
the <span class="math">\(L\)</span>-function&#8217;s analytic rank.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">analytic_rank_bound()</span></code>
for more documentation and examples on calling this method on elliptic curve
<span class="math">\(L\)</span>-functions.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="s2">&quot;389a&quot;</span><span class="p">);</span> <span class="n">E</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">lseries</span><span class="p">()</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[0.000000000, 0.000000000, 2.87609907]</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">Delta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">function</span><span class="o">=</span><span class="s2">&quot;sincsquared_fast&quot;</span><span class="p">)</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">2.037500084595065</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">Delta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">function</span><span class="o">=</span><span class="s2">&quot;sincsquared_parallel&quot;</span><span class="p">)</span> <span class="c1"># tol 1.0e-11</span>
<span class="go">2.037500084595065</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">Delta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">function</span><span class="o">=</span><span class="s2">&quot;sincsquared&quot;</span><span class="p">)</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">2.0375000845950644</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">Delta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">tau</span><span class="o">=</span><span class="mf">2.876</span><span class="p">,</span><span class="n">function</span><span class="o">=</span><span class="s2">&quot;sincsquared&quot;</span><span class="p">)</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">1.075551295651154</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">Delta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">tau</span><span class="o">=</span><span class="mf">1.2</span><span class="p">,</span><span class="n">function</span><span class="o">=</span><span class="s2">&quot;sincsquared&quot;</span><span class="p">)</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">0.10831555377490683</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">Delta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">function</span><span class="o">=</span><span class="s2">&quot;gaussian&quot;</span><span class="p">)</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">2.056890425029435</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <h4>Previous topic</h4>
            <p class="topless"><a href="dokchitser.html"
                                  title="previous chapter">Dokchitser&#8217;s L-functions Calculator</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../_sources/sage/lfunctions/zero_sums.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dokchitser.html" title="Dokchitser’s L-functions Calculator"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">L-Functions</a> &raquo;</li>
 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &copy; Copyright 2005--2016, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.1.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>