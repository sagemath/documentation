<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Module with basis morphisms &mdash; Sage Reference Manual v6.8: Modules</title>
    
    <link rel="stylesheet" href="../../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '6.8',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v6.8: Modules" href="../../../index.html" />
    <link rel="next" title="Quotients of Modules With Basis" href="subquotient.html" />
    <link rel="prev" title="Concrete classes related to modules with a distinguished basis." href="__init__.html" />
    <link rel="icon" href="../../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="subquotient.html" title="Quotients of Modules With Basis"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="__init__.html" title="Concrete classes related to modules with a distinguished basis."
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../../index.html">Modules</a> &raquo;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-with-basis-morphisms">
<span id="sage-modules-with-basis-morphism"></span><h1>Module with basis morphisms<a class="headerlink" href="#module-with-basis-morphisms" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.modules.with_basis.morphism"></span><p>This module contains a hierarchy of classes for morphisms of modules
with a basis (category <tt class="xref py py-class docutils literal"><span class="pre">Modules.WithBasis</span></tt>):</p>
<ul class="simple">
<li><a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphism" title="sage.modules.with_basis.morphism.ModuleMorphism"><tt class="xref py py-class docutils literal"><span class="pre">ModuleMorphism</span></tt></a></li>
<li><a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphismByLinearity" title="sage.modules.with_basis.morphism.ModuleMorphismByLinearity"><tt class="xref py py-class docutils literal"><span class="pre">ModuleMorphismByLinearity</span></tt></a></li>
<li><a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphismFromMatrix" title="sage.modules.with_basis.morphism.ModuleMorphismFromMatrix"><tt class="xref py py-class docutils literal"><span class="pre">ModuleMorphismFromMatrix</span></tt></a></li>
<li><a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphismFromFunction" title="sage.modules.with_basis.morphism.ModuleMorphismFromFunction"><tt class="xref py py-class docutils literal"><span class="pre">ModuleMorphismFromFunction</span></tt></a></li>
<li><a class="reference internal" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism" title="sage.modules.with_basis.morphism.TriangularModuleMorphism"><tt class="xref py py-class docutils literal"><span class="pre">TriangularModuleMorphism</span></tt></a></li>
<li><a class="reference internal" href="#sage.modules.with_basis.morphism.TriangularModuleMorphismByLinearity" title="sage.modules.with_basis.morphism.TriangularModuleMorphismByLinearity"><tt class="xref py py-class docutils literal"><span class="pre">TriangularModuleMorphismByLinearity</span></tt></a></li>
<li><a class="reference internal" href="#sage.modules.with_basis.morphism.TriangularModuleMorphismFromFunction" title="sage.modules.with_basis.morphism.TriangularModuleMorphismFromFunction"><tt class="xref py py-class docutils literal"><span class="pre">TriangularModuleMorphismFromFunction</span></tt></a></li>
</ul>
<p>These are internal classes; it is recommended <em>not</em> to use them
directly, and instead to construct morphisms through the
<a class="reference external" href="../../../../categories/sage/categories/modules_with_basis.html#sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.module_morphism" title="(in Sage Reference Manual: Category Theory v6.8)"><tt class="xref py py-meth docutils literal"><span class="pre">ModulesWithBasis.ParentMethods.module_morphism()</span></tt></a> method of the
domain, or through the homset. See the former for an overview
of the possible arguments.</p>
<p>EXAMPLES:</p>
<p>We construct a morphism through the method
<a class="reference external" href="../../../../categories/sage/categories/modules_with_basis.html#sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.module_morphism" title="(in Sage Reference Manual: Category Theory v6.8)"><tt class="xref py py-meth docutils literal"><span class="pre">ModulesWithBasis.ParentMethods.module_morphism()</span></tt></a>, by specifying
the image of each element of the distinguished basis:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span>   <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">on_basis</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">Y</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">Y</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="gp">sage: </span><span class="n">phi1</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">on_basis</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi1</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">B[1] + 2*B[2]</span>

<span class="gp">sage: </span><span class="n">phi1</span>
<span class="go">Generic morphism:</span>
<span class="go">  From: Free module generated by {1, 2, 3} over Rational Field</span>
<span class="go">  To:   Free module generated by {1, 2, 3, 4} over Rational Field</span>
<span class="gp">sage: </span><span class="n">phi1</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Set of Morphisms from Free module generated by {1, 2, 3} over Rational Field to Free module generated by {1, 2, 3, 4} over Rational Field in Category of finite dimensional vector spaces with basis over Rational Field</span>
<span class="gp">sage: </span><span class="n">phi1</span><span class="o">.</span><span class="n">__class__</span>
<span class="go">&lt;class &#39;sage.modules.with_basis.morphism.ModuleMorphismByLinearity_with_category&#39;&gt;</span>
</pre></div>
</div>
<p>Constructing the same morphism from the homset:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Hom</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi2</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span><span class="n">on_basis</span><span class="o">=</span><span class="n">on_basis</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi1</span> <span class="o">==</span> <span class="n">phi2</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Constructing the same morphism directly using the class; no backward
compatibility is guaranteed in this case:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.modules.with_basis.morphism</span> <span class="kn">import</span> <span class="n">ModuleMorphismByLinearity</span>
<span class="gp">sage: </span><span class="n">phi3</span> <span class="o">=</span> <span class="n">ModuleMorphismByLinearity</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">on_basis</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi3</span> <span class="o">==</span> <span class="n">phi1</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>The hierarchy of classes implemented in this module is one of the
first non-trivial hierarchies of classes for morphisms. It is
hitting a couple scaling issues:</p>
<ul>
<li><p class="first">There are many independent properties from which module
morphisms can get code (being defined by linearity, from a
matrix, or a function; being triangular, being diagonal,
...). How to mitigate the class hierarchy growth?</p>
<p>This will become even more stringent as more properties are
added (e.g. being defined from generators for an algebra
morphism, ...)</p>
<p>Categories, whose primary purpose is to provide infrastructure
for handling such large hierarchy of classes, can&#8217;t help at this
point: there is no category whose morphisms are triangular
morphisms, and it&#8217;s not clear such a category would be sensible.</p>
</li>
<li><p class="first">How to properly handle <tt class="docutils literal"><span class="pre">__init__</span></tt> method calls and
multiple inheritance?</p>
</li>
<li><p class="first">Who should be in charge of setting the default category: the
classes themselves, or
<a class="reference external" href="../../../../categories/sage/categories/modules_with_basis.html#sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.module_morphism" title="(in Sage Reference Manual: Category Theory v6.8)"><tt class="xref py py-meth docutils literal"><span class="pre">ModulesWithBasis.ParentMethods.module_morphism()</span></tt></a>?</p>
</li>
</ul>
<p class="last">Because of this, the hierarchy of classes, and the specific APIs,
is likely to be refactored as better infrastructure and best
practices emerge.</p>
</div>
<p>AUTHORS:</p>
<ul class="simple">
<li>Nicolas M. Thiery (2008-2015)</li>
<li>Jason Bandlow and Florent Hivert (2010): Triangular Morphisms</li>
<li>Christian Stump (2010): <a class="reference external" href="http://trac.sagemath.org/9648">trac ticket #9648</a> module_morphism&#8217;s to a wider class
of codomains</li>
</ul>
<p>Before <a class="reference external" href="http://trac.sagemath.org/8678">trac ticket #8678</a>, this hierarchy of classes used to be in
sage.categories.modules_with_basis; see <a class="reference external" href="http://trac.sagemath.org/8678">trac ticket #8678</a> for the complete log.</p>
<dl class="class">
<dt id="sage.modules.with_basis.morphism.DiagonalModuleMorphism">
<em class="property">class </em><tt class="descclassname">sage.modules.with_basis.morphism.</tt><tt class="descname">DiagonalModuleMorphism</tt><big>(</big><em>domain</em>, <em>diagonal</em>, <em>codomain=None</em>, <em>category=None</em><big>)</big><a class="headerlink" href="#sage.modules.with_basis.morphism.DiagonalModuleMorphism" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphismByLinearity" title="sage.modules.with_basis.morphism.ModuleMorphismByLinearity"><tt class="xref py py-class docutils literal"><span class="pre">sage.modules.with_basis.morphism.ModuleMorphismByLinearity</span></tt></a></p>
<p>A class for diagonal module morphisms.</p>
<p>See <a class="reference external" href="../../../../categories/sage/categories/modules_with_basis.html#sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.module_morphism" title="(in Sage Reference Manual: Category Theory v6.8)"><tt class="xref py py-meth docutils literal"><span class="pre">ModulesWithBasis.ParentMethods.module_morphism()</span></tt></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">domain</span></tt>, <tt class="docutils literal"><span class="pre">codomain</span></tt> &#8211; two modules with basis <span class="math">\(F\)</span> and <span class="math">\(G\)</span>,
respectively</li>
<li><tt class="docutils literal"><span class="pre">diagonal</span></tt> &#8211; a function <span class="math">\(d\)</span></li>
</ul>
<p>Assumptions:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">domain</span></tt> and <tt class="docutils literal"><span class="pre">codomain</span></tt> have the same base ring <span class="math">\(R\)</span>,</li>
<li>their respective bases <span class="math">\(F\)</span> and <span class="math">\(G\)</span> have the same index set <span class="math">\(I\)</span>,</li>
<li><span class="math">\(d\)</span> is a function <span class="math">\(I \to R\)</span>.</li>
</ul>
<p>Return the diagonal module morphism from <tt class="docutils literal"><span class="pre">domain</span></tt> to <tt class="docutils literal"><span class="pre">codomain</span></tt>
sending <span class="math">\(F(i) \mapsto d(i) G(i)\)</span> for all <span class="math">\(i \in I\)</span>.</p>
<p>By default, <tt class="docutils literal"><span class="pre">codomain</span></tt> is currently assumed to be <tt class="docutils literal"><span class="pre">domain</span></tt>.
(Todo: make a consistent choice with <tt class="docutils literal"><span class="pre">*ModuleMorphism</span></tt>.)</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<ul class="last simple">
<li>Implement an optimized <tt class="docutils literal"><span class="pre">_call_()</span></tt> function.</li>
<li>Generalize to a mapcoeffs.</li>
<li>Generalize to a mapterms.</li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">diagonal</span><span class="o">=</span><span class="n">factorial</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">(B[1], 2*B[2], 6*B[3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.modules.with_basis.morphism.ModuleMorphism">
<em class="property">class </em><tt class="descclassname">sage.modules.with_basis.morphism.</tt><tt class="descname">ModuleMorphism</tt><big>(</big><em>domain</em>, <em>codomain=None</em>, <em>category=None</em>, <em>affine=False</em><big>)</big><a class="headerlink" href="#sage.modules.with_basis.morphism.ModuleMorphism" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../categories/sage/categories/morphism.html#sage.categories.morphism.Morphism" title="(in Sage Reference Manual: Category Theory v6.8)"><tt class="xref py py-class docutils literal"><span class="pre">sage.categories.morphism.Morphism</span></tt></a></p>
<p>The top abstract base class for module with basis morphisms.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">domain</span></tt> &#8211; a parent in <tt class="docutils literal"><span class="pre">ModulesWithBasis(...)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">codomain</span></tt> &#8211; a parent in <tt class="docutils literal"><span class="pre">Modules(...)</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">category</span></tt> &#8211; a category or <tt class="docutils literal"><span class="pre">None</span></tt> (default: <span class="math">\(None`\)</span>)</li>
<li><tt class="docutils literal"><span class="pre">affine</span></tt> &#8211; whether we define an affine module morphism
(default: False).</li>
</ul>
<p>Construct a module morphism from <tt class="docutils literal"><span class="pre">domain</span></tt> to <tt class="docutils literal"><span class="pre">codomain</span></tt> in the
category <tt class="docutils literal"><span class="pre">category</span></tt>. By default, the category is the first of
<tt class="docutils literal"><span class="pre">Modules(R).WithBasis().FiniteDimensional()</span></tt>,
<tt class="docutils literal"><span class="pre">Modules(R).WithBasis()</span></tt>, <tt class="docutils literal"><span class="pre">Modules(R)</span></tt>,
<tt class="docutils literal"><span class="pre">CommutativeAdditiveMonoids()</span></tt> that contains both the domain and
the codomain. If initializing an affine morphism, then <span class="math">\(Sets()\)</span> is
used instead.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="../../../../categories/sage/categories/modules_with_basis.html#sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.module_morphism" title="(in Sage Reference Manual: Category Theory v6.8)"><tt class="xref py py-meth docutils literal"><span class="pre">ModulesWithBasis.ParentMethods.module_morphism()</span></tt></a> for
usage information and examples;</li>
<li><a class="reference internal" href="#module-sage.modules.with_basis.morphism" title="sage.modules.with_basis.morphism"><tt class="xref py py-mod docutils literal"><span class="pre">sage.modules.with_basis.morphism</span></tt></a> for a technical
overview of the classes for module morphisms;</li>
<li><a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphismFromFunction" title="sage.modules.with_basis.morphism.ModuleMorphismFromFunction"><tt class="xref py py-class docutils literal"><span class="pre">ModuleMorphismFromFunction</span></tt></a> and
<a class="reference internal" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism" title="sage.modules.with_basis.morphism.TriangularModuleMorphism"><tt class="xref py py-class docutils literal"><span class="pre">TriangularModuleMorphism</span></tt></a>.</li>
</ul>
</div>
<p>The role of this class is minimal: it provides an <tt class="xref py py-meth docutils literal"><span class="pre">__init__()</span></tt>
method which:</p>
<ul class="simple">
<li>handles the choice of the default category</li>
<li>handles the proper inheritance from categories by updating the
class of <tt class="docutils literal"><span class="pre">self</span></tt> upon construction.</li>
</ul>
</dd></dl>

<dl class="class">
<dt id="sage.modules.with_basis.morphism.ModuleMorphismByLinearity">
<em class="property">class </em><tt class="descclassname">sage.modules.with_basis.morphism.</tt><tt class="descname">ModuleMorphismByLinearity</tt><big>(</big><em>domain</em>, <em>on_basis=None</em>, <em>codomain=None</em>, <em>category=None</em>, <em>position=0</em>, <em>zero=None</em><big>)</big><a class="headerlink" href="#sage.modules.with_basis.morphism.ModuleMorphismByLinearity" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphism" title="sage.modules.with_basis.morphism.ModuleMorphism"><tt class="xref py py-class docutils literal"><span class="pre">sage.modules.with_basis.morphism.ModuleMorphism</span></tt></a></p>
<p>A class for module morphisms obtained by extending a function by linearity.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">domain</span></tt>, <tt class="docutils literal"><span class="pre">codomain</span></tt>, <tt class="docutils literal"><span class="pre">category</span></tt> &#8211; as for <a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphism" title="sage.modules.with_basis.morphism.ModuleMorphism"><tt class="xref py py-class docutils literal"><span class="pre">ModuleMorphism</span></tt></a></p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">on_basis</span></tt> &#8211; a function which accepts indices of the basis of
<tt class="docutils literal"><span class="pre">domain</span></tt> as <tt class="docutils literal"><span class="pre">position</span></tt>-th argument</p>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">codomain</span></tt> &#8211; a parent in <tt class="docutils literal"><span class="pre">Modules(...)</span></tt></dt>
<dd><p class="first last">(default: <tt class="docutils literal"><span class="pre">on_basis.codomain()</span></tt>)</p>
</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">position</span></tt> &#8211; a non-negative integer (default: 0)</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">zero</span></tt> &#8211; the zero of the codomain (defaults: <tt class="docutils literal"><span class="pre">codomain.zero()</span></tt>)</p>
</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="../../../../categories/sage/categories/modules_with_basis.html#sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.module_morphism" title="(in Sage Reference Manual: Category Theory v6.8)"><tt class="xref py py-meth docutils literal"><span class="pre">ModulesWithBasis.ParentMethods.module_morphism()</span></tt></a> for
usage information and examples;</li>
<li><a class="reference internal" href="#module-sage.modules.with_basis.morphism" title="sage.modules.with_basis.morphism"><tt class="xref py py-mod docutils literal"><span class="pre">sage.modules.with_basis.morphism</span></tt></a> for a technical
overview of the classes for module morphisms;</li>
<li><a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphismFromFunction" title="sage.modules.with_basis.morphism.ModuleMorphismFromFunction"><tt class="xref py py-class docutils literal"><span class="pre">ModuleMorphismFromFunction</span></tt></a> and
<a class="reference internal" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism" title="sage.modules.with_basis.morphism.TriangularModuleMorphism"><tt class="xref py py-class docutils literal"><span class="pre">TriangularModuleMorphism</span></tt></a>.</li>
</ul>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><tt class="docutils literal"><span class="pre">on_basis</span></tt> may alternatively be provided in derived classes
by passing <tt class="docutils literal"><span class="pre">None</span></tt> as argument, and implementing or setting
the attribute <tt class="docutils literal"><span class="pre">_on_basis</span></tt></p>
</div>
<dl class="method">
<dt id="sage.modules.with_basis.morphism.ModuleMorphismByLinearity.on_basis">
<tt class="descname">on_basis</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.modules.with_basis.morphism.ModuleMorphismByLinearity.on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the action of this morphism on basis elements, as per
<tt class="xref py py-meth docutils literal"><span class="pre">ModulesWithBasis.Homsets.ElementMethods.on_basis()</span></tt>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>a function from the indices of the basis of the domain to the
codomain</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">phi_on_basis</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">monomial</span> <span class="o">*</span> <span class="nb">abs</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">with_basis</span><span class="o">.</span><span class="n">morphism</span><span class="o">.</span><span class="n">ModuleMorphismByLinearity</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">on_basis</span> <span class="o">=</span> <span class="n">phi_on_basis</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">on_basis</span><span class="p">()(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">B[2]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">on_basis</span><span class="p">()</span> <span class="o">==</span> <span class="n">phi_on_basis</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.modules.with_basis.morphism.ModuleMorphismFromFunction">
<em class="property">class </em><tt class="descclassname">sage.modules.with_basis.morphism.</tt><tt class="descname">ModuleMorphismFromFunction</tt><big>(</big><em>domain</em>, <em>function</em>, <em>codomain=None</em>, <em>category=None</em><big>)</big><a class="headerlink" href="#sage.modules.with_basis.morphism.ModuleMorphismFromFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphism" title="sage.modules.with_basis.morphism.ModuleMorphism"><tt class="xref py py-class docutils literal"><span class="pre">sage.modules.with_basis.morphism.ModuleMorphism</span></tt></a>, <a class="reference external" href="../../../../categories/sage/categories/morphism.html#sage.categories.morphism.SetMorphism" title="(in Sage Reference Manual: Category Theory v6.8)"><tt class="xref py py-class docutils literal"><span class="pre">sage.categories.morphism.SetMorphism</span></tt></a></p>
<p>A class for module morphisms implemented by a plain function.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">domain</span></tt>, <tt class="docutils literal"><span class="pre">codomain</span></tt>, <tt class="docutils literal"><span class="pre">category</span></tt> &#8211; as for <a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphism" title="sage.modules.with_basis.morphism.ModuleMorphism"><tt class="xref py py-class docutils literal"><span class="pre">ModuleMorphism</span></tt></a></li>
<li><tt class="docutils literal"><span class="pre">function</span></tt> &#8211; any function or callable from domain to codomain</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="../../../../categories/sage/categories/modules_with_basis.html#sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.module_morphism" title="(in Sage Reference Manual: Category Theory v6.8)"><tt class="xref py py-meth docutils literal"><span class="pre">ModulesWithBasis.ParentMethods.module_morphism()</span></tt></a> for
usage information and examples;</li>
<li><a class="reference internal" href="#module-sage.modules.with_basis.morphism" title="sage.modules.with_basis.morphism"><tt class="xref py py-mod docutils literal"><span class="pre">sage.modules.with_basis.morphism</span></tt></a> for a technical
overview of the classes for module morphisms;</li>
<li><a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphismFromFunction" title="sage.modules.with_basis.morphism.ModuleMorphismFromFunction"><tt class="xref py py-class docutils literal"><span class="pre">ModuleMorphismFromFunction</span></tt></a> and
<a class="reference internal" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism" title="sage.modules.with_basis.morphism.TriangularModuleMorphism"><tt class="xref py py-class docutils literal"><span class="pre">TriangularModuleMorphism</span></tt></a>.</li>
</ul>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.modules.with_basis.morphism.ModuleMorphismFromMatrix">
<em class="property">class </em><tt class="descclassname">sage.modules.with_basis.morphism.</tt><tt class="descname">ModuleMorphismFromMatrix</tt><big>(</big><em>domain</em>, <em>matrix</em>, <em>codomain=None</em>, <em>category=None</em>, <em>side='left'</em><big>)</big><a class="headerlink" href="#sage.modules.with_basis.morphism.ModuleMorphismFromMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphismByLinearity" title="sage.modules.with_basis.morphism.ModuleMorphismByLinearity"><tt class="xref py py-class docutils literal"><span class="pre">sage.modules.with_basis.morphism.ModuleMorphismByLinearity</span></tt></a></p>
<p>A class for module morphisms built from a matrix in the
distinguished bases of the domain and codomain.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">domain</span></tt>, <tt class="docutils literal"><span class="pre">codomain</span></tt> &#8211; two finite dimensional modules over
the same base ring <span class="math">\(R\)</span> with basis <span class="math">\(F\)</span> and <span class="math">\(G\)</span>, respectively</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">matrix</span></tt> &#8211; a matrix with base ring <span class="math">\(R\)</span> and dimensions
matching that of <span class="math">\(F\)</span> and <span class="math">\(G\)</span>, respectively</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">side</span></tt> &#8211; &#8220;left&#8221; or &#8220;right&#8221; (default: &#8220;left&#8221;)</p>
<blockquote>
<div><p>If <tt class="docutils literal"><span class="pre">side</span></tt> is &#8220;left&#8221;, this morphism is considered as
acting on the left; i.e. each column of the matrix
represents the image of an element of the basis of the
domain.</p>
</div></blockquote>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">category</span></tt> &#8211; a category or <tt class="docutils literal"><span class="pre">None</span></tt> (default: <tt class="docutils literal"><span class="pre">None</span></tt>)</p>
</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]);</span> <span class="n">Y</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;Y&quot;</span><span class="p">);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">matrix</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Set of Morphisms from X to Y in Category of finite dimensional modules with basis over Integer Ring</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">__class__</span>
<span class="go">&lt;class &#39;sage.modules.with_basis.morphism.ModuleMorphismFromMatrix_with_category&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">B[3] + 3*B[4]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">2*B[3] + 5*B[4]</span>

<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">matrix</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s">&quot;right&quot;</span><span class="p">,</span>
<span class="go">....:                         category=Modules(ZZ).WithBasis())</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Set of Morphisms from X to Y</span>
<span class="go">in Category of modules with basis over Integer Ring</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">B[3] + 2*B[4]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">3*B[3] + 5*B[4]</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">Possibly implement rank, addition, multiplication, matrix,
etc, from the stored matrix.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.modules.with_basis.morphism.PointwiseInverseFunction">
<em class="property">class </em><tt class="descclassname">sage.modules.with_basis.morphism.</tt><tt class="descname">PointwiseInverseFunction</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#sage.modules.with_basis.morphism.PointwiseInverseFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../structure/sage/structure/sage_object.html#sage.structure.sage_object.SageObject" title="(in Sage Reference Manual: Basic Structures v6.8)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.sage_object.SageObject</span></tt></a></p>
<p>A class for pointwise inverse functions.</p>
<p>The pointwise inverse function of a function <span class="math">\(f\)</span> is the function
sending every <span class="math">\(x\)</span> to <span class="math">\(1 / f(x)\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.modules.with_basis.morphism</span> <span class="kn">import</span> <span class="n">PointwiseInverseFunction</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">PointwiseInverseFunction</span><span class="p">(</span><span class="n">factorial</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">(1, 1, 1/2, 1/6)</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.modules.with_basis.morphism.PointwiseInverseFunction.pointwise_inverse">
<tt class="descname">pointwise_inverse</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.modules.with_basis.morphism.PointwiseInverseFunction.pointwise_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.modules.with_basis.morphism</span> <span class="kn">import</span> <span class="n">PointwiseInverseFunction</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">PointwiseInverseFunction</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">pointwise_inverse</span><span class="p">()</span> <span class="ow">is</span> <span class="n">operator</span><span class="o">.</span><span class="n">mul</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.modules.with_basis.morphism.TriangularModuleMorphism">
<em class="property">class </em><tt class="descclassname">sage.modules.with_basis.morphism.</tt><tt class="descname">TriangularModuleMorphism</tt><big>(</big><em>triangular='upper'</em>, <em>unitriangular=False</em>, <em>cmp=None</em>, <em>inverse=None</em>, <em>inverse_on_support=&lt;built-in function identity&gt;</em>, <em>invertible=None</em><big>)</big><a class="headerlink" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphism" title="sage.modules.with_basis.morphism.ModuleMorphism"><tt class="xref py py-class docutils literal"><span class="pre">sage.modules.with_basis.morphism.ModuleMorphism</span></tt></a></p>
<p>An abstract class for triangular module morphisms</p>
<p>Let <span class="math">\(X\)</span> and <span class="math">\(Y\)</span> be modules over the same base ring, with
distinguished bases <span class="math">\(F\)</span> indexed by <span class="math">\(I\)</span> and <span class="math">\(G\)</span> indexed by <span class="math">\(J\)</span>,
respectively.</p>
<p>A module morphism <span class="math">\(\phi\)</span> from <span class="math">\(X\)</span> to <span class="math">\(Y\)</span> is <em>triangular</em> if its
representing matrix in the distinguished bases of <span class="math">\(X\)</span> and <span class="math">\(Y\)</span> is
upper triangular (echelon form).</p>
<p>More precisely, <span class="math">\(\phi\)</span> is <em>upper triangular</em> w.r.t. a total order
<span class="math">\(&lt;\)</span> on <span class="math">\(J\)</span> if, for any <span class="math">\(j\in J\)</span>, there exists at most one index
<span class="math">\(i\in I\)</span> such that the leading support of <span class="math">\(\phi(F_i)\)</span> is <span class="math">\(j\)</span> (see
<tt class="xref py py-meth docutils literal"><span class="pre">leading_support()</span></tt>). We denote by <span class="math">\(r(j)\)</span> this index,
setting <span class="math">\(r(j)\)</span> to <tt class="docutils literal"><span class="pre">None</span></tt> if it does not exist.</p>
<p><em>Lower triangular</em> morphisms are defined similarly, taking the
trailing support instead (see <tt class="xref py py-meth docutils literal"><span class="pre">trailing_support()</span></tt>).</p>
<p>A triangular morphism is <em>unitriangular</em> if all its pivots
(i.e. coefficient of <span class="math">\(j\)</span> in each <span class="math">\(\phi(F[r(j)])\)</span>) are <span class="math">\(1\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">domain</span></tt> &#8211; a module with basis <span class="math">\(X\)</span></li>
<li><tt class="docutils literal"><span class="pre">codomain</span></tt> &#8211; a module with basis <span class="math">\(Y\)</span> (default: <span class="math">\(X\)</span>)</li>
<li><tt class="docutils literal"><span class="pre">category</span></tt> &#8211; a category, as for <a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphism" title="sage.modules.with_basis.morphism.ModuleMorphism"><tt class="xref py py-class docutils literal"><span class="pre">ModuleMorphism</span></tt></a></li>
<li><tt class="docutils literal"><span class="pre">triangular</span></tt> &#8211; <tt class="docutils literal"><span class="pre">&quot;upper&quot;</span></tt> or <tt class="docutils literal"><span class="pre">&quot;lower&quot;</span></tt> (default: <tt class="docutils literal"><span class="pre">&quot;upper&quot;</span></tt>)</li>
<li><tt class="docutils literal"><span class="pre">unitriangular</span></tt> &#8211; boolean (default: <tt class="docutils literal"><span class="pre">False</span></tt>)
As a shorthand, one may use <tt class="docutils literal"><span class="pre">unitriangular=&quot;lower&quot;</span></tt>
for <tt class="docutils literal"><span class="pre">triangular=&quot;lower&quot;,</span> <span class="pre">unitriangular=True</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">cmp</span></tt> &#8211; a comparison function on <span class="math">\(J\)</span>
(default: the usual comparison function on <span class="math">\(J\)</span>)</li>
<li><tt class="docutils literal"><span class="pre">inverse_on_support</span></tt> &#8211; a function <span class="math">\(J \to I\cup \{None\}\)</span>
implementing <span class="math">\(r\)</span> (default: the identity function).
If set to &#8220;compute&#8221;, the values of <span class="math">\(r(j)\)</span> are precomputed by
running through the index set <span class="math">\(I\)</span> of the basis of the
domain. This of course requires the domain to be finite
dimensional.</li>
<li><tt class="docutils literal"><span class="pre">invertible</span></tt> &#8211; a boolean or <tt class="docutils literal"><span class="pre">None</span></tt> (default: <tt class="docutils literal"><span class="pre">None</span></tt>); can
be set to specify that <span class="math">\(\phi\)</span> is known to be (or not to be)
invertible. If the domain and codomain share the same indexing
set, this is by default automatically set to <tt class="docutils literal"><span class="pre">True</span></tt> if
<tt class="docutils literal"><span class="pre">inverse_on_support</span></tt> is the identity, or in the finite
dimensional case.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="../../../../categories/sage/categories/modules_with_basis.html#sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.module_morphism" title="(in Sage Reference Manual: Category Theory v6.8)"><tt class="xref py py-meth docutils literal"><span class="pre">ModulesWithBasis.ParentMethods.module_morphism()</span></tt></a> for
usage information and examples;</li>
<li><a class="reference internal" href="#module-sage.modules.with_basis.morphism" title="sage.modules.with_basis.morphism"><tt class="xref py py-mod docutils literal"><span class="pre">sage.modules.with_basis.morphism</span></tt></a> for a technical
overview of the classes for module morphisms;</li>
<li><a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphismFromFunction" title="sage.modules.with_basis.morphism.ModuleMorphismFromFunction"><tt class="xref py py-class docutils literal"><span class="pre">ModuleMorphismFromFunction</span></tt></a> and
<a class="reference internal" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism" title="sage.modules.with_basis.morphism.TriangularModuleMorphism"><tt class="xref py py-class docutils literal"><span class="pre">TriangularModuleMorphism</span></tt></a>.</li>
</ul>
</div>
<p>OUTPUT:</p>
<p>A morphism from <span class="math">\(X\)</span> to <span class="math">\(Y\)</span>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This class is meant to be used as a complement for a concrete
morphism class.  In particular, the <tt class="xref py py-meth docutils literal"><span class="pre">__init__()</span></tt> method
focuses on setting up the data structure describing the
triangularity of the morphism. It purposely does <em>not</em> call
<tt class="xref py py-meth docutils literal"><span class="pre">ModuleMorphism.__init__()</span></tt> which should be called
(directly or indirectly) beforehand.</p>
</div>
<p>EXAMPLES:</p>
<p>We construct and invert an upper unitriangular module morphism between
two free <span class="math">\(\QQ\)</span>-modules:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">200</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="n">I</span><span class="p">);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="n">I</span><span class="p">);</span> <span class="n">Y</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;Y&quot;</span><span class="p">);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ut</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">sum_of_monomials</span> <span class="o">*</span> <span class="n">divisors</span>   <span class="c"># This * is map composition.</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">ut</span><span class="p">,</span> <span class="n">unitriangular</span><span class="o">=</span><span class="s">&quot;upper&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">B[1] + B[2]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>
<span class="go">B[1] + B[2] + B[3] + B[6]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">30</span><span class="p">])</span>
<span class="go">B[1] + B[2] + B[3] + B[5] + B[6] + B[10] + B[15] + B[30]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">-B[1] + B[2]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>
<span class="go">B[1] - B[2] - B[3] + B[6]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">30</span><span class="p">])</span>
<span class="go">-B[1] + B[2] + B[3] + B[5] - B[6] - B[10] - B[15] + B[30]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">phi</span><span class="o">^-</span><span class="mi">1</span><span class="p">)(</span><span class="n">y</span><span class="p">[</span><span class="mi">30</span><span class="p">])</span>
<span class="go">-B[1] + B[2] + B[3] + B[5] - B[6] - B[10] - B[15] + B[30]</span>
</pre></div>
</div>
<p>A lower triangular (but not unitriangular) morphism:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">lt</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">lt</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">2*B[2] + 3*B[3]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">1/2*B[2] - 1/2*B[3]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">B[2]</span>
</pre></div>
</div>
<p>Using the <tt class="docutils literal"><span class="pre">cmp</span></tt> keyword, we can use triangularity even if
the map becomes triangular only after a permutation of the basis:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">ut</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">else</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">perm</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">ut</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s">&quot;upper&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">X</span><span class="p">,</span>
<span class="go">....:                         cmp=lambda a, b: cmp(perm[a], perm[b]))</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[B[1] + B[2], B[2], B[2] + B[3]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[B[1] - B[2], B[2], -B[2] + B[3]]</span>
</pre></div>
</div>
<p>The same works in the lower-triangular case:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">def</span> <span class="nf">lt</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">lt</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">X</span><span class="p">,</span>
<span class="go">....:                         cmp=lambda a, b: cmp(perm[a], perm[b]))</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[B[1], B[1] + B[2] + B[3], B[3]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[B[1], -B[1] + B[2] - B[3], B[3]]</span>
</pre></div>
</div>
<p>An injective but not surjective morphism cannot be inverted,
but the <tt class="docutils literal"><span class="pre">inverse_on_support</span></tt> keyword allows Sage to find a
partial inverse:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ult</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span>  <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>  <span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">ult</span><span class="p">,</span> <span class="n">unitriangular</span><span class="o">=</span><span class="s">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span>
<span class="go">....:        inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">B[3] + B[4] + B[5]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">B[2] - B[3]</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">inverse_on_support</span></tt> keyword can also be used if the
bases of the domain and the codomain are identical but one of
them has to be permuted in order to render the morphism
triangular. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">ut</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="go">....:     return (x[3] if i == 1 else x[1] if i == 2</span>
<span class="go">....:             else x[1] + x[2])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">perm</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="go">....:     return (2 if i == 1 else 3 if i == 2 else 1)</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">ut</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s">&quot;upper&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">X</span><span class="p">,</span>
<span class="go">....:                         inverse_on_support=perm)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[B[3], B[1], B[1] + B[2]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[B[2], -B[2] + B[3], B[1]]</span>
</pre></div>
</div>
<p>The same works if the permutation induces lower triangularity:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">lt</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="go">....:     return (x[3] if i == 1 else x[2] if i == 2</span>
<span class="go">....:             else x[1] + x[2])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">perm</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="go">....:     return 4 - i</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">lt</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">X</span><span class="p">,</span>
<span class="go">....:                         inverse_on_support=perm)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[B[3], B[2], B[1] + B[2]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[-B[2] + B[3], B[2], B[1]]</span>
</pre></div>
</div>
<p>In the finite dimensional case, one can ask Sage to recover
<tt class="docutils literal"><span class="pre">inverse_on_support</span></tt> by a precomputation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ut</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span>  <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">ut</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s">&quot;upper&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span>
<span class="go">....:                         inverse_on_support=&quot;compute&quot;)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
<span class="go">....:     i = phi._inverse_on_support(j)</span>
<span class="go">....:     print j, i, phi(x[i]) if i is not None else None</span>
<span class="go">1 None None</span>
<span class="go">2 1 B[1] + B[2]</span>
<span class="go">3 2 B[1] + B[2] + B[3]</span>
<span class="go">4 3 B[1] + B[2] + B[3] + B[4]</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">inverse_on_basis</span></tt> and <tt class="docutils literal"><span class="pre">cmp</span></tt> keywords can be combined:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">ut</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="go">....:     return (2*x[2] + 3*x[3] if i == 1</span>
<span class="go">....:             else x[1] + x[2] + x[3] if i == 2</span>
<span class="go">....:             else 4*x[2])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">perm</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="go">....:     return (2 if i == 1 else 3 if i == 2 else 1)</span>
<span class="gp">sage: </span><span class="n">perverse_cmp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">cmp</span><span class="p">((</span><span class="n">a</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">ut</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s">&quot;upper&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">X</span><span class="p">,</span>
<span class="go">....:                         inverse_on_support=perm, cmp=perverse_cmp)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[2*B[2] + 3*B[3], B[1] + B[2] + B[3], 4*B[2]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[-1/3*B[1] + B[2] - 1/12*B[3], 1/4*B[3], 1/3*B[1] - 1/6*B[3]]</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.modules.with_basis.morphism.TriangularModuleMorphism.co_kernel_projection">
<tt class="descname">co_kernel_projection</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism.co_kernel_projection" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use <a class="reference internal" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism.cokernel_projection" title="sage.modules.with_basis.morphism.TriangularModuleMorphism.cokernel_projection"><tt class="xref py py-func docutils literal"><span class="pre">cokernel_projection()</span></tt></a> instead.
See <a class="reference external" href="http://trac.sagemath.org/8678">trac ticket #8678</a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.modules.with_basis.morphism.TriangularModuleMorphism.co_reduced">
<tt class="descname">co_reduced</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism.co_reduced" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use <a class="reference internal" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism.coreduced" title="sage.modules.with_basis.morphism.TriangularModuleMorphism.coreduced"><tt class="xref py py-func docutils literal"><span class="pre">coreduced()</span></tt></a> instead.
See <a class="reference external" href="http://trac.sagemath.org/8678">trac ticket #8678</a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.modules.with_basis.morphism.TriangularModuleMorphism.cokernel_basis_indices">
<tt class="descname">cokernel_basis_indices</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism.cokernel_basis_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of the natural monomial basis of the cokernel of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; a triangular morphism over a field or a
unitriangular morphism over a ring, with a finite
dimensional codomain.</li>
</ul>
<p>OUTPUT:</p>
<p>A list <span class="math">\(E\)</span> of indices of the basis <span class="math">\((B_e)_e\)</span> of the codomain
of <tt class="docutils literal"><span class="pre">self</span></tt> so that <span class="math">\((B_e)_{e\in E}\)</span> forms a basis of a
supplementary of the image set of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>Thinking of this triangular morphism as a row echelon matrix,
this returns the complementary of the characteristic
columns. Namely <span class="math">\(E\)</span> is the set of indices which do not appear
as leading support of some element of the image set of
<tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">uut</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span>  <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>  <span class="p">)</span> <span class="c"># uni-upper</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">uut</span><span class="p">,</span> <span class="n">unitriangular</span><span class="o">=</span><span class="s">&quot;upper&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span>
<span class="go">....:       inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">cokernel_basis_indices</span><span class="p">()</span>
<span class="go">[1, 5]</span>

<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">uut</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s">&quot;upper&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span>
<span class="go">....:       inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">cokernel_basis_indices</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">cokernel_basis_indices for a triangular but not unitriangular morphism over a ring</span>

<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="n">NN</span><span class="p">);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">uut</span><span class="p">,</span> <span class="n">unitriangular</span><span class="o">=</span><span class="s">&quot;upper&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span>
<span class="go">....:       inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">cokernel_basis_indices</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">cokernel_basis_indices implemented only for morphisms with a finite dimensional codomain</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.modules.with_basis.morphism.TriangularModuleMorphism.cokernel_projection">
<tt class="descname">cokernel_projection</tt><big>(</big><em>category=None</em><big>)</big><a class="headerlink" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism.cokernel_projection" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a projection on the co-kernel of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">category</span></tt> &#8211; the category of the result</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">lt</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span>  <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>  <span class="p">)</span> <span class="c"># lower</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">lt</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span>
<span class="go">....:      inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)</span>
<span class="gp">sage: </span><span class="n">phipro</span> <span class="o">=</span> <span class="n">phi</span><span class="o">.</span><span class="n">cokernel_projection</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">phipro</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">B[1]</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">phipro</span><span class="p">(</span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">phipro</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">B[1]</span>
<span class="gp">sage: </span><span class="n">phipro</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="go">-B[5]</span>
<span class="gp">sage: </span><span class="n">phipro</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
<span class="go">B[5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.modules.with_basis.morphism.TriangularModuleMorphism.coreduced">
<tt class="descname">coreduced</tt><big>(</big><em>y</em><big>)</big><a class="headerlink" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism.coreduced" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <span class="math">\(y\)</span> reduced w.r.t. the image of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; a triangular morphism over a field, or a
unitriangular morphism over a ring</li>
<li><tt class="docutils literal"><span class="pre">y</span></tt> &#8211; an element of the codomain of <tt class="docutils literal"><span class="pre">self</span></tt></li>
</ul>
<p>Suppose that <tt class="docutils literal"><span class="pre">self</span></tt> is a morphism from <span class="math">\(X\)</span> to <span class="math">\(Y\)</span>. Then, for
any <span class="math">\(y \in Y\)</span>, the call <tt class="docutils literal"><span class="pre">self.coreduced(y)</span></tt> returns a
normal form for <span class="math">\(y\)</span> in the quotient <span class="math">\(Y / I\)</span> where <span class="math">\(I\)</span> is the
image of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ult</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span>  <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>  <span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">ult</span><span class="p">,</span> <span class="n">unitriangular</span><span class="o">=</span><span class="s">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span>
<span class="go">....:        inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()]</span>
<span class="go">[B[2] + B[3] + B[4] + B[5],</span>
<span class="go">        B[3] + B[4] + B[5],</span>
<span class="go">               B[4] + B[5]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">coreduced</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="mi">4</span><span class="p">])]</span>
<span class="go">[B[1] + 2*B[5]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">coreduced</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">y</span><span class="p">]</span>
<span class="go">[B[1], 0, 0, -B[5], B[5]]</span>
</pre></div>
</div>
<p>Now with a non unitriangular morphism:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">lt</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span> <span class="n">j</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>  <span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">lt</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span>
<span class="go">....:       inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()]</span>
<span class="go">[2*B[2] + 3*B[3] + 4*B[4] + 5*B[5],</span>
<span class="go">          3*B[3] + 4*B[4] + 5*B[5],</span>
<span class="go">                   4*B[4] + 5*B[5]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">coreduced</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="mi">4</span><span class="p">])]</span>
<span class="go">[B[1] + 5/2*B[5]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">coreduced</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">y</span><span class="p">]</span>
<span class="go">[B[1], 0, 0, -5/4*B[5], B[5]]</span>
</pre></div>
</div>
<p>For general rings, this method is only implemented for
unitriangular morphisms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">ult</span><span class="p">,</span> <span class="n">unitriangular</span><span class="o">=</span><span class="s">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span>
<span class="go">....:       inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">coreduced</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="mi">4</span><span class="p">])]</span>
<span class="go">[B[1] + 2*B[5]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">coreduced</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">y</span><span class="p">]</span>
<span class="go">[B[1], 0, 0, -B[5], B[5]]</span>

<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">lt</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span>
<span class="go">....:       inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">coreduced</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">y</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">coreduce for a triangular but not unitriangular morphism over a ring</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Before <a class="reference external" href="http://trac.sagemath.org/8678">trac ticket #8678</a> this method used to be called co_reduced.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.modules.with_basis.morphism.TriangularModuleMorphism.preimage">
<tt class="descname">preimage</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism.preimage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the preimage of <span class="math">\(f\)</span> under <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ult</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span>  <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>  <span class="p">)</span> <span class="c"># uni-lower</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">ult</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">B[1] - B[3]</span>
</pre></div>
</div>
<p>The morphism need not be surjective. In the following example,
the codomain is of larger dimension than the domain:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">lt</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span>  <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>  <span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">lt</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">B[1] - B[3]</span>
</pre></div>
</div>
<p>Here are examples using <tt class="docutils literal"><span class="pre">inverse_on_support</span></tt> to handle a
morphism that shifts the leading indices by <span class="math">\(1\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">lt</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span>  <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>  <span class="p">)</span> <span class="c"># lower</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">lt</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span>
<span class="go">....:         inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">B[2] + B[3] + B[4] + B[5]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">B[4] + B[5]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">B[1] - B[3]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">el</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">phi</span><span class="p">(</span><span class="n">el</span><span class="p">))</span> <span class="o">==</span> <span class="n">el</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">B[1] is not in the image</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">B[4] is not in the image</span>
</pre></div>
</div>
<p>Over a base ring like <span class="math">\(\ZZ\)</span>, the morphism need not be
surjective even when the dimensions match:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">lt</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span> <span class="mi">2</span><span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>  <span class="p">)</span> <span class="c"># lower</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">lt</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">B[1] - B[3]</span>
</pre></div>
</div>
<p>The error message in case of failure could be more specific though:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">no conversion of this rational to integer</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.modules.with_basis.morphism.TriangularModuleMorphism.section">
<tt class="descname">section</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism.section" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the section (partial inverse) of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>Return a partial triangular morphism which is a section of
<tt class="docutils literal"><span class="pre">self</span></tt>. The section morphism raise a <tt class="docutils literal"><span class="pre">ValueError</span></tt> if asked to
apply on an element which is not in the image of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&#39;X&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ult</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span>  <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>  <span class="p">)</span> <span class="c"># uni-lower</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">ult</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span>
<span class="go">....:      inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)</span>
<span class="gp">sage: </span><span class="o">~</span><span class="n">phi</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Morphism not known to be invertible;</span>
<span class="go">see the invertible option of module_morphism</span>
<span class="gp">sage: </span><span class="n">phiinv</span> <span class="o">=</span> <span class="n">phi</span><span class="o">.</span><span class="n">section</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">map</span><span class="p">(</span><span class="n">phiinv</span><span class="o">*</span><span class="n">phi</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span><span class="o">.</span><span class="n">list</span><span class="p">())</span> <span class="o">==</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">phiinv</span><span class="p">(</span><span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">B[1] is not in the image</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.modules.with_basis.morphism.TriangularModuleMorphismByLinearity">
<em class="property">class </em><tt class="descclassname">sage.modules.with_basis.morphism.</tt><tt class="descname">TriangularModuleMorphismByLinearity</tt><big>(</big><em>domain</em>, <em>on_basis</em>, <em>codomain=None</em>, <em>category=None</em>, <em>**keywords</em><big>)</big><a class="headerlink" href="#sage.modules.with_basis.morphism.TriangularModuleMorphismByLinearity" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphismByLinearity" title="sage.modules.with_basis.morphism.ModuleMorphismByLinearity"><tt class="xref py py-class docutils literal"><span class="pre">sage.modules.with_basis.morphism.ModuleMorphismByLinearity</span></tt></a>, <a class="reference internal" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism" title="sage.modules.with_basis.morphism.TriangularModuleMorphism"><tt class="xref py py-class docutils literal"><span class="pre">sage.modules.with_basis.morphism.TriangularModuleMorphism</span></tt></a></p>
<p>A concrete class for triangular module morphisms obtained by extending a function by linearity.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="../../../../categories/sage/categories/modules_with_basis.html#sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.module_morphism" title="(in Sage Reference Manual: Category Theory v6.8)"><tt class="xref py py-meth docutils literal"><span class="pre">ModulesWithBasis.ParentMethods.module_morphism()</span></tt></a> for
usage information and examples;</li>
<li><a class="reference internal" href="#module-sage.modules.with_basis.morphism" title="sage.modules.with_basis.morphism"><tt class="xref py py-mod docutils literal"><span class="pre">sage.modules.with_basis.morphism</span></tt></a> for a technical
overview of the classes for module morphisms;</li>
<li><a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphismByLinearity" title="sage.modules.with_basis.morphism.ModuleMorphismByLinearity"><tt class="xref py py-class docutils literal"><span class="pre">ModuleMorphismByLinearity</span></tt></a> and
<a class="reference internal" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism" title="sage.modules.with_basis.morphism.TriangularModuleMorphism"><tt class="xref py py-class docutils literal"><span class="pre">TriangularModuleMorphism</span></tt></a>.</li>
</ul>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.modules.with_basis.morphism.TriangularModuleMorphismFromFunction">
<em class="property">class </em><tt class="descclassname">sage.modules.with_basis.morphism.</tt><tt class="descname">TriangularModuleMorphismFromFunction</tt><big>(</big><em>domain</em>, <em>function</em>, <em>codomain=None</em>, <em>category=None</em>, <em>**keywords</em><big>)</big><a class="headerlink" href="#sage.modules.with_basis.morphism.TriangularModuleMorphismFromFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphismFromFunction" title="sage.modules.with_basis.morphism.ModuleMorphismFromFunction"><tt class="xref py py-class docutils literal"><span class="pre">sage.modules.with_basis.morphism.ModuleMorphismFromFunction</span></tt></a>, <a class="reference internal" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism" title="sage.modules.with_basis.morphism.TriangularModuleMorphism"><tt class="xref py py-class docutils literal"><span class="pre">sage.modules.with_basis.morphism.TriangularModuleMorphism</span></tt></a></p>
<p>A concrete class for triangular module morphisms implemented by a function.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="../../../../categories/sage/categories/modules_with_basis.html#sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.module_morphism" title="(in Sage Reference Manual: Category Theory v6.8)"><tt class="xref py py-meth docutils literal"><span class="pre">ModulesWithBasis.ParentMethods.module_morphism()</span></tt></a> for
usage information and examples;</li>
<li><a class="reference internal" href="#module-sage.modules.with_basis.morphism" title="sage.modules.with_basis.morphism"><tt class="xref py py-mod docutils literal"><span class="pre">sage.modules.with_basis.morphism</span></tt></a> for a technical
overview of the classes for module morphisms;</li>
<li><a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphismFromFunction" title="sage.modules.with_basis.morphism.ModuleMorphismFromFunction"><tt class="xref py py-class docutils literal"><span class="pre">ModuleMorphismFromFunction</span></tt></a> and
<a class="reference internal" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism" title="sage.modules.with_basis.morphism.TriangularModuleMorphism"><tt class="xref py py-class docutils literal"><span class="pre">TriangularModuleMorphism</span></tt></a>.</li>
</ul>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.modules.with_basis.morphism.pointwise_inverse_function">
<tt class="descclassname">sage.modules.with_basis.morphism.</tt><tt class="descname">pointwise_inverse_function</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#sage.modules.with_basis.morphism.pointwise_inverse_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the function <span class="math">\(x \mapsto 1 / f(x)\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">f</span></tt> &#8211; a function</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.modules.with_basis.morphism</span> <span class="kn">import</span> <span class="n">pointwise_inverse_function</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">pointwise_inverse_function</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">g</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">g</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">(1, 1/2, 1/3)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#sage.modules.with_basis.morphism.pointwise_inverse_function" title="sage.modules.with_basis.morphism.pointwise_inverse_function"><tt class="xref py py-func docutils literal"><span class="pre">pointwise_inverse_function()</span></tt></a> is an involution:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span> <span class="ow">is</span> <span class="n">pointwise_inverse_function</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-2">
<p class="first admonition-title">Todo</p>
<p class="last">This has nothing to do here!!! Should there be a library for
pointwise operations on functions somewhere in Sage?</p>
</div>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h4>Previous topic</h4>
            <p class="topless"><a href="__init__.html"
                                  title="previous chapter">Concrete classes related to modules with a distinguished basis.</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="subquotient.html"
                                  title="next chapter">Quotients of Modules With Basis</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../../_sources/sage/modules/with_basis/morphism.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="subquotient.html" title="Quotients of Modules With Basis"
             >next</a> |</li>
        <li class="right" >
          <a href="__init__.html" title="Concrete classes related to modules with a distinguished basis."
             >previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../../index.html">Modules</a> &raquo;</li>
 
      </ul>
    </div>
    
    <div class="footer">
        &copy; Copyright 2005--2015, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>