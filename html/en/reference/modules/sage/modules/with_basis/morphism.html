
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Module with basis morphisms &#8212; Sage Reference Manual v8.6: Modules</title>
    <link rel="stylesheet" href="../../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="Quotients of Modules With Basis" href="subquotient.html" />
    <link rel="prev" title="Cell Modules" href="cell_module.html" />
    <link rel="icon" href="../../../../_static/sageicon.png" type="image/x-icon" />
    <script src="../../../../_static/thebe.js" type="text/javascript"></script>
    <script src="../../../../_static/thebe-sage.js" type="text/javascript"></script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="subquotient.html" title="Quotients of Modules With Basis"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="cell_module.html" title="Cell Modules"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../../index.html">Modules</a> &#187;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-with-basis-morphisms">
<span id="sage-modules-with-basis-morphism"></span><h1>Module with basis morphisms<a class="headerlink" href="#module-with-basis-morphisms" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.modules.with_basis.morphism"></span><p>This module contains a hierarchy of classes for morphisms of modules
with a basis (category <code class="xref py py-class docutils literal notranslate"><span class="pre">Modules.WithBasis</span></code>):</p>
<ul class="simple">
<li><a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphism" title="sage.modules.with_basis.morphism.ModuleMorphism"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleMorphism</span></code></a></li>
<li><a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphismByLinearity" title="sage.modules.with_basis.morphism.ModuleMorphismByLinearity"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleMorphismByLinearity</span></code></a></li>
<li><a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphismFromMatrix" title="sage.modules.with_basis.morphism.ModuleMorphismFromMatrix"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleMorphismFromMatrix</span></code></a></li>
<li><a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphismFromFunction" title="sage.modules.with_basis.morphism.ModuleMorphismFromFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleMorphismFromFunction</span></code></a></li>
<li><a class="reference internal" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism" title="sage.modules.with_basis.morphism.TriangularModuleMorphism"><code class="xref py py-class docutils literal notranslate"><span class="pre">TriangularModuleMorphism</span></code></a></li>
<li><a class="reference internal" href="#sage.modules.with_basis.morphism.TriangularModuleMorphismByLinearity" title="sage.modules.with_basis.morphism.TriangularModuleMorphismByLinearity"><code class="xref py py-class docutils literal notranslate"><span class="pre">TriangularModuleMorphismByLinearity</span></code></a></li>
<li><a class="reference internal" href="#sage.modules.with_basis.morphism.TriangularModuleMorphismFromFunction" title="sage.modules.with_basis.morphism.TriangularModuleMorphismFromFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">TriangularModuleMorphismFromFunction</span></code></a></li>
</ul>
<p>These are internal classes; it is recommended <em>not</em> to use them
directly, and instead to construct morphisms through the
<a class="reference external" href="../../../../categories/sage/categories/modules_with_basis.html#sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.module_morphism" title="(in Sage Reference Manual: Category Framework v8.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ModulesWithBasis.ParentMethods.module_morphism()</span></code></a> method of the
domain, or through the homset. See the former for an overview
of the possible arguments.</p>
<p>EXAMPLES:</p>
<p>We construct a morphism through the method
<a class="reference external" href="../../../../categories/sage/categories/modules_with_basis.html#sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.module_morphism" title="(in Sage Reference Manual: Category Framework v8.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ModulesWithBasis.ParentMethods.module_morphism()</span></code></a>, by specifying
the image of each element of the distinguished basis:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span>   <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">on_basis</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">Y</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">Y</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="gp">sage: </span><span class="n">phi1</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">on_basis</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi1</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">B[1] + 2*B[2]</span>

<span class="gp">sage: </span><span class="n">phi1</span>
<span class="go">Generic morphism:</span>
<span class="go">  From: Free module generated by {1, 2, 3} over Rational Field</span>
<span class="go">  To:   Free module generated by {1, 2, 3, 4} over Rational Field</span>
<span class="gp">sage: </span><span class="n">phi1</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Set of Morphisms from Free module generated by {1, 2, 3} over Rational Field to Free module generated by {1, 2, 3, 4} over Rational Field in Category of finite dimensional vector spaces with basis over Rational Field</span>
<span class="gp">sage: </span><span class="n">phi1</span><span class="o">.</span><span class="vm">__class__</span>
<span class="go">&lt;class &#39;sage.modules.with_basis.morphism.ModuleMorphismByLinearity_with_category&#39;&gt;</span>
</pre></div>
</div>
<p>Constructing the same morphism from the homset:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Hom</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi2</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span><span class="n">on_basis</span><span class="o">=</span><span class="n">on_basis</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi1</span> <span class="o">==</span> <span class="n">phi2</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Constructing the same morphism directly using the class; no backward
compatibility is guaranteed in this case:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.modules.with_basis.morphism</span> <span class="kn">import</span> <span class="n">ModuleMorphismByLinearity</span>
<span class="gp">sage: </span><span class="n">phi3</span> <span class="o">=</span> <span class="n">ModuleMorphismByLinearity</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">on_basis</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi3</span> <span class="o">==</span> <span class="n">phi1</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>The hierarchy of classes implemented in this module is one of the
first non-trivial hierarchies of classes for morphisms. It is
hitting a couple scaling issues:</p>
<ul>
<li><p class="first">There are many independent properties from which module
morphisms can get code (being defined by linearity, from a
matrix, or a function; being triangular, being diagonal,
…). How to mitigate the class hierarchy growth?</p>
<p>This will become even more stringent as more properties are
added (e.g. being defined from generators for an algebra
morphism, …)</p>
<p>Categories, whose primary purpose is to provide infrastructure
for handling such large hierarchy of classes, can’t help at this
point: there is no category whose morphisms are triangular
morphisms, and it’s not clear such a category would be sensible.</p>
</li>
<li><p class="first">How to properly handle <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method calls and
multiple inheritance?</p>
</li>
<li><p class="first">Who should be in charge of setting the default category: the
classes themselves, or
<a class="reference external" href="../../../../categories/sage/categories/modules_with_basis.html#sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.module_morphism" title="(in Sage Reference Manual: Category Framework v8.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ModulesWithBasis.ParentMethods.module_morphism()</span></code></a>?</p>
</li>
</ul>
<p class="last">Because of this, the hierarchy of classes, and the specific APIs,
is likely to be refactored as better infrastructure and best
practices emerge.</p>
</div>
<p>AUTHORS:</p>
<ul class="simple">
<li>Nicolas M. Thiery (2008-2015)</li>
<li>Jason Bandlow and Florent Hivert (2010): Triangular Morphisms</li>
<li>Christian Stump (2010): <a class="reference external" href="https://trac.sagemath.org/9648">trac ticket #9648</a> module_morphism’s to a wider class
of codomains</li>
</ul>
<p>Before <a class="reference external" href="https://trac.sagemath.org/8678">trac ticket #8678</a>, this hierarchy of classes used to be in
sage.categories.modules_with_basis; see <a class="reference external" href="https://trac.sagemath.org/8678">trac ticket #8678</a> for the complete log.</p>
<dl class="class">
<dt id="sage.modules.with_basis.morphism.DiagonalModuleMorphism">
<em class="property">class </em><code class="descclassname">sage.modules.with_basis.morphism.</code><code class="descname">DiagonalModuleMorphism</code><span class="sig-paren">(</span><em>domain</em>, <em>diagonal</em>, <em>codomain=None</em>, <em>category=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.modules.with_basis.morphism.DiagonalModuleMorphism" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphismByLinearity" title="sage.modules.with_basis.morphism.ModuleMorphismByLinearity"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.modules.with_basis.morphism.ModuleMorphismByLinearity</span></code></a></p>
<p>A class for diagonal module morphisms.</p>
<p>See <a class="reference external" href="../../../../categories/sage/categories/modules_with_basis.html#sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.module_morphism" title="(in Sage Reference Manual: Category Framework v8.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ModulesWithBasis.ParentMethods.module_morphism()</span></code></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">domain</span></code>, <code class="docutils literal notranslate"><span class="pre">codomain</span></code> – two modules with basis <span class="math notranslate nohighlight">\(F\)</span> and <span class="math notranslate nohighlight">\(G\)</span>,
respectively</li>
<li><code class="docutils literal notranslate"><span class="pre">diagonal</span></code> – a function <span class="math notranslate nohighlight">\(d\)</span></li>
</ul>
<p>Assumptions:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">domain</span></code> and <code class="docutils literal notranslate"><span class="pre">codomain</span></code> have the same base ring <span class="math notranslate nohighlight">\(R\)</span>,</li>
<li>their respective bases <span class="math notranslate nohighlight">\(F\)</span> and <span class="math notranslate nohighlight">\(G\)</span> have the same index set <span class="math notranslate nohighlight">\(I\)</span>,</li>
<li><span class="math notranslate nohighlight">\(d\)</span> is a function <span class="math notranslate nohighlight">\(I \to R\)</span>.</li>
</ul>
<p>Return the diagonal module morphism from <code class="docutils literal notranslate"><span class="pre">domain</span></code> to <code class="docutils literal notranslate"><span class="pre">codomain</span></code>
sending <span class="math notranslate nohighlight">\(F(i) \mapsto d(i) G(i)\)</span> for all <span class="math notranslate nohighlight">\(i \in I\)</span>.</p>
<p>By default, <code class="docutils literal notranslate"><span class="pre">codomain</span></code> is currently assumed to be <code class="docutils literal notranslate"><span class="pre">domain</span></code>.
(Todo: make a consistent choice with <code class="docutils literal notranslate"><span class="pre">*ModuleMorphism</span></code>.)</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<ul class="last simple">
<li>Implement an optimized <code class="docutils literal notranslate"><span class="pre">_call_()</span></code> function.</li>
<li>Generalize to a mapcoeffs.</li>
<li>Generalize to a mapterms.</li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">diagonal</span><span class="o">=</span><span class="n">factorial</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">(B[1], 2*B[2], 6*B[3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.modules.with_basis.morphism.ModuleMorphism">
<em class="property">class </em><code class="descclassname">sage.modules.with_basis.morphism.</code><code class="descname">ModuleMorphism</code><span class="sig-paren">(</span><em>domain</em>, <em>codomain=None</em>, <em>category=None</em>, <em>affine=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.modules.with_basis.morphism.ModuleMorphism" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../categories/sage/categories/morphism.html#sage.categories.morphism.Morphism" title="(in Sage Reference Manual: Category Framework v8.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.morphism.Morphism</span></code></a></p>
<p>The top abstract base class for module with basis morphisms.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">domain</span></code> – a parent in <code class="docutils literal notranslate"><span class="pre">ModulesWithBasis(...)</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">codomain</span></code> – a parent in <code class="docutils literal notranslate"><span class="pre">Modules(...)</span></code>;</li>
<li><code class="docutils literal notranslate"><span class="pre">category</span></code> – a category or <code class="docutils literal notranslate"><span class="pre">None</span></code> (default: <span class="math notranslate nohighlight">\(None`\)</span>)</li>
<li><code class="docutils literal notranslate"><span class="pre">affine</span></code> – whether we define an affine module morphism
(default: False).</li>
</ul>
<p>Construct a module morphism from <code class="docutils literal notranslate"><span class="pre">domain</span></code> to <code class="docutils literal notranslate"><span class="pre">codomain</span></code> in the
category <code class="docutils literal notranslate"><span class="pre">category</span></code>. By default, the category is the first of
<code class="docutils literal notranslate"><span class="pre">Modules(R).WithBasis().FiniteDimensional()</span></code>,
<code class="docutils literal notranslate"><span class="pre">Modules(R).WithBasis()</span></code>, <code class="docutils literal notranslate"><span class="pre">Modules(R)</span></code>,
<code class="docutils literal notranslate"><span class="pre">CommutativeAdditiveMonoids()</span></code> that contains both the domain and
the codomain. If initializing an affine morphism, then <span class="math notranslate nohighlight">\(Sets()\)</span> is
used instead.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="../../../../categories/sage/categories/modules_with_basis.html#sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.module_morphism" title="(in Sage Reference Manual: Category Framework v8.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ModulesWithBasis.ParentMethods.module_morphism()</span></code></a> for
usage information and examples;</li>
<li><a class="reference internal" href="#module-sage.modules.with_basis.morphism" title="sage.modules.with_basis.morphism"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.modules.with_basis.morphism</span></code></a> for a technical
overview of the classes for module morphisms;</li>
<li><a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphismFromFunction" title="sage.modules.with_basis.morphism.ModuleMorphismFromFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleMorphismFromFunction</span></code></a> and
<a class="reference internal" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism" title="sage.modules.with_basis.morphism.TriangularModuleMorphism"><code class="xref py py-class docutils literal notranslate"><span class="pre">TriangularModuleMorphism</span></code></a>.</li>
</ul>
</div>
<p>The role of this class is minimal: it provides an <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code>
method which:</p>
<ul class="simple">
<li>handles the choice of the default category</li>
<li>handles the proper inheritance from categories by updating the
class of <code class="docutils literal notranslate"><span class="pre">self</span></code> upon construction.</li>
</ul>
</dd></dl>

<dl class="class">
<dt id="sage.modules.with_basis.morphism.ModuleMorphismByLinearity">
<em class="property">class </em><code class="descclassname">sage.modules.with_basis.morphism.</code><code class="descname">ModuleMorphismByLinearity</code><span class="sig-paren">(</span><em>domain</em>, <em>on_basis=None</em>, <em>codomain=None</em>, <em>category=None</em>, <em>position=0</em>, <em>zero=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.modules.with_basis.morphism.ModuleMorphismByLinearity" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphism" title="sage.modules.with_basis.morphism.ModuleMorphism"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.modules.with_basis.morphism.ModuleMorphism</span></code></a></p>
<p>A class for module morphisms obtained by extending a function by linearity.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">domain</span></code>, <code class="docutils literal notranslate"><span class="pre">codomain</span></code>, <code class="docutils literal notranslate"><span class="pre">category</span></code> – as for <a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphism" title="sage.modules.with_basis.morphism.ModuleMorphism"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleMorphism</span></code></a></li>
<li><code class="docutils literal notranslate"><span class="pre">on_basis</span></code> – a function which accepts indices of the basis of
<code class="docutils literal notranslate"><span class="pre">domain</span></code> as <code class="docutils literal notranslate"><span class="pre">position</span></code>-th argument</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">codomain</span></code> – a parent in <code class="docutils literal notranslate"><span class="pre">Modules(...)</span></code></dt>
<dd>(default: <code class="docutils literal notranslate"><span class="pre">on_basis.codomain()</span></code>)</dd>
</dl>
</li>
<li><code class="docutils literal notranslate"><span class="pre">position</span></code> – a non-negative integer (default: 0)</li>
<li><code class="docutils literal notranslate"><span class="pre">zero</span></code> – the zero of the codomain (defaults: <code class="docutils literal notranslate"><span class="pre">codomain.zero()</span></code>)</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="../../../../categories/sage/categories/modules_with_basis.html#sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.module_morphism" title="(in Sage Reference Manual: Category Framework v8.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ModulesWithBasis.ParentMethods.module_morphism()</span></code></a> for
usage information and examples;</li>
<li><a class="reference internal" href="#module-sage.modules.with_basis.morphism" title="sage.modules.with_basis.morphism"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.modules.with_basis.morphism</span></code></a> for a technical
overview of the classes for module morphisms;</li>
<li><a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphismFromFunction" title="sage.modules.with_basis.morphism.ModuleMorphismFromFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleMorphismFromFunction</span></code></a> and
<a class="reference internal" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism" title="sage.modules.with_basis.morphism.TriangularModuleMorphism"><code class="xref py py-class docutils literal notranslate"><span class="pre">TriangularModuleMorphism</span></code></a>.</li>
</ul>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">on_basis</span></code> may alternatively be provided in derived classes
by passing <code class="docutils literal notranslate"><span class="pre">None</span></code> as argument, and implementing or setting
the attribute <code class="docutils literal notranslate"><span class="pre">_on_basis</span></code></p>
</div>
<dl class="method">
<dt id="sage.modules.with_basis.morphism.ModuleMorphismByLinearity.on_basis">
<code class="descname">on_basis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.modules.with_basis.morphism.ModuleMorphismByLinearity.on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the action of this morphism on basis elements, as per
<code class="xref py py-meth docutils literal notranslate"><span class="pre">ModulesWithBasis.Homsets.ElementMethods.on_basis()</span></code>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>a function from the indices of the basis of the domain to the
codomain</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">phi_on_basis</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">monomial</span> <span class="o">*</span> <span class="nb">abs</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">with_basis</span><span class="o">.</span><span class="n">morphism</span><span class="o">.</span><span class="n">ModuleMorphismByLinearity</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">on_basis</span> <span class="o">=</span> <span class="n">phi_on_basis</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">on_basis</span><span class="p">()(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">B[2]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">on_basis</span><span class="p">()</span> <span class="o">==</span> <span class="n">phi_on_basis</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.modules.with_basis.morphism.ModuleMorphismFromFunction">
<em class="property">class </em><code class="descclassname">sage.modules.with_basis.morphism.</code><code class="descname">ModuleMorphismFromFunction</code><span class="sig-paren">(</span><em>domain</em>, <em>function</em>, <em>codomain=None</em>, <em>category=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.modules.with_basis.morphism.ModuleMorphismFromFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphism" title="sage.modules.with_basis.morphism.ModuleMorphism"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.modules.with_basis.morphism.ModuleMorphism</span></code></a>, <a class="reference external" href="../../../../categories/sage/categories/morphism.html#sage.categories.morphism.SetMorphism" title="(in Sage Reference Manual: Category Framework v8.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.morphism.SetMorphism</span></code></a></p>
<p>A class for module morphisms implemented by a plain function.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">domain</span></code>, <code class="docutils literal notranslate"><span class="pre">codomain</span></code>, <code class="docutils literal notranslate"><span class="pre">category</span></code> – as for <a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphism" title="sage.modules.with_basis.morphism.ModuleMorphism"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleMorphism</span></code></a></li>
<li><code class="docutils literal notranslate"><span class="pre">function</span></code> – any function or callable from domain to codomain</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="../../../../categories/sage/categories/modules_with_basis.html#sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.module_morphism" title="(in Sage Reference Manual: Category Framework v8.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ModulesWithBasis.ParentMethods.module_morphism()</span></code></a> for
usage information and examples;</li>
<li><a class="reference internal" href="#module-sage.modules.with_basis.morphism" title="sage.modules.with_basis.morphism"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.modules.with_basis.morphism</span></code></a> for a technical
overview of the classes for module morphisms;</li>
<li><a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphismFromFunction" title="sage.modules.with_basis.morphism.ModuleMorphismFromFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleMorphismFromFunction</span></code></a> and
<a class="reference internal" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism" title="sage.modules.with_basis.morphism.TriangularModuleMorphism"><code class="xref py py-class docutils literal notranslate"><span class="pre">TriangularModuleMorphism</span></code></a>.</li>
</ul>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.modules.with_basis.morphism.ModuleMorphismFromMatrix">
<em class="property">class </em><code class="descclassname">sage.modules.with_basis.morphism.</code><code class="descname">ModuleMorphismFromMatrix</code><span class="sig-paren">(</span><em>domain</em>, <em>matrix</em>, <em>codomain=None</em>, <em>category=None</em>, <em>side='left'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.modules.with_basis.morphism.ModuleMorphismFromMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphismByLinearity" title="sage.modules.with_basis.morphism.ModuleMorphismByLinearity"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.modules.with_basis.morphism.ModuleMorphismByLinearity</span></code></a></p>
<p>A class for module morphisms built from a matrix in the
distinguished bases of the domain and codomain.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="../../../../categories/sage/categories/modules_with_basis.html#sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.module_morphism" title="(in Sage Reference Manual: Category Framework v8.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ModulesWithBasis.ParentMethods.module_morphism()</span></code></a></li>
<li><code class="xref py py-meth docutils literal notranslate"><span class="pre">ModulesWithBasis.FiniteDimensional.MorphismMethods.matrix()</span></code></li>
</ul>
</div>
<p>INPUT:</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">domain</span></code>, <code class="docutils literal notranslate"><span class="pre">codomain</span></code> – two finite dimensional modules over
the same base ring <span class="math notranslate nohighlight">\(R\)</span> with basis <span class="math notranslate nohighlight">\(F\)</span> and <span class="math notranslate nohighlight">\(G\)</span>, respectively</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">matrix</span></code> – a matrix with base ring <span class="math notranslate nohighlight">\(R\)</span> and dimensions
matching that of <span class="math notranslate nohighlight">\(F\)</span> and <span class="math notranslate nohighlight">\(G\)</span>, respectively</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">side</span></code> – “left” or “right” (default: “left”)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">side</span></code> is “left”, this morphism is considered as
acting on the left; i.e. each column of the matrix
represents the image of an element of the basis of the
domain.</p>
</div></blockquote>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">category</span></code> – a category or <code class="docutils literal notranslate"><span class="pre">None</span></code> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]);</span> <span class="n">Y</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">matrix</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Set of Morphisms from X to Y in Category of finite dimensional modules with basis over Integer Ring</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="vm">__class__</span>
<span class="go">&lt;class &#39;sage.modules.with_basis.morphism.ModuleMorphismFromMatrix_with_category&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">B[3] + 3*B[4]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">2*B[3] + 5*B[4]</span>

<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">matrix</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span>
<span class="go">....:                         category=Modules(ZZ).WithBasis())</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Set of Morphisms from X to Y</span>
<span class="go">in Category of modules with basis over Integer Ring</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">B[3] + 2*B[4]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">3*B[3] + 5*B[4]</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">Possibly implement rank, addition, multiplication, matrix,
etc, from the stored matrix.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.modules.with_basis.morphism.PointwiseInverseFunction">
<em class="property">class </em><code class="descclassname">sage.modules.with_basis.morphism.</code><code class="descname">PointwiseInverseFunction</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.modules.with_basis.morphism.PointwiseInverseFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../structure/sage/structure/sage_object.html#sage.structure.sage_object.SageObject" title="(in Sage Reference Manual: Parents and Elements v8.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.sage_object.SageObject</span></code></a></p>
<p>A class for pointwise inverse functions.</p>
<p>The pointwise inverse function of a function <span class="math notranslate nohighlight">\(f\)</span> is the function
sending every <span class="math notranslate nohighlight">\(x\)</span> to <span class="math notranslate nohighlight">\(1 / f(x)\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.modules.with_basis.morphism</span> <span class="kn">import</span> <span class="n">PointwiseInverseFunction</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">PointwiseInverseFunction</span><span class="p">(</span><span class="n">factorial</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">(1, 1, 1/2, 1/6)</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.modules.with_basis.morphism.PointwiseInverseFunction.pointwise_inverse">
<code class="descname">pointwise_inverse</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.modules.with_basis.morphism.PointwiseInverseFunction.pointwise_inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.modules.with_basis.morphism.TriangularModuleMorphism">
<em class="property">class </em><code class="descclassname">sage.modules.with_basis.morphism.</code><code class="descname">TriangularModuleMorphism</code><span class="sig-paren">(</span><em>triangular='upper'</em>, <em>unitriangular=False</em>, <em>key=None</em>, <em>inverse=None</em>, <em>inverse_on_support=&lt;built-in function identity&gt;</em>, <em>invertible=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphism" title="sage.modules.with_basis.morphism.ModuleMorphism"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.modules.with_basis.morphism.ModuleMorphism</span></code></a></p>
<p>An abstract class for triangular module morphisms</p>
<p>Let <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> be modules over the same base ring, with
distinguished bases <span class="math notranslate nohighlight">\(F\)</span> indexed by <span class="math notranslate nohighlight">\(I\)</span> and <span class="math notranslate nohighlight">\(G\)</span> indexed by <span class="math notranslate nohighlight">\(J\)</span>,
respectively.</p>
<p>A module morphism <span class="math notranslate nohighlight">\(\phi\)</span> from <span class="math notranslate nohighlight">\(X\)</span> to <span class="math notranslate nohighlight">\(Y\)</span> is <em>triangular</em> if its
representing matrix in the distinguished bases of <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> is
upper triangular (echelon form).</p>
<p>More precisely, <span class="math notranslate nohighlight">\(\phi\)</span> is <em>upper triangular</em> w.r.t. a total order
<span class="math notranslate nohighlight">\(&lt;\)</span> on <span class="math notranslate nohighlight">\(J\)</span> if, for any <span class="math notranslate nohighlight">\(j\in J\)</span>, there exists at most one index
<span class="math notranslate nohighlight">\(i\in I\)</span> such that the leading support of <span class="math notranslate nohighlight">\(\phi(F_i)\)</span> is <span class="math notranslate nohighlight">\(j\)</span> (see
<code class="xref py py-meth docutils literal notranslate"><span class="pre">leading_support()</span></code>). We denote by <span class="math notranslate nohighlight">\(r(j)\)</span> this index,
setting <span class="math notranslate nohighlight">\(r(j)\)</span> to <code class="docutils literal notranslate"><span class="pre">None</span></code> if it does not exist.</p>
<p><em>Lower triangular</em> morphisms are defined similarly, taking the
trailing support instead (see <code class="xref py py-meth docutils literal notranslate"><span class="pre">trailing_support()</span></code>).</p>
<p>A triangular morphism is <em>unitriangular</em> if all its pivots
(i.e. coefficient of <span class="math notranslate nohighlight">\(j\)</span> in each <span class="math notranslate nohighlight">\(\phi(F[r(j)])\)</span>) are <span class="math notranslate nohighlight">\(1\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">domain</span></code> – a module with basis <span class="math notranslate nohighlight">\(X\)</span></li>
<li><code class="docutils literal notranslate"><span class="pre">codomain</span></code> – a module with basis <span class="math notranslate nohighlight">\(Y\)</span> (default: <span class="math notranslate nohighlight">\(X\)</span>)</li>
<li><code class="docutils literal notranslate"><span class="pre">category</span></code> – a category, as for <a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphism" title="sage.modules.with_basis.morphism.ModuleMorphism"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleMorphism</span></code></a></li>
<li><code class="docutils literal notranslate"><span class="pre">triangular</span></code> – <code class="docutils literal notranslate"><span class="pre">&quot;upper&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;lower&quot;</span></code> (default: <code class="docutils literal notranslate"><span class="pre">&quot;upper&quot;</span></code>)</li>
<li><code class="docutils literal notranslate"><span class="pre">unitriangular</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)
As a shorthand, one may use <code class="docutils literal notranslate"><span class="pre">unitriangular=&quot;lower&quot;</span></code>
for <code class="docutils literal notranslate"><span class="pre">triangular=&quot;lower&quot;,</span> <span class="pre">unitriangular=True</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">key</span></code> – a comparison key on <span class="math notranslate nohighlight">\(J\)</span>
(default: the usual comparison of elements of <span class="math notranslate nohighlight">\(J\)</span>)</li>
<li><code class="docutils literal notranslate"><span class="pre">inverse_on_support</span></code> – a function <span class="math notranslate nohighlight">\(J \to I\cup \{None\}\)</span>
implementing <span class="math notranslate nohighlight">\(r\)</span> (default: the identity function).
If set to “compute”, the values of <span class="math notranslate nohighlight">\(r(j)\)</span> are precomputed by
running through the index set <span class="math notranslate nohighlight">\(I\)</span> of the basis of the
domain. This of course requires the domain to be finite
dimensional.</li>
<li><code class="docutils literal notranslate"><span class="pre">invertible</span></code> – a boolean or <code class="docutils literal notranslate"><span class="pre">None</span></code> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); can
be set to specify that <span class="math notranslate nohighlight">\(\phi\)</span> is known to be (or not to be)
invertible. If the domain and codomain share the same indexing
set, this is by default automatically set to <code class="docutils literal notranslate"><span class="pre">True</span></code> if
<code class="docutils literal notranslate"><span class="pre">inverse_on_support</span></code> is the identity, or in the finite
dimensional case.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="../../../../categories/sage/categories/modules_with_basis.html#sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.module_morphism" title="(in Sage Reference Manual: Category Framework v8.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ModulesWithBasis.ParentMethods.module_morphism()</span></code></a> for
usage information and examples;</li>
<li><a class="reference internal" href="#module-sage.modules.with_basis.morphism" title="sage.modules.with_basis.morphism"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.modules.with_basis.morphism</span></code></a> for a technical
overview of the classes for module morphisms;</li>
<li><a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphismFromFunction" title="sage.modules.with_basis.morphism.ModuleMorphismFromFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleMorphismFromFunction</span></code></a> and
<a class="reference internal" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism" title="sage.modules.with_basis.morphism.TriangularModuleMorphism"><code class="xref py py-class docutils literal notranslate"><span class="pre">TriangularModuleMorphism</span></code></a>.</li>
</ul>
</div>
<p>OUTPUT:</p>
<p>A morphism from <span class="math notranslate nohighlight">\(X\)</span> to <span class="math notranslate nohighlight">\(Y\)</span>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This class is meant to be used as a complement for a concrete
morphism class.  In particular, the <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> method
focuses on setting up the data structure describing the
triangularity of the morphism. It purposely does <em>not</em> call
<code class="xref py py-meth docutils literal notranslate"><span class="pre">ModuleMorphism.__init__()</span></code> which should be called
(directly or indirectly) beforehand.</p>
</div>
<p>EXAMPLES:</p>
<p>We construct and invert an upper unitriangular module morphism between
two free <span class="math notranslate nohighlight">\(\QQ\)</span>-modules:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">200</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="n">I</span><span class="p">);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="n">I</span><span class="p">);</span> <span class="n">Y</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ut</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">sum_of_monomials</span> <span class="o">*</span> <span class="n">divisors</span>   <span class="c1"># This * is map composition.</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">ut</span><span class="p">,</span> <span class="n">unitriangular</span><span class="o">=</span><span class="s2">&quot;upper&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">B[1] + B[2]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>
<span class="go">B[1] + B[2] + B[3] + B[6]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">30</span><span class="p">])</span>
<span class="go">B[1] + B[2] + B[3] + B[5] + B[6] + B[10] + B[15] + B[30]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">-B[1] + B[2]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>
<span class="go">B[1] - B[2] - B[3] + B[6]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">30</span><span class="p">])</span>
<span class="go">-B[1] + B[2] + B[3] + B[5] - B[6] - B[10] - B[15] + B[30]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">phi</span><span class="o">^-</span><span class="mi">1</span><span class="p">)(</span><span class="n">y</span><span class="p">[</span><span class="mi">30</span><span class="p">])</span>
<span class="go">-B[1] + B[2] + B[3] + B[5] - B[6] - B[10] - B[15] + B[30]</span>
</pre></div>
</div>
<p>A lower triangular (but not unitriangular) morphism:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">lt</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">lt</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">2*B[2] + 3*B[3]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">1/2*B[2] - 1/2*B[3]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">B[2]</span>
</pre></div>
</div>
<p>Using the <code class="docutils literal notranslate"><span class="pre">key</span></code> keyword, we can use triangularity even if
the map becomes triangular only after a permutation of the basis:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">ut</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">else</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">perm</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">ut</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s2">&quot;upper&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">X</span><span class="p">,</span>
<span class="go">....:                         key=lambda a: perm[a])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[B[1] + B[2], B[2], B[2] + B[3]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[B[1] - B[2], B[2], -B[2] + B[3]]</span>
</pre></div>
</div>
<p>The same works in the lower-triangular case:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">lt</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">lt</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">X</span><span class="p">,</span>
<span class="go">....:                         key=lambda a: perm[a])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[B[1], B[1] + B[2] + B[3], B[3]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[B[1], -B[1] + B[2] - B[3], B[3]]</span>
</pre></div>
</div>
<p>An injective but not surjective morphism cannot be inverted,
but the <code class="docutils literal notranslate"><span class="pre">inverse_on_support</span></code> keyword allows Sage to find a
partial inverse:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ult</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span>  <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>  <span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">ult</span><span class="p">,</span> <span class="n">unitriangular</span><span class="o">=</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span>
<span class="go">....:        inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">B[3] + B[4] + B[5]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">B[2] - B[3]</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">inverse_on_support</span></code> keyword can also be used if the
bases of the domain and the codomain are identical but one of
them has to be permuted in order to render the morphism
triangular. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">ut</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="go">....:     return (x[3] if i == 1 else x[1] if i == 2</span>
<span class="go">....:             else x[1] + x[2])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">perm</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="go">....:     return (2 if i == 1 else 3 if i == 2 else 1)</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">ut</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s2">&quot;upper&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">X</span><span class="p">,</span>
<span class="go">....:                         inverse_on_support=perm)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[B[3], B[1], B[1] + B[2]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[B[2], -B[2] + B[3], B[1]]</span>
</pre></div>
</div>
<p>The same works if the permutation induces lower triangularity:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">lt</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="go">....:     return (x[3] if i == 1 else x[2] if i == 2</span>
<span class="go">....:             else x[1] + x[2])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">perm</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="go">....:     return 4 - i</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">lt</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">X</span><span class="p">,</span>
<span class="go">....:                         inverse_on_support=perm)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[B[3], B[2], B[1] + B[2]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[-B[2] + B[3], B[2], B[1]]</span>
</pre></div>
</div>
<p>In the finite dimensional case, one can ask Sage to recover
<code class="docutils literal notranslate"><span class="pre">inverse_on_support</span></code> by a precomputation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ut</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span>  <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">ut</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s2">&quot;upper&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span>
<span class="go">....:                         inverse_on_support=&quot;compute&quot;)</span>
<span class="gp">sage: </span><span class="n">tx</span> <span class="o">=</span> <span class="s2">&quot;{} {} {}&quot;</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
<span class="go">....:     i = phi._inverse_on_support(j)</span>
<span class="go">....:     print(tx.format(j, i, phi(x[i]) if i is not None else None))</span>
<span class="go">1 None None</span>
<span class="go">2 1 B[1] + B[2]</span>
<span class="go">3 2 B[1] + B[2] + B[3]</span>
<span class="go">4 3 B[1] + B[2] + B[3] + B[4]</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">inverse_on_basis</span></code> and <code class="docutils literal notranslate"><span class="pre">key</span></code> keywords can be combined:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">ut</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="go">....:     return (2*x[2] + 3*x[3] if i == 1</span>
<span class="go">....:             else x[1] + x[2] + x[3] if i == 2</span>
<span class="go">....:             else 4*x[2])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">perm</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="go">....:     return (2 if i == 1 else 3 if i == 2 else 1)</span>
<span class="gp">sage: </span><span class="n">perverse_key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">ut</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s2">&quot;upper&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">X</span><span class="p">,</span>
<span class="go">....:                         inverse_on_support=perm, key=perverse_key)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[2*B[2] + 3*B[3], B[1] + B[2] + B[3], 4*B[2]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[-1/3*B[1] + B[2] - 1/12*B[3], 1/4*B[3], 1/3*B[1] - 1/6*B[3]]</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.modules.with_basis.morphism.TriangularModuleMorphism.co_kernel_projection">
<code class="descname">co_kernel_projection</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism.co_kernel_projection" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use <a class="reference internal" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism.cokernel_projection" title="sage.modules.with_basis.morphism.TriangularModuleMorphism.cokernel_projection"><code class="xref py py-func docutils literal notranslate"><span class="pre">cokernel_projection()</span></code></a> instead.
See <a class="reference external" href="https://trac.sagemath.org/8678">trac ticket #8678</a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.modules.with_basis.morphism.TriangularModuleMorphism.co_reduced">
<code class="descname">co_reduced</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism.co_reduced" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use <a class="reference internal" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism.coreduced" title="sage.modules.with_basis.morphism.TriangularModuleMorphism.coreduced"><code class="xref py py-func docutils literal notranslate"><span class="pre">coreduced()</span></code></a> instead.
See <a class="reference external" href="https://trac.sagemath.org/8678">trac ticket #8678</a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.modules.with_basis.morphism.TriangularModuleMorphism.cokernel_basis_indices">
<code class="descname">cokernel_basis_indices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism.cokernel_basis_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of the natural monomial basis of the cokernel of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">self</span></code> – a triangular morphism over a field or a
unitriangular morphism over a ring, with a finite
dimensional codomain.</li>
</ul>
<p>OUTPUT:</p>
<p>A list <span class="math notranslate nohighlight">\(E\)</span> of indices of the basis <span class="math notranslate nohighlight">\((B_e)_e\)</span> of the codomain
of <code class="docutils literal notranslate"><span class="pre">self</span></code> so that <span class="math notranslate nohighlight">\((B_e)_{e\in E}\)</span> forms a basis of a
supplementary of the image set of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Thinking of this triangular morphism as a row echelon matrix,
this returns the complementary of the characteristic
columns. Namely <span class="math notranslate nohighlight">\(E\)</span> is the set of indices which do not appear
as leading support of some element of the image set of
<code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">uut</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span>  <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>  <span class="p">)</span> <span class="c1"># uni-upper</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">uut</span><span class="p">,</span> <span class="n">unitriangular</span><span class="o">=</span><span class="s2">&quot;upper&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span>
<span class="go">....:       inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">cokernel_basis_indices</span><span class="p">()</span>
<span class="go">[1, 5]</span>

<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">uut</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s2">&quot;upper&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span>
<span class="go">....:       inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">cokernel_basis_indices</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">cokernel_basis_indices for a triangular but not unitriangular morphism over a ring</span>

<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="n">NN</span><span class="p">);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">uut</span><span class="p">,</span> <span class="n">unitriangular</span><span class="o">=</span><span class="s2">&quot;upper&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span>
<span class="go">....:       inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">cokernel_basis_indices</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">cokernel_basis_indices implemented only for morphisms with a finite dimensional codomain</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.modules.with_basis.morphism.TriangularModuleMorphism.cokernel_projection">
<code class="descname">cokernel_projection</code><span class="sig-paren">(</span><em>category=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism.cokernel_projection" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a projection on the co-kernel of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">category</span></code> – the category of the result</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">lt</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span>  <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>  <span class="p">)</span> <span class="c1"># lower</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">lt</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span>
<span class="go">....:      inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)</span>
<span class="gp">sage: </span><span class="n">phipro</span> <span class="o">=</span> <span class="n">phi</span><span class="o">.</span><span class="n">cokernel_projection</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">phipro</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">B[1]</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">phipro</span><span class="p">(</span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">phipro</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">B[1]</span>
<span class="gp">sage: </span><span class="n">phipro</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="go">-B[5]</span>
<span class="gp">sage: </span><span class="n">phipro</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
<span class="go">B[5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.modules.with_basis.morphism.TriangularModuleMorphism.coreduced">
<code class="descname">coreduced</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism.coreduced" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <span class="math notranslate nohighlight">\(y\)</span> reduced w.r.t. the image of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">self</span></code> – a triangular morphism over a field, or a
unitriangular morphism over a ring</li>
<li><code class="docutils literal notranslate"><span class="pre">y</span></code> – an element of the codomain of <code class="docutils literal notranslate"><span class="pre">self</span></code></li>
</ul>
<p>Suppose that <code class="docutils literal notranslate"><span class="pre">self</span></code> is a morphism from <span class="math notranslate nohighlight">\(X\)</span> to <span class="math notranslate nohighlight">\(Y\)</span>. Then, for
any <span class="math notranslate nohighlight">\(y \in Y\)</span>, the call <code class="docutils literal notranslate"><span class="pre">self.coreduced(y)</span></code> returns a
normal form for <span class="math notranslate nohighlight">\(y\)</span> in the quotient <span class="math notranslate nohighlight">\(Y / I\)</span> where <span class="math notranslate nohighlight">\(I\)</span> is the
image of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ult</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span>  <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>  <span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">ult</span><span class="p">,</span> <span class="n">unitriangular</span><span class="o">=</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span>
<span class="go">....:        inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()]</span>
<span class="go">[B[2] + B[3] + B[4] + B[5],</span>
<span class="go">        B[3] + B[4] + B[5],</span>
<span class="go">               B[4] + B[5]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">coreduced</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="mi">4</span><span class="p">])]</span>
<span class="go">[B[1] + 2*B[5]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">coreduced</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">y</span><span class="p">]</span>
<span class="go">[B[1], 0, 0, -B[5], B[5]]</span>
</pre></div>
</div>
<p>Now with a non unitriangular morphism:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">lt</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span> <span class="n">j</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>  <span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">lt</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span>
<span class="go">....:       inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()]</span>
<span class="go">[2*B[2] + 3*B[3] + 4*B[4] + 5*B[5],</span>
<span class="go">          3*B[3] + 4*B[4] + 5*B[5],</span>
<span class="go">                   4*B[4] + 5*B[5]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">coreduced</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="mi">4</span><span class="p">])]</span>
<span class="go">[B[1] + 5/2*B[5]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">coreduced</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">y</span><span class="p">]</span>
<span class="go">[B[1], 0, 0, -5/4*B[5], B[5]]</span>
</pre></div>
</div>
<p>For general rings, this method is only implemented for
unitriangular morphisms:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">ult</span><span class="p">,</span> <span class="n">unitriangular</span><span class="o">=</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span>
<span class="go">....:       inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">coreduced</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="mi">4</span><span class="p">])]</span>
<span class="go">[B[1] + 2*B[5]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">coreduced</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">y</span><span class="p">]</span>
<span class="go">[B[1], 0, 0, -B[5], B[5]]</span>

<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">lt</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span>
<span class="go">....:       inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">coreduced</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">y</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">coreduce for a triangular but not unitriangular morphism over a ring</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Before <a class="reference external" href="https://trac.sagemath.org/8678">trac ticket #8678</a> this method used to be called co_reduced.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.modules.with_basis.morphism.TriangularModuleMorphism.preimage">
<code class="descname">preimage</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism.preimage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the preimage of <span class="math notranslate nohighlight">\(f\)</span> under <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ult</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span>  <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>  <span class="p">)</span> <span class="c1"># uni-lower</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">ult</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">B[1] - B[3]</span>
</pre></div>
</div>
<p>The morphism need not be surjective. In the following example,
the codomain is of larger dimension than the domain:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">lt</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span>  <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>  <span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">lt</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">B[1] - B[3]</span>
</pre></div>
</div>
<p>Here are examples using <code class="docutils literal notranslate"><span class="pre">inverse_on_support</span></code> to handle a
morphism that shifts the leading indices by <span class="math notranslate nohighlight">\(1\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">lt</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span>  <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>  <span class="p">)</span> <span class="c1"># lower</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">lt</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span>
<span class="go">....:         inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">B[2] + B[3] + B[4] + B[5]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">B[4] + B[5]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">B[1] - B[3]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">el</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">phi</span><span class="p">(</span><span class="n">el</span><span class="p">))</span> <span class="o">==</span> <span class="n">el</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">B[1] is not in the image</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">B[4] is not in the image</span>
</pre></div>
</div>
<p>Over a base ring like <span class="math notranslate nohighlight">\(\ZZ\)</span>, the morphism need not be
surjective even when the dimensions match:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">lt</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span> <span class="mi">2</span><span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>  <span class="p">)</span> <span class="c1"># lower</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">lt</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">B[1] - B[3]</span>
</pre></div>
</div>
<p>The error message in case of failure could be more specific though:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">no conversion of this rational to integer</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.modules.with_basis.morphism.TriangularModuleMorphism.section">
<code class="descname">section</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism.section" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the section (partial inverse) of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Return a partial triangular morphism which is a section of
<code class="docutils literal notranslate"><span class="pre">self</span></code>. The section morphism raise a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> if asked to
apply on an element which is not in the image of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ult</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span>  <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>  <span class="p">)</span> <span class="c1"># uni-lower</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">ult</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span>
<span class="go">....:      inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)</span>
<span class="gp">sage: </span><span class="o">~</span><span class="n">phi</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Morphism not known to be invertible;</span>
<span class="go">see the invertible option of module_morphism</span>
<span class="gp">sage: </span><span class="n">phiinv</span> <span class="o">=</span> <span class="n">phi</span><span class="o">.</span><span class="n">section</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">phiinv</span><span class="o">*</span><span class="n">phi</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span><span class="o">.</span><span class="n">list</span><span class="p">()))</span> <span class="o">==</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">phiinv</span><span class="p">(</span><span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">B[1] is not in the image</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.modules.with_basis.morphism.TriangularModuleMorphismByLinearity">
<em class="property">class </em><code class="descclassname">sage.modules.with_basis.morphism.</code><code class="descname">TriangularModuleMorphismByLinearity</code><span class="sig-paren">(</span><em>domain</em>, <em>on_basis</em>, <em>codomain=None</em>, <em>category=None</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.modules.with_basis.morphism.TriangularModuleMorphismByLinearity" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphismByLinearity" title="sage.modules.with_basis.morphism.ModuleMorphismByLinearity"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.modules.with_basis.morphism.ModuleMorphismByLinearity</span></code></a>, <a class="reference internal" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism" title="sage.modules.with_basis.morphism.TriangularModuleMorphism"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.modules.with_basis.morphism.TriangularModuleMorphism</span></code></a></p>
<p>A concrete class for triangular module morphisms obtained by extending a function by linearity.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="../../../../categories/sage/categories/modules_with_basis.html#sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.module_morphism" title="(in Sage Reference Manual: Category Framework v8.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ModulesWithBasis.ParentMethods.module_morphism()</span></code></a> for
usage information and examples;</li>
<li><a class="reference internal" href="#module-sage.modules.with_basis.morphism" title="sage.modules.with_basis.morphism"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.modules.with_basis.morphism</span></code></a> for a technical
overview of the classes for module morphisms;</li>
<li><a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphismByLinearity" title="sage.modules.with_basis.morphism.ModuleMorphismByLinearity"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleMorphismByLinearity</span></code></a> and
<a class="reference internal" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism" title="sage.modules.with_basis.morphism.TriangularModuleMorphism"><code class="xref py py-class docutils literal notranslate"><span class="pre">TriangularModuleMorphism</span></code></a>.</li>
</ul>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.modules.with_basis.morphism.TriangularModuleMorphismFromFunction">
<em class="property">class </em><code class="descclassname">sage.modules.with_basis.morphism.</code><code class="descname">TriangularModuleMorphismFromFunction</code><span class="sig-paren">(</span><em>domain</em>, <em>function</em>, <em>codomain=None</em>, <em>category=None</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.modules.with_basis.morphism.TriangularModuleMorphismFromFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphismFromFunction" title="sage.modules.with_basis.morphism.ModuleMorphismFromFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.modules.with_basis.morphism.ModuleMorphismFromFunction</span></code></a>, <a class="reference internal" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism" title="sage.modules.with_basis.morphism.TriangularModuleMorphism"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.modules.with_basis.morphism.TriangularModuleMorphism</span></code></a></p>
<p>A concrete class for triangular module morphisms implemented by a function.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="../../../../categories/sage/categories/modules_with_basis.html#sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.module_morphism" title="(in Sage Reference Manual: Category Framework v8.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ModulesWithBasis.ParentMethods.module_morphism()</span></code></a> for
usage information and examples;</li>
<li><a class="reference internal" href="#module-sage.modules.with_basis.morphism" title="sage.modules.with_basis.morphism"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.modules.with_basis.morphism</span></code></a> for a technical
overview of the classes for module morphisms;</li>
<li><a class="reference internal" href="#sage.modules.with_basis.morphism.ModuleMorphismFromFunction" title="sage.modules.with_basis.morphism.ModuleMorphismFromFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleMorphismFromFunction</span></code></a> and
<a class="reference internal" href="#sage.modules.with_basis.morphism.TriangularModuleMorphism" title="sage.modules.with_basis.morphism.TriangularModuleMorphism"><code class="xref py py-class docutils literal notranslate"><span class="pre">TriangularModuleMorphism</span></code></a>.</li>
</ul>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.modules.with_basis.morphism.pointwise_inverse_function">
<code class="descclassname">sage.modules.with_basis.morphism.</code><code class="descname">pointwise_inverse_function</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.modules.with_basis.morphism.pointwise_inverse_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the function <span class="math notranslate nohighlight">\(x \mapsto 1 / f(x)\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code> – a function</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.modules.with_basis.morphism</span> <span class="kn">import</span> <span class="n">pointwise_inverse_function</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">pointwise_inverse_function</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">g</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">g</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">(1, 1/2, 1/3)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#sage.modules.with_basis.morphism.pointwise_inverse_function" title="sage.modules.with_basis.morphism.pointwise_inverse_function"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointwise_inverse_function()</span></code></a> is an involution:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="ow">is</span> <span class="n">pointwise_inverse_function</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-2">
<p class="first admonition-title">Todo</p>
<p class="last">This has nothing to do here!!! Should there be a library for
pointwise operations on functions somewhere in Sage?</p>
</div>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="cell_module.html"
                        title="previous chapter">Cell Modules</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="subquotient.html"
                        title="next chapter">Quotients of Modules With Basis</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/sage/modules/with_basis/morphism.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="subquotient.html" title="Quotients of Modules With Basis"
             >next</a> |</li>
        <li class="right" >
          <a href="cell_module.html" title="Cell Modules"
             >previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../../index.html">Modules</a> &#187;</li>
 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2019, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.6.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>