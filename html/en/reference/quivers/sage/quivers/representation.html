<!doctype html>
<html class="no-js">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" /><link rel="prev" title="Quiver Paths" href="paths.html" />

    <meta name="generator" content="sphinx-4.4.0, furo 2022.06.21"/>
        <title>Quiver Representations - Quivers</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?digest=40978830699223671f4072448e654b5958f38b89" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom-furo.css" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  --color-brand-primary: #0f0fff;
  --color-brand-content: #0f0fff;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZGD13B5572"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ZGD13B5572');
</script></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">Quivers</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><div class="sidebar-scroll"><a class="sidebar-brand" href="../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../../_static/logo_sagemath_black.svg" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../../_static/logo_sagemath_white.svg" alt="Dark Logo"/>
  </div>
  
      <span class="sidebar-brand-text">Sage 9.7 Reference Manual</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-home">
  <div class="sidebar-tree">
    <ul><li class="toctree-l1">
      <a class="reference internal" href="../../index.html">Home - Quivers</a>
    </li></ul>
  </div>
</div><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="algebra.html">Path Algebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="algebra_elements.html">Path algebra elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="homspace.html">Quiver Homspace</a></li>
<li class="toctree-l1"><a class="reference internal" href="morphism.html">Quiver Morphisms</a></li>
<li class="toctree-l1"><a class="reference internal" href="path_semigroup.html">Path Semigroups</a></li>
<li class="toctree-l1"><a class="reference internal" href="paths.html">Quiver Paths</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Quiver Representations</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="quiver-representations">
<span id="sage-quivers-representation"></span><h1>Quiver Representations<a class="headerlink" href="#quiver-representations" title="Permalink to this headline">#</a></h1>
<span class="target" id="module-sage.quivers.representation"></span><p>AUTHORS:</p>
<ul class="simple">
<li><p>Jim Stark (2012-03-04): Initial implementation of acyclic quivers without
relations.</p></li>
<li><p>Simon King (2013-05, 2014-02): Split code up. Allow cyclic quivers where
possible.</p></li>
</ul>
<p>A quiver is a directed graph used for representation theory. In our
representation theoretic code, it is assumed that</p>
<ul class="simple">
<li><p>the vertices of the quiver are labelled by integers, and</p></li>
<li><p>each edge of the quiver is labelled with a nonempty string.  The label
cannot begin with <code class="docutils literal notranslate"><span class="pre">'e_'</span></code> or contain <code class="docutils literal notranslate"><span class="pre">'*'</span></code> and distinct edges must have
distinct labels.</p></li>
</ul>
<p>As far as the <a class="reference external" href="../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Graph Theory v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraph</span></code></a> class is concerned, a
path is a finite list of pairwise distinct vertices <span class="math notranslate nohighlight">\(v_1, ..., v_n\)</span> such
that there exists an edge from <span class="math notranslate nohighlight">\(v_i\)</span> to <span class="math notranslate nohighlight">\(v_{i + 1}\)</span>.  If there are
multiple edges between the same two vertices this does not contribute
additional paths as listed by the <a class="reference external" href="../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Graph Theory v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraph</span></code></a>
class; for example only two paths are listed from 1 to 3 in <code class="docutils literal notranslate"><span class="pre">Q</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;d&#39;</span><span class="p">]}})</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(1, 2, &#39;a&#39;), (1, 2, &#39;b&#39;), (1, 3, &#39;c&#39;), (2, 3, &#39;d&#39;)]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">all_paths</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[[1, 2, 3], [1, 3]]</span>
</pre></div>
</div>
<p>The notion of a path in a quiver (in representation theory) is
fundamentally different in several aspects. First, paths are no longer
required to have distinct vertices, or even distinct edges; thus, “path”
in quiver theory is closer to the notion of “walk” in graph theory.
Furthermore, paths in quiver theory “know” their edges, so parallel edges
between the same two vertices of a Quiver make different paths. But
paths in quiver theory also “know” their vertices, so that a length-<span class="math notranslate nohighlight">\(0\)</span>
path from <span class="math notranslate nohighlight">\(a\)</span> to <span class="math notranslate nohighlight">\(a\)</span> is not the same as a length-<span class="math notranslate nohighlight">\(0\)</span> path from <span class="math notranslate nohighlight">\(b\)</span> to <span class="math notranslate nohighlight">\(b\)</span>
for <span class="math notranslate nohighlight">\(a \neq b\)</span>.
Formally, we say that a path is given by two vertices, <code class="docutils literal notranslate"><span class="pre">start</span></code> and
<code class="docutils literal notranslate"><span class="pre">end</span></code>, and a finite (possibly empty) list of edges <span class="math notranslate nohighlight">\(e_1, e_2, \ldots, e_n\)</span>
such that the initial vertex of <span class="math notranslate nohighlight">\(e_1\)</span> is <code class="docutils literal notranslate"><span class="pre">start</span></code>, the final vertex of <span class="math notranslate nohighlight">\(e_i\)</span>
is the initial vertex of <span class="math notranslate nohighlight">\(e_{i + 1}\)</span>, and the final vertex of <span class="math notranslate nohighlight">\(e_n\)</span> is
<code class="docutils literal notranslate"><span class="pre">end</span></code>.  In the case where no edges are specified, we must have
<code class="docutils literal notranslate"><span class="pre">start</span> <span class="pre">=</span> <span class="pre">end</span></code> and the path is called the trivial path at the given vertex.</p>
<p>Quiver paths in the sense stated above correspond to the elements of a
partial semigroup, with multiplication of paths given by concatenation. Hence,
rather than overloading the method name inherited from
<a class="reference external" href="../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Graph Theory v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraph</span></code></a> or inventing a
new method name, we move this functionality to this so-called <em>path
semigroup</em>.  Note that with this definition there are three paths from 1 to 3
in our example:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span><span class="o">.</span><span class="n">all_paths</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[a*d, b*d, c]</span>
</pre></div>
</div>
<p>The returned paths are of type <a class="reference internal" href="paths.html#sage.quivers.paths.QuiverPath" title="sage.quivers.paths.QuiverPath"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverPath</span></code></a>, which
are elements in the path semigroup that is associated with the quiver (a
partial semigroup, which does not generally have a neutral element). You can
specify a <a class="reference internal" href="paths.html#sage.quivers.paths.QuiverPath" title="sage.quivers.paths.QuiverPath"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverPath</span></code></a> by giving an edge or a
list of edges, passed as arguments to the path semigroup containing this path.
Here an edge is a tuple of the form <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">j,</span> <span class="pre">l)</span></code>, where <code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code>
are vertices and <code class="docutils literal notranslate"><span class="pre">l</span></code> is the label of an edge from i to j:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">p</span>
<span class="go">a*d</span>
</pre></div>
</div>
<p>Trivial paths are indicated by passing a list containing the tuple <code class="docutils literal notranslate"><span class="pre">(vertex,</span> <span class="pre">vertex)</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()([(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="go">e_3</span>
</pre></div>
</div>
<p>Here is an alternative way to define a path:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">PQ</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">q</span> <span class="o">=</span> <span class="n">PQ</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">==</span> <span class="n">q</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If the vertices along the path do not match, a value error is raised:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">inv1</span> <span class="o">=</span> <span class="n">PQ</span><span class="p">([(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: edge d ends at 3, but edge a starts at 1</span>
<span class="gp">sage: </span><span class="n">inv2</span> <span class="o">=</span> <span class="n">PQ</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: edge a ends at 2, but edge a starts at 1</span>
<span class="gp">sage: </span><span class="n">inv3</span> <span class="o">=</span> <span class="n">PQ</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: (1, 2, &#39;x&#39;) is not an edge</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">*</span></code> operator is concatenation of paths. If the two paths do not compose,
then the result is <code class="docutils literal notranslate"><span class="pre">None</span></code> (whence the “partial” in “partial semigroup”).</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="go">None</span>
</pre></div>
</div>
<p>Let us now construct a larger quiver:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Qbig</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;d&#39;</span><span class="p">]},</span> <span class="mi">3</span><span class="p">:{</span><span class="mi">4</span><span class="p">:[</span><span class="s1">&#39;e&#39;</span><span class="p">]},</span> <span class="mi">4</span><span class="p">:{</span><span class="mi">5</span><span class="p">:[</span><span class="s1">&#39;f&#39;</span><span class="p">]},</span> <span class="mi">5</span><span class="p">:{</span><span class="mi">1</span><span class="p">:[</span><span class="s1">&#39;g&#39;</span><span class="p">]}</span> <span class="p">})</span>
<span class="gp">sage: </span><span class="n">Pbig</span> <span class="o">=</span> <span class="n">Qbig</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
</pre></div>
</div>
<p>Since <code class="docutils literal notranslate"><span class="pre">Q</span></code> is a sub-digraph of <code class="docutils literal notranslate"><span class="pre">Qbig</span></code>, we have a coercion of the associated
path semigroups:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Pbig</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">PQ</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In particular, <code class="docutils literal notranslate"><span class="pre">p</span></code> is considered to be an element of <code class="docutils literal notranslate"><span class="pre">Pbig</span></code>, and can be
composed with paths that were defined for the larger quiver:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="ow">in</span> <span class="n">Pbig</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">*</span><span class="n">Pbig</span><span class="p">([(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">)])</span>
<span class="go">a*d*e</span>
<span class="gp">sage: </span><span class="n">Pbig</span><span class="p">([(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">)])</span><span class="o">*</span><span class="n">p</span>
<span class="go">f*g*a*d</span>
</pre></div>
</div>
<p>The length of a path is the number of edges in that path:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">triv</span> <span class="o">=</span> <span class="n">PQ</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">triv</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>List index and slice notation can be used to access the edges in a path.
QuiverPaths can also be iterated over.  Trivial paths have no elements:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(1, 2, &#39;a&#39;)</span>
<span class="go">(2, 3, &#39;d&#39;)</span>
<span class="gp">sage: </span><span class="n">triv</span><span class="p">[:]</span>
<span class="go">e_1</span>
</pre></div>
</div>
<p>There are methods giving the initial and terminal vertex of a path:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">initial_vertex</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">terminal_vertex</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p><a class="reference internal" href="paths.html#sage.quivers.paths.QuiverPath" title="sage.quivers.paths.QuiverPath"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverPath</span></code></a> form the basis of the quiver
algebra of a quiver.  Given a field <span class="math notranslate nohighlight">\(k\)</span> and a quiver <span class="math notranslate nohighlight">\(Q\)</span>, the quiver
algebra <span class="math notranslate nohighlight">\(kQ\)</span> is, as a vector space, the free <span class="math notranslate nohighlight">\(k\)</span>-vector space whose basis
is the set of all paths in <span class="math notranslate nohighlight">\(Q\)</span>. Multiplication is defined on this basis
and extended bilinearly.  The product of two basis elements is given by
path composition when it makes sense and is set to be zero otherwise.
Specifically, if the terminal vertex of the left path equals the initial
vertex of the right path, then their product is the concatenation of the
two paths, and otherwise their product is zero. In sage, quiver algebras
are handled by the <code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverAlgebra</span></code> class:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">PQ</span><span class="o">.</span><span class="n">algebra</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">A</span>
<span class="go">Path algebra of Multi-digraph on 3 vertices over Finite Field of size 7</span>
</pre></div>
</div>
<p>Quivers have a method that creates their algebra over a given field (or,
more generally, commutative ring).  Note that
<code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverAlgebras</span></code> are uniquely defined by
their quiver and field, and play nicely with coercions of the underlying
path semigroups:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="ow">is</span> <span class="n">PQ</span><span class="o">.</span><span class="n">algebra</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="ow">is</span> <span class="n">PQ</span><span class="o">.</span><span class="n">algebra</span><span class="p">(</span><span class="n">RR</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q1</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q1</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">PQ1</span> <span class="o">=</span> <span class="n">Q1</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="ow">is</span> <span class="n">PQ1</span><span class="o">.</span><span class="n">algebra</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Pbig</span><span class="o">.</span><span class="n">algebra</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverAlgebra</span></code> can create elements
from <code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverPaths</span></code> or from elements of the
base ring:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">5*e_1 + 5*e_2 + 5*e_3</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="n">PQ</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">e2</span> <span class="o">=</span> <span class="n">PQ</span><span class="p">([(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="n">A</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span>
<span class="go">a*d + e_2</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="n">A</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">y</span>
<span class="go">b*d + a*d</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverAlgebras</span></code> are <span class="math notranslate nohighlight">\(\NN\)</span>-graded algebras.
The grading is given by assigning to each basis element the length of the
path corresponding to that basis element:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">is_homogeneous</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: element is not homogeneous</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">is_homogeneous</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">Free module spanned by [a, b, c, d] over Finite Field of size 7</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">Free module spanned by [a*d, b*d] over Finite Field of size 7</span>
</pre></div>
</div>
<p>The category of right modules over a given quiver algebra is equivalent to the
category of representations of that quiver.  A quiver representation is a
diagram in the category of vector spaces whose underlying graph is the quiver.
So to each vertex of the quiver we assign a vector space and to each edge of
the quiver a linear map between the vector spaces assigned to the start and end
vertices of that edge.  To create the zero representation we just specify the
base ring and the path semigroup:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">Q1</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>To each vertex of a quiver there is associated a simple module, an
indecomposable projective, and an indecomposable injective, and these can
be created from the quiver:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">PQ</span><span class="o">.</span><span class="n">S</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">PQ</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">PQ</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Radicals, socles, tops, and quotients can all be computed and we can test if
modules are simple or semisimple, get their dimension, and test for equality.
Like quivers, <code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRep</span></code> objects
are unique and therefore equal if and only if they are identical:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_simple</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">radical</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">socle</span><span class="p">()</span>
<span class="go">Representation with dimension vector (0, 0, 3)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">P</span><span class="o">/</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">is_simple</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">==</span> <span class="n">R</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">top</span><span class="p">()</span> <span class="ow">is</span> <span class="n">P</span><span class="o">/</span><span class="n">R</span>
<span class="go">True</span>
</pre></div>
</div>
<p>There are special methods to deal with modules that are given as right
ideals in the quiver algebra.  To create such a module pass the keyword
<code class="docutils literal notranslate"><span class="pre">option='paths'</span></code> along with a path or list of paths that generate the
desired ideal:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">PQ</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)]],</span> <span class="n">option</span><span class="o">=</span><span class="s1">&#39;paths&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">dimension_vector</span><span class="p">()</span>
<span class="go">(1, 2, 3)</span>
</pre></div>
</div>
<p>There are also special methods to deal with modules that are given as the
linear dual of a right ideal in the quiver algebra.  To create such a
module, pass the keyword <code class="docutils literal notranslate"><span class="pre">option='dual</span> <span class="pre">paths'</span></code> to the constructor along
with a path or list of paths.  The module returned is the dual of the
ideal created in the opposite quiver by the reverses of the given paths:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">PQ</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)]],</span> <span class="n">option</span><span class="o">=</span><span class="s1">&#39;dual paths&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">dimension_vector</span><span class="p">()</span>
<span class="go">(2, 0, 0)</span>
</pre></div>
</div>
<p>For modules that are not a standard module or an ideal of the quiver algebra
<code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRep</span></code> can take as input two
dictionaries.  The first associates to each vertex a vector space or an
integer (the desired dimension of the vector space), the second associates to
each edge a map or a matrix or something from which sage can construct a map:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">PQ2</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M2</span> <span class="o">=</span> <span class="n">PQ2</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="n">QQ</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="n">QQ</span><span class="o">^</span><span class="mi">1</span><span class="p">},</span> <span class="p">{(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">):</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">get_space</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Vector space of dimension 2 over Rational Field</span>
<span class="gp">sage: </span><span class="n">M2</span><span class="o">.</span><span class="n">get_space</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Vector space of dimension 1 over Rational Field</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">get_map</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">))</span>
<span class="go">Vector space morphism represented by the matrix:</span>
<span class="go">[1 0]</span>
<span class="go">Domain: Vector space of dimension 1 over Rational Field</span>
<span class="go">Codomain: Vector space of dimension 2 over Rational Field</span>
</pre></div>
</div>
<p>A homomorphism between two quiver representations is given by homomorphisms
between the spaces assigned to the vertices of those representations such that
those homomorphisms commute with the edge maps of the representations. The
homomorphisms are created in the usual Sage syntax, the defining data given by
a dictionary associating maps to vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">PQ2</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">P2</span><span class="o">.</span><span class="n">hom</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]]},</span> <span class="n">M2</span><span class="p">)</span>
</pre></div>
</div>
<p>When the domain is given as a right ideal in the quiver algebra we can also
create a homomorphism by just giving a single element in the codomain.
The map is then induced by acting on that element:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">P2</span><span class="o">.</span><span class="n">gens</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">x</span>
<span class="go">x_0</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">==</span> <span class="n">P2</span><span class="o">.</span><span class="n">hom</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">M2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>As you can see, the above homomorphisms can be applied to elements.  Just
like elements, addition is defined via the <code class="docutils literal notranslate"><span class="pre">+</span></code> operator.  On elements scalar
multiplication is defined via the <code class="docutils literal notranslate"><span class="pre">*</span></code> operator but on homomorphisms <code class="docutils literal notranslate"><span class="pre">*</span></code>
defines composition, so scalar multiplication is done using a method:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">f</span> <span class="o">+</span> <span class="n">f</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">==</span> <span class="n">f</span><span class="o">.</span><span class="n">scalar_mult</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">==</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span>       <span class="c1"># This multiplies the map with the scalar 2</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># This applies the map, then multiplies by the scalar</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">direct_sum</span></code> method for modules returns only the resulting module by
default.  But can also return the projection and inclusion homomorphisms into
the various factors:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N2</span><span class="p">,</span> <span class="n">inclusions</span><span class="p">,</span> <span class="n">projections</span> <span class="o">=</span> <span class="n">M2</span><span class="o">.</span><span class="n">direct_sum</span><span class="p">([</span><span class="n">P2</span><span class="p">],</span> <span class="n">return_maps</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">inclusions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span> <span class="ow">is</span> <span class="n">M2</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">projections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span> <span class="ow">is</span> <span class="n">M2</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">projections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">inclusions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">is_isomorphism</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>As you see above we can determine if a given map is an isomorphism.  Testing
for injectivity and surjectivity works as well:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">is_injective</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">is_surjective</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We can create all the standard modules associated to maps:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">Representation with dimension vector (0, 1)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">cokernel</span><span class="p">()</span>
<span class="go">Representation with dimension vector (1, 0)</span>
<span class="gp">sage: </span><span class="n">im</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">image</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">im</span>
<span class="go">Representation with dimension vector (1, 1)</span>
</pre></div>
</div>
<p>These methods, as well as the <code class="docutils literal notranslate"><span class="pre">submodule</span></code> and <code class="docutils literal notranslate"><span class="pre">quotient</span></code> methods that are
defined for representations, return only the resulting representation.  To get
the inclusion map of a submodule or the factor homomorphism of a quotient use
<code class="docutils literal notranslate"><span class="pre">coerce_map_from</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">incl</span> <span class="o">=</span> <span class="n">M2</span><span class="o">.</span><span class="n">coerce_map_from</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">incl</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span> <span class="ow">is</span> <span class="n">im</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">incl</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span> <span class="ow">is</span> <span class="n">M2</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">incl</span><span class="o">.</span><span class="n">is_injective</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Both <code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRep</span></code> objects and
<code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRepHom</span></code> objects have <code class="docutils literal notranslate"><span class="pre">linear_dual</span></code> and
<code class="docutils literal notranslate"><span class="pre">algebraic_dual</span></code> methods.  The <code class="docutils literal notranslate"><span class="pre">linear_dual</span></code> method applies the functor
<span class="math notranslate nohighlight">\(Hom_k(..., k)\)</span> where <span class="math notranslate nohighlight">\(k\)</span> is the base ring of the representation, and the
<code class="docutils literal notranslate"><span class="pre">algebraic_dual</span></code> method applies the functor <span class="math notranslate nohighlight">\(Hom_Q(..., kQ)\)</span> where <span class="math notranslate nohighlight">\(kQ\)</span>
is the quiver algebra.  Both these functors yield left modules.  A left
module is equivalent to a right module over the opposite algebra, and the
opposite of a quiver algebra is the algebra of the opposite quiver, so both
these methods yield modules and representations of the opposite quiver:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">linear_dual</span><span class="p">()</span>
<span class="go">Homomorphism of representations of Reverse of (): Multi-digraph on 2 vertices</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">M2</span><span class="o">.</span><span class="n">algebraic_dual</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">quiver</span><span class="p">()</span> <span class="ow">is</span> <span class="n">PQ2</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span><span class="o">.</span><span class="n">quiver</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="id1">
<p class="admonition-title">Todo</p>
<p>Change the wording <code class="docutils literal notranslate"><span class="pre">Reverse</span> <span class="pre">of</span> <span class="pre">()</span></code> into something more meaningful.</p>
</div>
<p>There is a method returning the projective cover of any module.  Note that
this method returns the homomorphism; to get the module take the domain of
the homomorphism:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cov</span> <span class="o">=</span> <span class="n">M2</span><span class="o">.</span><span class="n">projective_cover</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">cov</span>
<span class="go">Homomorphism of representations of Multi-digraph on 2 vertices</span>
<span class="gp">sage: </span><span class="n">cov</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span>
<span class="go">Representation with dimension vector (2, 4)</span>
</pre></div>
</div>
<p>As projective covers are computable, so are the transpose and Auslander-Reiten
translates of modules:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M2</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="go">Representation with dimension vector (4, 3)</span>
<span class="gp">sage: </span><span class="n">PQ2</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">AR_translate</span><span class="p">()</span>
<span class="go">Representation with dimension vector (3, 2)</span>
</pre></div>
</div>
<p>We have already used the <code class="docutils literal notranslate"><span class="pre">gens</span></code> method above to get an element of a quiver
representation.  An element of a quiver representation is simply a choice of
element from each of the spaces assigned to the vertices of the quiver.
Addition, subtraction, and scalar multiplication are performed pointwise and
implemented by the usual operators:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M2</span><span class="o">.</span><span class="n">dimension_vector</span><span class="p">()</span>
<span class="go">(2, 1)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">M2</span><span class="o">.</span><span class="n">gens</span><span class="p">(</span><span class="s1">&#39;xyz&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">!=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span>
<span class="go">True</span>
</pre></div>
</div>
<p>To create a specific element of a given representation we just specify the
representation and a dictionary associating to each vertex an element of the
space associated to that vertex in the representation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">M2</span><span class="p">({</span><span class="mi">1</span><span class="p">:(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">:(</span><span class="mi">3</span><span class="p">,)})</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">get_element</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(1, -1)</span>
</pre></div>
</div>
<p>The right action of a quiver algebra on an element is implemented via
the <code class="docutils literal notranslate"><span class="pre">*</span></code> operator:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A2</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">quiver</span><span class="p">()</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span><span class="o">.</span><span class="n">algebra</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">A2</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">*</span><span class="n">a</span> <span class="o">==</span> <span class="n">z</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRepElement">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.quivers.representation.</span></span><span class="sig-name descname"><span class="pre">QuiverRepElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parent</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elements</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRepElement" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/element.html#sage.structure.element.ModuleElement" title="(in Parents and Elements v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.element.ModuleElement</span></code></a></p>
<p>An element of a quiver representation is a choice of element from each
of the spaces assigned to the vertices of the quiver.  Addition,
subtraction, and scalar multiplication of these elements is done
pointwise within these spaces.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">module</span></code> – <code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRep</span></code> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>), the module to
which the element belongs</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elements</span></code> - dict (default: empty), a dictionary associating to each
vertex a vector or an object from which sage can create a vector.
Not all vertices must be specified, unspecified vertices will be
assigned the zero vector of the space associated to that vertex in
the given module.  Keys that do not correspond to a vertex are ignored.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>), the name of the element</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.quivers.representation.QuiverRepElement" title="sage.quivers.representation.QuiverRepElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRepElement</span></code></a></p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The constructor needs to know the quiver in order to create an
element of a representation over that quiver.  The default is to
read this information from <code class="docutils literal notranslate"><span class="pre">module</span></code> as well as to fill in
unspecified vectors with the zeros of the spaces in <code class="docutils literal notranslate"><span class="pre">module</span></code>.
If <code class="docutils literal notranslate"><span class="pre">module</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code> then <code class="docutils literal notranslate"><span class="pre">quiver</span></code> <em>MUST</em> be a quiver and each
vertex <em>MUST</em> be specified or an error will result.  If both
<code class="docutils literal notranslate"><span class="pre">module</span></code> and <code class="docutils literal notranslate"><span class="pre">quiver</span></code> are given then <code class="docutils literal notranslate"><span class="pre">quiver</span></code> is ignored.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">spaces</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Q</span><span class="o">.</span><span class="n">quiver</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">spaces</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">elems</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)}</span>
<span class="gp">sage: </span><span class="n">M</span><span class="p">(</span><span class="n">elems</span><span class="p">)</span>
<span class="go">Element of quiver representation</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">M</span><span class="p">(</span><span class="n">elems</span><span class="p">,</span> <span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span>
<span class="go">v</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="n">v</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRepElement.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRepElement.copy" title="Permalink to this definition">#</a></dt>
<dd><p>Return a copy of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">spaces</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Q</span><span class="o">.</span><span class="n">quiver</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">spaces</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">elems</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)}</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">M</span><span class="p">(</span><span class="n">elems</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">_set_element</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">get_element</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(0, 0)</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">get_element</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(1, 0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRepElement.get_element">
<span class="sig-name descname"><span class="pre">get_element</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertex</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRepElement.get_element" title="Permalink to this definition">#</a></dt>
<dd><p>Return the element at the given vertex.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertex</span></code> – integer, a vertex of the quiver</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>vector, the vector assigned to the given vertex</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">spaces</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Q</span><span class="o">.</span><span class="n">quiver</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">spaces</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">elems</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)}</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">M</span><span class="p">(</span><span class="n">elems</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">get_element</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(1, 0)</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">get_element</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">(2, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRepElement.is_zero">
<span class="sig-name descname"><span class="pre">is_zero</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRepElement.is_zero" title="Permalink to this definition">#</a></dt>
<dd><p>Test whether <code class="docutils literal notranslate"><span class="pre">self</span></code> is zero.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>bool, <code class="docutils literal notranslate"><span class="pre">True</span></code> if the element is the zero element, <code class="docutils literal notranslate"><span class="pre">False</span></code>
otherwise</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">spaces</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Q</span><span class="o">.</span><span class="n">quiver</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">spaces</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">elems</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)}</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">M</span><span class="p">(</span><span class="n">elems</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">M</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRepElement.quiver">
<span class="sig-name descname"><span class="pre">quiver</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRepElement.quiver" title="Permalink to this definition">#</a></dt>
<dd><p>Return the quiver of the representation.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p><a class="reference external" href="../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Graph Theory v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraph</span></code></a>, the quiver of the representation</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">quiver</span><span class="p">()</span> <span class="ow">is</span> <span class="n">Q</span><span class="o">.</span><span class="n">quiver</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRepElement.support">
<span class="sig-name descname"><span class="pre">support</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRepElement.support" title="Permalink to this definition">#</a></dt>
<dd><p>Return the support of <code class="docutils literal notranslate"><span class="pre">self</span></code> as a list.</p>
<p>The support is the set of vertices to which a nonzero vector is
associated.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>list, the support</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">spaces</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Q</span><span class="o">.</span><span class="n">quiver</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">spaces</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">elems</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)}</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">M</span><span class="p">(</span><span class="n">elems</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">support</span><span class="p">()</span>
<span class="go">[1, 3]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRepFactory">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.quivers.representation.</span></span><span class="sig-name descname"><span class="pre">QuiverRepFactory</span></span><a class="headerlink" href="#sage.quivers.representation.QuiverRepFactory" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/factory.html#sage.structure.factory.UniqueFactory" title="(in Parents and Elements v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.factory.UniqueFactory</span></code></a></p>
<p>A quiver representation is a diagram in the category of vector spaces whose
underlying graph is the quiver.  Giving a finite dimensional representation
is equivalent to giving a finite dimensional right module for the path
algebra of the quiver.</p>
<p>INPUT:</p>
<p>The first two arguments specify the base ring and the quiver,
and they are always required:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> – ring, the base ring of the representation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">P</span></code> – the partial semigroup formed by the paths of the quiver of the
representation</p></li>
</ul>
<p>Then to specify the spaces and maps associated to the quiver
there are three possible options.  The first is the <code class="docutils literal notranslate"><span class="pre">'values'</span></code> option,
where the next two arguments give the data to be assigned.  The following
can either be the next two entries in the argument list or they can be
passed by keyword.  If the argument list is long enough the keywords
are ignored; the keywords are only checked in the event that the argument
list does not have enough entries after <code class="docutils literal notranslate"><span class="pre">P</span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">spaces</span></code> – dict (default: empty); a dictionary associating to each
vertex a free module over the base ring <span class="math notranslate nohighlight">\(k\)</span>.  Not all vertices must be
specified; unspecified vertices are automatically set to <span class="math notranslate nohighlight">\(k^0\)</span>.  Keys
of the dictionary  that don’t correspond to vertices are ignored.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">maps</span></code> - dict (default: empty); a dictionary associating to each edge
a map whose domain and codomain are the spaces associated to the initial
and terminal vertex of the edge respectively.  Not all edges must be
specified; unspecified edges are automatically set to the zero map.
Keys of the dictionary that don’t correspond to edges are ignored.</p></li>
</ul>
<p>The second option is the <code class="docutils literal notranslate"><span class="pre">paths</span></code> option which creates a module by
generating a right ideal from a list of paths.  Thus the basis elements
of this module correspond to paths of the quiver and the maps are given
by right multiplication by the corresponding edge.  As above this can be
passed either as the next entry in the argument list or as a keyword.
The keyword is only checked if there is no entry in the argument list
after <code class="docutils literal notranslate"><span class="pre">Q</span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">basis</span></code> - list; a nonempty list of paths in the quiver <code class="docutils literal notranslate"><span class="pre">Q</span></code>.
Entries that do not represent valid paths are ignored and duplicate
paths are deleted.  There must be at least one valid path in the list
or a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> is raised.  The closure of this list under right
multiplication forms the basis of the resulting representation.</p></li>
</ul>
<p>The third option is the <code class="docutils literal notranslate"><span class="pre">dual</span> <span class="pre">paths</span></code> option which creates the dual of
a left ideal in the quiver algebra.  Thus the basis elements of this
module correspond to paths of the quiver and the maps are given by
deleting the corresponding edge from the start of the path (the edge map
is zero on a path if that edge is not the initial edge of the path).
As above this can be passed either as the next entry in the argument
list or as a keyword.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">basis</span></code> – list; a nonempty list of paths in the quiver <code class="docutils literal notranslate"><span class="pre">Q</span></code>.
Entries that do not represent valid paths are ignored and duplicate
paths are deleted.  There must be at least one valid path in the list
or a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> is raised.  The closure of this list under left
multiplication of edges forms the basis of  the resulting representation.</p></li>
</ul>
<p>Using the second and third options requires that the following keyword be
passed to the constructor.  This must be passed as a keyword.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">option</span></code> - string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>), either <code class="docutils literal notranslate"><span class="pre">'values'</span></code> or
<code class="docutils literal notranslate"><span class="pre">'paths'</span></code> or <code class="docutils literal notranslate"><span class="pre">'dual</span> <span class="pre">paths'</span></code>. <code class="docutils literal notranslate"><span class="pre">None</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">'values'</span></code>.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRep</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q1</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
</pre></div>
</div>
<p>When the <code class="docutils literal notranslate"><span class="pre">option</span></code> keyword is not supplied the constructor uses the
<code class="docutils literal notranslate"><span class="pre">'values'</span></code> option and expects the spaces and maps to be specified.
If no maps or spaces are given the zero module is created:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q1</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The simple modules, indecomposable projectives, and indecomposable
injectives are examples of quiver representations:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">Q1</span><span class="o">.</span><span class="n">S</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">Q1</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Q1</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Various standard submodules can be computed, such as radicals and socles.
We can also form quotients and test for certain attributes such as
semisimplicity:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">radical</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">P</span><span class="o">/</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">is_simple</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">==</span> <span class="n">R</span>
<span class="go">False</span>
</pre></div>
</div>
<p>With the option <code class="docutils literal notranslate"><span class="pre">'paths'</span></code> the input data should be a list of
<code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverPaths</span></code> or things that <code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverPaths</span></code> can be
constructed from.  The resulting module is the submodule generated by
these paths in the quiver algebra, when considered as a right module
over itself:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">Q1</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]],</span> <span class="n">option</span><span class="o">=</span><span class="s1">&#39;paths&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P1</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
<p>In the following example, the 3rd and 4th paths are actually the same,
so the duplicate is removed:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">Q1</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)]],</span> <span class="n">option</span><span class="o">=</span><span class="s1">&#39;paths&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>The dimension at each vertex equals the number of paths in the closed
basis whose terminal point is that vertex:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q2</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;d&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q2</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)]],</span> <span class="n">option</span><span class="o">=</span><span class="s1">&#39;paths&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">dimension_vector</span><span class="p">()</span>
<span class="go">(0, 2, 2)</span>
<span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">Q2</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)]],</span> <span class="n">option</span><span class="o">=</span><span class="s1">&#39;paths&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">dimension_vector</span><span class="p">()</span>
<span class="go">(0, 1, 2)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRepFactory.create_key">
<span class="sig-name descname"><span class="pre">create_key</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRepFactory.create_key" title="Permalink to this definition">#</a></dt>
<dd><p>Return a key for the specified module.</p>
<p>The key is a tuple.  The first and second entries are the base ring
<code class="docutils literal notranslate"><span class="pre">k</span></code> and the partial semigroup <code class="docutils literal notranslate"><span class="pre">P</span></code> formed by the paths of a quiver.
The third entry is the <code class="docutils literal notranslate"><span class="pre">option</span></code> and the remaining entries depend on
that option.  If the option is <code class="docutils literal notranslate"><span class="pre">'values'</span></code> and the quiver
has <span class="math notranslate nohighlight">\(n\)</span> vertices then the next <span class="math notranslate nohighlight">\(n\)</span> entries are the vector spaces
to be assigned to those vertices.  After that are the matrices of
the maps assigned to edges, listed in the same order that
<code class="docutils literal notranslate"><span class="pre">Q.edges(sort=True)</span></code> uses.  If the option is <code class="docutils literal notranslate"><span class="pre">'paths'</span></code> or <code class="docutils literal notranslate"><span class="pre">'dual</span> <span class="pre">paths'</span></code>
then the next entry is a tuple containing a sorted list of the
paths that form a basis of the quiver.</p>
<p>INPUT:</p>
<p>See the class documentation.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>tuple</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.quivers.representation</span> <span class="kn">import</span> <span class="n">QuiverRep</span>
<span class="gp">sage: </span><span class="n">QuiverRep</span><span class="o">.</span><span class="n">create_key</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">P</span><span class="p">)</span>
<span class="go">(Finite Field of size 5,</span>
<span class="go"> Partial semigroup formed by the directed paths of Multi-digraph on 2 vertices,</span>
<span class="go"> &#39;values&#39;,</span>
<span class="go"> Vector space of dimension 0 over Finite Field of size 5,</span>
<span class="go"> Vector space of dimension 0 over Finite Field of size 5,</span>
<span class="go"> [])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRepFactory.create_object">
<span class="sig-name descname"><span class="pre">create_object</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">version</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">extra_args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRepFactory.create_object" title="Permalink to this definition">#</a></dt>
<dd><p>Create a <a class="reference internal" href="#sage.quivers.representation.QuiverRep_generic" title="sage.quivers.representation.QuiverRep_generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRep_generic</span></code></a> or
<a class="reference internal" href="#sage.quivers.representation.QuiverRep_with_path_basis" title="sage.quivers.representation.QuiverRep_with_path_basis"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRep_with_path_basis</span></code></a> object from the key.</p>
<p>The key is a tuple.  The first and second entries are the base ring
<code class="docutils literal notranslate"><span class="pre">k</span></code> and the quiver <code class="docutils literal notranslate"><span class="pre">Q</span></code>.  The third entry is the
<code class="docutils literal notranslate"><span class="pre">'option'</span></code> and the remaining entries depend on that option.
If the option is <code class="docutils literal notranslate"><span class="pre">'values'</span></code> and the quiver has <span class="math notranslate nohighlight">\(n\)</span>
vertices then the next <span class="math notranslate nohighlight">\(n\)</span> entries are the vector spaces to be
assigned to those vertices.  After that are the matrices
of the maps assigned to edges, listed in the same order that
<code class="docutils literal notranslate"><span class="pre">Q.edges(sort=True)</span></code> uses.  If the option is <code class="docutils literal notranslate"><span class="pre">'paths'</span></code> or <code class="docutils literal notranslate"><span class="pre">'dual</span> <span class="pre">paths'</span></code>
then the next entry is a tuple containing a sorted list of the
paths that form a basis of the quiver.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">version</span></code> – the version of sage, this is currently ignored</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">key</span></code> – tuple</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.quivers.representation.QuiverRep_generic" title="sage.quivers.representation.QuiverRep_generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRep_generic</span></code></a> or <a class="reference internal" href="#sage.quivers.representation.QuiverRep_with_path_basis" title="sage.quivers.representation.QuiverRep_with_path_basis"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRep_with_path_basis</span></code></a></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.quivers.representation</span> <span class="kn">import</span> <span class="n">QuiverRep</span>
<span class="gp">sage: </span><span class="n">key</span> <span class="o">=</span> <span class="n">QuiverRep</span><span class="o">.</span><span class="n">create_key</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">Q</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">QuiverRep</span><span class="o">.</span><span class="n">create_object</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="go">Representation with dimension vector (0, 0)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.quivers.representation.</span></span><span class="sig-name descname"><span class="pre">QuiverRep_generic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spaces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../misc/sage/misc/fast_methods.html#sage.misc.fast_methods.WithEqualityById" title="(in Utilities v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.misc.fast_methods.WithEqualityById</span></code></a>, <a class="reference external" href="../../../modules/sage/modules/module.html#sage.modules.module.Module" title="(in Modules v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.modules.module.Module</span></code></a></p>
<p>A generic quiver representation.</p>
<p>This class should not be called by the user.</p>
<p>Call <code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRep</span></code> with <code class="docutils literal notranslate"><span class="pre">option='values'</span></code> (which is the default)
instead.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> – ring, the base ring of the representation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">P</span></code> – the path semigroup of the quiver <span class="math notranslate nohighlight">\(Q\)</span> of the representation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">spaces</span></code> – dict (default: empty), a dictionary associating to each
vertex a free module over the base ring <span class="math notranslate nohighlight">\(k\)</span>.  Not all vertices need
to be specified, unspecified vertices are automatically set to
<span class="math notranslate nohighlight">\(k^0\)</span>.  Keys of the dictionary that don’t correspond to vertices are
ignored.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">maps</span></code> – dict (default: empty), a dictionary associating to each
edge a map whose domain and codomain are the spaces associated to
the initial and terminal vertex of the edge respectively.  Not all
edges need to be specified, unspecified edges are automatically set
to the zero map.  Keys of the dictionary that don’t correspond to
edges are ignored.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRep</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">spaces</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="n">QQ</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="n">QQ</span><span class="o">^</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="n">QQ</span><span class="o">^</span><span class="mi">2</span><span class="p">}</span>
<span class="gp">sage: </span><span class="n">maps</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="p">(</span><span class="n">QQ</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">Hom</span><span class="p">(</span><span class="n">QQ</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">identity</span><span class="p">(),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">):</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]}</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="n">spaces</span><span class="p">,</span> <span class="n">maps</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span> <span class="ow">in</span> <span class="n">P</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span> <span class="ow">in</span> <span class="n">P</span>
<span class="go">False</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.AR_translate">
<span class="sig-name descname"><span class="pre">AR_translate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.AR_translate" title="Permalink to this definition">#</a></dt>
<dd><p>Return the Auslander-Reiten translate of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="mi">1</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">tauM</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">AR_translate</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">tauM</span>
<span class="go">Representation with dimension vector (1, 1)</span>
<span class="gp">sage: </span><span class="n">tauM</span><span class="o">.</span><span class="n">get_map</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">matrix</span><span class="p">()</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="n">tauM</span><span class="o">.</span><span class="n">get_map</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">matrix</span><span class="p">()</span>
<span class="go">[0]</span>
</pre></div>
</div>
<p>The module <code class="docutils literal notranslate"><span class="pre">M</span></code> above is its own AR translate.  This is not
always true:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q2</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">3</span><span class="p">:{</span><span class="mi">1</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">5</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q2</span><span class="o">.</span><span class="n">S</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">AR_translate</span><span class="p">()</span>
<span class="go">Representation with dimension vector (0, 1, 0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.Element">
<span class="sig-name descname"><span class="pre">Element</span></span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.Element" title="Permalink to this definition">#</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.quivers.representation.QuiverRepElement" title="sage.quivers.representation.QuiverRepElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRepElement</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.Hom">
<span class="sig-name descname"><span class="pre">Hom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">codomain</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.Hom" title="Permalink to this definition">#</a></dt>
<dd><p>Return the hom space from <code class="docutils literal notranslate"><span class="pre">self</span></code> to <code class="docutils literal notranslate"><span class="pre">codomain</span></code>.</p>
<p>For more information see the <code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverHomSpace</span></code> documentation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.actor">
<span class="sig-name descname"><span class="pre">actor</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.actor" title="Permalink to this definition">#</a></dt>
<dd><p>Return the quiver path algebra acting on this representation.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>a quiver path algebra</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>
<span class="go">Finite Field of size 5</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">actor</span><span class="p">()</span>
<span class="go">Path algebra of Multi-digraph on 2 vertices over Finite Field of size 5</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.algebraic_dual">
<span class="sig-name descname"><span class="pre">algebraic_dual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.algebraic_dual" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the algebraic dual <span class="math notranslate nohighlight">\(Hom_Q(M, kQ)\)</span> of the module
<span class="math notranslate nohighlight">\(M\)</span> = <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">basis</span></code> – bool; if <code class="docutils literal notranslate"><span class="pre">False</span></code>, then only the module is
returned.  If <code class="docutils literal notranslate"><span class="pre">True</span></code>, then a tuple is returned.  The first
element is the <code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRep</span></code> and the second element is a
dictionary which associates to each vertex a list.  The elements
of this list are the homomorphisms which correspond to the basis
elements of that vertex in the module.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRep</span></code> or tuple</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Here <span class="math notranslate nohighlight">\(kQ\)</span> is the path algebra considered as a right module
over itself.  If <span class="math notranslate nohighlight">\(e\)</span> is an edge of the quiver <span class="math notranslate nohighlight">\(Q\)</span> then we let
<span class="math notranslate nohighlight">\((fe)(m) = ef(m)\)</span>.  This gives <span class="math notranslate nohighlight">\(Hom_Q(M, kQ)\)</span> a module
structure over the opposite quiver <code class="docutils literal notranslate"><span class="pre">Q.reverse()</span></code>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;e&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">free_module</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span><span class="o">.</span><span class="n">algebraic_dual</span><span class="p">()</span><span class="o">.</span><span class="n">dimension_vector</span><span class="p">()</span>
<span class="go">(7, 2, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.an_element">
<span class="sig-name descname"><span class="pre">an_element</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.an_element" title="Permalink to this definition">#</a></dt>
<dd><p>Return an element of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.quivers.representation.QuiverRepElement" title="sage.quivers.representation.QuiverRepElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRepElement</span></code></a></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="go">Element of quiver representation</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.coordinates">
<span class="sig-name descname"><span class="pre">coordinates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.coordinates" title="Permalink to this definition">#</a></dt>
<dd><p>Return the coordinates when <code class="docutils literal notranslate"><span class="pre">vector</span></code> is expressed in terms of
the gens.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vector</span></code> – <a class="reference internal" href="#sage.quivers.representation.QuiverRepElement" title="sage.quivers.representation.QuiverRepElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRepElement</span></code></a></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>list, the coefficients when the vector is expressed as a linear
combination of the generators of the module</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">gens</span><span class="p">(</span><span class="s1">&#39;xyz&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span>
<span class="go">[1, -1, 1]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">an_element</span><span class="p">())</span>
<span class="go">[1, 1, 0]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span> <span class="o">==</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.dimension">
<span class="sig-name descname"><span class="pre">dimension</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.dimension" title="Permalink to this definition">#</a></dt>
<dd><p>Return the dimension of the space associated to the given vertex
<code class="docutils literal notranslate"><span class="pre">vertex</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertex</span></code> – integer or <code class="docutils literal notranslate"><span class="pre">None</span></code> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>), the given
vertex</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>integer, the dimension over the base ring of the space
associated to the given vertex.  If <code class="docutils literal notranslate"><span class="pre">vertex=None</span></code> then the
dimension over the base ring of the module is returned</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">dimension</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">dimension</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>The total dimension of the module is the sum of the dimensions
at each vertex:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.dimension_vector">
<span class="sig-name descname"><span class="pre">dimension_vector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.dimension_vector" title="Permalink to this definition">#</a></dt>
<dd><p>Return the dimension vector of the representation.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>tuple</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The order of the entries in the tuple matches the order given
by calling the <code class="docutils literal notranslate"><span class="pre">vertices()</span></code> method on the quiver.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">dimension_vector</span><span class="p">()</span>
<span class="go">(1, 2)</span>
</pre></div>
</div>
<p>Each coordinate of the dimension vector is the dimension of the space
associated to that coordinate:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">get_space</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.direct_sum">
<span class="sig-name descname"><span class="pre">direct_sum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">modules</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_maps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.direct_sum" title="Permalink to this definition">#</a></dt>
<dd><p>Return the direct sum of <code class="docutils literal notranslate"><span class="pre">self</span></code> with the given modules
<code class="docutils literal notranslate"><span class="pre">modules</span></code>.</p>
<p>The modules must be modules over the same quiver and base ring.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">modules</span></code> – <code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRep</span></code> or list of <code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRep</span></code>’s</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">return_maps</span></code> – Boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">False</span></code>, then
the output is a single QuiverRep object which is the direct sum
of <code class="docutils literal notranslate"><span class="pre">self</span></code> with the given module or modules.  If <code class="docutils literal notranslate"><span class="pre">True</span></code>, then
the output is a list <code class="docutils literal notranslate"><span class="pre">[sum,</span> <span class="pre">iota,</span> <span class="pre">pi]</span></code>.  The first entry
<code class="docutils literal notranslate"><span class="pre">sum</span></code> is the direct sum of <code class="docutils literal notranslate"><span class="pre">self</span></code> with the given module or
modules.  Both <code class="docutils literal notranslate"><span class="pre">iota</span></code> and <code class="docutils literal notranslate"><span class="pre">pi</span></code> are lists of QuiverRepHoms
with one entry for each summand; <code class="docutils literal notranslate"><span class="pre">iota[i]</span></code> is the inclusion
map and <code class="docutils literal notranslate"><span class="pre">pi[i]</span></code> is the projection map of the <span class="math notranslate nohighlight">\(i\)</span>-th summand.
The summands are ordered as given with <code class="docutils literal notranslate"><span class="pre">self</span></code> being the zeroth
summand.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRep</span></code> or tuple</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">4</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">]},</span> <span class="mi">3</span><span class="p">:{</span><span class="mi">4</span><span class="p">:[</span><span class="s1">&#39;d&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">direct_sum</span><span class="p">(</span><span class="n">P2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P1</span><span class="o">.</span><span class="n">dimension_vector</span><span class="p">()</span>
<span class="go">(1, 1, 1, 2)</span>
<span class="gp">sage: </span><span class="n">P2</span><span class="o">.</span><span class="n">dimension_vector</span><span class="p">()</span>
<span class="go">(0, 1, 0, 1)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">dimension_vector</span><span class="p">()</span>
<span class="go">(1, 2, 1, 3)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">,</span> <span class="n">iota</span><span class="p">,</span> <span class="n">pi</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">direct_sum</span><span class="p">(</span><span class="n">P2</span><span class="p">,</span> <span class="n">return_maps</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">iota</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span> <span class="ow">is</span> <span class="n">P1</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">iota</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span> <span class="ow">is</span> <span class="n">P2</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span> <span class="ow">is</span> <span class="n">P1</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">pi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span> <span class="ow">is</span> <span class="n">P2</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">iota</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span> <span class="ow">is</span> <span class="n">S</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">iota</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span> <span class="ow">is</span> <span class="n">S</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span> <span class="ow">is</span> <span class="n">S</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">pi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span> <span class="ow">is</span> <span class="n">S</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">iota</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">[1 0 0]</span>
<span class="go">[0 1 0]</span>
<span class="gp">sage: </span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">[1 0]</span>
<span class="go">[0 1]</span>
<span class="go">[0 0]</span>
<span class="gp">sage: </span><span class="n">P1prime</span> <span class="o">=</span> <span class="n">S</span><span class="o">/</span><span class="n">iota</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">image</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">P1prime</span><span class="o">.</span><span class="n">coerce_map_from</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">iota</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_isomorphism</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.gens">
<span class="sig-name descname"><span class="pre">gens</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'v'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.gens" title="Permalink to this definition">#</a></dt>
<dd><p>Return a list of generators of <code class="docutils literal notranslate"><span class="pre">self</span></code> as a <span class="math notranslate nohighlight">\(k\)</span>-module.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">names</span></code> – an iterable variable of length equal to the number
of generators, or a string (default: <code class="docutils literal notranslate"><span class="pre">'v'</span></code>); gives the names of
the generators either by giving a name to each generator or by
giving a name to which an index will be appended</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>list of <a class="reference internal" href="#sage.quivers.representation.QuiverRepElement" title="sage.quivers.representation.QuiverRepElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRepElement</span></code></a> objects, the linear generators
of the module (over the base ring)</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The generators are ordered first by vertex and then by the order
given by the <code class="docutils literal notranslate"><span class="pre">gens()</span></code> method of the space associated to
that vertex.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="go">[v_0, v_1, v_2]</span>
</pre></div>
</div>
<p>If a string is given then it is used as the name of each generator,
with the index of the generator appended in order to differentiate
them:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">gens</span><span class="p">(</span><span class="s1">&#39;generator&#39;</span><span class="p">)</span>
<span class="go">[generator_0, generator_1, generator_2]</span>
</pre></div>
</div>
<p>If a list or other iterable variable is given then each generator
is named using the appropriate entry.  The length of the variable
must equal the number of generators (the dimension of the module):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">gens</span><span class="p">([</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: can only concatenate list (not &quot;str&quot;) to list</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">gens</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">])</span>
<span class="go">[x, y, z]</span>
</pre></div>
</div>
<p>Strings are iterable, so if the length of the string is equal to the
number of generators then the characters of the string will be used
as the names:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">gens</span><span class="p">(</span><span class="s1">&#39;xyz&#39;</span><span class="p">)</span>
<span class="go">[x, y, z]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.get_map">
<span class="sig-name descname"><span class="pre">get_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.get_map" title="Permalink to this definition">#</a></dt>
<dd><p>Return the map associated to the given edge <code class="docutils literal notranslate"><span class="pre">edge</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">edge</span></code> – tuple of the form
(initial vertex, terminal vertex, label) specifying the edge
whose map is returned</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">get_map</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">))</span>
<span class="go">Free module morphism defined by the matrix</span>
<span class="go">[1 0]</span>
<span class="go">Domain: Ambient free module of rank 1 over the principal ideal domain Integer Ring</span>
<span class="go">Codomain: Ambient free module of rank 2 over the principal ideal domain Integer Ring</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.get_space">
<span class="sig-name descname"><span class="pre">get_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertex</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.get_space" title="Permalink to this definition">#</a></dt>
<dd><p>Return the module associated to the given vertex <code class="docutils literal notranslate"><span class="pre">vertex</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertex</span></code> – integer, a vertex of the quiver of the module</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">get_space</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Vector space of dimension 1 over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.is_semisimple">
<span class="sig-name descname"><span class="pre">is_semisimple</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.is_semisimple" title="Permalink to this definition">#</a></dt>
<dd><p>Test whether the representation is semisimple.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>bool</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">M</span><span class="o">/</span><span class="n">M</span><span class="o">.</span><span class="n">radical</span><span class="p">())</span><span class="o">.</span><span class="n">is_semisimple</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.is_simple">
<span class="sig-name descname"><span class="pre">is_simple</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.is_simple" title="Permalink to this definition">#</a></dt>
<dd><p>Test whether the representation is simple.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>bool</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">RR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">is_simple</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">S</span><span class="p">(</span><span class="n">RR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">is_simple</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.is_zero">
<span class="sig-name descname"><span class="pre">is_zero</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.is_zero" title="Permalink to this definition">#</a></dt>
<dd><p>Test whether the representation is zero.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>bool</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">M</span>
<span class="go">Representation with dimension vector (0, 0)</span>
<span class="gp">sage: </span><span class="n">N</span>
<span class="go">Representation with dimension vector (1, 0)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.linear_combination_of_basis">
<span class="sig-name descname"><span class="pre">linear_combination_of_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.linear_combination_of_basis" title="Permalink to this definition">#</a></dt>
<dd><p>Return the linear combination of the basis for <code class="docutils literal notranslate"><span class="pre">self</span></code> given
by <code class="docutils literal notranslate"><span class="pre">coordinates</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">coordinates</span></code> – list; a list whose length is the dimension of
<code class="docutils literal notranslate"><span class="pre">self</span></code>.  The <span class="math notranslate nohighlight">\(i\)</span>-th element of this list defines the
coefficient of the <span class="math notranslate nohighlight">\(i\)</span>-th basis vector in the linear
combination.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.quivers.representation.QuiverRepElement" title="sage.quivers.representation.QuiverRepElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRepElement</span></code></a></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">gens</span><span class="p">(</span><span class="s1">&#39;xyz&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="go">[1, -1, 1]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">linear_combination_of_basis</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">e</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.linear_dual">
<span class="sig-name descname"><span class="pre">linear_dual</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.linear_dual" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the linear dual <span class="math notranslate nohighlight">\(Hom_k(M, k)\)</span> of the module
<span class="math notranslate nohighlight">\(M =\)</span> <code class="docutils literal notranslate"><span class="pre">self</span></code> over the base ring <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRep</span></code>, the dual representation</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <span class="math notranslate nohighlight">\(e\)</span> is an edge of the quiver <span class="math notranslate nohighlight">\(Q\)</span> then we let
<span class="math notranslate nohighlight">\((fe)(m) = f(me)\)</span>.  This gives <span class="math notranslate nohighlight">\(Hom_k(M, k)\)</span> a module
structure over the opposite quiver <code class="docutils literal notranslate"><span class="pre">Q.reverse()</span></code>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">linear_dual</span><span class="p">()</span>
<span class="go">Representation with dimension vector (1, 2, 2)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">linear_dual</span><span class="p">()</span><span class="o">.</span><span class="n">quiver</span><span class="p">()</span> <span class="ow">is</span> <span class="n">Q</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span><span class="o">.</span><span class="n">quiver</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.projective_cover">
<span class="sig-name descname"><span class="pre">projective_cover</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_maps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.projective_cover" title="Permalink to this definition">#</a></dt>
<dd><p>Return the projective cover of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">S</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f1</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">projective_cover</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f1</span><span class="o">.</span><span class="n">is_surjective</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">f1</span><span class="o">.</span><span class="n">_domain</span>
<span class="go">Representation with dimension vector (1, 2, 4)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Representation with dimension vector (1, 2, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.quiver">
<span class="sig-name descname"><span class="pre">quiver</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.quiver" title="Permalink to this definition">#</a></dt>
<dd><p>Return the quiver of the representation.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p><a class="reference external" href="../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Graph Theory v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraph</span></code></a></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">quiver</span><span class="p">()</span> <span class="ow">is</span> <span class="n">Q</span><span class="o">.</span><span class="n">quiver</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.quotient">
<span class="sig-name descname"><span class="pre">quotient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.quotient" title="Permalink to this definition">#</a></dt>
<dd><p>Return the quotient of <code class="docutils literal notranslate"><span class="pre">self</span></code> by the submodule <code class="docutils literal notranslate"><span class="pre">sub</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sub</span></code> – <code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRep</span></code>; this must be a submodule of <code class="docutils literal notranslate"><span class="pre">self</span></code>,
meaning the space associated to each vertex <span class="math notranslate nohighlight">\(v\)</span> of <code class="docutils literal notranslate"><span class="pre">sub</span></code> is a
subspace of the space associated to <span class="math notranslate nohighlight">\(v\)</span> in <code class="docutils literal notranslate"><span class="pre">self</span></code> and the map
associated to each edge <span class="math notranslate nohighlight">\(e\)</span> of <code class="docutils literal notranslate"><span class="pre">sub</span></code> is the restriction of
the map associated to <span class="math notranslate nohighlight">\(e\)</span> in <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – bool; if <code class="docutils literal notranslate"><span class="pre">True</span></code> then <code class="docutils literal notranslate"><span class="pre">sub</span></code> is checked to verify
that it is indeed a submodule of <code class="docutils literal notranslate"><span class="pre">self</span></code> and an error is raised
if it is not</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRep</span></code>, the quotient module <code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">/</span> <span class="pre">sub</span></code></p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function returns only a QuiverRep object <code class="docutils literal notranslate"><span class="pre">quot</span></code>.  The
projection map from <code class="docutils literal notranslate"><span class="pre">self</span></code> to <code class="docutils literal notranslate"><span class="pre">quot</span></code> can be obtained by
calling <code class="docutils literal notranslate"><span class="pre">quot.coerce_map_from(self)</span></code>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">S</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">quotient</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="go">Representation with dimension vector (2, 1, 0)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">quotient</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">radical</span><span class="p">())</span>
<span class="go">Representation with dimension vector (2, 0, 0)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">quotient</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="go">Representation with dimension vector (0, 0, 0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.radical">
<span class="sig-name descname"><span class="pre">radical</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.radical" title="Permalink to this definition">#</a></dt>
<dd><p>Return the Jacobson radical of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRep</span></code>, the Jacobson radical</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">radical</span><span class="p">()</span>
<span class="go">Representation with dimension vector (0, 2, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.right_edge_action">
<span class="sig-name descname"><span class="pre">right_edge_action</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.right_edge_action" title="Permalink to this definition">#</a></dt>
<dd><p>Return the result of <code class="docutils literal notranslate"><span class="pre">element*path</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">element</span></code> – <a class="reference internal" href="#sage.quivers.representation.QuiverRepElement" title="sage.quivers.representation.QuiverRepElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRepElement</span></code></a>, an element of <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">path</span></code> – <code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverPath</span></code> or list of tuples</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.quivers.representation.QuiverRepElement" title="sage.quivers.representation.QuiverRepElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRepElement</span></code></a>, the result of <code class="docutils literal notranslate"><span class="pre">element*path</span></code> when
<code class="docutils literal notranslate"><span class="pre">path</span></code> is considered an element of the path algebra of the quiver</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">support</span><span class="p">()</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">right_edge_action</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span><span class="o">.</span><span class="n">support</span><span class="p">()</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">right_edge_action</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span><span class="o">.</span><span class="n">support</span><span class="p">()</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">right_edge_action</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)])</span><span class="o">.</span><span class="n">support</span><span class="p">()</span>
<span class="go">[2]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">right_edge_action</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">M</span><span class="o">.</span><span class="n">right_edge_action</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.socle">
<span class="sig-name descname"><span class="pre">socle</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.socle" title="Permalink to this definition">#</a></dt>
<dd><p>The socle of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRep</span></code>, the socle</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">socle</span><span class="p">()</span>
<span class="go">Representation with dimension vector (0, 0, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.submodule">
<span class="sig-name descname"><span class="pre">submodule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elements</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spaces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.submodule" title="Permalink to this definition">#</a></dt>
<dd><p>Return the submodule generated by the data.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">elements</span></code> – a collection of QuiverRepElements (default:
empty list), each should be an element of <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">spaces</span></code> – dictionary (default: empty), this dictionary
should contain entries of the form <code class="docutils literal notranslate"><span class="pre">{v:</span> <span class="pre">S}</span></code> where <span class="math notranslate nohighlight">\(v\)</span> is a
vertex of the quiver and <span class="math notranslate nohighlight">\(S\)</span> is a subspace of the vector space
associated to <span class="math notranslate nohighlight">\(v\)</span></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRep</span></code>, the smallest subrepresentation of <code class="docutils literal notranslate"><span class="pre">self</span></code>
containing the given elements and the given subspaces</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function returns only a <code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRep</span></code> object <code class="docutils literal notranslate"><span class="pre">sub</span></code>.
The inclusion map of <code class="docutils literal notranslate"><span class="pre">sub</span></code> into <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">self</span></code> can be obtained
by calling <code class="docutils literal notranslate"><span class="pre">M.coerce_map_from(sub)</span></code>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">spaces</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="n">QQ</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="n">QQ</span><span class="o">^</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="n">QQ</span><span class="o">^</span><span class="mi">2</span><span class="p">}</span>
<span class="gp">sage: </span><span class="n">maps</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="p">(</span><span class="n">QQ</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">Hom</span><span class="p">(</span><span class="n">QQ</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">identity</span><span class="p">(),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">):</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]}</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="n">spaces</span><span class="p">,</span> <span class="n">maps</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">submodule</span><span class="p">([</span><span class="n">v</span><span class="p">])</span>
<span class="go">Representation with dimension vector (1, 1, 1)</span>
</pre></div>
</div>
<p>The smallest submodule containing the vector space at vertex 1
also contains the entire vector space associated to vertex 3
because there is an isomorphism associated to the edge
<code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">3,</span> <span class="pre">'a')</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">submodule</span><span class="p">(</span><span class="n">spaces</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="n">QQ</span><span class="o">^</span><span class="mi">2</span><span class="p">})</span>
<span class="go">Representation with dimension vector (2, 0, 2)</span>
</pre></div>
</div>
<p>The smallest submodule containing the vector space at vertex 2
also contains the image of the rank 1 homomorphism associated to
the edge <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">3,</span> <span class="pre">'b')</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">submodule</span><span class="p">(</span><span class="n">spaces</span><span class="o">=</span><span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="n">QQ</span><span class="o">^</span><span class="mi">3</span><span class="p">})</span>
<span class="go">Representation with dimension vector (0, 3, 1)</span>
</pre></div>
</div>
<p>As <code class="docutils literal notranslate"><span class="pre">v</span></code> is not already contained in this submodule, adding it as
a generator yields a larger submodule:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">support</span><span class="p">()</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">submodule</span><span class="p">([</span><span class="n">v</span><span class="p">],</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="n">QQ</span><span class="o">^</span><span class="mi">3</span><span class="p">})</span>
<span class="go">Representation with dimension vector (1, 3, 1)</span>
</pre></div>
</div>
<p>Giving no generating data yields the zero submodule:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">submodule</span><span class="p">()</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If the given data generates all of M then the result is M:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">submodule</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">gens</span><span class="p">())</span> <span class="ow">is</span> <span class="n">M</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.support">
<span class="sig-name descname"><span class="pre">support</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.support" title="Permalink to this definition">#</a></dt>
<dd><p>Return the support of <code class="docutils literal notranslate"><span class="pre">self</span></code> as a list.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>list, the vertices of the representation that have nonzero
spaces associated to them</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">]},</span> <span class="mi">3</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span>
<span class="go">Representation with dimension vector (0, 1, 1, 1)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">support</span><span class="p">()</span>
<span class="go">[2, 3, 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.top">
<span class="sig-name descname"><span class="pre">top</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.top" title="Permalink to this definition">#</a></dt>
<dd><p>Return the top of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRep</span></code>, the quotient of <code class="docutils literal notranslate"><span class="pre">self</span></code> by its radical</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">top</span><span class="p">()</span>
<span class="go">Representation with dimension vector (1, 0, 0)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">top</span><span class="p">()</span> <span class="o">==</span> <span class="n">M</span><span class="o">/</span><span class="n">M</span><span class="o">.</span><span class="n">radical</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.transpose">
<span class="sig-name descname"><span class="pre">transpose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.transpose" title="Permalink to this definition">#</a></dt>
<dd><p>Return the transpose of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The transpose, <span class="math notranslate nohighlight">\(\mbox{Tr} M\)</span>, of a module <span class="math notranslate nohighlight">\(M\)</span> is defined as
follows.  Let <span class="math notranslate nohighlight">\(p: P_1 \to P_2\)</span> be the second map in a minimal
projective presentation <span class="math notranslate nohighlight">\(P_1 \to P_2 \to M \to 0\)</span> of <span class="math notranslate nohighlight">\(M\)</span>.
If <span class="math notranslate nohighlight">\(p^t\)</span> is the algebraic dual of <span class="math notranslate nohighlight">\(p\)</span> then define
<span class="math notranslate nohighlight">\(\mbox{Tr} M = \mbox{coker} p^t\)</span>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRep</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="mi">1</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="go">Representation with dimension vector (1, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_generic.zero_submodule">
<span class="sig-name descname"><span class="pre">zero_submodule</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.zero_submodule" title="Permalink to this definition">#</a></dt>
<dd><p>Return the zero submodule of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">QuiverRep</span></code>, the zero submodule of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">zero_submodule</span><span class="p">()</span>
<span class="go">Representation with dimension vector (0, 0, 0)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">zero_submodule</span><span class="p">()</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_with_dual_path_basis">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.quivers.representation.</span></span><span class="sig-name descname"><span class="pre">QuiverRep_with_dual_path_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_with_dual_path_basis" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.quivers.representation.QuiverRep_generic" title="sage.quivers.representation.QuiverRep_generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.quivers.representation.QuiverRep_generic</span></code></a></p>
<p>The basis of the module must be closed under left deletion of an edge; that
is, deleting any edge from the beginning of any path in the basis must
result in a path also contained in the basis of the module.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> – ring; the base ring of the representation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">P</span></code> – the path semigroup of the quiver <span class="math notranslate nohighlight">\(Q\)</span> of the representation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">basis</span></code> – list (default: empty); should be a list of paths (also
lists) in the quiver <span class="math notranslate nohighlight">\(Q\)</span>.  Entries that do not represent valid paths
are ignored and duplicate paths are deleted.  The closure of this
list under left deletion forms the basis of the resulting
representation.</p></li>
</ul>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_with_path_basis">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.quivers.representation.</span></span><span class="sig-name descname"><span class="pre">QuiverRep_with_path_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_with_path_basis" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.quivers.representation.QuiverRep_generic" title="sage.quivers.representation.QuiverRep_generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.quivers.representation.QuiverRep_generic</span></code></a></p>
<p>The basis of the module must be closed under right multiplication by
an edge; that is, appending any edge to the end of any path in the
basis must result in either an invalid path or a valid path also
contained in the basis of the module.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> – ring, the base ring of the representation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">P</span></code> – the path semigroup of the quiver <span class="math notranslate nohighlight">\(Q\)</span> of the representation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">basis</span></code> – list (default: empty); should be a list of paths (also
lists) in the quiver <span class="math notranslate nohighlight">\(Q\)</span>.  Entries that do not represent valid paths
are ignored and duplicate paths are deleted.  The closure of this
list under right multiplication forms the basis of the resulting
representation.</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="sage.quivers.representation.QuiverRep_with_path_basis.is_left_module">
<span class="sig-name descname"><span class="pre">is_left_module</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.quivers.representation.QuiverRep_with_path_basis.is_left_module" title="Permalink to this definition">#</a></dt>
<dd><p>Test whether the basis is closed under left multiplication.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q1</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">Q1</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]],</span> <span class="n">option</span><span class="o">=</span><span class="s1">&#39;paths&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P2</span><span class="o">.</span><span class="n">is_left_module</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The supplied basis is not closed under left multiplication, but it’s
not closed under right multiplication either.  When the closure under
right multiplication is taken the result is also closed under left
multiplication and therefore produces a left module structure:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">kQ</span> <span class="o">=</span> <span class="n">Q1</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]],</span> <span class="n">option</span><span class="o">=</span><span class="s1">&#39;paths&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">kQ</span><span class="o">.</span><span class="n">is_left_module</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Taking the right closure of a left closed set produces another
left closed set:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q2</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s1">&#39;d&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q2</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)]],</span> <span class="n">option</span><span class="o">=</span><span class="s1">&#39;paths&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">is_left_module</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note that the second path is length 2, so even though the edge (1, 2, ‘a’)
appears in the input the path [(1, 2, ‘a’)] is not in the right closure:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">Q2</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)]],</span> <span class="n">option</span><span class="o">=</span><span class="s1">&#39;paths&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">is_left_module</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          <a class="prev-page" href="paths.html">
              <svg><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Quiver Paths</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2005--2022, The Sage Development Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script data-url_root="../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/scripts/furo.js"></script>
    <script src="../../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.1/dist/embed-amd.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"ZZ": "\\Bold{Z}", "NN": "\\Bold{N}", "RR": "\\Bold{R}", "CC": "\\Bold{C}", "QQ": "\\Bold{Q}", "QQbar": "\\overline{\\QQ}", "GF": ["\\Bold{F}_{#1}", 1], "Zp": ["\\Bold{Z}_{#1}", 1], "Qp": ["\\Bold{Q}_{#1}", 1], "Zmod": ["\\ZZ/#1\\ZZ", 1], "CDF": "\\Bold{C}", "CIF": "\\Bold{C}", "CLF": "\\Bold{C}", "RDF": "\\Bold{R}", "RIF": "\\Bold{I} \\Bold{R}", "RLF": "\\Bold{R}", "SL": "\\mathrm{SL}", "PSL": "\\mathrm{PSL}", "Bold": ["\\mathbf{#1}", 1]}, "inlineMath": [["$", "$"], ["\\(", "\\)"]], "maxBuffer": 51200, "autoload": {"color": [], "colorv2": ["color"]}}}</script>
    <script defer="defer" src="../../../_static/mathjax/tex-chtml.js"></script>
    </body>
</html>