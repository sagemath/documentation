<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" /><link rel="next" title="Finite semigroups" href="finite_semigroups.html" /><link rel="prev" title="Finite Permutation Groups" href="finite_permutation_groups.html" />

    <meta name="generator" content="sphinx-5.2.3, furo 2022.09.29"/>
        <title>Finite posets - Category Framework</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?digest=d81277517bee4d6b0349d71bb2661d4890b5617c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom-furo.css" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  --color-brand-primary: #0f0fff;
  --color-brand-content: #0f0fff;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZGD13B5572"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ZGD13B5572');
</script></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">Category Framework</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><div class="sidebar-scroll"><a class="sidebar-brand" href="../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../../_static/logo_sagemath_black.svg" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../../_static/logo_sagemath_white.svg" alt="Dark Logo"/>
  </div>
  
      <span class="sidebar-brand-text">Sage 9.8 Reference Manual</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-home">
  <div class="sidebar-tree">
    <ul><li class="toctree-l1">
      <a class="reference internal" href="../../index.html">Home - Category Framework</a>
    </li></ul>
  </div>
</div><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="all.html">Sage categories quickref</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="primer.html">Elements, parents, and categories in Sage: a primer</a></li>
<li class="toctree-l1"><a class="reference internal" href="category.html">Categories</a></li>
<li class="toctree-l1"><a class="reference internal" href="category_with_axiom.html">Axioms</a></li>
<li class="toctree-l1"><a class="reference internal" href="functor.html">Functors</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Implementing a new parent: a tutorial</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="map.html">Base class for maps</a></li>
<li class="toctree-l1"><a class="reference internal" href="homset.html">Homsets</a></li>
<li class="toctree-l1"><a class="reference internal" href="morphism.html">Morphisms</a></li>
<li class="toctree-l1"><a class="reference internal" href="pushout.html">Coercion via construction functors</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="action.html">Group, ring, etc. actions on objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="additive_groups.html">Additive groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="additive_magmas.html">Additive magmas</a></li>
<li class="toctree-l1"><a class="reference internal" href="additive_monoids.html">Additive monoids</a></li>
<li class="toctree-l1"><a class="reference internal" href="additive_semigroups.html">Additive semigroups</a></li>
<li class="toctree-l1"><a class="reference internal" href="affine_weyl_groups.html">Affine Weyl groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="algebra_ideals.html">Algebra ideals</a></li>
<li class="toctree-l1"><a class="reference internal" href="algebra_modules.html">Algebra modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="algebras.html">Algebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="algebras_with_basis.html">Algebras With Basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="aperiodic_semigroups.html">Aperiodic semigroups</a></li>
<li class="toctree-l1"><a class="reference internal" href="associative_algebras.html">Associative algebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="bialgebras.html">Bialgebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="bialgebras_with_basis.html">Bialgebras with basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="bimodules.html">Bimodules</a></li>
<li class="toctree-l1"><a class="reference internal" href="classical_crystals.html">Classical Crystals</a></li>
<li class="toctree-l1"><a class="reference internal" href="coalgebras.html">Coalgebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="coalgebras_with_basis.html">Coalgebras with basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="commutative_additive_groups.html">Commutative additive groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="commutative_additive_monoids.html">Commutative additive monoids</a></li>
<li class="toctree-l1"><a class="reference internal" href="commutative_additive_semigroups.html">Commutative additive semigroups</a></li>
<li class="toctree-l1"><a class="reference internal" href="commutative_algebra_ideals.html">Commutative algebra ideals</a></li>
<li class="toctree-l1"><a class="reference internal" href="commutative_algebras.html">Commutative algebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="commutative_ring_ideals.html">Commutative ring ideals</a></li>
<li class="toctree-l1"><a class="reference internal" href="commutative_rings.html">Commutative rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="complete_discrete_valuation.html">Complete Discrete Valuation Rings (CDVR) and Fields (CDVF)</a></li>
<li class="toctree-l1"><a class="reference internal" href="complex_reflection_groups.html">Complex reflection groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="complex_reflection_or_generalized_coxeter_groups.html">Common category for Generalized Coxeter Groups or Complex Reflection Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="coxeter_group_algebras.html">Coxeter Group Algebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="coxeter_groups.html">Coxeter Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="crystals.html">Crystals</a></li>
<li class="toctree-l1"><a class="reference internal" href="cw_complexes.html">CW Complexes</a></li>
<li class="toctree-l1"><a class="reference internal" href="discrete_valuation.html">Discrete Valuation Rings (DVR) and Fields (DVF)</a></li>
<li class="toctree-l1"><a class="reference internal" href="distributive_magmas_and_additive_magmas.html">Distributive Magmas and Additive Magmas</a></li>
<li class="toctree-l1"><a class="reference internal" href="division_rings.html">Division rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="domains.html">Domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="enumerated_sets.html">Enumerated sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="euclidean_domains.html">Euclidean domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="fields.html">Fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="filtered_algebras.html">Filtered Algebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="filtered_algebras_with_basis.html">Filtered Algebras With Basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="filtered_modules.html">Filtered Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="filtered_modules_with_basis.html">Filtered Modules With Basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="finite_complex_reflection_groups.html">Finite Complex Reflection Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="finite_coxeter_groups.html">Finite Coxeter Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="finite_crystals.html">Finite Crystals</a></li>
<li class="toctree-l1"><a class="reference internal" href="finite_dimensional_algebras_with_basis.html">Finite dimensional algebras with basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="finite_dimensional_bialgebras_with_basis.html">Finite dimensional bialgebras with basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="finite_dimensional_coalgebras_with_basis.html">Finite dimensional coalgebras with basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="finite_dimensional_graded_lie_algebras_with_basis.html">Finite Dimensional Graded Lie Algebras With Basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="finite_dimensional_hopf_algebras_with_basis.html">Finite dimensional Hopf algebras with basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="finite_dimensional_lie_algebras_with_basis.html">Finite Dimensional Lie Algebras With Basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="finite_dimensional_modules_with_basis.html">Finite dimensional modules with basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="finite_dimensional_nilpotent_lie_algebras_with_basis.html">Finite Dimensional Nilpotent Lie Algebras With Basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="finite_dimensional_semisimple_algebras_with_basis.html">Finite dimensional semisimple algebras with basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="finite_enumerated_sets.html">Finite Enumerated Sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="finite_fields.html">Finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="finite_groups.html">Finite groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="finite_lattice_posets.html">Finite lattice posets</a></li>
<li class="toctree-l1"><a class="reference internal" href="finite_monoids.html">Finite monoids</a></li>
<li class="toctree-l1"><a class="reference internal" href="finite_permutation_groups.html">Finite Permutation Groups</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Finite posets</a></li>
<li class="toctree-l1"><a class="reference internal" href="finite_semigroups.html">Finite semigroups</a></li>
<li class="toctree-l1"><a class="reference internal" href="finite_sets.html">Finite sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="finite_weyl_groups.html">Finite Weyl Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="finitely_generated_lambda_bracket_algebras.html">Finitely Generated Lambda bracket Algebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="finitely_generated_lie_conformal_algebras.html">Finitely Generated Lie Conformal Algebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="finitely_generated_magmas.html">Finitely generated magmas</a></li>
<li class="toctree-l1"><a class="reference internal" href="finitely_generated_semigroups.html">Finitely generated semigroups</a></li>
<li class="toctree-l1"><a class="reference internal" href="function_fields.html">Function fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="g_sets.html">G-Sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="gcd_domains.html">Gcd domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="generalized_coxeter_groups.html">Generalized Coxeter Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="graded_algebras.html">Graded Algebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="graded_algebras_with_basis.html">Graded algebras with basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="graded_bialgebras.html">Graded bialgebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="graded_bialgebras_with_basis.html">Graded bialgebras with basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="graded_coalgebras.html">Graded Coalgebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="graded_coalgebras_with_basis.html">Graded coalgebras with basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="graded_hopf_algebras.html">Graded Hopf algebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="graded_hopf_algebras_with_basis.html">Graded Hopf algebras with basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="graded_lie_algebras.html">Graded Lie Algebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="graded_lie_algebras_with_basis.html">Graded Lie Algebras With Basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="graded_lie_conformal_algebras.html">Graded Lie Conformal Algebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="graded_modules.html">Graded modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="graded_modules_with_basis.html">Graded modules with basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="graphs.html">Graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_algebras.html">Group Algebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="groupoid.html">Groupoid</a></li>
<li class="toctree-l1"><a class="reference internal" href="groups.html">Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="hecke_modules.html">Hecke modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="highest_weight_crystals.html">Highest Weight Crystals</a></li>
<li class="toctree-l1"><a class="reference internal" href="hopf_algebras.html">Hopf algebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="hopf_algebras_with_basis.html">Hopf algebras with basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="h_trivial_semigroups.html">H-trivial semigroups</a></li>
<li class="toctree-l1"><a class="reference internal" href="infinite_enumerated_sets.html">Infinite Enumerated Sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="integral_domains.html">Integral domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="j_trivial_semigroups.html">J-trivial semigroups</a></li>
<li class="toctree-l1"><a class="reference internal" href="kac_moody_algebras.html">Kac-Moody Algebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="lambda_bracket_algebras.html">Lambda Bracket Algebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="lambda_bracket_algebras_with_basis.html">Lambda Bracket Algebras With Basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="lattice_posets.html">Lattice posets</a></li>
<li class="toctree-l1"><a class="reference internal" href="left_modules.html">Left modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="lie_algebras.html">Lie Algebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="lie_algebras_with_basis.html">Lie Algebras With Basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="lie_conformal_algebras.html">Lie Conformal Algebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="lie_conformal_algebras_with_basis.html">Lie Conformal Algebras With Basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="lie_groups.html">Lie Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="loop_crystals.html">Loop Crystals</a></li>
<li class="toctree-l1"><a class="reference internal" href="l_trivial_semigroups.html">L-trivial semigroups</a></li>
<li class="toctree-l1"><a class="reference internal" href="magmas.html">Magmas</a></li>
<li class="toctree-l1"><a class="reference internal" href="magmas_and_additive_magmas.html">Magmas and Additive Magmas</a></li>
<li class="toctree-l1"><a class="reference internal" href="magmatic_algebras.html">Non-unital non-associative algebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="manifolds.html">Manifolds</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_algebras.html">Matrix algebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="metric_spaces.html">Metric Spaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="modular_abelian_varieties.html">Modular abelian varieties</a></li>
<li class="toctree-l1"><a class="reference internal" href="modules.html">Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="modules_with_basis.html">Modules With Basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="monoid_algebras.html">Monoid algebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="monoids.html">Monoids</a></li>
<li class="toctree-l1"><a class="reference internal" href="number_fields.html">Number fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="objects.html">Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="partially_ordered_monoids.html">Partially ordered monoids</a></li>
<li class="toctree-l1"><a class="reference internal" href="permutation_groups.html">Permutation groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="pointed_sets.html">Pointed sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="polyhedra.html">Polyhedral subsets of free ZZ, QQ or RR-modules.</a></li>
<li class="toctree-l1"><a class="reference internal" href="posets.html">Posets</a></li>
<li class="toctree-l1"><a class="reference internal" href="principal_ideal_domains.html">Principal ideal domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="quotient_fields.html">Quotient fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_group_representations.html">Quantum Group Representations</a></li>
<li class="toctree-l1"><a class="reference internal" href="regular_crystals.html">Regular Crystals</a></li>
<li class="toctree-l1"><a class="reference internal" href="regular_supercrystals.html">Regular Supercrystals</a></li>
<li class="toctree-l1"><a class="reference internal" href="right_modules.html">Right modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="ring_ideals.html">Ring ideals</a></li>
<li class="toctree-l1"><a class="reference internal" href="rings.html">Rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="rngs.html">Rngs</a></li>
<li class="toctree-l1"><a class="reference internal" href="r_trivial_semigroups.html">R-trivial semigroups</a></li>
<li class="toctree-l1"><a class="reference internal" href="schemes.html">Schemes</a></li>
<li class="toctree-l1"><a class="reference internal" href="semigroups.html">Semigroups</a></li>
<li class="toctree-l1"><a class="reference internal" href="semirings.html">Semirngs</a></li>
<li class="toctree-l1"><a class="reference internal" href="semisimple_algebras.html">Semisimple Algebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="sets_cat.html">Sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="sets_with_grading.html">Sets With a Grading</a></li>
<li class="toctree-l1"><a class="reference internal" href="sets_with_partial_maps.html">SetsWithPartialMaps</a></li>
<li class="toctree-l1"><a class="reference internal" href="shephard_groups.html">Shephard Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="simplicial_complexes.html">Simplicial Complexes</a></li>
<li class="toctree-l1"><a class="reference internal" href="simplicial_sets.html">Simplicial Sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="super_algebras.html">Super Algebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="super_algebras_with_basis.html">Super algebras with basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="super_hopf_algebras_with_basis.html">Super Hopf algebras with basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="super_lie_conformal_algebras.html">Super Lie Conformal Algebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="super_modules.html">Super modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="super_modules_with_basis.html">Super modules with basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="supercommutative_algebras.html">Supercommutative Algebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="supercrystals.html">Supercrystals</a></li>
<li class="toctree-l1"><a class="reference internal" href="topological_spaces.html">Topological Spaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="triangular_kac_moody_algebras.html">Kac-Moody Algebras With Triangular Decomposition Basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="unique_factorization_domains.html">Unique factorization domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="unital_algebras.html">Unital algebras</a></li>
<li class="toctree-l1"><a class="reference internal" href="vector_bundles.html">Vector Bundles</a></li>
<li class="toctree-l1"><a class="reference internal" href="vector_spaces.html">Vector Spaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="weyl_groups.html">Weyl Groups</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="facade_sets.html">Facade Sets</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="covariant_functorial_construction.html">Covariant Functorial Constructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="cartesian_product.html">Cartesian Product Functorial Construction</a></li>
<li class="toctree-l1"><a class="reference internal" href="tensor.html">Tensor Product Functorial Construction</a></li>
<li class="toctree-l1"><a class="reference internal" href="signed_tensor.html">Signed Tensor Product Functorial Construction</a></li>
<li class="toctree-l1"><a class="reference internal" href="dual.html">Dual functorial construction</a></li>
<li class="toctree-l1"><a class="reference internal" href="algebra_functor.html">Group algebras and beyond: the Algebra functorial construction</a></li>
<li class="toctree-l1"><a class="reference internal" href="subquotients.html">Subquotient Functorial Construction</a></li>
<li class="toctree-l1"><a class="reference internal" href="quotients.html">Quotients Functorial Construction</a></li>
<li class="toctree-l1"><a class="reference internal" href="subobjects.html">Subobjects Functorial Construction</a></li>
<li class="toctree-l1"><a class="reference internal" href="isomorphic_objects.html">Isomorphic Objects Functorial Construction</a></li>
<li class="toctree-l1"><a class="reference internal" href="homsets.html">Homset categories</a></li>
<li class="toctree-l1"><a class="reference internal" href="realizations.html">Realizations Covariant Functorial Construction</a></li>
<li class="toctree-l1"><a class="reference internal" href="with_realizations.html">With Realizations Covariant Functorial Construction</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="examples/algebras_with_basis.html">Examples of algebras with basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/commutative_additive_monoids.html">Examples of commutative additive monoids</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/commutative_additive_semigroups.html">Examples of commutative additive semigroups</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/coxeter_groups.html">Examples of Coxeter groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/crystals.html">Example of a crystal</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/cw_complexes.html">Examples of CW complexes</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/facade_sets.html">Example of facade set</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/finite_coxeter_groups.html">Examples of finite Coxeter groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/finite_dimensional_algebras_with_basis.html">Example of a finite dimensional algebra with basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/finite_dimensional_lie_algebras_with_basis.html">Examples of a finite dimensional Lie algebra with basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/finite_enumerated_sets.html">Examples of finite enumerated sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/finite_monoids.html">Examples of finite monoids</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/finite_semigroups.html">Examples of finite semigroups</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/finite_weyl_groups.html">Examples of finite Weyl groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/graded_connected_hopf_algebras_with_basis.html">Examples of graded connected Hopf algebras with basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/graded_modules_with_basis.html">Examples of graded modules with basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/graphs.html">Examples of graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/hopf_algebras_with_basis.html">Examples of Hopf algebras with basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/infinite_enumerated_sets.html">Examples of infinite enumerated sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/lie_algebras.html">Examples of a Lie algebra</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/lie_algebras_with_basis.html">Examples of a Lie algebra with basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/magmas.html">Examples of magmas</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/manifolds.html">Examples of manifolds</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/monoids.html">Examples of monoids</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/posets.html">Examples of posets</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/semigroups.html">Examples of semigroups</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/semigroups_cython.html">Examples of semigroups in cython</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/sets_cat.html">Examples of sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/sets_with_grading.html">Example of a set with grading</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/with_realizations.html">Examples of parents endowed with multiple realizations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="category_types.html">Specific category classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="category_singleton.html">Singleton categories</a></li>
<li class="toctree-l1"><a class="reference internal" href="category_cy_helper.html">Fast functions for the category framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="coercion_methods.html">Coercion methods for categories</a></li>
<li class="toctree-l1"><a class="reference internal" href="poor_man_map.html">Poor Man’s map</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="finite-posets">
<span id="sage-categories-finite-posets"></span><h1>Finite posets<a class="headerlink" href="#finite-posets" title="Permalink to this heading">#</a></h1>
<span class="target" id="module-sage.categories.finite_posets"></span><p>Here is some terminology used in this file:</p>
<ul class="simple">
<li><p>An <em>order filter</em> (or <em>upper set</em>) of a poset <span class="math notranslate nohighlight">\(P\)</span> is a subset <span class="math notranslate nohighlight">\(S\)</span> of <span class="math notranslate nohighlight">\(P\)</span>
such that if <span class="math notranslate nohighlight">\(x \leq y\)</span> and <span class="math notranslate nohighlight">\(x\in S\)</span> then <span class="math notranslate nohighlight">\(y\in S\)</span>.</p></li>
<li><p>An <em>order ideal</em> (or <em>lower set</em>) of a poset <span class="math notranslate nohighlight">\(P\)</span> is a subset <span class="math notranslate nohighlight">\(S\)</span> of <span class="math notranslate nohighlight">\(P\)</span>
such that if <span class="math notranslate nohighlight">\(x \leq y\)</span> and <span class="math notranslate nohighlight">\(y\in S\)</span> then <span class="math notranslate nohighlight">\(x\in S\)</span>.</p></li>
</ul>
<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.finite_posets.FinitePosets">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.categories.finite_posets.</span></span><span class="sig-name descname"><span class="pre">FinitePosets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="category_with_axiom.html#sage.categories.category_with_axiom.CategoryWithAxiom" title="sage.categories.category_with_axiom.CategoryWithAxiom"><code class="xref py py-class docutils literal notranslate"><span class="pre">CategoryWithAxiom</span></code></a></p>
<p>The category of finite posets i.e. finite sets with a partial
order structure.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FinitePosets</span><span class="p">()</span>
<span class="go">Category of finite posets</span>
<span class="gp">sage: </span><span class="n">FinitePosets</span><span class="p">()</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of posets, Category of finite sets]</span>
<span class="gp">sage: </span><span class="n">FinitePosets</span><span class="p">()</span><span class="o">.</span><span class="n">example</span><span class="p">()</span>
<span class="go">NotImplemented</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="posets.html#sage.categories.posets.Posets" title="sage.categories.posets.Posets"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posets</span></code></a>, <a class="reference external" href="../../../combinat/sage/combinat/posets/posets.html#sage.combinat.posets.posets.Poset" title="(in Combinatorics v9.8)"><code class="xref py py-func docutils literal notranslate"><span class="pre">Poset()</span></code></a></p>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.finite_posets.FinitePosets.ParentMethods">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ParentMethods</span></span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.finite_posets.FinitePosets.ParentMethods.antichains">
<span class="sig-name descname"><span class="pre">antichains</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.antichains" title="Permalink to this definition">#</a></dt>
<dd><p>Return all antichains of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">antichains</span><span class="p">();</span> <span class="n">A</span>
<span class="go">Set of antichains of Finite lattice containing 5 elements</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[[], [0], [1], [1, 2], [1, 3], [2], [3], [4]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling">
<span class="sig-name descname"><span class="pre">birational_free_labelling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">linear_extension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'x'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_field</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduced</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">addvars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling" title="Permalink to this definition">#</a></dt>
<dd><p>Return the birational free labelling of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Let us hold back defining this, and introduce birational
toggles and birational rowmotion first. These notions have
been introduced in <a class="reference internal" href="../../../references/index.html#ep2013" id="id1"><span>[EP2013]</span></a> as generalizations of the notions
of toggles (<a class="reference internal" href="posets.html#sage.categories.posets.Posets.ParentMethods.order_ideal_toggle" title="sage.categories.posets.Posets.ParentMethods.order_ideal_toggle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_ideal_toggle()</span></code></a>)
and <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rowmotion</span></code></a> on order ideals of a finite poset. They
have been studied further in <a class="reference internal" href="../../../references/index.html#gr2013" id="id2"><span>[GR2013]</span></a>.</p>
<p>Let <span class="math notranslate nohighlight">\(\mathbf{K}\)</span> be a field, and <span class="math notranslate nohighlight">\(P\)</span> be a finite poset. Let
<span class="math notranslate nohighlight">\(\widehat{P}\)</span> denote the poset obtained from <span class="math notranslate nohighlight">\(P\)</span> by adding a
new element <span class="math notranslate nohighlight">\(1\)</span> which is greater than all existing elements
of <span class="math notranslate nohighlight">\(P\)</span>, and a new element <span class="math notranslate nohighlight">\(0\)</span> which is smaller than all
existing elements of <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(1\)</span>. Now, a <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-<em>labelling
of</em> <span class="math notranslate nohighlight">\(P\)</span> will mean any function from <span class="math notranslate nohighlight">\(\widehat{P}\)</span> to <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>.
The image of an element <span class="math notranslate nohighlight">\(v\)</span> of <span class="math notranslate nohighlight">\(\widehat{P}\)</span> under this labelling
will be called the <em>label</em> of this labelling at <span class="math notranslate nohighlight">\(v\)</span>. The set
of all <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labellings of <span class="math notranslate nohighlight">\(P\)</span> is clearly
<span class="math notranslate nohighlight">\(\mathbf{K}^{\widehat{P}}\)</span>.</p>
<p>For any <span class="math notranslate nohighlight">\(v \in P\)</span>, we now define a rational map
<span class="math notranslate nohighlight">\(T_v : \mathbf{K}^{\widehat{P}} \dashrightarrow
\mathbf{K}^{\widehat{P}}\)</span> as follows: For every <span class="math notranslate nohighlight">\(f \in
\mathbf{K}^{\widehat{P}}\)</span>, the image <span class="math notranslate nohighlight">\(T_v f\)</span> should send every
element <span class="math notranslate nohighlight">\(u \in \widehat{P}\)</span> distinct from <span class="math notranslate nohighlight">\(v\)</span> to <span class="math notranslate nohighlight">\(f(u)\)</span> (so the
labels at all <span class="math notranslate nohighlight">\(u \neq v\)</span> don’t change), while <span class="math notranslate nohighlight">\(v\)</span> is sent to</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\frac{1}{f(v)} \cdot
\frac{\sum_{u \lessdot v} f(u)}
{\sum_{u \gtrdot v} \frac{1}{f(u)}}\]</div>
</div>
<p>(both sums are over all <span class="math notranslate nohighlight">\(u \in \widehat{P}\)</span> satisfying the
respectively given conditions). Here, <span class="math notranslate nohighlight">\(\lessdot\)</span> and <span class="math notranslate nohighlight">\(\gtrdot\)</span>
mean (respectively) “covered by” and “covers”, interpreted with
respect to the poset <span class="math notranslate nohighlight">\(\widehat{P}\)</span>. This rational map <span class="math notranslate nohighlight">\(T_v\)</span>
is an involution and is called the <em>(birational)</em> <span class="math notranslate nohighlight">\(v\)</span>-<em>toggle</em>; see
<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggle" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">birational_toggle()</span></code></a> for its implementation.</p>
<p>Now, <em>birational rowmotion</em> is defined as the composition
<span class="math notranslate nohighlight">\(T_{v_1} \circ T_{v_2} \circ \cdots \circ T_{v_n}\)</span>, where
<span class="math notranslate nohighlight">\((v_1, v_2, \ldots, v_n)\)</span> is a linear extension of <span class="math notranslate nohighlight">\(P\)</span>
(written as a linear ordering of the elements of <span class="math notranslate nohighlight">\(P\)</span>). This
is a rational map
<span class="math notranslate nohighlight">\(\mathbf{K}^{\widehat{P}} \dashrightarrow \mathbf{K}^{\widehat{P}}\)</span>
which does not depend on the choice of the linear extension;
it is denoted by <span class="math notranslate nohighlight">\(R\)</span>. See <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_rowmotion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">birational_rowmotion()</span></code></a> for
its implementation.</p>
<p>The definitions of birational toggles and birational
rowmotion extend to the case of <span class="math notranslate nohighlight">\(\mathbf{K}\)</span> being any semifield
rather than necessarily a field (although it becomes less
clear what constitutes a rational map in this generality).
The most useful case is that of the <a class="reference external" href="../../../semirings/sage/rings/semirings/tropical_semiring.html#sage.rings.semirings.tropical_semiring.TropicalSemiring" title="(in Standard Semirings v9.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tropical</span> <span class="pre">semiring</span></code></a>,
in which case birational rowmotion relates to classical
constructions such as promotion of rectangular semistandard
Young tableaux (page 5 of <a class="reference internal" href="../../../references/index.html#ep2013b" id="id3"><span>[EP2013b]</span></a> and future work, via the
related notion of birational <em>promotion</em>) and rowmotion on
order ideals of the poset (<a class="reference internal" href="../../../references/index.html#ep2013" id="id4"><span>[EP2013]</span></a>).</p>
<p>The <em>birational free labelling</em> is a special labelling
defined for every finite poset <span class="math notranslate nohighlight">\(P\)</span> and every linear extension
<span class="math notranslate nohighlight">\((v_1, v_2, \ldots, v_n)\)</span> of <span class="math notranslate nohighlight">\(P\)</span>. It is given by sending
every element <span class="math notranslate nohighlight">\(v_i\)</span> in <span class="math notranslate nohighlight">\(P\)</span> to <span class="math notranslate nohighlight">\(x_i\)</span>, sending the element <span class="math notranslate nohighlight">\(0\)</span>
of <span class="math notranslate nohighlight">\(\widehat{P}\)</span> to <span class="math notranslate nohighlight">\(a\)</span>, and sending the element <span class="math notranslate nohighlight">\(1\)</span> of
<span class="math notranslate nohighlight">\(\widehat{P}\)</span> to <span class="math notranslate nohighlight">\(b\)</span>, where the ground field <span class="math notranslate nohighlight">\(\mathbf{K}\)</span> is the
field of rational functions in <span class="math notranslate nohighlight">\(n+2\)</span> indeterminates
<span class="math notranslate nohighlight">\(a, x_1, x_2, \ldots, x_n, b\)</span> over <span class="math notranslate nohighlight">\(\mathbb Q\)</span>.</p>
<p>In Sage, a labelling <span class="math notranslate nohighlight">\(f\)</span> of a poset <span class="math notranslate nohighlight">\(P\)</span> is encoded as a
<span class="math notranslate nohighlight">\(4\)</span>-tuple <span class="math notranslate nohighlight">\((\mathbf{K}, d, u, v)\)</span>, where <span class="math notranslate nohighlight">\(\mathbf{K}\)</span> is the
ground field of the labelling (i. e., its target), <span class="math notranslate nohighlight">\(d\)</span> is the
dictionary containing the values of <span class="math notranslate nohighlight">\(f\)</span> at the elements of
<span class="math notranslate nohighlight">\(P\)</span> (the keys being the respective elements of <span class="math notranslate nohighlight">\(P\)</span>), <span class="math notranslate nohighlight">\(u\)</span>
is the label of <span class="math notranslate nohighlight">\(f\)</span> at <span class="math notranslate nohighlight">\(0\)</span>, and <span class="math notranslate nohighlight">\(v\)</span> is the label of <span class="math notranslate nohighlight">\(f\)</span> at
<span class="math notranslate nohighlight">\(1\)</span>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The dictionary <span class="math notranslate nohighlight">\(d\)</span> is labelled by the elements of <span class="math notranslate nohighlight">\(P\)</span>.
If <span class="math notranslate nohighlight">\(P\)</span> is a poset with <code class="docutils literal notranslate"><span class="pre">facade</span></code> option set to
<code class="docutils literal notranslate"><span class="pre">False</span></code>, these might not be what they seem to be!
(For instance, if
<code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">==</span> <span class="pre">Poset({1:</span> <span class="pre">[2,</span> <span class="pre">3]},</span> <span class="pre">facade=False)</span></code>, then the
value of <span class="math notranslate nohighlight">\(d\)</span> at <span class="math notranslate nohighlight">\(1\)</span> has to be accessed by <code class="docutils literal notranslate"><span class="pre">d[P(1)]</span></code>, not
by <code class="docutils literal notranslate"><span class="pre">d[1]</span></code>.)</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Dictionaries are mutable. They do compare correctly,
but are not hashable and need to be cloned to avoid
spooky action at a distance. Be careful!</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">linear_extension</span></code> – (default: the default linear
extension of <code class="docutils literal notranslate"><span class="pre">self</span></code>) a linear extension of <code class="docutils literal notranslate"><span class="pre">self</span></code>
(as a linear extension or as a list), or more generally
a list of all elements of all elements of <code class="docutils literal notranslate"><span class="pre">self</span></code> each
occurring exactly once</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">prefix</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'x'</span></code>) the prefix to name
the indeterminates corresponding to the elements of
<code class="docutils literal notranslate"><span class="pre">self</span></code> in the labelling (so, setting it to
<code class="docutils literal notranslate"><span class="pre">'frog'</span></code> will result in these indeterminates being
called <code class="docutils literal notranslate"><span class="pre">frog1,</span> <span class="pre">frog2,</span> <span class="pre">...,</span> <span class="pre">frogn</span></code> rather than
<code class="docutils literal notranslate"><span class="pre">x1,</span> <span class="pre">x2,</span> <span class="pre">...,</span> <span class="pre">xn</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">base_field</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">QQ</span></code>) the base field to
be used instead of <span class="math notranslate nohighlight">\(\QQ\)</span> to define the rational
function field over; this is not going to be the base
field of the labelling, because the latter will have
indeterminates adjoined!</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reduced</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) if set to
<code class="docutils literal notranslate"><span class="pre">True</span></code>, the result will be the <em>reduced</em> birational
free labelling, which differs from the regular one by
having <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(1\)</span> both sent to <span class="math notranslate nohighlight">\(1\)</span> instead of <span class="math notranslate nohighlight">\(a\)</span> and
<span class="math notranslate nohighlight">\(b\)</span> (the indeterminates <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> then also won’t
appear in the ground field)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">addvars</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">''</span></code>) a string containing
names of extra variables to be adjoined to the ground
field (these don’t have an effect on the labels)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">labels</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'x'</span></code>) Either a function
that takes an element of the poset and returns a name
for the indeterminate corresponding to that element,
or a string containing a comma-separated list of
indeterminates that will be assigned to elements in
the order of <code class="docutils literal notranslate"><span class="pre">linear_extension</span></code>. If the
list contains more indeterminates than needed, the
excess will be ignored. If it contains too few, then
the needed indeterminates will be constructed from
<code class="docutils literal notranslate"><span class="pre">prefix</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">min_label</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'a'</span></code>) a string to be
used as the label for the element <span class="math notranslate nohighlight">\(0\)</span> of <span class="math notranslate nohighlight">\(\widehat{P}\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_label</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'b'</span></code>) a string to be
used as the label for the element <span class="math notranslate nohighlight">\(1\)</span> of <span class="math notranslate nohighlight">\(\widehat{P}\)</span></p></li>
</ul>
<p>OUTPUT:</p>
<p>The birational free labelling of the poset <code class="docutils literal notranslate"><span class="pre">self</span></code> and the
linear extension <code class="docutils literal notranslate"><span class="pre">linear_extension</span></code>. Or, if <code class="docutils literal notranslate"><span class="pre">reduced</span></code>
is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the reduced birational free labelling.</p>
<p>EXAMPLES:</p>
<p>We construct the birational free labelling on a simple
poset:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">();</span> <span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, x1), (2, x2), (3, x3)]</span>

<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span> <span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, x1), (2, x3), (3, x2)]</span>

<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">reduced</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">addvars</span><span class="o">=</span><span class="s2">&quot;spam, eggs&quot;</span><span class="p">);</span> <span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in x1, x2, x3, spam, eggs over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> 1,</span>
<span class="go"> 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, x1), (2, x3), (3, x2)]</span>

<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;wut&quot;</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">addvars</span><span class="o">=</span><span class="s2">&quot;spam, eggs&quot;</span><span class="p">);</span> <span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in wut1, wut2, wut3, spam, eggs over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> 1,</span>
<span class="go"> 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, wut1), (2, wut3), (3, wut2)]</span>

<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">reduced</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">addvars</span><span class="o">=</span><span class="s2">&quot;spam, eggs&quot;</span><span class="p">);</span> <span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b, spam, eggs over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, x1), (2, x3), (3, x2)]</span>
<span class="gp">sage: </span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
<span class="go">x3</span>
</pre></div>
</div>
<p>Illustrating labelling with a function:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span> <span class="p">:</span> <span class="s1">&#39;x_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[((0, 0), x_00), ((0, 1), x_01), ((1, 0), x_10), ((1, 1), x_11)]</span>
<span class="gp">sage: </span><span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">a</span>
</pre></div>
</div>
<p>The same, but with <code class="docutils literal notranslate"><span class="pre">min_label</span></code> and <code class="docutils literal notranslate"><span class="pre">max_label</span></code> provided:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span> <span class="p">:</span> <span class="s1">&#39;x_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">min_label</span><span class="o">=</span><span class="s2">&quot;lambda&quot;</span><span class="p">,</span> <span class="n">max_label</span><span class="o">=</span><span class="s2">&quot;mu&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[((0, 0), x_00), ((0, 1), x_01), ((1, 0), x_10), ((1, 1), x_11)]</span>
<span class="gp">sage: </span><span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">lambda</span>
<span class="gp">sage: </span><span class="n">l</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">mu</span>
</pre></div>
</div>
<p>Illustrating labelling with a comma separated list of labels:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="s1">&#39;w,x,y,z&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[((0, 0), w), ((0, 1), x), ((1, 0), y), ((1, 1), z)]</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="s1">&#39;w,x,y,z,m&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[((0, 0), w), ((0, 1), x), ((1, 0), y), ((1, 1), z)]</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[((0, 0), w), ((0, 1), x1), ((1, 0), x2), ((1, 1), x3)]</span>
</pre></div>
</div>
<p>Illustrating the warning about facade:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]},</span> <span class="n">facade</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">reduced</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">addvars</span><span class="o">=</span><span class="s2">&quot;spam, eggs&quot;</span><span class="p">);</span> <span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b, spam, eggs over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">KeyError: 2</span>
<span class="gp">sage: </span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
<span class="go">x3</span>
</pre></div>
</div>
<p>Another poset:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">SSTPoset</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">lext</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="n">lext</span><span class="p">,</span> <span class="n">addvars</span><span class="o">=</span><span class="s2">&quot;ohai&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, x4, x5, x6, x7, x8, b, ohai over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[([[1, 1], [2]], x1), ([[1, 1], [3]], x2), ([[1, 2], [2]], x3), ([[1, 2], [3]], x4),</span>
<span class="go"> ([[1, 3], [2]], x5), ([[1, 3], [3]], x6), ([[2, 2], [3]], x7), ([[2, 3], [3]], x8)]</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_rowmotion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">birational_rowmotion()</span></code></a>, <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggle" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">birational_toggle()</span></code></a> and
<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggles" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggles"><code class="xref py py-meth docutils literal notranslate"><span class="pre">birational_toggles()</span></code></a> for more substantial examples of what
one can do with the birational free labelling.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_rowmotion">
<span class="sig-name descname"><span class="pre">birational_rowmotion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labelling</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_rowmotion" title="Permalink to this definition">#</a></dt>
<dd><p>Return the result of applying birational rowmotion to the
<span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labelling <code class="docutils literal notranslate"><span class="pre">labelling</span></code> of the poset <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>See the documentation of <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">birational_free_labelling()</span></code></a>
for a definition of birational rowmotion and
<span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labellings and for an explanation of how
<span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labellings are to be encoded to be understood
by Sage. This implementation allows <span class="math notranslate nohighlight">\(\mathbf{K}\)</span> to be a
semifield, not just a field. Birational rowmotion is only a
rational map, so an exception (most likely, <code class="docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code>)
will be thrown if the denominator is zero.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">labelling</span></code> – a <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labelling of <code class="docutils literal notranslate"><span class="pre">self</span></code> in the
sense as defined in the documentation of
<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">birational_free_labelling()</span></code></a></p></li>
</ul>
<p>OUTPUT:</p>
<p>The image of the <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labelling <span class="math notranslate nohighlight">\(f\)</span> under birational
rowmotion.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">lex</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="n">lex</span><span class="p">);</span> <span class="n">t</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, x4, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, x1), (2, x2), (3, x3), (4, x4)]</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_rowmotion</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="n">t</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, x4, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, a*b/x4), (2, (x1*x2*b + x1*x3*b)/(x2*x4)),</span>
<span class="go"> (3, (x1*x2*b + x1*x3*b)/(x3*x4)), (4, (x2*b + x3*b)/x4)]</span>
</pre></div>
</div>
<p>A result of <a class="reference internal" href="../../../references/index.html#gr2013" id="id5"><span>[GR2013]</span></a> states that applying birational rowmotion
<span class="math notranslate nohighlight">\(n+m\)</span> times to a <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labelling <span class="math notranslate nohighlight">\(f\)</span> of the poset
<span class="math notranslate nohighlight">\([n] \times [m]\)</span> gives back <span class="math notranslate nohighlight">\(f\)</span>. Let us check this:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">test_rectangle_periodicity</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
<span class="gp">....: </span>    <span class="n">t0</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="n">t</span> <span class="o">=</span> <span class="n">t0</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="n">t</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_rowmotion</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">t</span> <span class="o">==</span> <span class="n">t0</span>
<span class="gp">sage: </span><span class="n">test_rectangle_periodicity</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_rectangle_periodicity</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">test_rectangle_periodicity</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># long time</span>
<span class="go">True</span>
</pre></div>
</div>
<p>While computations with the birational free labelling quickly
run out of memory due to the complexity of the rational
functions involved, it is computationally cheap to check
properties of birational rowmotion on examples in the tropical
semiring:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">test_rectangle_periodicity_tropical</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
<span class="gp">....: </span>    <span class="n">TT</span> <span class="o">=</span> <span class="n">TropicalSemiring</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="n">t0</span> <span class="o">=</span> <span class="p">(</span><span class="n">TT</span><span class="p">,</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">99</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">P</span><span class="p">},</span> <span class="n">TT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">TT</span><span class="p">(</span><span class="mi">124</span><span class="p">))</span>
<span class="gp">....: </span>    <span class="n">t</span> <span class="o">=</span> <span class="n">t0</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="n">t</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_rowmotion</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">t</span> <span class="o">==</span> <span class="n">t0</span>
<span class="gp">sage: </span><span class="n">test_rectangle_periodicity_tropical</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Tropicalization is also what relates birational rowmotion to
classical rowmotion on order ideals. In fact, if <span class="math notranslate nohighlight">\(T\)</span> denotes
the <a class="reference external" href="../../../semirings/sage/rings/semirings/tropical_semiring.html#sage.rings.semirings.tropical_semiring.TropicalSemiring" title="(in Standard Semirings v9.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tropical</span> <span class="pre">semiring</span></code></a> of
<span class="math notranslate nohighlight">\(\ZZ\)</span> and <span class="math notranslate nohighlight">\(P\)</span> is a finite poset, then we can define an embedding
<span class="math notranslate nohighlight">\(\phi\)</span> from the set <span class="math notranslate nohighlight">\(J(P)\)</span> of all order ideals of <span class="math notranslate nohighlight">\(P\)</span> into the
set <span class="math notranslate nohighlight">\(T^{\widehat{P}}\)</span> of all <span class="math notranslate nohighlight">\(T\)</span>-labellings of <span class="math notranslate nohighlight">\(P\)</span> by sending
every <span class="math notranslate nohighlight">\(I \in J(P)\)</span> to the indicator function of <span class="math notranslate nohighlight">\(I\)</span> extended by
the value <span class="math notranslate nohighlight">\(1\)</span> at the element <span class="math notranslate nohighlight">\(0\)</span> and the value <span class="math notranslate nohighlight">\(0\)</span> at the
element <span class="math notranslate nohighlight">\(1\)</span>. This map <span class="math notranslate nohighlight">\(\phi\)</span> has the property that
<span class="math notranslate nohighlight">\(R \circ \phi = \phi \circ r\)</span>, where <span class="math notranslate nohighlight">\(R\)</span> denotes birational
rowmotion, and <span class="math notranslate nohighlight">\(r\)</span> denotes <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classical</span> <span class="pre">rowmotion</span></code></a>
on <span class="math notranslate nohighlight">\(J(P)\)</span>. An example:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">IntegerPartitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">TT</span> <span class="o">=</span> <span class="n">TropicalSemiring</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">indicator_labelling</span><span class="p">(</span><span class="n">I</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="c1"># send order ideal `I` to a `T`-labelling of `P`.</span>
<span class="gp">....: </span>    <span class="n">dct</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="n">v</span> <span class="ow">in</span> <span class="n">I</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">P</span><span class="p">}</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="p">(</span><span class="n">TT</span><span class="p">,</span> <span class="n">dct</span><span class="p">,</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">TT</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">indicator_labelling</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion</span><span class="p">(</span><span class="n">I</span><span class="p">))</span>
<span class="gp">....: </span>    <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_rowmotion</span><span class="p">(</span><span class="n">indicator_labelling</span><span class="p">(</span><span class="n">I</span><span class="p">))</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">order_ideals_lattice</span><span class="p">(</span><span class="n">facade</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggle">
<span class="sig-name descname"><span class="pre">birational_toggle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labelling</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggle" title="Permalink to this definition">#</a></dt>
<dd><p>Return the result of applying the birational <span class="math notranslate nohighlight">\(v\)</span>-toggle <span class="math notranslate nohighlight">\(T_v\)</span>
to the <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labelling <code class="docutils literal notranslate"><span class="pre">labelling</span></code> of the poset <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>See the documentation of <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">birational_free_labelling()</span></code></a>
for a definition of this toggle and of <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labellings as
well as an explanation of how <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labellings are to be
encoded to be understood by Sage. This implementation allows
<span class="math notranslate nohighlight">\(\mathbf{K}\)</span> to be a semifield, not just a field. The birational
<span class="math notranslate nohighlight">\(v\)</span>-toggle is only a rational map, so an exception (most
likely, <code class="docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code>) will be thrown if the
denominator is zero.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">v</span></code> – an element of <code class="docutils literal notranslate"><span class="pre">self</span></code> (must have <code class="docutils literal notranslate"><span class="pre">self</span></code> as
parent if <code class="docutils literal notranslate"><span class="pre">self</span></code> is a <code class="docutils literal notranslate"><span class="pre">facade=False</span></code> poset)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">labelling</span></code> – a <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labelling of <code class="docutils literal notranslate"><span class="pre">self</span></code> in the
sense as defined in the documentation of
<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">birational_free_labelling()</span></code></a></p></li>
</ul>
<p>OUTPUT:</p>
<p>The <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labelling <span class="math notranslate nohighlight">\(T_v f\)</span> of <code class="docutils literal notranslate"><span class="pre">self</span></code>, where <span class="math notranslate nohighlight">\(f\)</span> is
<code class="docutils literal notranslate"><span class="pre">labelling</span></code>.</p>
<p>EXAMPLES:</p>
<p>Let us start with the birational free labelling of the
“V”-poset (the three-element poset with Hasse diagram looking
like a “V”):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">();</span> <span class="n">s</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, x1), (2, x2), (3, x3)]</span>
</pre></div>
</div>
<p>The image of <span class="math notranslate nohighlight">\(s\)</span> under the <span class="math notranslate nohighlight">\(1\)</span>-toggle <span class="math notranslate nohighlight">\(T_1\)</span> is:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s1</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span> <span class="n">s1</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, a*x2*x3/(x1*x2 + x1*x3)), (2, x2), (3, x3)]</span>
</pre></div>
</div>
<p>Now let us apply the <span class="math notranslate nohighlight">\(2\)</span>-toggle <span class="math notranslate nohighlight">\(T_2\)</span> (to the old <code class="docutils literal notranslate"><span class="pre">s</span></code>):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s2</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span> <span class="n">s2</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, x1), (2, x1*b/x2), (3, x3)]</span>
</pre></div>
</div>
<p>On the other hand, we can also apply <span class="math notranslate nohighlight">\(T_2\)</span> to the image of <span class="math notranslate nohighlight">\(s\)</span>
under <span class="math notranslate nohighlight">\(T_1\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s12</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">s1</span><span class="p">);</span> <span class="n">s12</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">s12</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, a*x2*x3/(x1*x2 + x1*x3)), (2, a*x3*b/(x1*x2 + x1*x3)), (3, x3)]</span>
</pre></div>
</div>
<p>Each toggle is an involution:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="o">==</span> <span class="n">s</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">V</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We can also start with a less generic labelling:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">7</span><span class="p">},</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span> <span class="n">t1</span>
<span class="go">(Rational Field, {...}, 2, 10)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, 28/13), (2, 6), (3, 7)]</span>
<span class="gp">sage: </span><span class="n">t13</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">t1</span><span class="p">);</span> <span class="n">t13</span>
<span class="go">(Rational Field, {...}, 2, 10)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t13</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, 28/13), (2, 6), (3, 40/13)]</span>
</pre></div>
</div>
<p>However, labellings have to be sufficiently generic, lest
denominators vanish:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="o">-</span><span class="mi">5</span><span class="p">},</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ZeroDivisionError: rational division by zero</span>
</pre></div>
</div>
<p>We don’t get into zero-division issues in the tropical
semiring (unless the zero of the tropical semiring appears
in the labelling):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">TT</span> <span class="o">=</span> <span class="n">TropicalSemiring</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">TT</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="mi">3</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">)},</span> <span class="n">TT</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="n">TT</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span> <span class="n">t1</span>
<span class="go">(Tropical semiring over Rational Field, {...}, 6, 0)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, 8), (2, 4), (3, 1)]</span>
<span class="gp">sage: </span><span class="n">t12</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">t1</span><span class="p">);</span> <span class="n">t12</span>
<span class="go">(Tropical semiring over Rational Field, {...}, 6, 0)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t12</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, 8), (2, 4), (3, 1)]</span>
<span class="gp">sage: </span><span class="n">t123</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">t12</span><span class="p">);</span> <span class="n">t123</span>
<span class="go">(Tropical semiring over Rational Field, {...}, 6, 0)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t123</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, 8), (2, 4), (3, 7)]</span>
</pre></div>
</div>
<p>We turn to more interesting posets. Here is the <span class="math notranslate nohighlight">\(6\)</span>-element
poset arising from the weak order on <span class="math notranslate nohighlight">\(S_3\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">SymmetricGroupWeakOrderPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">))</span>
<span class="go">[&#39;123&#39;, &#39;132&#39;, &#39;213&#39;, &#39;231&#39;, &#39;312&#39;, &#39;321&#39;]</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">TT</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;123&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="s1">&#39;132&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="s1">&#39;213&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;231&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;321&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;312&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">2</span><span class="p">)},</span> <span class="n">TT</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="s1">&#39;123&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span> <span class="n">t1</span>
<span class="go">(Tropical semiring over Rational Field, {...}, 7, 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;123&#39;, 6), (&#39;132&#39;, 2), (&#39;213&#39;, 3), (&#39;231&#39;, 1), (&#39;312&#39;, 2), (&#39;321&#39;, 1)]</span>
<span class="gp">sage: </span><span class="n">t13</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="s1">&#39;213&#39;</span><span class="p">,</span> <span class="n">t1</span><span class="p">);</span> <span class="n">t13</span>
<span class="go">(Tropical semiring over Rational Field, {...}, 7, 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t13</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;123&#39;, 6), (&#39;132&#39;, 2), (&#39;213&#39;, 4), (&#39;231&#39;, 1), (&#39;312&#39;, 2), (&#39;321&#39;, 1)]</span>
</pre></div>
</div>
<p>Let us verify on this example some basic properties of
toggles. First of all, again let us check that <span class="math notranslate nohighlight">\(T_v\)</span> is an
involution for every <span class="math notranslate nohighlight">\(v\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span> <span class="o">==</span> <span class="n">t</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">P</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Furthermore, two toggles <span class="math notranslate nohighlight">\(T_v\)</span> and <span class="math notranslate nohighlight">\(T_w\)</span> commute unless
one of <span class="math notranslate nohighlight">\(v\)</span> or <span class="math notranslate nohighlight">\(w\)</span> covers the other:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">P</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">or</span> <span class="n">P</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="gp">....: </span>     <span class="ow">or</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
<span class="gp">....: </span>        <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">P</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">P</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggles">
<span class="sig-name descname"><span class="pre">birational_toggles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labelling</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggles" title="Permalink to this definition">#</a></dt>
<dd><p>Return the result of applying a sequence of birational
toggles (specified by <code class="docutils literal notranslate"><span class="pre">vs</span></code>) to the <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labelling
<code class="docutils literal notranslate"><span class="pre">labelling</span></code> of the poset <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>See the documentation of <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">birational_free_labelling()</span></code></a>
for a definition of birational toggles and <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labellings
and for an explanation of how <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labellings are to be
encoded to be understood by Sage. This implementation allows
<span class="math notranslate nohighlight">\(\mathbf{K}\)</span> to be a semifield, not just a field. The birational
<span class="math notranslate nohighlight">\(v\)</span>-toggle is only a rational map, so an exception (most
likely, <code class="docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code>) will be thrown if the
denominator is zero.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vs</span></code> – an iterable comprising elements of <code class="docutils literal notranslate"><span class="pre">self</span></code>
(which must have <code class="docutils literal notranslate"><span class="pre">self</span></code> as parent if <code class="docutils literal notranslate"><span class="pre">self</span></code> is a
<code class="docutils literal notranslate"><span class="pre">facade=False</span></code> poset)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">labelling</span></code> – a <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labelling of <code class="docutils literal notranslate"><span class="pre">self</span></code> in the
sense as defined in the documentation of
<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">birational_free_labelling()</span></code></a></p></li>
</ul>
<p>OUTPUT:</p>
<p>The <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labelling <span class="math notranslate nohighlight">\(T_{v_n} T_{v_{n-1}} \cdots T_{v_1} f\)</span>
of <code class="docutils literal notranslate"><span class="pre">self</span></code>, where <span class="math notranslate nohighlight">\(f\)</span> is <code class="docutils literal notranslate"><span class="pre">labelling</span></code> and
<span class="math notranslate nohighlight">\((v_1, v_2, \ldots, v_n)\)</span> is <code class="docutils literal notranslate"><span class="pre">vs</span></code> (written as list).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">SymmetricGroupBruhatOrderPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">))</span>
<span class="go">[&#39;123&#39;, &#39;132&#39;, &#39;213&#39;, &#39;231&#39;, &#39;312&#39;, &#39;321&#39;]</span>
<span class="gp">sage: </span><span class="n">TT</span> <span class="o">=</span> <span class="n">TropicalSemiring</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">TT</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;123&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="s1">&#39;132&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="s1">&#39;213&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;231&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;321&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;312&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">2</span><span class="p">)},</span> <span class="n">TT</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">tA</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggles</span><span class="p">([</span><span class="s1">&#39;123&#39;</span><span class="p">,</span> <span class="s1">&#39;231&#39;</span><span class="p">,</span> <span class="s1">&#39;312&#39;</span><span class="p">],</span> <span class="n">t</span><span class="p">);</span> <span class="n">tA</span>
<span class="go">(Tropical semiring over Integer Ring, {...}, 7, 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">tA</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;123&#39;, 6), (&#39;132&#39;, 2), (&#39;213&#39;, 3), (&#39;231&#39;, 2), (&#39;312&#39;, 1), (&#39;321&#39;, 1)]</span>
<span class="gp">sage: </span><span class="n">tAB</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggles</span><span class="p">([</span><span class="s1">&#39;132&#39;</span><span class="p">,</span> <span class="s1">&#39;213&#39;</span><span class="p">,</span> <span class="s1">&#39;321&#39;</span><span class="p">],</span> <span class="n">tA</span><span class="p">);</span> <span class="n">tAB</span>
<span class="go">(Tropical semiring over Integer Ring, {...}, 7, 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">tAB</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;123&#39;, 6), (&#39;132&#39;, 6), (&#39;213&#39;, 5), (&#39;231&#39;, 2), (&#39;312&#39;, 1), (&#39;321&#39;, 1)]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">Qx</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">Qx</span><span class="o">.</span><span class="n">gen</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">Qx</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="p">},</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggles</span><span class="p">((</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)),</span> <span class="n">t</span><span class="p">);</span> <span class="n">t1</span>
<span class="go">(Fraction Field of Univariate Polynomial Ring in x over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> 1,</span>
<span class="go"> 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, (x^2 + x)/(x^2 + x + 1)), (2, (x^3 + x^2)/(x^2 + x + 1)), (3, x^4/(x^2 + x + 1)), (4, 1)]</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggles</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)),</span> <span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, 1/x^2), (2, (x^2 + x + 1)/x^4), (3, (x^2 + x + 1)/(x^3 + x^2)), (4, (x^2 + x + 1)/x^3)]</span>
</pre></div>
</div>
<p>Facade set to <code class="docutils literal notranslate"><span class="pre">False</span></code> works:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">],</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">],</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]},</span> <span class="n">facade</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">lex</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="n">lex</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">birational_toggles</span><span class="p">([</span><span class="n">P</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">P</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)],</span> <span class="n">t</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(x, a*x2*x3/(x1*x2 + x1*x3)), (y, a*x3*x4/(x1*x2 + x1*x3)), (w, x3), (z, x4)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.finite_posets.FinitePosets.ParentMethods.directed_subsets">
<span class="sig-name descname"><span class="pre">directed_subsets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">direction</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.directed_subsets" title="Permalink to this definition">#</a></dt>
<dd><p>Return the order filters (resp. order ideals) of <code class="docutils literal notranslate"><span class="pre">self</span></code>, as lists.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">direction</span></code> is ‘up’, returns the order filters (upper sets).</p>
<p>If <code class="docutils literal notranslate"><span class="pre">direction</span></code> is ‘down’, returns the order ideals (lower sets).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">direction</span></code> – ‘up’ or ‘down’</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">directed_subsets</span><span class="p">(</span><span class="s1">&#39;up&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="go">[[], [1, 2, 4, 3, 6, 12], [2, 4, 3, 6, 12], [2, 4, 6, 12], [3, 6, 12], [4, 3, 6, 12], [4, 6, 12], [4, 12], [6, 12], [12]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.finite_posets.FinitePosets.ParentMethods.is_lattice">
<span class="sig-name descname"><span class="pre">is_lattice</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.is_lattice" title="Permalink to this definition">#</a></dt>
<dd><p>Return whether the poset is a lattice.</p>
<p>A poset is a lattice if all pairs of elements have
both a least upper bound (“join”) and a greatest lower bound
(“meet”) in the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="p">[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lattice</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lattice</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lattice</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span>
<span class="gp">....: </span>           <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="mi">7</span><span class="p">:</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="mi">8</span><span class="p">:</span> <span class="p">[</span><span class="mi">11</span><span class="p">],</span> <span class="mi">9</span><span class="p">:</span> <span class="p">[</span><span class="mi">11</span><span class="p">],</span> <span class="mi">10</span><span class="p">:</span> <span class="p">[</span><span class="mi">11</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lattice</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p>Weaker properties: <a class="reference external" href="../../../combinat/sage/combinat/posets/posets.html#sage.combinat.posets.posets.FinitePoset.is_join_semilattice" title="(in Combinatorics v9.8)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_join_semilattice()</span></code></a>,
<a class="reference external" href="../../../combinat/sage/combinat/posets/posets.html#sage.combinat.posets.posets.FinitePoset.is_meet_semilattice" title="(in Combinatorics v9.8)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_meet_semilattice()</span></code></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.finite_posets.FinitePosets.ParentMethods.is_poset_isomorphism">
<span class="sig-name descname"><span class="pre">is_poset_isomorphism</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">codomain</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.is_poset_isomorphism" title="Permalink to this definition">#</a></dt>
<dd><p>Return whether <span class="math notranslate nohighlight">\(f\)</span> is an isomorphism of posets from
<code class="docutils literal notranslate"><span class="pre">self</span></code> to <code class="docutils literal notranslate"><span class="pre">codomain</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">f</span></code> – a function from <code class="docutils literal notranslate"><span class="pre">self</span></code> to <code class="docutils literal notranslate"><span class="pre">codomain</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">codomain</span></code> – a poset</p></li>
</ul>
<p>EXAMPLES:</p>
<p>We build the poset <span class="math notranslate nohighlight">\(D\)</span> of divisors of 30, and check that
it is isomorphic to the boolean lattice <span class="math notranslate nohighlight">\(B\)</span> of the subsets
of <span class="math notranslate nohighlight">\(\{2,3,5\}\)</span> ordered by inclusion, via the reverse
function <span class="math notranslate nohighlight">\(f: B \to D, b \mapsto \prod_{x\in b} x\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Subsets</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">])],</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;issubset&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">D</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_poset_isomorphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>On the other hand, <span class="math notranslate nohighlight">\(f\)</span> is not an isomorphism to the chain
of divisors of 30, ordered by usual comparison:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">))</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">P</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_poset_isomorphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A non surjective case:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Subsets</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])],</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;issubset&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">D</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_poset_isomorphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A non injective case:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Subsets</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])],</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;issubset&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">D</span><span class="p">(</span><span class="n">gcd</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="mi">30</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_poset_isomorphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>since <code class="docutils literal notranslate"><span class="pre">D</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> are not facade posets, <code class="docutils literal notranslate"><span class="pre">f</span></code> is
responsible for the conversions between integers and subsets to
elements of <code class="docutils literal notranslate"><span class="pre">D</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> and back.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="finite_lattice_posets.html#sage.categories.finite_lattice_posets.FiniteLatticePosets.ParentMethods.is_lattice_morphism" title="sage.categories.finite_lattice_posets.FiniteLatticePosets.ParentMethods.is_lattice_morphism"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FiniteLatticePosets.ParentMethods.is_lattice_morphism()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.finite_posets.FinitePosets.ParentMethods.is_poset_morphism">
<span class="sig-name descname"><span class="pre">is_poset_morphism</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">codomain</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.is_poset_morphism" title="Permalink to this definition">#</a></dt>
<dd><p>Return whether <span class="math notranslate nohighlight">\(f\)</span> is a morphism of posets from <code class="docutils literal notranslate"><span class="pre">self</span></code>
to <code class="docutils literal notranslate"><span class="pre">codomain</span></code>, that is</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[x\leq y \Longrightarrow f(x) \leq f(y)\]</div>
</div>
<p>for all <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">f</span></code> – a function from <code class="docutils literal notranslate"><span class="pre">self</span></code> to <code class="docutils literal notranslate"><span class="pre">codomain</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">codomain</span></code> – a poset</p></li>
</ul>
<p>EXAMPLES:</p>
<p>We build the boolean lattice of the subsets of
<span class="math notranslate nohighlight">\(\{2,3,5,6\}\)</span> and the lattice of divisors of <span class="math notranslate nohighlight">\(30\)</span>, and
check that the map <span class="math notranslate nohighlight">\(b \mapsto \gcd(\prod_{x\in b} x, 30)\)</span>
is a morphism of posets:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Subsets</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])],</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;issubset&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">D</span><span class="p">(</span><span class="n">gcd</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="mi">30</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_poset_morphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>since <code class="docutils literal notranslate"><span class="pre">D</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> are not facade posets, <code class="docutils literal notranslate"><span class="pre">f</span></code> is responsible
for the conversions between integers and subsets to elements of
<code class="docutils literal notranslate"><span class="pre">D</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> and back.</p>
</div>
<p><span class="math notranslate nohighlight">\(f\)</span> is also a morphism of posets to the chain of divisors
of 30, ordered by usual comparison:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">))</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">P</span><span class="p">(</span><span class="n">gcd</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="mi">30</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_poset_morphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>FIXME: should this be <code class="docutils literal notranslate"><span class="pre">is_order_preserving_morphism</span></code>?</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.is_poset_isomorphism" title="sage.categories.finite_posets.FinitePosets.ParentMethods.is_poset_isomorphism"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_poset_isomorphism()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.finite_posets.FinitePosets.ParentMethods.is_self_dual">
<span class="sig-name descname"><span class="pre">is_self_dual</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.is_self_dual" title="Permalink to this definition">#</a></dt>
<dd><p>Return whether the poset is <em>self-dual</em>.</p>
<p>A poset is self-dual if it is isomorphic to its dual poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_self_dual</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_self_dual</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p>Stronger properties: <a class="reference external" href="../../../combinat/sage/combinat/posets/lattices.html#sage.combinat.posets.lattices.FiniteLatticePoset.is_orthocomplemented" title="(in Combinatorics v9.8)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_orthocomplemented()</span></code></a> (for lattices)</p></li>
<li><p>Other: <a class="reference external" href="../../../combinat/sage/combinat/posets/posets.html#sage.combinat.posets.posets.FinitePoset.dual" title="(in Combinatorics v9.8)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dual()</span></code></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.finite_posets.FinitePosets.ParentMethods.order_filter_generators">
<span class="sig-name descname"><span class="pre">order_filter_generators</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filter</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.order_filter_generators" title="Permalink to this definition">#</a></dt>
<dd><p>Generators for an order filter</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">filter</span></code> – an order filter of <code class="docutils literal notranslate"><span class="pre">self</span></code>, as a list (or iterable)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">Subsets</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;issubset&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_filter</span><span class="p">([</span><span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span> <span class="n">Set</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">])])</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">I</span><span class="p">)</span>
<span class="go">[[1], [1, 2], [1, 2, 3], [1, 3], [2, 3]]</span>
<span class="gp">sage: </span><span class="n">gen</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_filter_generators</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">gen</span><span class="p">)</span>
<span class="go">[[1], [2, 3]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideal_generators" title="sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideal_generators"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_ideal_generators()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideal_complement_generators">
<span class="sig-name descname"><span class="pre">order_ideal_complement_generators</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">antichain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'up'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideal_complement_generators" title="Permalink to this definition">#</a></dt>
<dd><p>Return the Panyushev complement of the antichain
<code class="docutils literal notranslate"><span class="pre">antichain</span></code>.</p>
<p>Given an antichain <span class="math notranslate nohighlight">\(A\)</span> of a poset <span class="math notranslate nohighlight">\(P\)</span>, the Panyushev
complement of <span class="math notranslate nohighlight">\(A\)</span> is defined to be the antichain consisting
of the minimal elements of the order filter <span class="math notranslate nohighlight">\(B\)</span>, where <span class="math notranslate nohighlight">\(B\)</span>
is the (set-theoretic) complement of the order ideal of
<span class="math notranslate nohighlight">\(P\)</span> generated by <span class="math notranslate nohighlight">\(A\)</span>.</p>
<p>Setting the optional keyword variable <code class="docutils literal notranslate"><span class="pre">direction</span></code> to
<code class="docutils literal notranslate"><span class="pre">'down'</span></code> leads to the inverse Panyushev complement being
computed instead of the Panyushev complement. The inverse
Panyushev complement of an antichain <span class="math notranslate nohighlight">\(A\)</span> is the antichain
whose Panyushev complement is <span class="math notranslate nohighlight">\(A\)</span>. It can be found as the
antichain consisting of the maximal elements of the order
ideal <span class="math notranslate nohighlight">\(C\)</span>, where <span class="math notranslate nohighlight">\(C\)</span> is the (set-theoretic) complement of
the order filter of <span class="math notranslate nohighlight">\(P\)</span> generated by <span class="math notranslate nohighlight">\(A\)</span>.</p>
<p><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement" title="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">panyushev_complement()</span></code></a> is an alias for this method.</p>
<p>Panyushev complementation is related (actually, isomorphic)
to rowmotion (<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rowmotion()</span></code></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">antichain</span></code> – an antichain of <code class="docutils literal notranslate"><span class="pre">self</span></code>, as a list (or
iterable), or, more generally, generators of an order ideal
(resp. order filter)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">direction</span></code> – ‘up’ or ‘down’ (default: ‘up’)</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>the generating antichain of the complement order filter
(resp. order ideal) of the order ideal (resp. order filter)
generated by the antichain <code class="docutils literal notranslate"><span class="pre">antichain</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">{2}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="go">set()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">{3}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">set()</span>

<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">{2}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">3</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">{1, 2}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">set()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">set()</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is a brute force implementation, building the
order ideal generated by the antichain, and searching
for order filter generators of its complement</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideal_generators">
<span class="sig-name descname"><span class="pre">order_ideal_generators</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ideal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'down'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideal_generators" title="Permalink to this definition">#</a></dt>
<dd><p>Return the antichain of (minimal) generators of the order
ideal (resp. order filter) <code class="docutils literal notranslate"><span class="pre">ideal</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ideal</span></code> – an order ideal <span class="math notranslate nohighlight">\(I\)</span> (resp. order filter)
of <code class="docutils literal notranslate"><span class="pre">self</span></code>, as a list (or iterable); this should be
an order ideal if <code class="docutils literal notranslate"><span class="pre">direction</span></code> is set to <code class="docutils literal notranslate"><span class="pre">'down'</span></code>,
and an order filter if <code class="docutils literal notranslate"><span class="pre">direction</span></code> is set to
<code class="docutils literal notranslate"><span class="pre">'up'</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">direction</span></code> – <code class="docutils literal notranslate"><span class="pre">'up'</span></code> or <code class="docutils literal notranslate"><span class="pre">'down'</span></code> (default:
<code class="docutils literal notranslate"><span class="pre">'down'</span></code>).</p></li>
</ul>
<p>The antichain of (minimal) generators of an order ideal
<span class="math notranslate nohighlight">\(I\)</span> in a poset <span class="math notranslate nohighlight">\(P\)</span> is the set of all minimal elements of
<span class="math notranslate nohighlight">\(P\)</span>. In the case of an order filter, the definition is
similar, but with “maximal” used instead of “minimal”.</p>
<p>EXAMPLES:</p>
<p>We build the boolean lattice of all subsets of <span class="math notranslate nohighlight">\(\{1,2,3\}\)</span>
ordered by inclusion, and compute an order ideal there:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">Subsets</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;issubset&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_ideal</span><span class="p">([</span><span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span> <span class="n">Set</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">])])</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">I</span><span class="p">)</span>
<span class="go">[[], [1], [1, 2], [2], [2, 3], [3]]</span>
</pre></div>
</div>
<p>Then, we retrieve the generators of this ideal:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">gen</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_ideal_generators</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">gen</span><span class="p">)</span>
<span class="go">[[1, 2], [2, 3]]</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">direction</span></code> is ‘up’, then this instead computes
the minimal generators for an order filter:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_filter</span><span class="p">([</span><span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span> <span class="n">Set</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">])])</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">I</span><span class="p">)</span>
<span class="go">[[1], [1, 2], [1, 2, 3], [1, 3], [2, 3]]</span>
<span class="gp">sage: </span><span class="n">gen</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_ideal_generators</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;up&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">gen</span><span class="p">)</span>
<span class="go">[[1], [2, 3]]</span>
</pre></div>
</div>
<p>Complexity: <span class="math notranslate nohighlight">\(O(n+m)\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the cardinality of <span class="math notranslate nohighlight">\(I\)</span>,
and <span class="math notranslate nohighlight">\(m\)</span> the number of upper covers of elements of <span class="math notranslate nohighlight">\(I\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideals_lattice">
<span class="sig-name descname"><span class="pre">order_ideals_lattice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">as_ideals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">facade</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideals_lattice" title="Permalink to this definition">#</a></dt>
<dd><p>Return the lattice of order ideals of a poset <code class="docutils literal notranslate"><span class="pre">self</span></code>,
ordered by inclusion.</p>
<p>The lattice of order ideals of a poset <span class="math notranslate nohighlight">\(P\)</span> is usually
denoted by <span class="math notranslate nohighlight">\(J(P)\)</span>. Its underlying set is the set of order
ideals of <span class="math notranslate nohighlight">\(P\)</span>, and its partial order is given by
inclusion.</p>
<p>The order ideals of <span class="math notranslate nohighlight">\(P\)</span> are in a canonical bijection
with the antichains of <span class="math notranslate nohighlight">\(P\)</span>. The bijection maps every
order ideal to the antichain formed by its maximal
elements. By setting the <code class="docutils literal notranslate"><span class="pre">as_ideals</span></code> keyword variable to
<code class="docutils literal notranslate"><span class="pre">False</span></code>, one can make this method apply this bijection
before returning the lattice.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">as_ideals</span></code> – Boolean, if <code class="docutils literal notranslate"><span class="pre">True</span></code> (default) returns
a poset on the set of order ideals, otherwise on the set
of antichains</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">facade</span></code> – Boolean or <code class="docutils literal notranslate"><span class="pre">None</span></code> (default). Whether to
return a facade lattice or not. By default return facade
lattice if the poset is a facade poset.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[0, 1], [0, 2], [1, 4], [2, 3], [3, 4]]</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_ideals_lattice</span><span class="p">();</span> <span class="n">J</span>
<span class="go">Finite lattice containing 8 elements</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">J</span><span class="p">)</span>
<span class="go"> [[], [0], [0, 1], [0, 1, 2], [0, 1, 2, 3], [0, 1, 2, 3, 4], [0, 2], [0, 2, 3]]</span>
</pre></div>
</div>
<p>As a lattice on antichains:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">J2</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_ideals_lattice</span><span class="p">(</span><span class="kc">False</span><span class="p">);</span> <span class="n">J2</span>
<span class="go">Finite lattice containing 8 elements</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">J2</span><span class="p">)</span>
<span class="go">[(), (0,), (1,), (1, 2), (1, 3), (2,), (3,), (4,)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement">
<span class="sig-name descname"><span class="pre">panyushev_complement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">antichain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'up'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement" title="Permalink to this definition">#</a></dt>
<dd><p>Return the Panyushev complement of the antichain
<code class="docutils literal notranslate"><span class="pre">antichain</span></code>.</p>
<p>Given an antichain <span class="math notranslate nohighlight">\(A\)</span> of a poset <span class="math notranslate nohighlight">\(P\)</span>, the Panyushev
complement of <span class="math notranslate nohighlight">\(A\)</span> is defined to be the antichain consisting
of the minimal elements of the order filter <span class="math notranslate nohighlight">\(B\)</span>, where <span class="math notranslate nohighlight">\(B\)</span>
is the (set-theoretic) complement of the order ideal of
<span class="math notranslate nohighlight">\(P\)</span> generated by <span class="math notranslate nohighlight">\(A\)</span>.</p>
<p>Setting the optional keyword variable <code class="docutils literal notranslate"><span class="pre">direction</span></code> to
<code class="docutils literal notranslate"><span class="pre">'down'</span></code> leads to the inverse Panyushev complement being
computed instead of the Panyushev complement. The inverse
Panyushev complement of an antichain <span class="math notranslate nohighlight">\(A\)</span> is the antichain
whose Panyushev complement is <span class="math notranslate nohighlight">\(A\)</span>. It can be found as the
antichain consisting of the maximal elements of the order
ideal <span class="math notranslate nohighlight">\(C\)</span>, where <span class="math notranslate nohighlight">\(C\)</span> is the (set-theoretic) complement of
the order filter of <span class="math notranslate nohighlight">\(P\)</span> generated by <span class="math notranslate nohighlight">\(A\)</span>.</p>
<p><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement" title="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">panyushev_complement()</span></code></a> is an alias for this method.</p>
<p>Panyushev complementation is related (actually, isomorphic)
to rowmotion (<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rowmotion()</span></code></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">antichain</span></code> – an antichain of <code class="docutils literal notranslate"><span class="pre">self</span></code>, as a list (or
iterable), or, more generally, generators of an order ideal
(resp. order filter)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">direction</span></code> – ‘up’ or ‘down’ (default: ‘up’)</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>the generating antichain of the complement order filter
(resp. order ideal) of the order ideal (resp. order filter)
generated by the antichain <code class="docutils literal notranslate"><span class="pre">antichain</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">{2}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="go">set()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">{3}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">set()</span>

<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">{2}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">3</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">{1, 2}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">set()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">set()</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is a brute force implementation, building the
order ideal generated by the antichain, and searching
for order filter generators of its complement</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_orbit_iter">
<span class="sig-name descname"><span class="pre">panyushev_orbit_iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">antichain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">element_constructor=&lt;class</span> <span class="pre">'set'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check=True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_orbit_iter" title="Permalink to this definition">#</a></dt>
<dd><p>Iterate over the Panyushev orbit of an antichain
<code class="docutils literal notranslate"><span class="pre">antichain</span></code> of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The Panyushev orbit of an antichain is its orbit under
Panyushev complementation (see
<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement" title="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">panyushev_complement()</span></code></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">antichain</span></code> – an antichain of <code class="docutils literal notranslate"><span class="pre">self</span></code>, given as an
iterable.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">element_constructor</span></code> (defaults to <code class="docutils literal notranslate"><span class="pre">set</span></code>) – a type
constructor (<code class="docutils literal notranslate"><span class="pre">set</span></code>, <code class="docutils literal notranslate"><span class="pre">tuple</span></code>, <code class="docutils literal notranslate"><span class="pre">list</span></code>, <code class="docutils literal notranslate"><span class="pre">frozenset</span></code>,
<code class="docutils literal notranslate"><span class="pre">iter</span></code>, etc.) which is to be applied to the antichains
before they are yielded.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">stop</span></code> – a Boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) determining
whether the iterator should stop once it completes its
cycle (this happens when it is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>) or go on
forever (this happens when it is set to <code class="docutils literal notranslate"><span class="pre">False</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – a Boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) determining
whether <code class="docutils literal notranslate"><span class="pre">antichain</span></code> should be checked for being an
antichain.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>an iterator over the orbit of the antichain <code class="docutils literal notranslate"><span class="pre">antichain</span></code>
under Panyushev complementation. This iterator <span class="math notranslate nohighlight">\(I\)</span> has the
property that <code class="docutils literal notranslate"><span class="pre">I[0]</span> <span class="pre">==</span> <span class="pre">antichain</span></code> and each <span class="math notranslate nohighlight">\(i\)</span> satisfies
<code class="docutils literal notranslate"><span class="pre">self.order_ideal_complement_generators(I[i])</span> <span class="pre">==</span> <span class="pre">I[i+1]</span></code>,
where <code class="docutils literal notranslate"><span class="pre">I[i+1]</span></code> has to be understood as <code class="docutils literal notranslate"><span class="pre">I[0]</span></code> if it is
undefined.
The entries <code class="docutils literal notranslate"><span class="pre">I[i]</span></code> are sets by default, but depending on
the optional keyword variable <code class="docutils literal notranslate"><span class="pre">element_constructors</span></code>
they can also be tuples, lists etc.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])))</span>
<span class="go">[{1, 2}, {3}, set()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[{1, 2}, {3}, set()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="go">[{1, 2}, {3}, set()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">list</span><span class="p">))</span>
<span class="go">[[1, 2], [3], []]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">))</span>
<span class="go">[frozenset({1, 2}), frozenset({3}), frozenset()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">))</span>
<span class="go">[(1, 2), (3,), ()]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">([]))</span>
<span class="go">[set()]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[]</span> <span class="p">})</span>
<span class="gp">sage: </span><span class="n">Piter</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">([</span><span class="mi">2</span><span class="p">],</span> <span class="n">stop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{2}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{3}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{2}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{3}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_orbits">
<span class="sig-name descname"><span class="pre">panyushev_orbits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element_constructor=&lt;class</span> <span class="pre">'set'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_orbits" title="Permalink to this definition">#</a></dt>
<dd><p>Return the Panyushev orbits of antichains in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The Panyushev orbit of an antichain is its orbit under
Panyushev complementation (see
<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement" title="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">panyushev_complement()</span></code></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">element_constructor</span></code> (defaults to <code class="docutils literal notranslate"><span class="pre">set</span></code>) – a type
constructor (<code class="docutils literal notranslate"><span class="pre">set</span></code>, <code class="docutils literal notranslate"><span class="pre">tuple</span></code>, <code class="docutils literal notranslate"><span class="pre">list</span></code>, <code class="docutils literal notranslate"><span class="pre">frozenset</span></code>,
<code class="docutils literal notranslate"><span class="pre">iter</span></code>, etc.) which is to be applied to the antichains
before they are returned.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>the partition of the set of all antichains of <code class="docutils literal notranslate"><span class="pre">self</span></code> into
orbits under Panyushev complementation. This is returned as
a list of lists <code class="docutils literal notranslate"><span class="pre">L</span></code> such that for each <code class="docutils literal notranslate"><span class="pre">L</span></code> and <code class="docutils literal notranslate"><span class="pre">i</span></code>,
cyclically:
<code class="docutils literal notranslate"><span class="pre">self.order_ideal_complement_generators(L[i])</span> <span class="pre">==</span> <span class="pre">L[i+1]</span></code>.
The entries <code class="docutils literal notranslate"><span class="pre">L[i]</span></code> are sets by default, but depending on
the optional keyword variable <code class="docutils literal notranslate"><span class="pre">element_constructors</span></code>
they can also be tuples, lists etc.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">orb</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbits</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">orb</span><span class="p">)</span>
<span class="go">[[set(), {1, 2}, {3}], [{2}, {1}]]</span>
<span class="gp">sage: </span><span class="n">orb</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbits</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">orb</span><span class="p">)</span>
<span class="go">[[[], [1, 2], [3]], [[1], [2]]]</span>
<span class="gp">sage: </span><span class="n">orb</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbits</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">orb</span><span class="p">)</span>
<span class="go">[[frozenset(), frozenset({1, 2}), frozenset({3})],</span>
<span class="go"> [frozenset({2}), frozenset({1})]]</span>
<span class="gp">sage: </span><span class="n">orb</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbits</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">orb</span><span class="p">)</span>
<span class="go">[[(), (1, 2), (3,)], [(1,), (2,)]]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbits</span><span class="p">()</span>
<span class="go">[[set()]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion">
<span class="sig-name descname"><span class="pre">rowmotion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order_ideal</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="Permalink to this definition">#</a></dt>
<dd><p>The image of the order ideal <code class="docutils literal notranslate"><span class="pre">order_ideal</span></code> under rowmotion
in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Rowmotion on a finite poset <span class="math notranslate nohighlight">\(P\)</span> is an automorphism of the set
<span class="math notranslate nohighlight">\(J(P)\)</span> of all order ideals of <span class="math notranslate nohighlight">\(P\)</span>. One way to define it is as
follows: Given an order ideal <span class="math notranslate nohighlight">\(I \in J(P)\)</span>, we let <span class="math notranslate nohighlight">\(F\)</span> be the
set-theoretic complement of <span class="math notranslate nohighlight">\(I\)</span> in <span class="math notranslate nohighlight">\(P\)</span>. Furthermore we let
<span class="math notranslate nohighlight">\(A\)</span> be the antichain consisting of all minimal elements of
<span class="math notranslate nohighlight">\(F\)</span>. Then, the rowmotion of <span class="math notranslate nohighlight">\(I\)</span> is defined to be the order
ideal of <span class="math notranslate nohighlight">\(P\)</span> generated by the antichain <span class="math notranslate nohighlight">\(A\)</span> (that is, the
order ideal consisting of each element of <span class="math notranslate nohighlight">\(P\)</span> which has some
element of <span class="math notranslate nohighlight">\(A\)</span> above it).</p>
<p>Rowmotion is related (actually, isomorphic) to Panyushev
complementation (<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement" title="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">panyushev_complement()</span></code></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">order_ideal</span></code> – an order ideal of <code class="docutils literal notranslate"><span class="pre">self</span></code>, as a set</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>the image of <code class="docutils literal notranslate"><span class="pre">order_ideal</span></code> under rowmotion, as a set again</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">7</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">8</span><span class="p">:</span> <span class="p">[]}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">Set</span><span class="p">({</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="go">{1, 3, 4, 5, 6, 7}</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">Set</span><span class="p">({})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="go">{}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion_orbit_iter">
<span class="sig-name descname"><span class="pre">rowmotion_orbit_iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oideal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">element_constructor=&lt;class</span> <span class="pre">'set'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check=True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion_orbit_iter" title="Permalink to this definition">#</a></dt>
<dd><p>Iterate over the rowmotion orbit of an order ideal
<code class="docutils literal notranslate"><span class="pre">oideal</span></code> of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The rowmotion orbit of an order ideal is its orbit under
rowmotion (see <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rowmotion()</span></code></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">oideal</span></code> – an order ideal of <code class="docutils literal notranslate"><span class="pre">self</span></code>, given as an
iterable.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">element_constructor</span></code> (defaults to <code class="docutils literal notranslate"><span class="pre">set</span></code>) – a type
constructor (<code class="docutils literal notranslate"><span class="pre">set</span></code>, <code class="docutils literal notranslate"><span class="pre">tuple</span></code>, <code class="docutils literal notranslate"><span class="pre">list</span></code>, <code class="docutils literal notranslate"><span class="pre">frozenset</span></code>,
<code class="docutils literal notranslate"><span class="pre">iter</span></code>, etc.) which is to be applied to the order
ideals before they are yielded.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">stop</span></code> – a Boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) determining
whether the iterator should stop once it completes its
cycle (this happens when it is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>) or go on
forever (this happens when it is set to <code class="docutils literal notranslate"><span class="pre">False</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – a Boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) determining
whether <code class="docutils literal notranslate"><span class="pre">oideal</span></code> should be checked for being an
order ideal.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>an iterator over the orbit of the order ideal <code class="docutils literal notranslate"><span class="pre">oideal</span></code>
under rowmotion. This iterator <span class="math notranslate nohighlight">\(I\)</span> has the property that
<code class="docutils literal notranslate"><span class="pre">I[0]</span> <span class="pre">==</span> <span class="pre">oideal</span></code> and that every <span class="math notranslate nohighlight">\(i\)</span> satisfies
<code class="docutils literal notranslate"><span class="pre">self.rowmotion(I[i])</span> <span class="pre">==</span> <span class="pre">I[i+1]</span></code>, where <code class="docutils literal notranslate"><span class="pre">I[i+1]</span></code> has
to be understood as <code class="docutils literal notranslate"><span class="pre">I[0]</span></code> if it is undefined.
The entries <code class="docutils literal notranslate"><span class="pre">I[i]</span></code> are sets by default, but depending on
the optional keyword variable <code class="docutils literal notranslate"><span class="pre">element_constructors</span></code>
they can also be tuples, lists etc.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])))</span>
<span class="go">[{1, 2}, {1, 2, 3}, set()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[{1, 2}, {1, 2, 3}, set()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="go">[{1, 2}, {1, 2, 3}, set()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">list</span><span class="p">))</span>
<span class="go">[[1, 2], [1, 2, 3], []]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">))</span>
<span class="go">[frozenset({1, 2}), frozenset({1, 2, 3}), frozenset()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">))</span>
<span class="go">[(1, 2), (1, 2, 3), ()]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">([]))</span>
<span class="go">[set()]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[]</span> <span class="p">})</span>
<span class="gp">sage: </span><span class="n">Piter</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">stop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1, 2, 3}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1, 2, 3, 4}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">set()</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1, 2, 3}</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">})</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">list</span><span class="p">))</span>
<span class="go">[[1, 2], [1, 2, 3, 4], [2, 3, 5], [1], [2, 3], [1, 2, 3, 5], [1, 2, 4], [3]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion_orbits">
<span class="sig-name descname"><span class="pre">rowmotion_orbits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element_constructor=&lt;class</span> <span class="pre">'set'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion_orbits" title="Permalink to this definition">#</a></dt>
<dd><p>Return the rowmotion orbits of order ideals in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The rowmotion orbit of an order ideal is its orbit under
rowmotion (see <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rowmotion()</span></code></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">element_constructor</span></code> (defaults to <code class="docutils literal notranslate"><span class="pre">set</span></code>) – a type
constructor (<code class="docutils literal notranslate"><span class="pre">set</span></code>, <code class="docutils literal notranslate"><span class="pre">tuple</span></code>, <code class="docutils literal notranslate"><span class="pre">list</span></code>, <code class="docutils literal notranslate"><span class="pre">frozenset</span></code>,
<code class="docutils literal notranslate"><span class="pre">iter</span></code>, etc.) which is to be applied to the antichains
before they are returned.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>the partition of the set of all order ideals of <code class="docutils literal notranslate"><span class="pre">self</span></code>
into orbits under rowmotion. This is returned as
a list of lists <code class="docutils literal notranslate"><span class="pre">L</span></code> such that for each <code class="docutils literal notranslate"><span class="pre">L</span></code> and <code class="docutils literal notranslate"><span class="pre">i</span></code>,
cyclically: <code class="docutils literal notranslate"><span class="pre">self.rowmotion(L[i])</span> <span class="pre">==</span> <span class="pre">L[i+1]</span></code>.
The entries <code class="docutils literal notranslate"><span class="pre">L[i]</span></code> are sets by default, but depending on
the optional keyword variable <code class="docutils literal notranslate"><span class="pre">element_constructors</span></code>
they can also be tuples, lists etc.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">]}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbits</span><span class="p">())</span>
<span class="go">[3, 5]</span>
<span class="gp">sage: </span><span class="n">orb</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbits</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">orb</span><span class="p">)</span>
<span class="go">[[[], [4, 1], [4, 1, 2, 3]], [[1], [1, 3], [4], [4, 1, 2], [4, 1, 3]]]</span>
<span class="gp">sage: </span><span class="n">orb</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbits</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">orb</span><span class="p">)</span>
<span class="go">[[(), (4, 1), (4, 1, 2, 3)], [(1,), (1, 3), (4,), (4, 1, 2), (4, 1, 3)]]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbits</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">)</span>
<span class="go">[[()]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion_orbits_plots">
<span class="sig-name descname"><span class="pre">rowmotion_orbits_plots</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion_orbits_plots" title="Permalink to this definition">#</a></dt>
<dd><p>Return plots of the rowmotion orbits of order ideals in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The rowmotion orbit of an order ideal is its orbit under
rowmotion (see <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rowmotion()</span></code></a>).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">]}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbits_plots</span><span class="p">()</span>
<span class="go">Graphics Array of size 2 x 5</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbits_plots</span><span class="p">()</span>
<span class="go">Graphics Array of size 1 x 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.finite_posets.FinitePosets.ParentMethods.toggling_orbit_iter">
<span class="sig-name descname"><span class="pre">toggling_orbit_iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">oideal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">element_constructor=&lt;class</span> <span class="pre">'set'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check=True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.toggling_orbit_iter" title="Permalink to this definition">#</a></dt>
<dd><p>Iterate over the orbit of an order ideal <code class="docutils literal notranslate"><span class="pre">oideal</span></code> of
<code class="docutils literal notranslate"><span class="pre">self</span></code> under the operation of toggling the vertices
<code class="docutils literal notranslate"><span class="pre">vs[0],</span> <span class="pre">vs[1],</span> <span class="pre">...</span></code> in this order.</p>
<p>See <a class="reference internal" href="posets.html#sage.categories.posets.Posets.ParentMethods.order_ideal_toggle" title="sage.categories.posets.Posets.ParentMethods.order_ideal_toggle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_ideal_toggle()</span></code></a> for a definition of toggling.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The orbit is that under the composition of toggles,
<em>not</em> under the single toggles themselves. Thus, for
example, if <code class="docutils literal notranslate"><span class="pre">vs</span> <span class="pre">==</span> <span class="pre">[1,2]</span></code>, then the orbit has the
form <span class="math notranslate nohighlight">\((I, T_2 T_1 I, T_2 T_1 T_2 T_1 I, \ldots)\)</span>
(where <span class="math notranslate nohighlight">\(I\)</span> denotes <code class="docutils literal notranslate"><span class="pre">oideal</span></code> and <span class="math notranslate nohighlight">\(T_i\)</span> means
toggling at <span class="math notranslate nohighlight">\(i\)</span>) rather than
<span class="math notranslate nohighlight">\((I, T_1 I, T_2 T_1 I, T_1 T_2 T_1 I, \ldots)\)</span>.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vs</span></code>: a list (or other iterable) of elements of <code class="docutils literal notranslate"><span class="pre">self</span></code>
(but since the output depends on the order, sets should
not be used as <code class="docutils literal notranslate"><span class="pre">vs</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">oideal</span></code> – an order ideal of <code class="docutils literal notranslate"><span class="pre">self</span></code>, given as an
iterable.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">element_constructor</span></code> (defaults to <code class="docutils literal notranslate"><span class="pre">set</span></code>) – a type
constructor (<code class="docutils literal notranslate"><span class="pre">set</span></code>, <code class="docutils literal notranslate"><span class="pre">tuple</span></code>, <code class="docutils literal notranslate"><span class="pre">list</span></code>, <code class="docutils literal notranslate"><span class="pre">frozenset</span></code>,
<code class="docutils literal notranslate"><span class="pre">iter</span></code>, etc.) which is to be applied to the order
ideals before they are yielded.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">stop</span></code> – a Boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) determining
whether the iterator should stop once it completes its
cycle (this happens when it is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>) or go on
forever (this happens when it is set to <code class="docutils literal notranslate"><span class="pre">False</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – a Boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) determining
whether <code class="docutils literal notranslate"><span class="pre">oideal</span></code> should be checked for being an
order ideal.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>an iterator over the orbit of the order ideal <code class="docutils literal notranslate"><span class="pre">oideal</span></code>
under toggling the vertices in the list <code class="docutils literal notranslate"><span class="pre">vs</span></code> in this
order. This iterator <span class="math notranslate nohighlight">\(I\)</span> has the property that
<code class="docutils literal notranslate"><span class="pre">I[0]</span> <span class="pre">==</span> <span class="pre">oideal</span></code> and that every <span class="math notranslate nohighlight">\(i\)</span> satisfies
<code class="docutils literal notranslate"><span class="pre">self.order_ideal_toggles(I[i],</span> <span class="pre">vs)</span> <span class="pre">==</span> <span class="pre">I[i+1]</span></code>, where
<code class="docutils literal notranslate"><span class="pre">I[i+1]</span></code> has to be understood as <code class="docutils literal notranslate"><span class="pre">I[0]</span></code> if it is
undefined.
The entries <code class="docutils literal notranslate"><span class="pre">I[i]</span></code> are sets by default, but depending on
the optional keyword variable <code class="docutils literal notranslate"><span class="pre">element_constructors</span></code>
they can also be tuples, lists etc.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])))</span>
<span class="go">[{1, 2}]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])))</span>
<span class="go">[{1, 2}, set(), {1, 2, 3}]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])))</span>
<span class="go">[{1, 2}, {1, 2, 3}, set()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">list</span><span class="p">))</span>
<span class="go">[[1, 2], [1, 2, 3], []]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">))</span>
<span class="go">[frozenset({1, 2}), frozenset({1, 2, 3}), frozenset()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">))</span>
<span class="go">[(1, 2), (1, 2, 3), ()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">))</span>
<span class="go">[(1, 2), (1, 2, 3), ()]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([],</span> <span class="p">[]))</span>
<span class="go">[set()]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[]</span> <span class="p">})</span>
<span class="gp">sage: </span><span class="n">Piter</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">stop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1, 2, 3}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">set()</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1, 2, 3}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.finite_posets.FinitePosets.ParentMethods.toggling_orbits">
<span class="sig-name descname"><span class="pre">toggling_orbits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">element_constructor=&lt;class</span> <span class="pre">'set'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.toggling_orbits" title="Permalink to this definition">#</a></dt>
<dd><p>Return the orbits of order ideals in <code class="docutils literal notranslate"><span class="pre">self</span></code> under the
operation of toggling the vertices <code class="docutils literal notranslate"><span class="pre">vs[0],</span> <span class="pre">vs[1],</span> <span class="pre">...</span></code>
in this order.</p>
<p>See <a class="reference internal" href="posets.html#sage.categories.posets.Posets.ParentMethods.order_ideal_toggle" title="sage.categories.posets.Posets.ParentMethods.order_ideal_toggle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_ideal_toggle()</span></code></a> for a definition of toggling.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The orbits are those under the composition of toggles,
<em>not</em> under the single toggles themselves. Thus, for
example, if <code class="docutils literal notranslate"><span class="pre">vs</span> <span class="pre">==</span> <span class="pre">[1,2]</span></code>, then the orbits have the
form <span class="math notranslate nohighlight">\((I, T_2 T_1 I, T_2 T_1 T_2 T_1 I, \ldots)\)</span>
(where <span class="math notranslate nohighlight">\(I\)</span> denotes an order ideal and <span class="math notranslate nohighlight">\(T_i\)</span> means
toggling at <span class="math notranslate nohighlight">\(i\)</span>) rather than
<span class="math notranslate nohighlight">\((I, T_1 I, T_2 T_1 I, T_1 T_2 T_1 I, \ldots)\)</span>.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vs</span></code>: a list (or other iterable) of elements of <code class="docutils literal notranslate"><span class="pre">self</span></code>
(but since the output depends on the order, sets should
not be used as <code class="docutils literal notranslate"><span class="pre">vs</span></code>).</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>a partition of the order ideals of <code class="docutils literal notranslate"><span class="pre">self</span></code>, as a list of
sets <code class="docutils literal notranslate"><span class="pre">L</span></code> such that for each <code class="docutils literal notranslate"><span class="pre">L</span></code> and <code class="docutils literal notranslate"><span class="pre">i</span></code>, cyclically:
<code class="docutils literal notranslate"><span class="pre">self.order_ideal_toggles(L[i],</span> <span class="pre">vs)</span> <span class="pre">==</span> <span class="pre">L[i+1]</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[]}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">toggling_orbits</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[2, 3, 3]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">]}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">toggling_orbits</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
<span class="go">[3, 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.finite_posets.FinitePosets.ParentMethods.toggling_orbits_plots">
<span class="sig-name descname"><span class="pre">toggling_orbits_plots</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.toggling_orbits_plots" title="Permalink to this definition">#</a></dt>
<dd><p>Return plots of the orbits of order ideals in <code class="docutils literal notranslate"><span class="pre">self</span></code> under the
operation of toggling the vertices <code class="docutils literal notranslate"><span class="pre">vs[0],</span> <span class="pre">vs[1],</span> <span class="pre">...</span></code>
in this order.</p>
<p>See <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.toggling_orbits" title="sage.categories.finite_posets.FinitePosets.ParentMethods.toggling_orbits"><code class="xref py py-meth docutils literal notranslate"><span class="pre">toggling_orbits()</span></code></a> for more information.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">]}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbits_plots</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="go">Graphics Array of size 2 x 5</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbits_plots</span><span class="p">([])</span>
<span class="go">Graphics Array of size 1 x 1</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</dd></dl>

</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="finite_semigroups.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Finite semigroups</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="finite_permutation_groups.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Finite Permutation Groups</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2005--2023, The Sage Development Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Finite posets</a><ul>
<li><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets"><code class="docutils literal notranslate"><span class="pre">FinitePosets</span></code></a><ul>
<li><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods"><code class="docutils literal notranslate"><span class="pre">ParentMethods</span></code></a><ul>
<li><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.antichains"><code class="docutils literal notranslate"><span class="pre">antichains()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling"><code class="docutils literal notranslate"><span class="pre">birational_free_labelling()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_rowmotion"><code class="docutils literal notranslate"><span class="pre">birational_rowmotion()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggle"><code class="docutils literal notranslate"><span class="pre">birational_toggle()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggles"><code class="docutils literal notranslate"><span class="pre">birational_toggles()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.directed_subsets"><code class="docutils literal notranslate"><span class="pre">directed_subsets()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.is_lattice"><code class="docutils literal notranslate"><span class="pre">is_lattice()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.is_poset_isomorphism"><code class="docutils literal notranslate"><span class="pre">is_poset_isomorphism()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.is_poset_morphism"><code class="docutils literal notranslate"><span class="pre">is_poset_morphism()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.is_self_dual"><code class="docutils literal notranslate"><span class="pre">is_self_dual()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.order_filter_generators"><code class="docutils literal notranslate"><span class="pre">order_filter_generators()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideal_complement_generators"><code class="docutils literal notranslate"><span class="pre">order_ideal_complement_generators()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideal_generators"><code class="docutils literal notranslate"><span class="pre">order_ideal_generators()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideals_lattice"><code class="docutils literal notranslate"><span class="pre">order_ideals_lattice()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement"><code class="docutils literal notranslate"><span class="pre">panyushev_complement()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_orbit_iter"><code class="docutils literal notranslate"><span class="pre">panyushev_orbit_iter()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_orbits"><code class="docutils literal notranslate"><span class="pre">panyushev_orbits()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion"><code class="docutils literal notranslate"><span class="pre">rowmotion()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion_orbit_iter"><code class="docutils literal notranslate"><span class="pre">rowmotion_orbit_iter()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion_orbits"><code class="docutils literal notranslate"><span class="pre">rowmotion_orbits()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion_orbits_plots"><code class="docutils literal notranslate"><span class="pre">rowmotion_orbits_plots()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.toggling_orbit_iter"><code class="docutils literal notranslate"><span class="pre">toggling_orbit_iter()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.toggling_orbits"><code class="docutils literal notranslate"><span class="pre">toggling_orbits()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.toggling_orbits_plots"><code class="docutils literal notranslate"><span class="pre">toggling_orbits_plots()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/scripts/furo.js"></script>
    <script src="../../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"ZZ": "\\Bold{Z}", "NN": "\\Bold{N}", "RR": "\\Bold{R}", "CC": "\\Bold{C}", "QQ": "\\Bold{Q}", "QQbar": "\\overline{\\QQ}", "GF": ["\\Bold{F}_{#1}", 1], "Zp": ["\\Bold{Z}_{#1}", 1], "Qp": ["\\Bold{Q}_{#1}", 1], "Zmod": ["\\ZZ/#1\\ZZ", 1], "CDF": "\\Bold{C}", "CIF": "\\Bold{C}", "CLF": "\\Bold{C}", "RDF": "\\Bold{R}", "RIF": "\\Bold{I} \\Bold{R}", "RLF": "\\Bold{R}", "SL": "\\mathrm{SL}", "PSL": "\\mathrm{PSL}", "Bold": ["\\mathbf{#1}", 1]}, "inlineMath": [["$", "$"], ["\\(", "\\)"]], "maxBuffer": 51200, "autoload": {"color": [], "colorv2": ["color"]}}}</script>
    <script defer="defer" src="../../../_static/mathjax/tex-chtml.js"></script>
    </body>
</html>