<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Elements, parents, and categories in Sage: a (draft of) primer &mdash; Sage Reference Manual v7.0: Category Framework</title>
    
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '7.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v7.0: Category Framework" href="../../index.html" />
    <link rel="next" title="Categories" href="category.html" />
    <link rel="prev" title="Category Framework" href="../../index.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="category.html" title="Categories"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../../index.html" title="Category Framework"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Category Framework</a> &raquo;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="elements-parents-and-categories-in-sage-a-draft-of-primer">
<span id="sage-categories-primer"></span><h1><a class="toc-backref" href="#id2">Elements, parents, and categories in Sage: a (draft of) primer</a><a class="headerlink" href="#elements-parents-and-categories-in-sage-a-draft-of-primer" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.categories.primer"></span><div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#elements-parents-and-categories-in-sage-a-draft-of-primer" id="id2">Elements, parents, and categories in Sage: a (draft of) primer</a><ul>
<li><a class="reference internal" href="#abstract" id="id3">Abstract</a></li>
<li><a class="reference internal" href="#introduction-sage-as-a-library-of-objects-and-algorithms" id="id4">Introduction: Sage as a library of objects and algorithms</a></li>
<li><a class="reference internal" href="#a-bit-of-help-from-abstract-algebra" id="id5">A bit of help from abstract algebra</a></li>
<li><a class="reference internal" href="#a-bit-of-help-from-computer-science" id="id6">A bit of help from computer science</a></li>
<li><a class="reference internal" href="#sage-categories" id="id7">Sage categories</a></li>
<li><a class="reference internal" href="#case-study" id="id8">Case study</a></li>
<li><a class="reference internal" href="#specifying-the-category-of-a-parent" id="id9">Specifying the category of a parent</a></li>
<li><a class="reference internal" href="#scaling-further-functorial-constructions-axioms" id="id10">Scaling further: functorial constructions, axioms, ...</a></li>
<li><a class="reference internal" href="#writing-a-new-category" id="id11">Writing a new category</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="abstract">
<h2><a class="toc-backref" href="#id3">Abstract</a><a class="headerlink" href="#abstract" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The purpose of categories in Sage is to translate the mathematical
concept of categories (category of groups, of vector spaces, ...)
into a concrete software engineering design pattern for:</p>
<ul class="simple">
<li>organizing and promoting generic code</li>
<li>fostering consistency across the Sage library (naming
conventions, doc, tests)</li>
<li>embedding more mathematical knowledge into the system</li>
</ul>
<p>This design pattern is largely inspired from Axiom and its
followers (Aldor, Fricas, MuPAD, ...). It differs from those by:</p>
<ul class="simple">
<li>blending in the Magma inspired concept of Parent/Element</li>
<li>being built on top of (and not into) the standard Python object
oriented and class hierarchy mechanism. This did not require
changing the language, and could in principle be implemented in
any language supporting the creation of new classes dynamically.</li>
</ul>
<p>The general philosophy is that <em>Building mathematical information
into the system yields more expressive, more conceptual and, at
the end, easier to maintain and faster code</em> (within a programming
realm; this would not necessarily apply to specialized libraries
like gmp!).</p>
</div></blockquote>
<div class="section" id="one-line-pitch-for-mathematicians">
<h3>One line pitch for mathematicians<a class="headerlink" href="#one-line-pitch-for-mathematicians" title="Permalink to this headline">¶</a></h3>
<p>Categories in Sage provide a library of interrelated bookshelves, with
each bookshelf containing algorithms, tests, documentation, or some
mathematical facts about the objects of a given category (e.g. groups).</p>
</div>
<div class="section" id="one-line-pitch-for-programmers">
<h3>One line pitch for programmers<a class="headerlink" href="#one-line-pitch-for-programmers" title="Permalink to this headline">¶</a></h3>
<p>Categories in Sage provide a large hierarchy of abstract classes for
mathematical objects. To keep it maintainable, the inheritance
information between the classes is not hardcoded but instead
reconstructed dynamically from duplication free semantic information.</p>
</div>
</div>
<div class="section" id="introduction-sage-as-a-library-of-objects-and-algorithms">
<h2><a class="toc-backref" href="#id4">Introduction: Sage as a library of objects and algorithms</a><a class="headerlink" href="#introduction-sage-as-a-library-of-objects-and-algorithms" title="Permalink to this headline">¶</a></h2>
<p>The Sage library, with more than one million lines of code,
documentation, and tests, implements:</p>
<ul>
<li><p class="first">Thousands of different kinds of objects (classes):</p>
<p>Integers, polynomials, matrices, groups, number fields, elliptic
curves, permutations, morphisms, languages, ... and a few racoons ...</p>
</li>
<li><p class="first">Tens of thousands methods and functions:</p>
<p>Arithmetic, integer and polynomial factorization, pattern matching
on words, ...</p>
</li>
</ul>
<div class="section" id="some-challenges">
<h3>Some challenges<a class="headerlink" href="#some-challenges" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">How to organize this library?</p>
<p>One needs some bookshelves to group together related objects and algorithms.</p>
</li>
<li><p class="first">How to ensure consistency?</p>
<p>Similar objects should behave similarly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Permutations</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">120</span>

<span class="gp">sage: </span><span class="n">GL</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">6</span>

<span class="gp">sage: </span><span class="n">A</span><span class="o">=</span><span class="n">random_matrix</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">=</span><span class="n">LatticePolytope</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">rows</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">npoints</span><span class="p">()</span>                <span class="c"># oops!   # random</span>
<span class="go">37</span>
</pre></div>
</div>
</li>
<li><p class="first">How to ensure robustness?</p>
</li>
<li><p class="first">How to reduce duplication?</p>
<p>Example: binary powering:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">^</span><span class="mi">8</span> <span class="o">==</span> <span class="n">m</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">m</span> <span class="o">==</span> <span class="p">((</span><span class="n">m</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">m</span><span class="o">=</span><span class="n">random_matrix</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;echelonizable&#39;</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">upper_bound</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">^</span><span class="mi">8</span> <span class="o">==</span> <span class="n">m</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">m</span> <span class="o">==</span> <span class="p">((</span><span class="n">m</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We want to implement binary powering only once, as <em>generic</em> code
that will apply in all cases.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="a-bit-of-help-from-abstract-algebra">
<h2><a class="toc-backref" href="#id5">A bit of help from abstract algebra</a><a class="headerlink" href="#a-bit-of-help-from-abstract-algebra" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-hierarchy-of-categories">
<h3>The hierarchy of categories<a class="headerlink" href="#the-hierarchy-of-categories" title="Permalink to this headline">¶</a></h3>
<p>What makes binary powering work in the above examples? In both cases,
we have <em>a set</em> endowed with a <em>multiplicative binary operation</em> which
is <em>associative</em>. Such a set is called a <em>semigroup</em>, and binary
powering works generally for any semigroup.</p>
<p>Sage knows about semigroups:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Semigroups</span><span class="p">()</span>
<span class="go">Category of semigroups</span>
</pre></div>
</div>
<p>and sure enough, binary powering is defined there:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">_pow_</span><span class="o">.</span><span class="n">__module__</span>
<span class="go">&#39;sage.categories.semigroups&#39;</span>
</pre></div>
</div>
<p>That&#8217;s our bookshelf! And it&#8217;s used in many places:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">GL</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">ZZ</span><span class="p">)</span> <span class="ow">in</span> <span class="n">Semigroups</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">NN</span> <span class="ow">in</span> <span class="n">Semigroups</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>For a less trivial bookshelf we can consider euclidean rings: once we
know how to do euclidean division in some set <span class="math">\(R\)</span>, we can compute
gcd&#8217;s in <span class="math">\(R\)</span> generically using the Euclidean algorithm.</p>
<p>We are in fact very lucky: abstract algebra provides us right away
with a large and robust set of bookshelves which is the result of
centuries of work of mathematicians to identify the important
concepts. This includes for example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span>
<span class="go">Category of sets</span>

<span class="gp">sage: </span><span class="n">Groups</span><span class="p">()</span>
<span class="go">Category of groups</span>

<span class="gp">sage: </span><span class="n">Rings</span><span class="p">()</span>
<span class="go">Category of rings</span>

<span class="gp">sage: </span><span class="n">Fields</span><span class="p">()</span>
<span class="go">Category of fields</span>

<span class="gp">sage: </span><span class="n">HopfAlgebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">Category of hopf algebras over Rational Field</span>
</pre></div>
</div>
<p>Each of the above is called a <em>category</em>. It typically specifies what
are the operations on the elements, as well as the axioms satisfied by
those operations. For example the category of groups specifies that a
group is a set endowed with a binary operation (the multiplication)
which is associative and admits a unit and inverses.</p>
<p>Each set in Sage knows which bookshelf of generic algorithms it can
use, that is to which category it belongs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">GL</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of groups</span>
</pre></div>
</div>
<p>In fact a group is a semigroup, and Sage knows about this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Groups</span><span class="p">()</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="n">Semigroups</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="ow">in</span> <span class="n">Semigroups</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Altogether, our group gets algorithms from a bunch of bookshelves:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">categories</span><span class="p">()</span>
<span class="go">[Category of groups, Category of monoids, Category of semigroups,</span>
<span class="go"> ...,</span>
<span class="go"> Category of magmas,</span>
<span class="go"> Category of sets, ...]</span>
</pre></div>
</div>
<p>Those can be viewed graphically:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Groups</span><span class="p">()</span><span class="o">.</span><span class="n">category_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">set_latex_options</span><span class="p">(</span><span class="n">format</span><span class="o">=</span><span class="s">&quot;dot2tex&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">view</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">tightpage</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>                 <span class="c"># not tested</span>
</pre></div>
</div>
<p>In case <tt class="docutils literal"><span class="pre">dot2tex</span></tt> is not available, you can use instead:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">vertex_shape</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
<p>Here is an overview of all categories in Sage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">category</span><span class="o">.</span><span class="n">category_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">set_latex_options</span><span class="p">(</span><span class="n">format</span><span class="o">=</span><span class="s">&quot;dot2tex&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">view</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">tightpage</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>                 <span class="c"># not tested</span>
</pre></div>
</div>
<p>Wrap-up: generic algorithms in Sage are organized in a hierarchy of
bookshelves modelled upon the usual hierarchy of categories provided
by abstract algebra.</p>
</div>
<div class="section" id="elements-parents-categories">
<span id="category-primer-parents-elements-categories"></span><h3>Elements, Parents, Categories<a class="headerlink" href="#elements-parents-categories" title="Permalink to this headline">¶</a></h3>
<p class="rubric">Parent</p>
<p>A <em>parent</em> is a Python instance modelling a set of mathematical
elements together with its additional (algebraic) structure.</p>
<p>Examples include the ring of integers, the group <span class="math">\(S_3\)</span>, the set of
prime numbers, the set of linear maps between two given vector
spaces, and a given finite semigroup.</p>
<p>These sets are often equipped with additional structure: the set
of all integers forms a ring. The main way of encoding this
information is specifying which categories a parent belongs to.</p>
<p>It is completely possible to have different Python instances
modelling the same set of elements.  For example, one might want
to consider the ring of integers, or the poset of integers under
their standard order, or the poset of integers under divisibility,
or the semiring of integers under the operations of maximum and
addition.  Each of these would be a different instance, belonging
to different categories.</p>
<p>For a given model, there should be a unique instance in Sage
representing that parent:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">IntegerRing</span><span class="p">()</span> <span class="ow">is</span> <span class="n">IntegerRing</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">Element</p>
<p>An <em>element</em> is a Python instance modelling a mathematical element
of a set.</p>
<p>Examples of element include <span class="math">\(5\)</span> in the integer ring, <span class="math">\(x^3 - x\)</span> in
the polynomial ring in <span class="math">\(x\)</span> over the rationals, <span class="math">\(4 + O(3^3)\)</span> in the
3-adics, the transposition <span class="math">\((1 2)\)</span> in <span class="math">\(S_3\)</span>, and the identity
morphism in the set of linear maps from <span class="math">\(\QQ^3\)</span> to <span class="math">\(\QQ^3\)</span>.</p>
<p>Every element in Sage has a parent.  The standard idiom in Sage
for creating elements is to create their parent, and then provide
enough data to define the element:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">3*x^2 + 2*x + 1</span>
</pre></div>
</div>
<p>One can also create elements using various methods on the parent
and arithmetic of elements:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">gen</span><span class="p">()</span>
<span class="gp">sage: </span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span>
<span class="go">3*x^2 + 2*x + 1</span>
</pre></div>
</div>
<p>Unlike parents, elements in Sage are not necessarily unique:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">ZZ</span><span class="p">(</span><span class="mi">5040</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ZZ</span><span class="p">(</span><span class="mi">5040</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Many parents model algebraic structures, and their elements
support arithmetic operations. One often further wants to do
arithmetic by combining elements from different parents: adding
together integers and rationals for example. Sage supports this
feature using coercion (see <a class="reference external" href="../../../coercion/sage/structure/coerce.html#module-sage.structure.coerce" title="(in Sage Reference Manual: Coercion v7.0)"><tt class="xref py py-mod docutils literal"><span class="pre">sage.structure.coerce</span></tt></a> for more
details).</p>
<p>It is possible for a parent to also have simultaneously the
structure of an element. Consider for example the monoid of all
finite groups, endowed with the Cartesian product operation.
Then, every finite group (which is a parent) is also an element of
this monoid. This is not yet implemented, and the design details
are not yet fixed but experiments are underway in this direction.</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">Give a concrete example, typically using <a class="reference external" href="../../../structure/sage/structure/element_wrapper.html#sage.structure.element_wrapper.ElementWrapper" title="(in Sage Reference Manual: Basic Structures v7.0)"><tt class="xref py py-class docutils literal"><span class="pre">ElementWrapper</span></tt></a>.</p>
</div>
<p class="rubric">Category</p>
<p>A <em>category</em> is a Python instance modelling a mathematical category.</p>
<p>Examples of categories include the category of finite semigroups,
the category of all (Python) objects, the category of
<span class="math">\(\ZZ\)</span>-algebras, and the category of Cartesian products of
<span class="math">\(\ZZ\)</span>-algebras:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FiniteSemigroups</span><span class="p">()</span>
<span class="go">Category of finite semigroups</span>
<span class="gp">sage: </span><span class="n">Objects</span><span class="p">()</span>
<span class="go">Category of objects</span>
<span class="gp">sage: </span><span class="n">Algebras</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">Category of algebras over Integer Ring</span>
<span class="gp">sage: </span><span class="n">Algebras</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">CartesianProducts</span><span class="p">()</span>
<span class="go">Category of Cartesian products of algebras over Integer Ring</span>
</pre></div>
</div>
<p>Mind the &#8216;s&#8217; in the names of the categories above;
<tt class="docutils literal"><span class="pre">GroupAlgebra</span></tt> and <tt class="docutils literal"><span class="pre">GroupAlgebras</span></tt> are distinct things.</p>
<p>Every parent belongs to a collection of categories. Moreover,
categories are interrelated by the <em>super categories</em>
relation. For example, the category of rings is a super category
of the category of fields, because every field is also a ring.</p>
<p>A category serves two roles:</p>
<ul class="simple">
<li>to provide a model for the mathematical concept of a category
and the associated structures: homsets, morphisms, functorial
constructions, axioms.</li>
<li>to organize and promote generic code, naming conventions,
documentation, and tests across similar mathematical structures.</li>
</ul>
<p class="rubric">CategoryObject</p>
<p>Objects of a mathematical category are not necessarily parents.
Parent has a superclass that provides a means of modeling such.</p>
<p>For example, the category of schemes does not have a faithful
forgetful functor to the category of sets, so it does not make
sense to talk about schemes as parents.</p>
<p class="rubric">Morphisms, Homsets</p>
<p>As category theorists will expect, <em>Morphisms</em> and <em>Homsets</em> will
play an ever more important role, as support for them will
improve.</p>
<hr class="docutils" />
<p>Much of the mathematical information in Sage is encoded as relations
between elements and their parents, parents and their categories, and
categories and their super categories:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="mf">1.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Integer Ring</span>

<span class="gp">sage: </span><span class="n">ZZ</span>
<span class="go">Integer Ring</span>

<span class="gp">sage: </span><span class="n">ZZ</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Join of Category of euclidean domains</span>
<span class="go">    and Category of infinite enumerated sets</span>
<span class="go">    and Category of metric spaces</span>

<span class="gp">sage: </span><span class="n">ZZ</span><span class="o">.</span><span class="n">categories</span><span class="p">()</span>
<span class="go">[Join of Category of euclidean domains</span>
<span class="go">     and Category of infinite enumerated sets</span>
<span class="go">     and Category of metric spaces,</span>
<span class="go"> Category of euclidean domains, Category of principal ideal domains,</span>
<span class="go"> Category of unique factorization domains, Category of gcd domains,</span>
<span class="go"> Category of integral domains, Category of domains,</span>
<span class="go"> Category of commutative rings, Category of rings, ...</span>
<span class="go"> Category of magmas and additive magmas, ...</span>
<span class="go"> Category of monoids, Category of semigroups,</span>
<span class="go"> Category of commutative magmas, Category of unital magmas, Category of magmas,</span>
<span class="go"> Category of commutative additive groups, ..., Category of additive magmas,</span>
<span class="go"> Category of infinite enumerated sets, Category of enumerated sets,</span>
<span class="go"> Category of infinite sets, Category of metric spaces,</span>
<span class="go"> Category of topological spaces, Category of sets,</span>
<span class="go"> Category of sets with partial maps,</span>
<span class="go"> Category of objects]</span>

<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">EuclideanDomains</span><span class="p">()</span><span class="o">.</span><span class="n">category_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">set_latex_options</span><span class="p">(</span><span class="n">format</span><span class="o">=</span><span class="s">&quot;dot2tex&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">view</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">tightpage</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>                 <span class="c"># not tested</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="a-bit-of-help-from-computer-science">
<h2><a class="toc-backref" href="#id6">A bit of help from computer science</a><a class="headerlink" href="#a-bit-of-help-from-computer-science" title="Permalink to this headline">¶</a></h2>
<div class="section" id="hierarchy-of-classes">
<h3>Hierarchy of classes<a class="headerlink" href="#hierarchy-of-classes" title="Permalink to this headline">¶</a></h3>
<p>How are the bookshelves implemented in practice?</p>
<p>Sage uses the classical design paradigm of Object Oriented Programming
(OOP). Its fundamental principle is that any object that a program is
to manipulate should be modelled by an <em>instance</em> of a <em>class</em>. The
class implements:</p>
<blockquote>
<div><ul class="simple">
<li>a <em>data structure</em>: which describes how the object is stored,</li>
<li><em>methods</em>: which describe the operations on the object.</li>
</ul>
</div></blockquote>
<p>The instance itself contains the data for the given object, according
to the specified data structure.</p>
<p>Hence, all the objects mentioned above should be instances of some
classes. For example, an integer in Sage is an instance of the class
<a class="reference external" href="../../../rings_standard/sage/rings/integer.html#sage.rings.integer.Integer" title="(in Sage Reference Manual: Standard Commutative Rings v7.0)"><tt class="xref py py-class docutils literal"><span class="pre">Integer</span></tt></a> (and it knows about it!):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">i</span> <span class="o">=</span> <span class="mi">12</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">&lt;type &#39;sage.rings.integer.Integer&#39;&gt;</span>
</pre></div>
</div>
<p>Applying an operation is generally done by <em>calling a method</em>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">i</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">2^2 * 3</span>

<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">12</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">6</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">&lt;type &#39;sage.symbolic.expression.Expression&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">6*(x + 1)^2</span>

<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pQ</span> <span class="o">=</span> <span class="n">R</span> <span class="p">(</span> <span class="n">p</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">pQ</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.rings.polynomial.polynomial_element_generic.Polynomial_generic_sparse_field&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">pQ</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">(6) * (x + 1)^2</span>

<span class="gp">sage: </span><span class="n">pZ</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span> <span class="p">(</span> <span class="n">p</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">pZ</span><span class="p">)</span>
<span class="go">&lt;type &#39;sage.rings.polynomial.polynomial_integer_dense_flint.Polynomial_integer_dense_flint&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">pZ</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">2 * 3 * (x + 1)^2</span>
</pre></div>
</div>
<p>Factoring integers, expressions, or polynomials are distinct tasks,
with completely different algorithms. Yet, from a user (or caller)
point of view, all those objects can be manipulated alike. This
illustrates the OOP concepts of <em>polymorphism</em>, <em>data abstraction</em>,
and <em>encapsulation</em>.</p>
<p>Let us be curious, and see where some methods are defined. This can be
done by introspection:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: i._mul_??                   # not tested
</pre></div>
</div>
<p>For plain Python methods, one can also just ask in which module they
are implemented:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">i</span><span class="o">.</span><span class="n">_pow_</span><span class="o">.</span><span class="n">__module__</span>
<span class="go">&#39;sage.categories.semigroups&#39;</span>

<span class="gp">sage: </span><span class="n">pQ</span><span class="o">.</span><span class="n">_mul_</span><span class="o">.</span><span class="n">__module__</span>
<span class="go">&#39;sage.rings.polynomial.polynomial_element_generic&#39;</span>
<span class="gp">sage: </span><span class="n">pQ</span><span class="o">.</span><span class="n">_pow_</span><span class="o">.</span><span class="n">__module__</span>
<span class="go">&#39;sage.categories.semigroups&#39;</span>
</pre></div>
</div>
<p>We see that integers and polynomials have each their own
multiplication method: the multiplication algorithms are indeed
unrelated and deeply tied to their respective datastructures. On the
other hand, as we have seen above, they share the same powering method
because the set <span class="math">\(\ZZ\)</span> of integers, and the set <span class="math">\(\QQ[x]\)</span> of
polynomials are both semigroups. Namely, the class for integers and
the class for polynomials both derive from an <em>abstract class</em> for
semigroup elements, which factors out the <em>generic</em> methods like
<tt class="docutils literal"><span class="pre">_pow_</span></tt>. This illustrates the use of <em>hierarchy of classes</em> to share
common code between classes having common behaviour.</p>
<p>OOP design is all about isolating the objects that one wants to model
together with their operations, and designing an appropriate hierarchy
of classes for organizing the code. As we have seen above, the design
of the class hierarchy is easy since it can be modelled upon the
hierarchy of categories (bookshelves). Here is for example a piece of
the hierarchy of classes for an element of a group of matrices:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">GL</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">cls</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">mro</span><span class="p">():</span> <span class="k">print</span> <span class="n">cls</span>
<span class="go">&lt;class &#39;sage.groups.matrix_gps.group_element.LinearMatrixGroup_gap_with_category.element_class&#39;&gt;</span>
<span class="go">&lt;class &#39;sage.groups.matrix_gps.group_element.MatrixGroupElement_gap&#39;&gt;</span>
<span class="gp">...</span>
<span class="go">&lt;class &#39;sage.categories.groups.Groups.element_class&#39;&gt;</span>
<span class="go">&lt;class &#39;sage.categories.monoids.Monoids.element_class&#39;&gt;</span>
<span class="go">&lt;class &#39;sage.categories.semigroups.Semigroups.element_class&#39;&gt;</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>On the top, we see concrete classes that describe the data structure
for matrices and provide the operations that are tied to this data
structure. Then follow abstract classes that are attached to the
hierarchy of categories and provide generic algorithms.</p>
<p>The full hierarchy is best viewed graphically:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">class_graph</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">set_latex_options</span><span class="p">(</span><span class="n">format</span><span class="o">=</span><span class="s">&quot;dot2tex&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">view</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">tightpage</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>                 <span class="c"># not tested</span>
</pre></div>
</div>
</div>
<div class="section" id="parallel-hierarchy-of-classes-for-parents">
<h3>Parallel hierarchy of classes for parents<a class="headerlink" href="#parallel-hierarchy-of-classes-for-parents" title="Permalink to this headline">¶</a></h3>
<p>Let us recall that we do not just want to compute with elements of
mathematical sets, but with the sets themselves:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">ZZ</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
<span class="go">1</span>

<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s">&#39;x,y&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">krull_dimension</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">quotient</span><span class="p">(</span> <span class="n">R</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">krull_dimension</span><span class="p">()</span> <span class="c"># todo: not implemented</span>
</pre></div>
</div>
<p>Here are some typical operations that one may want to carry on various
kinds of sets:</p>
<ul class="simple">
<li>The set of permutations of 5, the set of rational points of an
elliptic curve: counting, listing, random generation</li>
<li>A language (set of words): rationality testing, counting elements,
generating series</li>
<li>A finite semigroup: left/right ideals, center, representation theory</li>
<li>A vector space, an algebra: Cartesian product, tensor product, quotient</li>
</ul>
<p>Hence, following the OOP fundamental principle, parents should also be
modelled by instances of some (hierarchy of) classes. For example, our
group <span class="math">\(G\)</span> is an instance of the following class:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">GL</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.groups.matrix_gps.linear.LinearMatrixGroup_gap_with_category&#39;&gt;</span>
</pre></div>
</div>
<p>Here is a piece of the hierarchy of classes above it:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">for</span> <span class="n">cls</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">mro</span><span class="p">():</span> <span class="k">print</span> <span class="n">cls</span>
<span class="go">&lt;class &#39;sage.groups.matrix_gps.linear.LinearMatrixGroup_gap_with_category&#39;&gt;</span>
<span class="gp">...</span>
<span class="go">&lt;class &#39;sage.categories.groups.Groups.parent_class&#39;&gt;</span>
<span class="go">&lt;class &#39;sage.categories.monoids.Monoids.parent_class&#39;&gt;</span>
<span class="go">&lt;class &#39;sage.categories.semigroups.Semigroups.parent_class&#39;&gt;</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>Note that the hierarchy of abstract classes is again attached to
categories and parallel to that we had seen for the elements. This is
best viewed graphically:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">class_graph</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;_&quot;</span><span class="p">,</span><span class="s">&quot;\_&quot;</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">set_latex_options</span><span class="p">(</span><span class="n">format</span><span class="o">=</span><span class="s">&quot;dot2tex&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">view</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">tightpage</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>                 <span class="c"># not tested</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is a progress upon systems like Axiom or MuPAD where a parent
is modelled by the class of its elements; this oversimplification
leads to confusion between methods on parents and elements, and
makes parents special; in particular it prevents potentially
interesting constructions like &#8220;groups of groups&#8221;.</p>
</div>
</div>
</div>
<div class="section" id="sage-categories">
<h2><a class="toc-backref" href="#id7">Sage categories</a><a class="headerlink" href="#sage-categories" title="Permalink to this headline">¶</a></h2>
<p>Why this business of categories? And to start with, why don&#8217;t we just
have a good old hierarchy of classes <tt class="docutils literal"><span class="pre">Group</span></tt>, <tt class="docutils literal"><span class="pre">Semigroup</span></tt>,
<tt class="docutils literal"><span class="pre">Magma</span></tt>, ... ?</p>
<div class="section" id="dynamic-hierarchy-of-classes">
<h3>Dynamic hierarchy of classes<a class="headerlink" href="#dynamic-hierarchy-of-classes" title="Permalink to this headline">¶</a></h3>
<p>As we have just seen, when we manipulate groups, we actually
manipulate several kinds of objects:</p>
<ul class="simple">
<li>groups</li>
<li>group elements</li>
<li>morphisms between groups</li>
<li>and even the category of groups itself!</li>
</ul>
<p>Thus, on the group bookshelf, we want to put generic code for each of
the above. We therefore need three, parallel hierarchies of abstract
classes:</p>
<ul class="simple">
<li>Group, Monoid, Semigroup, Magma, ...</li>
<li>GroupElement, MonoidElement, SemigroupElement, MagmaElement, ...</li>
<li>GroupMorphism, SemigroupElement, SemigroupMorphism, MagmaMorphism, ...</li>
</ul>
<p>(and in fact many more as we will see).</p>
<p>We could implement the above hierarchies as usual:</p>
<div class="highlight-python"><div class="highlight"><pre>class Group(Monoid):
    # generic methods that apply to all groups

class GroupElement(MonoidElement):
    # generic methods that apply to all group elements

class GroupMorphism(MonoidMorphism):
    # generic methods that apply to all group morphisms
</pre></div>
</div>
<p>And indeed that&#8217;s how it was done in Sage before 2009, and there are
still many traces of this. The drawback of this approach is
duplication: the fact that a group is a monoid is repeated three times
above!</p>
<p>Instead, Sage now uses the following syntax, where the <a class="reference internal" href="groups.html#sage.categories.groups.Groups" title="sage.categories.groups.Groups"><tt class="xref py py-class docutils literal"><span class="pre">Groups</span></tt></a>
bookshelf is structured into units with <em>nested classes</em>:</p>
<div class="highlight-python"><div class="highlight"><pre>class Groups(Category):

    def super_categories(self):
        return [Monoids(), ...]

    class ParentMethods:
        # generic methods that apply to all groups

    class ElementMethods:
        # generic methods that apply to all group elements

    class MorphismMethods:
        # generic methods that apply to all group morphisms (not yet implemented)

    class SubcategoryMethods:
        # generic methods that apply to all subcategories of Groups()
</pre></div>
</div>
<p>With this syntax, the information that a group is a monoid is
specified only once, in the <a class="reference internal" href="category.html#sage.categories.category.Category.super_categories" title="sage.categories.category.Category.super_categories"><tt class="xref py py-meth docutils literal"><span class="pre">Category.super_categories()</span></tt></a>
method. And indeed, when the category of inverse unital magmas was
introduced, there was a <em>single point of truth</em> to update in order to
reflect the fact that a group is an inverse unital magma:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Groups</span><span class="p">()</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of monoids, Category of inverse unital magmas]</span>
</pre></div>
</div>
<p>The price to pay (there is no free lunch) is that some magic is
required to construct the actual hierarchy of classes for parents,
elements, and morphisms.  Namely, <tt class="docutils literal"><span class="pre">Groups.ElementMethods</span></tt> should be
seen as just a bag of methods, and the actual class
<tt class="docutils literal"><span class="pre">Groups().element_class</span></tt> is constructed from it by adding the
appropriate super classes according to
<tt class="docutils literal"><span class="pre">Groups().super_categories()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Groups</span><span class="p">()</span><span class="o">.</span><span class="n">element_class</span>
<span class="go">&lt;class &#39;sage.categories.groups.Groups.element_class&#39;&gt;</span>

<span class="gp">sage: </span><span class="n">Groups</span><span class="p">()</span><span class="o">.</span><span class="n">element_class</span><span class="o">.</span><span class="n">__bases__</span>
<span class="go">(&lt;class &#39;sage.categories.monoids.Monoids.element_class&#39;&gt;,</span>
<span class="go"> &lt;class &#39;sage.categories.magmas.Magmas.Unital.Inverse.element_class&#39;&gt;)</span>
</pre></div>
</div>
<p>We now see that the hierarchy of classes for parents and elements is
parallel to the hierarchy of categories:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Groups</span><span class="p">()</span><span class="o">.</span><span class="n">all_super_categories</span><span class="p">()</span>
<span class="go">[Category of groups,</span>
<span class="go"> Category of monoids,</span>
<span class="go"> Category of semigroups,</span>
<span class="go"> ...</span>
<span class="go"> Category of magmas,</span>
<span class="go"> Category of sets,</span>
<span class="go"> ...]</span>

<span class="gp">sage: </span><span class="k">for</span> <span class="n">cls</span> <span class="ow">in</span> <span class="n">Groups</span><span class="p">()</span><span class="o">.</span><span class="n">element_class</span><span class="o">.</span><span class="n">mro</span><span class="p">():</span> <span class="k">print</span> <span class="n">cls</span>
<span class="go">&lt;class &#39;sage.categories.groups.Groups.element_class&#39;&gt;</span>
<span class="go">&lt;class &#39;sage.categories.monoids.Monoids.element_class&#39;&gt;</span>
<span class="go">&lt;class &#39;sage.categories.semigroups.Semigroups.element_class&#39;&gt;</span>
<span class="gp">...</span>
<span class="go">&lt;class &#39;sage.categories.magmas.Magmas.element_class&#39;&gt;</span>
<span class="gp">...</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">cls</span> <span class="ow">in</span> <span class="n">Groups</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span><span class="o">.</span><span class="n">mro</span><span class="p">():</span> <span class="k">print</span> <span class="n">cls</span>
<span class="go">&lt;class &#39;sage.categories.groups.Groups.parent_class&#39;&gt;</span>
<span class="go">&lt;class &#39;sage.categories.monoids.Monoids.parent_class&#39;&gt;</span>
<span class="go">&lt;class &#39;sage.categories.semigroups.Semigroups.parent_class&#39;&gt;</span>
<span class="gp">...</span>
<span class="go">&lt;class &#39;sage.categories.magmas.Magmas.parent_class&#39;&gt;</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>Another advantage of building the hierarchy of classes dynamically is
that, for parametrized categories, the hierarchy may depend on the
parameters. For example an algebra over <span class="math">\(\QQ\)</span> is a <span class="math">\(\QQ\)</span>-vector space,
but an algebra over <span class="math">\(\ZZ\)</span> is not (it is just a <span class="math">\(\ZZ\)</span>-module)!</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>At this point this whole infrastructure may feel like
overdesigning, right? We felt like this too! But we will see later
that, once one gets used to it, this approach scales very
naturally.</p>
<p>From a computer science point of view, this infrastructure
implements, on top of standard multiple inheritance, a dynamic
composition mechanism of mixin classes (<a class="reference external" href="https://en.wikipedia.org/wiki/Mixin">Wikipedia article Mixin</a>),
governed by mathematical properties.</p>
<p class="last">For implementation details on how the hierarchy of classes for
parents and elements is constructed, see <a class="reference internal" href="category.html#sage.categories.category.Category" title="sage.categories.category.Category"><tt class="xref py py-class docutils literal"><span class="pre">Category</span></tt></a>.</p>
</div>
</div>
<div class="section" id="on-the-category-hierarchy-subcategories-and-super-categories">
<span id="category-primer-subcategory"></span><h3>On the category hierarchy: subcategories and super categories<a class="headerlink" href="#on-the-category-hierarchy-subcategories-and-super-categories" title="Permalink to this headline">¶</a></h3>
<p>We have seen above that, for example, the category of sets is a super
category of the category of groups. This models the fact that a group
can be unambiguously considered as a set by forgetting its group
operation. In object-oriented parlance, we want the relation &#8220;a group
<em>is a</em> set&#8221;, so that groups can directly inherit code implemented on
sets.</p>
<p>Formally, a category <tt class="docutils literal"><span class="pre">Cs()</span></tt> is a <em>super category</em> of a category
<tt class="docutils literal"><span class="pre">Ds()</span></tt> if Sage considers any object of <tt class="docutils literal"><span class="pre">Ds()</span></tt> to be an object of
<tt class="docutils literal"><span class="pre">Cs()</span></tt>, up to an implicit application of a canonical functor from
<tt class="docutils literal"><span class="pre">Ds()</span></tt> to <tt class="docutils literal"><span class="pre">Cs()</span></tt>. This functor is normally an inclusion of
categories or a forgetful functor. Reciprocally, <tt class="docutils literal"><span class="pre">Ds()</span></tt> is said to
be a <em>subcategory</em> of <tt class="docutils literal"><span class="pre">Cs()</span></tt>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This terminology deviates from the usual mathematical definition
of <em>subcategory</em> and is subject to change. Indeed, the forgetful
functor from the category of groups to the category of sets is not
an inclusion of categories, as it is not injective: a given set
may admit more than one group structure. See <a class="reference external" href="http://trac.sagemath.org/16183">trac ticket #16183</a> for
more details. The name <em>supercategory</em> is also used with a
different meaning in certain areas of mathematics.</p>
</div>
</div>
<div class="section" id="categories-are-instances-and-have-operations">
<h3>Categories are instances and have operations<a class="headerlink" href="#categories-are-instances-and-have-operations" title="Permalink to this headline">¶</a></h3>
<p>Note that categories themselves are naturally modelled by instances
because they can have operations of their own. An important one is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Groups</span><span class="p">()</span><span class="o">.</span><span class="n">example</span><span class="p">()</span>
<span class="go">General Linear Group of degree 4 over Rational Field</span>
</pre></div>
</div>
<p>which gives an example of object of the category. Besides illustrating
the category, the example provides a minimal template for implementing
a new object in the category:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">Semigroups</span><span class="p">()</span><span class="o">.</span><span class="n">example</span><span class="p">();</span> <span class="n">S</span>
<span class="go">An example of a semigroup: the left zero semigroup</span>
</pre></div>
</div>
<p>Its source code can be obtained by introspection:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: S??                                     # not tested
</pre></div>
</div>
<p>This example is also typically used for testing generic methods. See
<a class="reference internal" href="category.html#sage.categories.category.Category.example" title="sage.categories.category.Category.example"><tt class="xref py py-meth docutils literal"><span class="pre">Category.example()</span></tt></a> for more.</p>
<p>Other operations on categories include querying the super categories
or the axioms satisfied by the operations of a category:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Groups</span><span class="p">()</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of monoids, Category of inverse unital magmas]</span>
<span class="gp">sage: </span><span class="n">Groups</span><span class="p">()</span><span class="o">.</span><span class="n">axioms</span><span class="p">()</span>
<span class="go">frozenset({&#39;Associative&#39;, &#39;Inverse&#39;, &#39;Unital&#39;})</span>
</pre></div>
</div>
<p>or constructing the intersection of two categories, or the smallest
category containing them:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Groups</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">FiniteSets</span><span class="p">()</span>
<span class="go">Category of finite groups</span>
<span class="gp">sage: </span><span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span> <span class="o">|</span> <span class="n">Groups</span><span class="p">()</span>
<span class="go">Category of monoids</span>
</pre></div>
</div>
</div>
<div class="section" id="specifications-and-generic-documentation">
<h3>Specifications and generic documentation<a class="headerlink" href="#specifications-and-generic-documentation" title="Permalink to this headline">¶</a></h3>
<p>Categories do not only contain code but also the specifications of the
operations. In particular a list of mandatory and optional methods to
be implemented can be found by introspection with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Groups</span><span class="p">()</span><span class="o">.</span><span class="n">required_methods</span><span class="p">()</span>
<span class="go">{&#39;element&#39;: {&#39;optional&#39;: [&#39;_mul_&#39;], &#39;required&#39;: []},</span>
<span class="go"> &#39;parent&#39;: {&#39;optional&#39;: [], &#39;required&#39;: [&#39;__contains__&#39;]}}</span>
</pre></div>
</div>
<p>Documentation about those methods can be obtained with:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: G = Groups()
sage: G.element_class._mul_?        # not tested
sage: G.parent_class.one?           # not tested
</pre></div>
</div>
<p>See also the <a class="reference external" href="../../../misc/sage/misc/abstract_method.html#sage.misc.abstract_method.abstract_method" title="(in Sage Reference Manual: Utilities v7.0)"><tt class="xref py py-func docutils literal"><span class="pre">abstract_method()</span></tt></a> decorator.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Well, more precisely, that&#8217;s how things should be, but there is
still some work to do in this direction. For example, the inverse
operation is not specified above. Also, we are still missing a
good programmatic syntax to specify the input and output types of
the methods. Finally, in many cases the implementer must provide
at least one of two methods, each having a default implementation
using the other one (e.g. listing or iterating for a finite
enumerated set); there is currently no good programmatic way to
specify this.</p>
</div>
</div>
<div class="section" id="generic-tests">
<h3>Generic tests<a class="headerlink" href="#generic-tests" title="Permalink to this headline">¶</a></h3>
<p>Another feature that parents and elements receive from categories is
generic tests; their purpose is to check (at least to some extent)
that the parent satisfies the required mathematical properties (is my
semigroup indeed associative?) and is implemented according to the
specifications (does the method <tt class="docutils literal"><span class="pre">an_element</span></tt> indeed return an
element of the parent?):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">FiniteSemigroups</span><span class="p">()</span><span class="o">.</span><span class="n">example</span><span class="p">(</span><span class="n">alphabet</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">verbose</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="go">running ._test_an_element() . . . pass</span>
<span class="go">running ._test_associativity() . . . pass</span>
<span class="go">running ._test_cardinality() . . . pass</span>
<span class="go">running ._test_category() . . . pass</span>
<span class="go">running ._test_elements() . . .</span>
<span class="go">  Running the test suite of self.an_element()</span>
<span class="go">  running ._test_category() . . . pass</span>
<span class="go">  running ._test_eq() . . . pass</span>
<span class="go">  running ._test_not_implemented_methods() . . . pass</span>
<span class="go">  running ._test_pickling() . . . pass</span>
<span class="go">  pass</span>
<span class="go">    running ._test_elements_eq_reflexive() . . . pass</span>
<span class="go">    running ._test_elements_eq_symmetric() . . . pass</span>
<span class="go">    running ._test_elements_eq_transitive() . . . pass</span>
<span class="go">    running ._test_elements_neq() . . . pass</span>
<span class="go">running ._test_enumerated_set_contains() . . . pass</span>
<span class="go">running ._test_enumerated_set_iter_cardinality() . . . pass</span>
<span class="go">running ._test_enumerated_set_iter_list() . . . pass</span>
<span class="go">running ._test_eq() . . . pass</span>
<span class="go">running ._test_not_implemented_methods() . . . pass</span>
<span class="go">running ._test_pickling() . . . pass</span>
<span class="go">running ._test_some_elements() . . . pass</span>
</pre></div>
</div>
<p>Tests can be run individually:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">_test_associativity</span><span class="p">()</span>
</pre></div>
</div>
<p>Here is how to access the code of this test:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: S._test_associativity?? # not tested
</pre></div>
</div>
<p>Here is how to run the test on all elements:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">_test_associativity</span><span class="p">(</span><span class="n">elements</span><span class="o">=</span><span class="n">L</span><span class="p">)</span>
</pre></div>
</div>
<p>See <a class="reference external" href="../../../misc/sage/misc/sage_unittest.html#sage.misc.sage_unittest.TestSuite" title="(in Sage Reference Manual: Utilities v7.0)"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> for more information.</p>
<p>Let us see what happens when a test fails. Here we redefine the
product of <span class="math">\(S\)</span> to something definitely not associative:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">product</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">S</span><span class="p">(</span><span class="s">&quot;(&quot;</span><span class="o">+</span><span class="n">x</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span><span class="n">y</span><span class="o">.</span><span class="n">value</span><span class="o">+</span><span class="s">&quot;)&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>And rerun the test:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">_test_associativity</span><span class="p">(</span><span class="n">elements</span><span class="o">=</span><span class="n">L</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">  File &quot;.../sage/categories/semigroups.py&quot;, line ..., in _test_associativity</span>
<span class="gr">    tester.assert_((x * y) * z == x * (y * z))</span>
<span class="gr">...</span>
<span class="gr">AssertionError</span>: <span class="n">False is not true</span>
</pre></div>
</div>
<p>We can recover instantly the actual values of <tt class="docutils literal"><span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">y</span></tt>, <tt class="docutils literal"><span class="pre">z</span></tt>, that is,
a counterexample to the associativity of our broken semigroup, using post
mortem introspection with the Python debugger <tt class="docutils literal"><span class="pre">pdb</span></tt> (this does not
work yet in the notebook):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">pdb</span>
<span class="gp">sage: </span><span class="n">pdb</span><span class="o">.</span><span class="n">pm</span><span class="p">()</span>                       <span class="c"># not tested</span>
<span class="go">&gt; /opt/sage-5.11.rc1/local/lib/python/unittest/case.py(424)assertTrue()</span>
<span class="go">-&gt; raise self.failureException(msg)</span>
<span class="go">(Pdb) u</span>
<span class="go">&gt; /opt/sage-5.11.rc1/local/lib/python2.7/site-packages/sage/categories/semigroups.py(145)_test_associativity()</span>
<span class="go">-&gt; tester.assert_((x * y) * z == x * (y * z))</span>
<span class="go">(Pdb) p x, y, z</span>
<span class="go">(&#39;a&#39;, &#39;a&#39;, &#39;a&#39;)</span>
<span class="go">(Pdb) p (x * y) * z</span>
<span class="go">&#39;((aa)a)&#39;</span>
<span class="go">(Pdb) p x * (y * z)</span>
<span class="go">&#39;(a(aa))&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="wrap-up">
<h3>Wrap-up<a class="headerlink" href="#wrap-up" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Categories provide a natural hierarchy of bookshelves to organize
not only code, but also specifications and testing tools.</li>
<li>Everything about, say, algebras with a distinguished basis is
gathered in <a class="reference internal" href="algebras_with_basis.html#sage.categories.algebras_with_basis.AlgebrasWithBasis" title="sage.categories.algebras_with_basis.AlgebrasWithBasis"><tt class="xref py py-class docutils literal"><span class="pre">AlgebrasWithBasis</span></tt></a> or its super categories.
This includes properties and algorithms for elements, parents,
morphisms, but also, as we will see, for constructions like
Cartesian products or quotients.</li>
<li>The mathematical relations between elements, parents, and categories
translate dynamically into a traditional hierarchy of classes.</li>
<li>This design enforces robustness and consistency, which is
particularly welcome given that Python is an interpreted language
without static type checking.</li>
</ul>
</div>
</div>
<div class="section" id="case-study">
<h2><a class="toc-backref" href="#id8">Case study</a><a class="headerlink" href="#case-study" title="Permalink to this headline">¶</a></h2>
<p>In this section, we study an existing parent in detail; a good followup is to
go through the <a class="reference internal" href="tutorial.html#module-sage.categories.tutorial" title="sage.categories.tutorial"><tt class="xref py py-mod docutils literal"><span class="pre">sage.categories.tutorial</span></tt></a> or the thematic tutorial on
coercion and categories (&#8220;How to implement new algebraic structures in Sage&#8221;)
to learn how to implement a new one!</p>
<p>We consider the example of finite semigroup provided by the category:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: S = FiniteSemigroups().example(); S
An example of a finite semigroup: the left regular band generated by (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;)
sage: S?                    # not tested
</pre></div>
</div>
<p>Where do all the operations on <tt class="docutils literal"><span class="pre">S</span></tt> and its elements come from?</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">_repr_</span></tt> is a technical method which comes with the data structure
(<a class="reference external" href="../../../structure/sage/structure/element_wrapper.html#sage.structure.element_wrapper.ElementWrapper" title="(in Sage Reference Manual: Basic Structures v7.0)"><tt class="xref py py-class docutils literal"><span class="pre">ElementWrapper</span></tt></a>); since it&#8217;s implemented in Cython, we need
to use Sage&#8217;s introspection tools to recover where it&#8217;s implemented:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">_repr_</span><span class="o">.</span><span class="n">__module__</span>
<span class="gp">sage: </span><span class="n">sage</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">sageinspect</span><span class="o">.</span><span class="n">sage_getfile</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">_repr_</span><span class="p">)</span>
<span class="go">&#39;.../sage/structure/element_wrapper.pyx&#39;</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">__pow__</span></tt> is a generic method for all finite semigroups:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">__pow__</span><span class="o">.</span><span class="n">__module__</span>
<span class="go">&#39;sage.categories.semigroups&#39;</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">__mul__</span></tt> is a default implementation from the <a class="reference internal" href="magmas.html#sage.categories.magmas.Magmas" title="sage.categories.magmas.Magmas"><tt class="xref py py-class docutils literal"><span class="pre">Magmas</span></tt></a>
category (a <em>magma</em> is a set with an inner law <span class="math">\(*\)</span>, not necessarily
associative):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">__mul__</span><span class="o">.</span><span class="n">__module__</span>
<span class="go">&#39;sage.categories.magmas&#39;</span>
</pre></div>
</div>
<p>It delegates the work to the parent (following the advice: if you do
not know what to do, ask your parent):</p>
<div class="highlight-python"><div class="highlight"><pre>sage: x.__mul__??                             # not tested
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">product</span></tt> is a mathematical method implemented by the parent:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">product</span><span class="o">.</span><span class="n">__module__</span>
<span class="go">&#39;sage.categories.examples.finite_semigroups&#39;</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">cayley_graph</span></tt> is a generic method on the parent, provided by the
<a class="reference internal" href="finite_semigroups.html#sage.categories.finite_semigroups.FiniteSemigroups" title="sage.categories.finite_semigroups.FiniteSemigroups"><tt class="xref py py-class docutils literal"><span class="pre">FiniteSemigroups</span></tt></a> category:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">cayley_graph</span><span class="o">.</span><span class="n">__module__</span>
<span class="go">&#39;sage.categories.semigroups&#39;</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">multiplication_table</span></tt> is a generic method on the parent, provided
by the <a class="reference internal" href="magmas.html#sage.categories.magmas.Magmas" title="sage.categories.magmas.Magmas"><tt class="xref py py-class docutils literal"><span class="pre">Magmas</span></tt></a> category (it does not require associativity):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">multiplication_table</span><span class="o">.</span><span class="n">__module__</span>
<span class="go">&#39;sage.categories.magmas&#39;</span>
</pre></div>
</div>
<p>Consider now the implementation of the semigroup:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: S??                                     # not tested
</pre></div>
</div>
<p>This implementation specifies a data structure for the parents and the
elements, and makes a promise: the implemented parent is a finite
semigroup. Then it fulfills the promise by implementing the basic
operation <tt class="docutils literal"><span class="pre">product</span></tt>.  It also implements the optional method
<tt class="docutils literal"><span class="pre">semigroup_generators</span></tt>. In exchange, <span class="math">\(S\)</span> and its elements receive
generic implementations of all the other operations. <span class="math">\(S\)</span> may override
any of those by more efficient ones. It may typically implement the
element method <tt class="docutils literal"><span class="pre">is_idempotent</span></tt> to always return <tt class="docutils literal"><span class="pre">True</span></tt>.</p>
<p>A (not yet complete) list of mandatory and optional methods to be
implemented can be found by introspection with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FiniteSemigroups</span><span class="p">()</span><span class="o">.</span><span class="n">required_methods</span><span class="p">()</span>
<span class="go">{&#39;element&#39;: {&#39;optional&#39;: [&#39;_mul_&#39;], &#39;required&#39;: []},</span>
<span class="go"> &#39;parent&#39;: {&#39;optional&#39;: [&#39;semigroup_generators&#39;],</span>
<span class="go">  &#39;required&#39;: [&#39;__contains__&#39;]}}</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">product</span></tt> does not appear in the list because a default implementation
is provided in term of the method <tt class="docutils literal"><span class="pre">_mul_</span></tt> on elements. Of course, at
least one of them should be implemented. On the other hand, a default
implementation for <tt class="docutils literal"><span class="pre">__contains__</span></tt> is provided by <a class="reference external" href="../../../structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Sage Reference Manual: Basic Structures v7.0)"><tt class="xref py py-class docutils literal"><span class="pre">Parent</span></tt></a>.</p>
<p>Documentation about those methods can be obtained with:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: C = FiniteSemigroups().element_class
sage: C._mul_?                                # not tested
</pre></div>
</div>
<p>See also the <a class="reference external" href="../../../misc/sage/misc/abstract_method.html#sage.misc.abstract_method.abstract_method" title="(in Sage Reference Manual: Utilities v7.0)"><tt class="xref py py-func docutils literal"><span class="pre">abstract_method()</span></tt></a> decorator.</p>
<p>Here is the code for the finite semigroups category:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: FiniteSemigroups??                      # not tested
</pre></div>
</div>
</div>
<div class="section" id="specifying-the-category-of-a-parent">
<h2><a class="toc-backref" href="#id9">Specifying the category of a parent</a><a class="headerlink" href="#specifying-the-category-of-a-parent" title="Permalink to this headline">¶</a></h2>
<p>Some parent constructors (not enough!) allow to specify the desired
category for the parent. This can typically be used to specify
additional properties of the parent that we know to hold a priori. For
example, permutation groups are by default in the category of finite
permutation groups (no surprise):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">PermutationGroup</span><span class="p">([[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)]]);</span> <span class="n">P</span>
<span class="go">Permutation Group with generators [(1,2,3)]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of finite permutation groups</span>
</pre></div>
</div>
<p>In this case, the group is commutative, so we can specify this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">PermutationGroup</span><span class="p">([[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)]],</span> <span class="n">category</span><span class="o">=</span><span class="n">PermutationGroups</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span><span class="o">.</span><span class="n">Commutative</span><span class="p">());</span> <span class="n">P</span>
<span class="go">Permutation Group with generators [(1,2,3)]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of finite commutative permutation groups</span>
</pre></div>
</div>
<p>This feature can even be used, typically in experimental code, to add
more structure to existing parents, and in particular to add methods
for the parents or the elements, without touching the code base:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">class</span> <span class="nc">Foos</span><span class="p">(</span><span class="n">Category</span><span class="p">):</span>
<span class="go">....:     def super_categories(self):</span>
<span class="go">....:          return [PermutationGroups().Finite().Commutative()]</span>
<span class="go">....:     class ParentMethods:</span>
<span class="go">....:         def foo(self): print &quot;foo&quot;</span>
<span class="go">....:     class ElementMethods:</span>
<span class="go">....:         def bar(self): print &quot;bar&quot;</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">PermutationGroup</span><span class="p">([[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)]],</span> <span class="n">category</span><span class="o">=</span><span class="n">Foos</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">foo</span><span class="p">()</span>
<span class="go">foo</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">bar</span><span class="p">()</span>
<span class="go">bar</span>
</pre></div>
</div>
<p>In the long run, it would be thinkable to use this idiom to implement
forgetful functors; for example the above group could be constructed
as a plain set with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">PermutationGroup</span><span class="p">([[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)]],</span> <span class="n">category</span><span class="o">=</span><span class="n">Sets</span><span class="p">())</span> <span class="c"># todo: not implemented</span>
</pre></div>
</div>
<p>At this stage though, this is still to be explored for robustness
and practicality. For now, most parents that accept a category argument
only accept a subcategory of the default one.</p>
</div>
<div class="section" id="scaling-further-functorial-constructions-axioms">
<h2><a class="toc-backref" href="#id10">Scaling further: functorial constructions, axioms, ...</a><a class="headerlink" href="#scaling-further-functorial-constructions-axioms" title="Permalink to this headline">¶</a></h2>
<p>In this section, we explore more advanced features of categories.
Along the way, we illustrate that a large hierarchy of categories is
desirable to model complicated mathematics, and that scaling to
support such a large hierarchy is the driving motivation for the
design of the category infrastructure.</p>
<div class="section" id="functorial-constructions">
<span id="category-primer-functorial-constructions"></span><h3>Functorial constructions<a class="headerlink" href="#functorial-constructions" title="Permalink to this headline">¶</a></h3>
<p>Sage has support for a certain number of so-called <em>covariant
functorial constructions</em> which can be used to construct new parents
from existing ones while carrying over as much as possible of their
algebraic structure. This includes:</p>
<ul class="simple">
<li>Cartesian products:
See <tt class="xref py py-const docutils literal"><span class="pre">cartesian_product</span></tt>.</li>
<li>Tensor products:
See <a class="reference internal" href="tensor.html#sage.categories.tensor.tensor" title="sage.categories.tensor.tensor"><tt class="xref py py-const docutils literal"><span class="pre">tensor</span></tt></a>.</li>
<li>Subquotients / quotients / subobjects / isomorphic objects:
See:<ul>
<li><a class="reference internal" href="sets_cat.html#sage.categories.sets_cat.Sets.SubcategoryMethods.Subquotients" title="sage.categories.sets_cat.Sets.SubcategoryMethods.Subquotients"><tt class="xref py py-meth docutils literal"><span class="pre">Sets().Subquotients</span></tt></a>,</li>
<li><a class="reference internal" href="sets_cat.html#sage.categories.sets_cat.Sets.SubcategoryMethods.Quotients" title="sage.categories.sets_cat.Sets.SubcategoryMethods.Quotients"><tt class="xref py py-meth docutils literal"><span class="pre">Sets().Quotients</span></tt></a>,</li>
<li><a class="reference internal" href="sets_cat.html#sage.categories.sets_cat.Sets.SubcategoryMethods.Subobjects" title="sage.categories.sets_cat.Sets.SubcategoryMethods.Subobjects"><tt class="xref py py-meth docutils literal"><span class="pre">Sets().Subobjects</span></tt></a>,</li>
<li><a class="reference internal" href="sets_cat.html#sage.categories.sets_cat.Sets.SubcategoryMethods.IsomorphicObjects" title="sage.categories.sets_cat.Sets.SubcategoryMethods.IsomorphicObjects"><tt class="xref py py-meth docutils literal"><span class="pre">Sets().IsomorphicObjects</span></tt></a></li>
</ul>
</li>
<li>Dual objects:
See <a class="reference internal" href="modules.html#sage.categories.modules.Modules.SubcategoryMethods.DualObjects" title="sage.categories.modules.Modules.SubcategoryMethods.DualObjects"><tt class="xref py py-meth docutils literal"><span class="pre">Modules().DualObjects</span></tt></a>.</li>
<li>Algebras, as in group algebras, monoid algebras, ...:
See: <tt class="xref py py-meth docutils literal"><span class="pre">Sets.ParentMethods.algebras()</span></tt>.</li>
</ul>
<p>Let for example <span class="math">\(A\)</span> and <span class="math">\(B\)</span> be two parents, and let us construct the
Cartesian product <span class="math">\(A \times B \times B\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">AlgebrasWithBasis</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">example</span><span class="p">();</span>     <span class="n">A</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">HopfAlgebrasWithBasis</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">example</span><span class="p">();</span> <span class="n">B</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">cartesian_product</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">B</span><span class="p">]);</span> <span class="n">C</span>
<span class="go">A (+) B (+) B</span>
</pre></div>
</div>
<p>In which category should this new parent be? Since <span class="math">\(A\)</span> and <span class="math">\(B\)</span> are
vector spaces, the result is, as a vector space, the direct sum
<span class="math">\(A \oplus B \oplus B\)</span>, hence the notation. Also, since both <span class="math">\(A\)</span> and <span class="math">\(B\)</span>
are monoids, <span class="math">\(A \times B \times B\)</span> is naturally endowed with a monoid
structure for pointwise multiplication:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span> <span class="ow">in</span> <span class="n">Monoids</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>the unit being the Cartesian product of the units of the operands:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
<span class="go">B[(0, word: )] + B[(1, ())] + B[(2, ())]</span>
<span class="gp">sage: </span><span class="n">cartesian_product</span><span class="p">([</span><span class="n">A</span><span class="o">.</span><span class="n">one</span><span class="p">(),</span> <span class="n">B</span><span class="o">.</span><span class="n">one</span><span class="p">(),</span> <span class="n">B</span><span class="o">.</span><span class="n">one</span><span class="p">()])</span>
<span class="go">B[(0, word: )] + B[(1, ())] + B[(2, ())]</span>
</pre></div>
</div>
<p>The pointwise product can be implemented generically for all magmas
(i.e. sets endowed with a multiplicative operation) that are
constructed as Cartesian products. It&#8217;s thus implemented in the
<a class="reference internal" href="magmas.html#sage.categories.magmas.Magmas" title="sage.categories.magmas.Magmas"><tt class="xref py py-class docutils literal"><span class="pre">Magmas</span></tt></a> category:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">product</span><span class="o">.</span><span class="n">__module__</span>
<span class="go">&#39;sage.categories.magmas&#39;</span>
</pre></div>
</div>
<p>More specifically, keeping on using nested classes to structure the
code, the product method is put in the nested class
<a class="reference internal" href="magmas.html#sage.categories.magmas.Magmas.CartesianProducts.ParentMethods" title="sage.categories.magmas.Magmas.CartesianProducts.ParentMethods"><tt class="xref py py-class docutils literal"><span class="pre">Magmas.CartesianProducts.ParentMethods</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre>class Magmas(Category):
    class ParentMethods:
        # methods for magmas
    class ElementMethods:
        # methods for elements of magmas
    class CartesianProduct(CartesianProductCategory):
        class ParentMethods:
            # methods for magmas that are constructed as Cartesian products
            def product(self, x, y):
                # ...
        class ElementMethods:
            # ...
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The support for nested classes in Python is relatively
recent. Their intensive use for the category infrastructure did
reveal some glitches in their implementation, in particular around
class naming and introspection. Sage currently works around the
more annoying ones but some remain visible. See
e.g. <a class="reference external" href="../../../misc/sage/misc/nested_class_test.html#module-sage.misc.nested_class_test" title="(in Sage Reference Manual: Utilities v7.0)"><tt class="xref py py-mod docutils literal"><span class="pre">sage.misc.nested_class_test</span></tt></a>.</p>
</div>
<p>Let us now look at the categories of <tt class="docutils literal"><span class="pre">C</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">categories</span><span class="p">()</span>
<span class="go">[Category of finite dimensional Cartesian products of algebras with basis over Rational Field, ...</span>
<span class="go"> Category of Cartesian products of algebras over Rational Field, ...</span>
<span class="go"> Category of Cartesian products of semigroups, Category of semigroups, ...</span>
<span class="go"> Category of Cartesian products of magmas, ..., Category of magmas, ...</span>
<span class="go"> Category of Cartesian products of additive magmas, ..., Category of additive magmas,</span>
<span class="go"> Category of Cartesian products of sets, Category of sets, ...]</span>
</pre></div>
</div>
<p>This reveals the parallel hierarchy of categories for Cartesian
products of semigroups magmas, ... We are thus glad that Sage uses
its knowledge that a monoid is a semigroup to automatically deduce
that a Cartesian product of monoids is a Cartesian product of
semigroups, and build the hierarchy of classes for parents and
elements accordingly.</p>
<p>In general, the Cartesian product of <span class="math">\(A\)</span> and <span class="math">\(B\)</span> can potentially be an
algebra, a coalgebra, a differential module, and be finite
dimensional, or graded, or ....  This can only be decided at runtime,
by introspection into the properties of <span class="math">\(A\)</span> and <span class="math">\(B\)</span>; furthermore, the
number of possible combinations (e.g. finite dimensional differential
algebra) grows exponentially with the number of properties.</p>
</div>
<div class="section" id="axioms">
<span id="category-primer-axioms"></span><h3>Axioms<a class="headerlink" href="#axioms" title="Permalink to this headline">¶</a></h3>
<div class="section" id="first-examples">
<h4>First examples<a class="headerlink" href="#first-examples" title="Permalink to this headline">¶</a></h4>
<p>We have seen that Sage is aware of the axioms satisfied by, for
example, groups:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Groups</span><span class="p">()</span><span class="o">.</span><span class="n">axioms</span><span class="p">()</span>
<span class="go">frozenset({&#39;Associative&#39;, &#39;Inverse&#39;, &#39;Unital&#39;})</span>
</pre></div>
</div>
<p>In fact, the category of groups can be <em>defined</em> by stating that a
group is a magma, that is a set endowed with an internal binary
multiplication, which satisfies the above axioms. Accordingly, we can
construct the category of groups from the category of magmas:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Associative</span><span class="p">()</span><span class="o">.</span><span class="n">Unital</span><span class="p">()</span><span class="o">.</span><span class="n">Inverse</span><span class="p">()</span>
<span class="go">Category of groups</span>
</pre></div>
</div>
<p>In general, we can construct new categories in Sage by specifying the
axioms that are satisfied by the operations of the super
categories. For example, starting from the category of magmas, we can
construct all the following categories just by specifying the axioms
satisfied by the multiplication:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Magmas</span><span class="p">()</span>
<span class="go">Category of magmas</span>
<span class="gp">sage: </span><span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Unital</span><span class="p">()</span>
<span class="go">Category of unital magmas</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Commutative</span><span class="p">()</span><span class="o">.</span><span class="n">Unital</span><span class="p">()</span>
<span class="go">Category of commutative unital magmas</span>
<span class="gp">sage: </span><span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Unital</span><span class="p">()</span><span class="o">.</span><span class="n">Commutative</span><span class="p">()</span>
<span class="go">Category of commutative unital magmas</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Associative</span><span class="p">()</span>
<span class="go">Category of semigroups</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Associative</span><span class="p">()</span><span class="o">.</span><span class="n">Unital</span><span class="p">()</span>
<span class="go">Category of monoids</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Associative</span><span class="p">()</span><span class="o">.</span><span class="n">Unital</span><span class="p">()</span><span class="o">.</span><span class="n">Commutative</span><span class="p">()</span>
<span class="go">Category of commutative monoids</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Associative</span><span class="p">()</span><span class="o">.</span><span class="n">Unital</span><span class="p">()</span><span class="o">.</span><span class="n">Inverse</span><span class="p">()</span>
<span class="go">Category of groups</span>
</pre></div>
</div>
</div>
<div class="section" id="axioms-and-categories-with-axioms">
<h4>Axioms and categories with axioms<a class="headerlink" href="#axioms-and-categories-with-axioms" title="Permalink to this headline">¶</a></h4>
<p>Here, <tt class="docutils literal"><span class="pre">Associative</span></tt>, <tt class="docutils literal"><span class="pre">Unital</span></tt>, <tt class="docutils literal"><span class="pre">Commutative</span></tt> are axioms. In
general, any category <tt class="docutils literal"><span class="pre">Cs</span></tt> in Sage can declare a new axiom
<tt class="docutils literal"><span class="pre">A</span></tt>. Then, the <em>category with axiom</em> <tt class="docutils literal"><span class="pre">Cs.A()</span></tt> models the
subcategory of the objects of <tt class="docutils literal"><span class="pre">Cs</span></tt> satisfying the axiom
<tt class="docutils literal"><span class="pre">A</span></tt>. Similarly, for any subcategory <tt class="docutils literal"><span class="pre">Ds</span></tt> of <tt class="docutils literal"><span class="pre">Cs</span></tt>, <tt class="docutils literal"><span class="pre">Ds.A()</span></tt>
models the subcategory of the objects of <tt class="docutils literal"><span class="pre">Ds</span></tt> satisfying the axiom
<tt class="docutils literal"><span class="pre">A</span></tt>. In most cases, it&#8217;s a <em>full subcategory</em> (see
<a class="reference external" href="https://en.wikipedia.org/wiki/Subcategory">Wikipedia article Subcategory</a>).</p>
<p>For example, the category of sets defines the <tt class="docutils literal"><span class="pre">Finite</span></tt> axiom, and
this axiom is available in the subcategory of groups:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span>
<span class="go">Category of finite sets</span>
<span class="gp">sage: </span><span class="n">Groups</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span>
<span class="go">Category of finite groups</span>
</pre></div>
</div>
<p>The meaning of each axiom is described in the documentation of the
corresponding method, which can be obtained as usual by
instrospection:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: C = Groups()
sage: C.Finite?              # not tested
</pre></div>
</div>
<p>The purpose of categories with axioms is no different from other
categories: to provide bookshelves of code, documentation,
mathematical knowledge, tests, for their objects. The extra feature is
that, when intersecting categories, axioms are automatically combined
together:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Associative</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Unital</span><span class="p">()</span><span class="o">.</span><span class="n">Inverse</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">();</span> <span class="n">C</span>
<span class="go">Category of finite groups</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">axioms</span><span class="p">())</span>
<span class="go">[&#39;Associative&#39;, &#39;Finite&#39;, &#39;Inverse&#39;, &#39;Unital&#39;]</span>
</pre></div>
</div>
<p>For a more advanced example, Sage knows that a ring is a set <span class="math">\(C\)</span>
endowed with a multiplication which distributes over addition, such
that <span class="math">\((C, +)\)</span> is a commutative additive group and <span class="math">\((C, *)\)</span> is a monoid:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="p">(</span><span class="n">CommutativeAdditiveGroups</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">Monoids</span><span class="p">())</span><span class="o">.</span><span class="n">Distributive</span><span class="p">();</span> <span class="n">C</span>
<span class="go">Category of rings</span>

<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">axioms</span><span class="p">())</span>
<span class="go">[&#39;AdditiveAssociative&#39;, &#39;AdditiveCommutative&#39;, &#39;AdditiveInverse&#39;,</span>
<span class="go"> &#39;AdditiveUnital&#39;, &#39;Associative&#39;, &#39;Distributive&#39;, &#39;Unital&#39;]</span>
</pre></div>
</div>
<p>The infrastructure allows for specifying further deduction rules, in
order to encode mathematical facts like Wedderburn&#8217;s theorem:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">DivisionRings</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span>
<span class="go">Category of finite fields</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>When an axiom specifies the properties of some operations in Sage,
the notations for those operations are tied to this axiom. For
example, as we have seen above, we need two distinct axioms for
associativity: the axiom &#8220;AdditiveAssociative&#8221; is about the
properties of the addition <span class="math">\(+\)</span>, whereas the axiom &#8220;Associative&#8221; is
about the properties of the multiplication <span class="math">\(*\)</span>.</p>
<p>We are touching here an inherent limitation of the current
infrastructure. There is indeed no support for providing generic
code that is independent of the notations. In particular, the
category hierarchy about additive structures (additive monoids,
additive groups, ...) is completely duplicated by that for
multiplicative structures (monoids, groups, ...).</p>
<p class="last">As far as we know, none of the existing computer algebra systems
has a good solution for this problem. The difficulty is that this
is not only about a single notation but a bunch of operators and
methods: <tt class="docutils literal"><span class="pre">+,</span> <span class="pre">-,</span> <span class="pre">zero,</span> <span class="pre">summation,</span> <span class="pre">sum,</span> <span class="pre">...</span></tt> in one case, <tt class="docutils literal"><span class="pre">*,</span> <span class="pre">/,</span>
<span class="pre">one,</span> <span class="pre">product,</span> <span class="pre">prod,</span> <span class="pre">factor,</span> <span class="pre">...</span></tt> in the other. Sharing something
between the two hierarchies of categories would only be useful if
one could write generic code that applies in both cases; for that
one needs to somehow automatically substitute the right operations
in the right spots in the code. That&#8217;s kind of what we are doing
manually between
e.g. <a class="reference internal" href="additive_magmas.html#sage.categories.additive_magmas.AdditiveMagmas.ParentMethods.addition_table" title="sage.categories.additive_magmas.AdditiveMagmas.ParentMethods.addition_table"><tt class="xref py py-meth docutils literal"><span class="pre">AdditiveMagmas.ParentMethods.addition_table()</span></tt></a> and
<a class="reference internal" href="magmas.html#sage.categories.magmas.Magmas.ParentMethods.multiplication_table" title="sage.categories.magmas.Magmas.ParentMethods.multiplication_table"><tt class="xref py py-meth docutils literal"><span class="pre">Magmas.ParentMethods.multiplication_table()</span></tt></a>, but doing this
systematically is a different beast from what we have been doing
so far with just usual inheritance.</p>
</div>
</div>
<div class="section" id="single-entry-point-and-name-space-usage">
<span id="category-primer-axioms-single-entry-point"></span><h4>Single entry point and name space usage<a class="headerlink" href="#single-entry-point-and-name-space-usage" title="Permalink to this headline">¶</a></h4>
<p>A nice feature of the notation <tt class="docutils literal"><span class="pre">Cs.A()</span></tt> is that, from a single entry
point (say the category <a class="reference internal" href="magmas.html#sage.categories.magmas.Magmas" title="sage.categories.magmas.Magmas"><tt class="xref py py-class docutils literal"><span class="pre">Magmas</span></tt></a> as above), one can explore a
whole range of related categories, typically with the help of
introspection to discover which axioms are available, and without
having to import new Python modules. This feature will be used in
<a class="reference external" href="http://trac.sagemath.org/15741">trac ticket #15741</a> to unclutter the global name space from, for example,
the many variants of the category of algebras like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FiniteDimensionalAlgebrasWithBasis</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">Category of finite dimensional algebras with basis over Rational Field</span>
</pre></div>
</div>
<p>There will of course be a deprecation step, but it&#8217;s recommended to
prefer right away the more flexible notation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">WithBasis</span><span class="p">()</span><span class="o">.</span><span class="n">FiniteDimensional</span><span class="p">()</span>
<span class="go">Category of finite dimensional algebras with basis over Rational Field</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title first">Design discussion</p>
<p>How far should this be pushed? <a class="reference internal" href="fields.html#sage.categories.fields.Fields" title="sage.categories.fields.Fields"><tt class="xref py py-class docutils literal"><span class="pre">Fields</span></tt></a> should definitely
stay, but should <a class="reference internal" href="finite_groups.html#sage.categories.finite_groups.FiniteGroups" title="sage.categories.finite_groups.FiniteGroups"><tt class="xref py py-class docutils literal"><span class="pre">FiniteGroups</span></tt></a> or <a class="reference internal" href="division_rings.html#sage.categories.division_rings.DivisionRings" title="sage.categories.division_rings.DivisionRings"><tt class="xref py py-class docutils literal"><span class="pre">DivisionRings</span></tt></a>
be removed from the global namespace? Do we want to further
completely deprecate the notation <tt class="docutils literal"><span class="pre">FiniteGroups()`</span> <span class="pre">in</span> <span class="pre">favor</span> <span class="pre">of</span>
<span class="pre">``Groups().Finite()</span></tt>?</p>
</div>
</div>
<div class="section" id="on-the-potential-combinatorial-explosion-of-categories-with-axioms">
<span id="category-primer-axioms-explosion"></span><h4>On the potential combinatorial explosion of categories with axioms<a class="headerlink" href="#on-the-potential-combinatorial-explosion-of-categories-with-axioms" title="Permalink to this headline">¶</a></h4>
<p>Even for a very simple category like <tt class="docutils literal"><span class="pre">Magmas</span></tt>, there are about <span class="math">\(2^5\)</span>
potential combinations of the axioms! Think about what this becomes
for a category with two operations <span class="math">\(+\)</span> and <span class="math">\(*\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="p">(</span><span class="n">Magmas</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">AdditiveMagmas</span><span class="p">())</span><span class="o">.</span><span class="n">Distributive</span><span class="p">();</span> <span class="n">C</span>
<span class="go">Category of distributive magmas and additive magmas</span>

<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">Associative</span><span class="p">()</span><span class="o">.</span><span class="n">AdditiveAssociative</span><span class="p">()</span><span class="o">.</span><span class="n">AdditiveCommutative</span><span class="p">()</span><span class="o">.</span><span class="n">AdditiveUnital</span><span class="p">()</span><span class="o">.</span><span class="n">AdditiveInverse</span><span class="p">()</span>
<span class="go">Category of rngs</span>

<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">Associative</span><span class="p">()</span><span class="o">.</span><span class="n">AdditiveAssociative</span><span class="p">()</span><span class="o">.</span><span class="n">AdditiveCommutative</span><span class="p">()</span><span class="o">.</span><span class="n">AdditiveUnital</span><span class="p">()</span><span class="o">.</span><span class="n">Unital</span><span class="p">()</span>
<span class="go">Category of semirings</span>

<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">Associative</span><span class="p">()</span><span class="o">.</span><span class="n">AdditiveAssociative</span><span class="p">()</span><span class="o">.</span><span class="n">AdditiveCommutative</span><span class="p">()</span><span class="o">.</span><span class="n">AdditiveUnital</span><span class="p">()</span><span class="o">.</span><span class="n">AdditiveInverse</span><span class="p">()</span><span class="o">.</span><span class="n">Unital</span><span class="p">()</span>
<span class="go">Category of rings</span>

<span class="gp">sage: </span><span class="n">Rings</span><span class="p">()</span><span class="o">.</span><span class="n">Division</span><span class="p">()</span>
<span class="go">Category of division rings</span>

<span class="gp">sage: </span><span class="n">Rings</span><span class="p">()</span><span class="o">.</span><span class="n">Division</span><span class="p">()</span><span class="o">.</span><span class="n">Commutative</span><span class="p">()</span>
<span class="go">Category of fields</span>

<span class="gp">sage: </span><span class="n">Rings</span><span class="p">()</span><span class="o">.</span><span class="n">Division</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span>
<span class="go">Category of finite fields</span>
</pre></div>
</div>
<p>or for more advanced categories:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">HopfAlgebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">WithBasis</span><span class="p">()</span><span class="o">.</span><span class="n">Graded</span><span class="p">()</span><span class="o">.</span><span class="n">Connected</span><span class="p">()</span><span class="o">.</span><span class="n">category_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">set_latex_options</span><span class="p">(</span><span class="n">format</span><span class="o">=</span><span class="s">&quot;dot2tex&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">view</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">tightpage</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>                 <span class="c"># not tested</span>
</pre></div>
</div>
</div>
<div class="section" id="difference-between-axioms-and-regressive-covariant-functorial-constructions">
<h4>Difference between axioms and regressive covariant functorial constructions<a class="headerlink" href="#difference-between-axioms-and-regressive-covariant-functorial-constructions" title="Permalink to this headline">¶</a></h4>
<p>Our running examples here will be the axiom <tt class="docutils literal"><span class="pre">FiniteDimensional</span></tt> and
the regressive covariant functorial construction <tt class="docutils literal"><span class="pre">Graded</span></tt>. Let
<tt class="docutils literal"><span class="pre">Cs</span></tt> be some subcategory of <tt class="docutils literal"><span class="pre">Modules</span></tt>, say the category of modules
itself:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Cs</span> <span class="o">=</span> <span class="n">Modules</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
</pre></div>
</div>
<p>Then, <tt class="docutils literal"><span class="pre">Cs.FiniteDimensional()</span></tt> (respectively <tt class="docutils literal"><span class="pre">Cs.Graded()</span></tt>) is the
subcategory of the objects <tt class="docutils literal"><span class="pre">O</span></tt> of <tt class="docutils literal"><span class="pre">Cs</span></tt> which are finite
dimensional (respectively graded).</p>
<p>Let also <tt class="docutils literal"><span class="pre">Ds</span></tt> be a subcategory of <tt class="docutils literal"><span class="pre">Cs</span></tt>, say:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Ds</span> <span class="o">=</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
</pre></div>
</div>
<p>A finite dimensional algebra is also a finite dimensional module:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">FiniteDimensional</span><span class="p">()</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span> <span class="n">Modules</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">FiniteDimensional</span><span class="p">()</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Similarly a graded algebra is also a graded module:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Graded</span><span class="p">()</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span> <span class="n">Modules</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Graded</span><span class="p">()</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This is the <em>covariance</em> property: for <tt class="docutils literal"><span class="pre">A</span></tt> an axiom or a covariant
functorial construction, if <tt class="docutils literal"><span class="pre">Ds</span></tt> is a subcategory of <tt class="docutils literal"><span class="pre">Cs</span></tt>, then
<tt class="docutils literal"><span class="pre">Ds.A()</span></tt> is a subcategory of <tt class="docutils literal"><span class="pre">Cs.A()</span></tt>.</p>
<p>What happens if we consider reciprocally an object of <tt class="docutils literal"><span class="pre">Cs.A()</span></tt> which
is also in <tt class="docutils literal"><span class="pre">Ds</span></tt>? A finite dimensional module which is also an
algebra is a finite dimensional algebra:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Modules</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">FiniteDimensional</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">Category of finite dimensional algebras over Rational Field</span>
</pre></div>
</div>
<p>On the other hand, a graded module <span class="math">\(O\)</span> which is also an algebra is not
necessarily a graded algebra! Indeed, the grading on <span class="math">\(O\)</span> may not be
compatible with the product on <span class="math">\(O\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Modules</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Graded</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">Join of Category of algebras over Rational Field and Category of graded modules over Rational Field</span>
</pre></div>
</div>
<p>The relevant difference between <tt class="docutils literal"><span class="pre">FiniteDimensional</span></tt> and <tt class="docutils literal"><span class="pre">Graded</span></tt>
is that <tt class="docutils literal"><span class="pre">FiniteDimensional</span></tt> is a statement about the properties of
<tt class="docutils literal"><span class="pre">O</span></tt> seen as a module (and thus does not depend on the given
category), whereas <tt class="docutils literal"><span class="pre">Graded</span></tt> is a statement about the properties of
<tt class="docutils literal"><span class="pre">O</span></tt> and all its operations in the given category.</p>
<p>In general, if a category satisfies a given axiom, any subcategory
also satisfies that axiom. Another formulation is that, for an axiom
<tt class="docutils literal"><span class="pre">A</span></tt> defined in a super category <tt class="docutils literal"><span class="pre">Cs</span></tt> of <tt class="docutils literal"><span class="pre">Ds</span></tt>, <tt class="docutils literal"><span class="pre">Ds.A()</span></tt> is the
intersection of the categories <tt class="docutils literal"><span class="pre">Ds</span></tt> and <tt class="docutils literal"><span class="pre">Cs.A()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">As</span> <span class="o">=</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">FiniteDimensional</span><span class="p">();</span> <span class="n">As</span>
<span class="go">Category of finite dimensional algebras over Rational Field</span>
<span class="gp">sage: </span><span class="n">Bs</span> <span class="o">=</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">Modules</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">FiniteDimensional</span><span class="p">();</span> <span class="n">As</span>
<span class="go">Category of finite dimensional algebras over Rational Field</span>
<span class="gp">sage: </span><span class="n">As</span> <span class="ow">is</span> <span class="n">Bs</span>
<span class="go">True</span>
</pre></div>
</div>
<p>An immediate consequence is that, as we have already noticed, axioms
commute:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">As</span> <span class="o">=</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">FiniteDimensional</span><span class="p">()</span><span class="o">.</span><span class="n">WithBasis</span><span class="p">();</span> <span class="n">As</span>
<span class="go">Category of finite dimensional algebras with basis over Rational Field</span>
<span class="gp">sage: </span><span class="n">Bs</span> <span class="o">=</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">WithBasis</span><span class="p">()</span><span class="o">.</span><span class="n">FiniteDimensional</span><span class="p">();</span> <span class="n">Bs</span>
<span class="go">Category of finite dimensional algebras with basis over Rational Field</span>
<span class="gp">sage: </span><span class="n">As</span> <span class="ow">is</span> <span class="n">Bs</span>
<span class="go">True</span>
</pre></div>
</div>
<p>On the other hand, axioms do not necessarily commute with functorial
constructions, even if the current printout may missuggest so:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">As</span> <span class="o">=</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Graded</span><span class="p">()</span><span class="o">.</span><span class="n">WithBasis</span><span class="p">();</span> <span class="n">As</span>
<span class="go">Category of graded algebras with basis over Rational Field</span>
<span class="gp">sage: </span><span class="n">Bs</span> <span class="o">=</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">WithBasis</span><span class="p">()</span><span class="o">.</span><span class="n">Graded</span><span class="p">();</span> <span class="n">Bs</span>
<span class="go">Category of graded algebras with basis over Rational Field</span>
<span class="gp">sage: </span><span class="n">As</span> <span class="ow">is</span> <span class="n">Bs</span>
<span class="go">False</span>
</pre></div>
</div>
<p>This is because <tt class="docutils literal"><span class="pre">Bs</span></tt> is the category of algebras endowed with basis,
which are further graded; in particular the basis must respect the
grading (i.e. be made of homogeneous elements). On the other hand,
<tt class="docutils literal"><span class="pre">As</span></tt> is the category of graded algebras, which are further endowed
with some basis; that basis need not respect the grading. In fact
<tt class="docutils literal"><span class="pre">As</span></tt> is really a join category:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">As</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.categories.category.JoinCategory_with_category&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">As</span><span class="o">.</span><span class="n">_repr_</span><span class="p">(</span><span class="n">as_join</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">&#39;Join of Category of algebras with basis over Rational Field and Category of graded algebras over Rational Field&#39;</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">Improve the printing of functorial constructions and joins to
raise this potentially dangerous ambiguity.</p>
</div>
</div>
<div class="section" id="further-reading-on-axioms">
<h4>Further reading on axioms<a class="headerlink" href="#further-reading-on-axioms" title="Permalink to this headline">¶</a></h4>
<p>We refer to <a class="reference internal" href="category_with_axiom.html#module-sage.categories.category_with_axiom" title="sage.categories.category_with_axiom"><tt class="xref py py-mod docutils literal"><span class="pre">sage.categories.category_with_axiom</span></tt></a> for how to
implement axioms.</p>
</div>
</div>
<div class="section" id="id1">
<h3>Wrap-up<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>As we have seen, there is a combinatorial explosion of possible
classes. Constructing by hand the full class hierarchy would not scale
unless one would restrict to a very rigid subset. Even if it was
possible to construct automatically the full hierarchy, this would not
scale with respect to system resources.</p>
<p>When designing software systems with large hierarchies of abstract
classes for business objects, the difficulty is usually to identify a
proper set of key concepts. Here we are lucky, as the key concepts
have been long identified and are relatively few:</p>
<ul class="simple">
<li>Operations (<span class="math">\(+\)</span>, <span class="math">\(*\)</span>, ...)</li>
<li>Axioms on those operations (associativity, ...)</li>
<li>Constructions (Cartesian products, ...)</li>
</ul>
<p>Better, those concepts are sufficiently well known so that a user can
reasonably be expected to be familiar with the concepts that are
involved for his own needs.</p>
<p>Instead, the difficulty is concentrated in the huge number of possible
combinations, an unpredictable large subset of which being potentially
of interest; at the same time, only a small &#8211; but moving &#8211; subset
has code naturally attached to it.</p>
<p>This has led to the current design, where one focuses on writing the
relatively few classes for which there is actual code or mathematical
information, and lets Sage <em>compose dynamically and lazily</em> those
building blocks to construct the minimal hierarchy of classes needed
for the computation at hand. This allows for the infrastructure to
scale smoothly as bookshelves are added, extended, or reorganized.</p>
</div>
</div>
<div class="section" id="writing-a-new-category">
<h2><a class="toc-backref" href="#id11">Writing a new category</a><a class="headerlink" href="#writing-a-new-category" title="Permalink to this headline">¶</a></h2>
<p>Each category <span class="math">\(C\)</span> <strong>must</strong> be provided with a method
<tt class="docutils literal"><span class="pre">C.super_categories()</span></tt> and <em>can</em> be provided with a method
<tt class="docutils literal"><span class="pre">C._subcategory_hook_(D)</span></tt>. Also, it may be needed to insert <span class="math">\(C\)</span> into
the output of the <tt class="docutils literal"><span class="pre">super_categories()</span></tt> method of some other
category. This determines the position of <span class="math">\(C\)</span> in the category graph.</p>
<p>A category <em>may</em> provide methods that can be used by all its objects,
respectively by all elements of its objects.</p>
<p>Each category <em>should</em> come with a good example, in
<tt class="xref py py-mod docutils literal"><span class="pre">sage.categories.examples</span></tt>.</p>
<div class="section" id="inserting-the-new-category-into-the-category-graph">
<h3>Inserting the new category into the category graph<a class="headerlink" href="#inserting-the-new-category-into-the-category-graph" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">C.super_categories()</span></tt> <em>must</em> return a list of categories, namely
the <em>immediate</em> super categories of <span class="math">\(C\)</span>.  Of course, if you know that
your new category <span class="math">\(C\)</span> is an immediate super category of some existing
category <span class="math">\(D\)</span>, then you should also update the method
<tt class="docutils literal"><span class="pre">D.super_categories</span></tt> to include <span class="math">\(C\)</span>.</p>
<p>The immediate super categories of <span class="math">\(C\)</span> <em>should not</em> be <a class="reference internal" href="category.html#sage.categories.category.JoinCategory" title="sage.categories.category.JoinCategory"><tt class="xref py py-class docutils literal"><span class="pre">join</span>
<span class="pre">categories</span></tt></a>. Furthermore, one always should have:</p>
<div class="highlight-python"><div class="highlight"><pre>Cs().is_subcategory( Category.join(Cs().super_categories()) )

Cs()._cmp_key  &gt;  other._cmp_key  for other in Cs().super_categories()
</pre></div>
</div>
<p>This is checked by <a class="reference internal" href="category.html#sage.categories.category.Category._test_category" title="sage.categories.category.Category._test_category"><tt class="xref py py-meth docutils literal"><span class="pre">_test_category()</span></tt></a>.</p>
<p>In several cases, the category <span class="math">\(C\)</span> is directly provided with a generic
implementation of <tt class="docutils literal"><span class="pre">super_categories</span></tt>; a typical example is when <span class="math">\(C\)</span>
implements an axiom or a functorial construction; in such a case, <span class="math">\(C\)</span>
may implement <tt class="docutils literal"><span class="pre">C.extra_super_categories()</span></tt> to complement the super
categories discovered by the generic implementation. This method needs
not return immediate super categories; instead it&#8217;s usually best to
specify the largest super category providing the desired mathematical
information. For example, the category
<a class="reference internal" href="magmas.html#sage.categories.magmas.Magmas.Commutative.Algebras" title="sage.categories.magmas.Magmas.Commutative.Algebras"><tt class="xref py py-class docutils literal"><span class="pre">Magmas.Commutative.Algebras</span></tt></a> just states that the algebra of a
commutative magma is a commutative magma. This is sufficient to let
Sage deduce that it&#8217;s in fact a commutative algebra.</p>
</div>
<div class="section" id="methods-for-objects-and-elements">
<h3>Methods for objects and elements<a class="headerlink" href="#methods-for-objects-and-elements" title="Permalink to this headline">¶</a></h3>
<p>Different objects of the same category share some algebraic features, and
very often these features can be encoded in a method, in a generic way.
For example, for every commutative additive monoid, it makes sense to ask
for the sum of a list of elements. Sage&#8217;s category framework allows to
provide a generic implementation for all objects of a category.</p>
<p>If you want to provide your new category with generic methods for
objects (or elements of objects), then you simply add a nested class
called <tt class="docutils literal"><span class="pre">ParentMethods</span></tt> (or <tt class="docutils literal"><span class="pre">ElementMethods</span></tt>). The methods of that
class will automatically become methods of the objects (or the
elements). For instance:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">2*x*y</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">prod</span><span class="o">.</span><span class="n">__module__</span>
<span class="go">&#39;sage.categories.monoids&#39;</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">prod</span><span class="o">.</span><span class="n">__func__</span> <span class="ow">is</span> <span class="n">Monoids</span><span class="p">()</span><span class="o">.</span><span class="n">ParentMethods</span><span class="o">.</span><span class="n">prod</span><span class="o">.</span><span class="n">__func__</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We recommend to study the code of one example:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: C = CommutativeAdditiveMonoids()
sage: C??                               # not tested
</pre></div>
</div>
</div>
<div class="section" id="on-the-order-of-super-categories">
<span id="category-primer-category-order"></span><h3>On the order of super categories<a class="headerlink" href="#on-the-order-of-super-categories" title="Permalink to this headline">¶</a></h3>
<p>The generic method <tt class="docutils literal"><span class="pre">C.all_super_categories()</span></tt> determines recursively
the list of <em>all</em> super categories of <span class="math">\(C\)</span>.</p>
<p>The order of the categories in this list does influence the
inheritance of methods for parents and elements. Namely, if <span class="math">\(P\)</span> is an
object in the category <span class="math">\(C\)</span> and if <span class="math">\(C_1\)</span> and <span class="math">\(C_2\)</span> are both super
categories of <span class="math">\(C\)</span> defining some method <tt class="docutils literal"><span class="pre">foo</span></tt> in <tt class="docutils literal"><span class="pre">ParentMethods</span></tt>,
then <span class="math">\(P\)</span> will use <span class="math">\(C_1\)</span>&#8216;s version of <tt class="docutils literal"><span class="pre">foo</span></tt> if and only if <span class="math">\(C_1\)</span>
appears in <tt class="docutils literal"><span class="pre">C.all_super_categories()</span></tt> before <span class="math">\(C_2\)</span>.</p>
<p>However this must be considered as an <em>implementation detail</em>: if
<span class="math">\(C_1\)</span> and <span class="math">\(C_2\)</span> are incomparable categories, then the order in which
they appear must be mathematically irrelevant: in particular, the
methods <tt class="docutils literal"><span class="pre">foo</span></tt> in <span class="math">\(C_1\)</span> and <span class="math">\(C_2\)</span> must have the same semantic. Code
should not rely on any specific order, as it is subject to later
change. Whenever one of the implementations is preferred in some common
subcategory of <span class="math">\(C_1\)</span> and <span class="math">\(C_2\)</span>, for example for efficiency reasons,
the ambiguity should be resolved explicitly by definining a
method <tt class="docutils literal"><span class="pre">foo</span></tt> in this category. See the method <tt class="docutils literal"><span class="pre">some_elements</span></tt> in
the code of the category <a class="reference internal" href="finite_coxeter_groups.html#sage.categories.finite_coxeter_groups.FiniteCoxeterGroups" title="sage.categories.finite_coxeter_groups.FiniteCoxeterGroups"><tt class="xref py py-class docutils literal"><span class="pre">FiniteCoxeterGroups</span></tt></a> for an example.</p>
<p>Since <a class="reference external" href="http://trac.sagemath.org/11943">trac ticket #11943</a>, <tt class="docutils literal"><span class="pre">C.all_super_categories()</span></tt> is computed by the
so-called <tt class="docutils literal"><span class="pre">C3</span></tt> algorithm used by Python to compute Method Resolution
Order of new-style classes. Thus the order in
<tt class="docutils literal"><span class="pre">C.all_super_categories()</span></tt>, <tt class="docutils literal"><span class="pre">C.parent_class.mro()</span></tt> and
<tt class="docutils literal"><span class="pre">C.element_class.mro()</span></tt> are guaranteed to be consistent.</p>
<p>Since <a class="reference external" href="http://trac.sagemath.org/13589">trac ticket #13589</a>, the <tt class="docutils literal"><span class="pre">C3</span></tt> algorithm is put under control of some
total order on categories. This order is not necessarily meaningful,
but it guarantees that <tt class="docutils literal"><span class="pre">C3</span></tt> always finds a consistent Method
Resolution Order. For background, see
<a class="reference external" href="../../../misc/sage/misc/c3_controlled.html#module-sage.misc.c3_controlled" title="(in Sage Reference Manual: Utilities v7.0)"><tt class="xref py py-mod docutils literal"><span class="pre">sage.misc.c3_controlled</span></tt></a>. A visible effect is that the order in
which categories are specified in <tt class="docutils literal"><span class="pre">C.super_categories()</span></tt>, or in a
join category, no longer influences the result of
<tt class="docutils literal"><span class="pre">C.all_super_categories()</span></tt>.</p>
</div>
<div class="section" id="subcategory-hook-advanced-optimization-feature">
<h3>Subcategory hook (advanced optimization feature)<a class="headerlink" href="#subcategory-hook-advanced-optimization-feature" title="Permalink to this headline">¶</a></h3>
<p>The default implementation of the method <tt class="docutils literal"><span class="pre">C.is_subcategory(D)</span></tt> is to
look up whether <span class="math">\(D\)</span> appears in <tt class="docutils literal"><span class="pre">C.all_super_categories()</span></tt>. However,
building the list of all the super categories of <span class="math">\(C\)</span> is an expensive
operation that is sometimes best avoided. For example, if both <span class="math">\(C\)</span> and
<span class="math">\(D\)</span> are categories defined over a base, but the bases differ, then one
knows right away that they can not be subcategories of each other.</p>
<p>When such a short-path is known, one can implement a method
<tt class="docutils literal"><span class="pre">_subcategory_hook_</span></tt>. Then, <tt class="docutils literal"><span class="pre">C.is_subcategory(D)</span></tt> first calls
<tt class="docutils literal"><span class="pre">D._subcategory_hook_(C)</span></tt>. If this returns <tt class="docutils literal"><span class="pre">Unknown</span></tt>, then
<tt class="docutils literal"><span class="pre">C.is_subcategory(D)</span></tt> tries to find <tt class="docutils literal"><span class="pre">D</span></tt> in
<tt class="docutils literal"><span class="pre">C.all_super_categories()</span></tt>. Otherwise, <tt class="docutils literal"><span class="pre">C.is_subcategory(D)</span></tt>
returns the result of <tt class="docutils literal"><span class="pre">D._subcategory_hook_(C)</span></tt>.</p>
<p>By default, <tt class="docutils literal"><span class="pre">D._subcategory_hook_(C)</span></tt> tests whether
<tt class="docutils literal"><span class="pre">issubclass(C.parent_class,D.parent_class)</span></tt>, which is very often
giving the right answer:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Rings</span><span class="p">()</span><span class="o">.</span><span class="n">_subcategory_hook_</span><span class="p">(</span><span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">HopfAlgebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">_subcategory_hook_</span><span class="p">(</span><span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">_subcategory_hook_</span><span class="p">(</span><span class="n">HopfAlgebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference internal" href="#">Elements, parents, and categories in Sage: a (draft of) primer</a><ul>
<li><a class="reference internal" href="#abstract">Abstract</a><ul>
<li><a class="reference internal" href="#one-line-pitch-for-mathematicians">One line pitch for mathematicians</a></li>
<li><a class="reference internal" href="#one-line-pitch-for-programmers">One line pitch for programmers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#introduction-sage-as-a-library-of-objects-and-algorithms">Introduction: Sage as a library of objects and algorithms</a><ul>
<li><a class="reference internal" href="#some-challenges">Some challenges</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-bit-of-help-from-abstract-algebra">A bit of help from abstract algebra</a><ul>
<li><a class="reference internal" href="#the-hierarchy-of-categories">The hierarchy of categories</a></li>
<li><a class="reference internal" href="#elements-parents-categories">Elements, Parents, Categories</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-bit-of-help-from-computer-science">A bit of help from computer science</a><ul>
<li><a class="reference internal" href="#hierarchy-of-classes">Hierarchy of classes</a></li>
<li><a class="reference internal" href="#parallel-hierarchy-of-classes-for-parents">Parallel hierarchy of classes for parents</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage-categories">Sage categories</a><ul>
<li><a class="reference internal" href="#dynamic-hierarchy-of-classes">Dynamic hierarchy of classes</a></li>
<li><a class="reference internal" href="#on-the-category-hierarchy-subcategories-and-super-categories">On the category hierarchy: subcategories and super categories</a></li>
<li><a class="reference internal" href="#categories-are-instances-and-have-operations">Categories are instances and have operations</a></li>
<li><a class="reference internal" href="#specifications-and-generic-documentation">Specifications and generic documentation</a></li>
<li><a class="reference internal" href="#generic-tests">Generic tests</a></li>
<li><a class="reference internal" href="#wrap-up">Wrap-up</a></li>
</ul>
</li>
<li><a class="reference internal" href="#case-study">Case study</a></li>
<li><a class="reference internal" href="#specifying-the-category-of-a-parent">Specifying the category of a parent</a></li>
<li><a class="reference internal" href="#scaling-further-functorial-constructions-axioms">Scaling further: functorial constructions, axioms, ...</a><ul>
<li><a class="reference internal" href="#functorial-constructions">Functorial constructions</a></li>
<li><a class="reference internal" href="#axioms">Axioms</a><ul>
<li><a class="reference internal" href="#first-examples">First examples</a></li>
<li><a class="reference internal" href="#axioms-and-categories-with-axioms">Axioms and categories with axioms</a></li>
<li><a class="reference internal" href="#single-entry-point-and-name-space-usage">Single entry point and name space usage</a></li>
<li><a class="reference internal" href="#on-the-potential-combinatorial-explosion-of-categories-with-axioms">On the potential combinatorial explosion of categories with axioms</a></li>
<li><a class="reference internal" href="#difference-between-axioms-and-regressive-covariant-functorial-constructions">Difference between axioms and regressive covariant functorial constructions</a></li>
<li><a class="reference internal" href="#further-reading-on-axioms">Further reading on axioms</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id1">Wrap-up</a></li>
</ul>
</li>
<li><a class="reference internal" href="#writing-a-new-category">Writing a new category</a><ul>
<li><a class="reference internal" href="#inserting-the-new-category-into-the-category-graph">Inserting the new category into the category graph</a></li>
<li><a class="reference internal" href="#methods-for-objects-and-elements">Methods for objects and elements</a></li>
<li><a class="reference internal" href="#on-the-order-of-super-categories">On the order of super categories</a></li>
<li><a class="reference internal" href="#subcategory-hook-advanced-optimization-feature">Subcategory hook (advanced optimization feature)</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="../../index.html"
                                  title="previous chapter">Category Framework</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="category.html"
                                  title="next chapter">Categories</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../_sources/sage/categories/primer.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="category.html" title="Categories"
             >next</a> |</li>
        <li class="right" >
          <a href="../../index.html" title="Category Framework"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Category Framework</a> &raquo;</li>
 
      </ul>
    </div>
    
    <div class="footer">
        &copy; Copyright 2005--2016, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>