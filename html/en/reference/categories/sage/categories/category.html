<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=600, initial-scale=1">
    <title>Categories &#8212; Sage Reference Manual v8.0: Category Framework</title>
    
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '8.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Axioms" href="category_with_axiom.html" />
    <link rel="prev" title="Elements, parents, and categories in Sage: a (draft of) primer" href="primer.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />
    <script src="../../../_static/thebe.js" type="text/javascript"></script>
    <script src="../../../_static/thebe-sage.js" type="text/javascript"></script>

  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="category_with_axiom.html" title="Axioms"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="primer.html" title="Elements, parents, and categories in Sage: a (draft of) primer"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Category Framework</a> &#187;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="categories">
<span id="sage-categories-category"></span><h1>Categories<a class="headerlink" href="#categories" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.categories.category"></span><p>AUTHORS:</p>
<ul class="simple">
<li>David Kohel, William Stein and Nicolas M. Thiery</li>
</ul>
<p>Every Sage object lies in a category. Categories in Sage are
modeled on the mathematical idea of category, and are distinct from
Python classes, which are a programming construct.</p>
<p>In most cases, typing <code class="docutils literal"><span class="pre">x.category()</span></code> returns the category to which <code class="docutils literal"><span class="pre">x</span></code>
belongs. If <code class="docutils literal"><span class="pre">C</span></code> is a category and <code class="docutils literal"><span class="pre">x</span></code> is any object, <code class="docutils literal"><span class="pre">C(x)</span></code> tries to
make an object in <code class="docutils literal"><span class="pre">C</span></code> from <code class="docutils literal"><span class="pre">x</span></code>. Checking if <code class="docutils literal"><span class="pre">x</span></code> belongs to <code class="docutils literal"><span class="pre">C</span></code> is done
as usually by <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">C</span></code>.</p>
<p>See <a class="reference internal" href="#sage.categories.category.Category" title="sage.categories.category.Category"><code class="xref py py-class docutils literal"><span class="pre">Category</span></code></a> and <a class="reference internal" href="primer.html#module-sage.categories.primer" title="sage.categories.primer"><code class="xref py py-mod docutils literal"><span class="pre">sage.categories.primer</span></code></a> for more details.</p>
<p>EXAMPLES:</p>
<p>We create a couple of categories:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span>
<span class="go">Category of sets</span>
<span class="gp">sage: </span><span class="n">GSets</span><span class="p">(</span><span class="n">AbelianGroup</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">]))</span>
<span class="go">Category of G-sets for Multiplicative Abelian group isomorphic to C2 x C4 x C9</span>
<span class="gp">sage: </span><span class="n">Semigroups</span><span class="p">()</span>
<span class="go">Category of semigroups</span>
<span class="gp">sage: </span><span class="n">VectorSpaces</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">11</span><span class="p">))</span>
<span class="go">Category of vector spaces over Finite Field of size 11</span>
<span class="gp">sage: </span><span class="n">Ideals</span><span class="p">(</span><span class="n">IntegerRing</span><span class="p">())</span>
<span class="go">Category of ring ideals in Integer Ring</span>
</pre></div>
</div>
<p>Let&#8217;s request the category of some objects:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">VectorSpace</span><span class="p">(</span><span class="n">RationalField</span><span class="p">(),</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of finite dimensional vector spaces with basis over (quotient fields and metric spaces)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">SymmetricGroup</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Join of Category of finite enumerated permutation groups and Category of finite weyl groups</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">PerfectMatchings</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of finite enumerated sets</span>
</pre></div>
</div>
<p>Let&#8217;s check some memberships:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">V</span> <span class="ow">in</span> <span class="n">VectorSpaces</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">V</span> <span class="ow">in</span> <span class="n">VectorSpaces</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">11</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="ow">in</span> <span class="n">Monoids</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="ow">in</span> <span class="n">Rings</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>For parametrized categories one can use the following shorthand:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">V</span> <span class="ow">in</span> <span class="n">VectorSpaces</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="ow">in</span> <span class="n">VectorSpaces</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A parent <code class="docutils literal"><span class="pre">P</span></code> is in a category <code class="docutils literal"><span class="pre">C</span></code> if <code class="docutils literal"><span class="pre">P.category()</span></code> is a subcategory of
<code class="docutils literal"><span class="pre">C</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Any object of a category should be an instance of
<a class="reference external" href="../../../structure/sage/structure/category_object.html#sage.structure.category_object.CategoryObject" title="(in Sage Reference Manual: Parents and Elements v8.0)"><code class="xref py py-class docutils literal"><span class="pre">CategoryObject</span></code></a>.</p>
<p>For backward compatibility this is not yet enforced:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
<span class="go">....:   def category(self):</span>
<span class="go">....:       return Fields()</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">()</span> <span class="ow">in</span> <span class="n">Rings</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>By default, the category of an element <span class="math">\(x\)</span> of a parent <span class="math">\(P\)</span> is the category
of all objects of <span class="math">\(P\)</span> (this is dubious an may be deprecated):</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">VectorSpace</span><span class="p">(</span><span class="n">RationalField</span><span class="p">(),</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of elements of Vector space of dimension 3 over Rational Field</span>
</pre></div>
</div>
</div>
<dl class="class">
<dt id="sage.categories.category.Category">
<em class="property">class </em><code class="descclassname">sage.categories.category.</code><code class="descname">Category</code><span class="sig-paren">(</span><em>s=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Sage Reference Manual: Parents and Elements v8.0)"><code class="xref py py-class docutils literal"><span class="pre">sage.structure.unique_representation.UniqueRepresentation</span></code></a>, <a class="reference external" href="../../../structure/sage/structure/sage_object.html#sage.structure.sage_object.SageObject" title="(in Sage Reference Manual: Parents and Elements v8.0)"><code class="xref py py-class docutils literal"><span class="pre">sage.structure.sage_object.SageObject</span></code></a></p>
<p>The base class for modeling mathematical categories, like for example:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">Groups()</span></code>: the category of groups</li>
<li><code class="docutils literal"><span class="pre">EuclideanDomains()</span></code>: the category of euclidean rings</li>
<li><code class="docutils literal"><span class="pre">VectorSpaces(QQ)</span></code>: the category of vector spaces over the field of
rationals</li>
</ul>
<p>See <a class="reference internal" href="primer.html#module-sage.categories.primer" title="sage.categories.primer"><code class="xref py py-mod docutils literal"><span class="pre">sage.categories.primer</span></code></a> for an introduction to
categories in Sage, their relevance, purpose, and usage. The
documentation below will focus on their implementation.</p>
<p>Technically, a category is an instance of the class
<a class="reference internal" href="#sage.categories.category.Category" title="sage.categories.category.Category"><code class="xref py py-class docutils literal"><span class="pre">Category</span></code></a> or some of its subclasses. Some categories, like
<a class="reference internal" href="vector_spaces.html#sage.categories.vector_spaces.VectorSpaces" title="sage.categories.vector_spaces.VectorSpaces"><code class="xref py py-class docutils literal"><span class="pre">VectorSpaces</span></code></a>, are parametrized: <code class="docutils literal"><span class="pre">VectorSpaces(QQ)</span></code> is one of
many instances of the class <a class="reference internal" href="vector_spaces.html#sage.categories.vector_spaces.VectorSpaces" title="sage.categories.vector_spaces.VectorSpaces"><code class="xref py py-class docutils literal"><span class="pre">VectorSpaces</span></code></a>. On the other
hand, <code class="docutils literal"><span class="pre">EuclideanDomains()</span></code> is the single instance of the class
<a class="reference internal" href="euclidean_domains.html#sage.categories.euclidean_domains.EuclideanDomains" title="sage.categories.euclidean_domains.EuclideanDomains"><code class="xref py py-class docutils literal"><span class="pre">EuclideanDomains</span></code></a>.</p>
<p>Recall that an algebraic structure (say, the ring <span class="math">\(\QQ[x]\)</span>) is
modelled in Sage by an object which is called a parent. This
object belongs to certain categories (here <code class="docutils literal"><span class="pre">EuclideanDomains()</span></code> and
<code class="docutils literal"><span class="pre">Algebras()</span></code>). The elements of the ring are themselves objects.</p>
<p>The class of a category (say <a class="reference internal" href="euclidean_domains.html#sage.categories.euclidean_domains.EuclideanDomains" title="sage.categories.euclidean_domains.EuclideanDomains"><code class="xref py py-class docutils literal"><span class="pre">EuclideanDomains</span></code></a>) can define simultaneously:</p>
<ul class="simple">
<li>Operations on the category itself (what is its super categories?
its category of morphisms? its dual category?).</li>
<li>Generic operations on parents in this category, like the ring <span class="math">\(\QQ[x]\)</span>.</li>
<li>Generic operations on elements of such parents (e. g., the
Euclidean algorithm for computing gcds).</li>
<li>Generic operations on morphisms of this category.</li>
</ul>
<p>This is achieved as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.all</span> <span class="kn">import</span> <span class="n">Category</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">EuclideanDomains</span><span class="p">(</span><span class="n">Category</span><span class="p">):</span>
<span class="go">....:     # operations on the category itself</span>
<span class="go">....:     def super_categories(self):</span>
<span class="go">....:         [Rings()]</span>
<span class="go">....:</span>
<span class="go">....:     def dummy(self): # TODO: find some good examples</span>
<span class="go">....:          pass</span>
<span class="go">....:</span>
<span class="go">....:     class ParentMethods: # holds the generic operations on parents</span>
<span class="go">....:          # TODO: find a good example of an operation</span>
<span class="go">....:          pass</span>
<span class="go">....:</span>
<span class="go">....:     class ElementMethods:# holds the generic operations on elements</span>
<span class="go">....:          def gcd(x,y):</span>
<span class="go">....:              # Euclid algorithms</span>
<span class="go">....:              pass</span>
<span class="go">....:</span>
<span class="go">....:     class MorphismMethods: # holds the generic operations on morphisms</span>
<span class="go">....:          # TODO: find a good example of an operation</span>
<span class="go">....:          pass</span>
<span class="go">....:</span>
</pre></div>
</div>
<p>Note that the nested class <code class="docutils literal"><span class="pre">ParentMethods</span></code> is merely a container
of operations, and does not inherit from anything. Instead, the
hierarchy relation is defined once at the level of the categories,
and the actual hierarchy of classes is built in parallel from all
the <code class="docutils literal"><span class="pre">ParentMethods</span></code> nested classes, and stored in the attributes
<code class="docutils literal"><span class="pre">parent_class</span></code>. Then, a parent in a category <code class="docutils literal"><span class="pre">C</span></code> receives the
appropriate operations from all the super categories by usual
class inheritance from <code class="docutils literal"><span class="pre">C.parent_class</span></code>.</p>
<p>Similarly, two other hierarchies of classes, for elements and
morphisms respectively, are built from all the <code class="docutils literal"><span class="pre">ElementMethods</span></code>
and <code class="docutils literal"><span class="pre">MorphismMethods</span></code> nested classes.</p>
<p>EXAMPLES:</p>
<p>We define a hierarchy of four categories <code class="docutils literal"><span class="pre">As()</span></code>, <code class="docutils literal"><span class="pre">Bs()</span></code>,
<code class="docutils literal"><span class="pre">Cs()</span></code>, <code class="docutils literal"><span class="pre">Ds()</span></code> with a diamond inheritance. Think for example:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">As()</span></code>: the category of sets</li>
<li><code class="docutils literal"><span class="pre">Bs()</span></code>: the category of additive groups</li>
<li><code class="docutils literal"><span class="pre">Cs()</span></code>: the category of multiplicative monoids</li>
<li><code class="docutils literal"><span class="pre">Ds()</span></code>: the category of rings</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.all</span> <span class="kn">import</span> <span class="n">Category</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.misc.lazy_attribute</span> <span class="kn">import</span> <span class="n">lazy_attribute</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">As</span> <span class="p">(</span><span class="n">Category</span><span class="p">):</span>
<span class="go">....:     def super_categories(self):</span>
<span class="go">....:         return []</span>
<span class="go">....:</span>
<span class="go">....:     class ParentMethods:</span>
<span class="go">....:         def fA(self):</span>
<span class="go">....:             return &quot;A&quot;</span>
<span class="go">....:         f = fA</span>

<span class="gp">sage: </span><span class="k">class</span> <span class="nc">Bs</span> <span class="p">(</span><span class="n">Category</span><span class="p">):</span>
<span class="go">....:     def super_categories(self):</span>
<span class="go">....:         return [As()]</span>
<span class="go">....:</span>
<span class="go">....:     class ParentMethods:</span>
<span class="go">....:         def fB(self):</span>
<span class="go">....:             return &quot;B&quot;</span>

<span class="gp">sage: </span><span class="k">class</span> <span class="nc">Cs</span> <span class="p">(</span><span class="n">Category</span><span class="p">):</span>
<span class="go">....:     def super_categories(self):</span>
<span class="go">....:         return [As()]</span>
<span class="go">....:</span>
<span class="go">....:     class ParentMethods:</span>
<span class="go">....:         def fC(self):</span>
<span class="go">....:             return &quot;C&quot;</span>
<span class="go">....:         f = fC</span>

<span class="gp">sage: </span><span class="k">class</span> <span class="nc">Ds</span> <span class="p">(</span><span class="n">Category</span><span class="p">):</span>
<span class="go">....:     def super_categories(self):</span>
<span class="go">....:         return [Bs(),Cs()]</span>
<span class="go">....:</span>
<span class="go">....:     class ParentMethods:</span>
<span class="go">....:         def fD(self):</span>
<span class="go">....:             return &quot;D&quot;</span>
</pre></div>
</div>
<p>Categories should always have unique representation; by trac ticket
<a class="reference external" href="https://trac.sagemath.org/12215">trac ticket #12215</a>, this means that it will be kept in cache, but only
if there is still some strong reference to it.</p>
<p>We check this before proceeding:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">gc</span>
<span class="gp">sage: </span><span class="n">idAs</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">As</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">_</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">n</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">As</span><span class="p">())</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">As</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">id</span><span class="p">(</span><span class="n">As</span><span class="p">())</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">As</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">As</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span> <span class="o">==</span> <span class="n">As</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We construct a parent in the category <code class="docutils literal"><span class="pre">Ds()</span></code> (that, is an instance
of <code class="docutils literal"><span class="pre">Ds().parent_class</span></code>), and check that it has access to all the
methods provided by all the categories, with the appropriate
inheritance order:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Ds</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span> <span class="n">D</span><span class="o">.</span><span class="n">fA</span><span class="p">(),</span> <span class="n">D</span><span class="o">.</span><span class="n">fB</span><span class="p">(),</span> <span class="n">D</span><span class="o">.</span><span class="n">fC</span><span class="p">(),</span> <span class="n">D</span><span class="o">.</span><span class="n">fD</span><span class="p">()</span> <span class="p">]</span>
<span class="go">[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
<span class="go">&#39;C&#39;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Cs</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span> <span class="n">C</span><span class="o">.</span><span class="n">fA</span><span class="p">(),</span> <span class="n">C</span><span class="o">.</span><span class="n">fC</span><span class="p">()</span> <span class="p">]</span>
<span class="go">[&#39;A&#39;, &#39;C&#39;]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
<span class="go">&#39;C&#39;</span>
</pre></div>
</div>
<p>Here is the parallel hierarchy of classes which has been built
automatically, together with the method resolution order (<code class="docutils literal"><span class="pre">.mro()</span></code>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">As</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span>
<span class="go">&lt;class &#39;__main__.As.parent_class&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">As</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span><span class="o">.</span><span class="vm">__bases__</span>
<span class="go">(&lt;... &#39;object&#39;&gt;,)</span>
<span class="gp">sage: </span><span class="n">As</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span><span class="o">.</span><span class="n">mro</span><span class="p">()</span>
<span class="go">[&lt;class &#39;__main__.As.parent_class&#39;&gt;, &lt;... &#39;object&#39;&gt;]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Bs</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span>
<span class="go">&lt;class &#39;__main__.Bs.parent_class&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">Bs</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span><span class="o">.</span><span class="vm">__bases__</span>
<span class="go">(&lt;class &#39;__main__.As.parent_class&#39;&gt;,)</span>
<span class="gp">sage: </span><span class="n">Bs</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span><span class="o">.</span><span class="n">mro</span><span class="p">()</span>
<span class="go">[&lt;class &#39;__main__.Bs.parent_class&#39;&gt;, &lt;class &#39;__main__.As.parent_class&#39;&gt;, &lt;... &#39;object&#39;&gt;]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Cs</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span>
<span class="go">&lt;class &#39;__main__.Cs.parent_class&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">Cs</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span><span class="o">.</span><span class="vm">__bases__</span>
<span class="go">(&lt;class &#39;__main__.As.parent_class&#39;&gt;,)</span>
<span class="gp">sage: </span><span class="n">Cs</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span><span class="o">.</span><span class="vm">__mro__</span>
<span class="go">(&lt;class &#39;__main__.Cs.parent_class&#39;&gt;, &lt;class &#39;__main__.As.parent_class&#39;&gt;, &lt;... &#39;object&#39;&gt;)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Ds</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span>
<span class="go">&lt;class &#39;__main__.Ds.parent_class&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">Ds</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span><span class="o">.</span><span class="vm">__bases__</span>
<span class="go">(&lt;class &#39;__main__.Cs.parent_class&#39;&gt;, &lt;class &#39;__main__.Bs.parent_class&#39;&gt;)</span>
<span class="gp">sage: </span><span class="n">Ds</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span><span class="o">.</span><span class="n">mro</span><span class="p">()</span>
<span class="go">[&lt;class &#39;__main__.Ds.parent_class&#39;&gt;, &lt;class &#39;__main__.Cs.parent_class&#39;&gt;, &lt;class &#39;__main__.Bs.parent_class&#39;&gt;, &lt;class &#39;__main__.As.parent_class&#39;&gt;, &lt;... &#39;object&#39;&gt;]</span>
</pre></div>
</div>
<p>Note that that two categories in the same class need not have the
same <code class="docutils literal"><span class="pre">super_categories</span></code>. For example, <code class="docutils literal"><span class="pre">Algebras(QQ)</span></code> has
<code class="docutils literal"><span class="pre">VectorSpaces(QQ)</span></code> as super category, whereas <code class="docutils literal"><span class="pre">Algebras(ZZ)</span></code>
only has <code class="docutils literal"><span class="pre">Modules(ZZ)</span></code> as super category. In particular, the
constructed parent class and element class will differ (inheriting,
or not, methods specific for vector spaces):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">parent_class</span> <span class="ow">is</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">parent_class</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="nb">issubclass</span><span class="p">(</span><span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">parent_class</span><span class="p">,</span> <span class="n">VectorSpaces</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">parent_class</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>On the other hand, identical hierarchies of classes are,
preferably, built only once (e.g. for categories over a base ring):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Algebras</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">parent_class</span> <span class="ow">is</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span><span class="o">.</span><span class="n">parent_class</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FractionField</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Coalgebras</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">parent_class</span> <span class="ow">is</span> <span class="n">Coalgebras</span><span class="p">(</span><span class="n">FractionField</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]))</span><span class="o">.</span><span class="n">parent_class</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We now construct a parent in the usual way:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">myparent</span><span class="p">(</span><span class="n">Parent</span><span class="p">):</span>
<span class="go">....:     def __init__(self):</span>
<span class="go">....:         Parent.__init__(self, category=Ds())</span>
<span class="go">....:     def g(self):</span>
<span class="go">....:         return &quot;myparent&quot;</span>
<span class="go">....:     class Element:</span>
<span class="go">....:         pass</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">myparent</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="vm">__class__</span>
<span class="go">&lt;class &#39;__main__.myparent_with_category&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__bases__</span>
<span class="go">(&lt;class &#39;__main__.myparent&#39;&gt;, &lt;class &#39;__main__.Ds.parent_class&#39;&gt;)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">mro</span><span class="p">()</span>
<span class="go">[&lt;class &#39;__main__.myparent_with_category&#39;&gt;,</span>
<span class="go">&lt;class &#39;__main__.myparent&#39;&gt;,</span>
<span class="go">&lt;type &#39;sage.structure.parent.Parent&#39;&gt;,</span>
<span class="go">&lt;type &#39;sage.structure.category_object.CategoryObject&#39;&gt;,</span>
<span class="go">&lt;type &#39;sage.structure.sage_object.SageObject&#39;&gt;,</span>
<span class="go">&lt;class &#39;__main__.Ds.parent_class&#39;&gt;,</span>
<span class="go">&lt;class &#39;__main__.Cs.parent_class&#39;&gt;,</span>
<span class="go">&lt;class &#39;__main__.Bs.parent_class&#39;&gt;,</span>
<span class="go">&lt;class &#39;__main__.As.parent_class&#39;&gt;,</span>
<span class="go">&lt;... &#39;object&#39;&gt;]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">fA</span><span class="p">()</span>
<span class="go">&#39;A&#39;</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">fB</span><span class="p">()</span>
<span class="go">&#39;B&#39;</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">fC</span><span class="p">()</span>
<span class="go">&#39;C&#39;</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">fD</span><span class="p">()</span>
<span class="go">&#39;D&#39;</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
<span class="go">&#39;C&#39;</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">g</span><span class="p">()</span>
<span class="go">&#39;myparent&#39;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">element_class</span>
<span class="go">&lt;class &#39;__main__.myparent_with_category.element_class&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">element_class</span><span class="o">.</span><span class="n">mro</span><span class="p">()</span>
<span class="go">[&lt;class &#39;__main__.myparent_with_category.element_class&#39;&gt;,</span>
<span class="go">&lt;class __main__.Element at ...&gt;,</span>
<span class="go">&lt;class &#39;__main__.Ds.element_class&#39;&gt;,</span>
<span class="go">&lt;class &#39;__main__.Cs.element_class&#39;&gt;,</span>
<span class="go">&lt;class &#39;__main__.Bs.element_class&#39;&gt;,</span>
<span class="go">&lt;class &#39;__main__.As.element_class&#39;&gt;,</span>
<span class="go">&lt;... &#39;object&#39;&gt;]</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.categories.category.Category._super_categories">
<code class="descname">_super_categories</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category._super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>The immediate super categories of this category.</p>
<p>This lazy attribute caches the result of the mandatory method
<a class="reference internal" href="#sage.categories.category.Category.super_categories" title="sage.categories.category.Category.super_categories"><code class="xref py py-meth docutils literal"><span class="pre">super_categories()</span></code></a> for speed. It also does some mangling
(flattening join categories, sorting, ...).</p>
<p>Whenever speed matters, developers are advised to use this
lazy attribute rather than calling <a class="reference internal" href="#sage.categories.category.Category.super_categories" title="sage.categories.category.Category.super_categories"><code class="xref py py-meth docutils literal"><span class="pre">super_categories()</span></code></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This attribute is likely to eventually become a tuple.
When this happens, we might as well use <a class="reference internal" href="#sage.categories.category.Category._sort" title="sage.categories.category.Category._sort"><code class="xref py py-meth docutils literal"><span class="pre">Category._sort()</span></code></a>,
if not <a class="reference internal" href="#sage.categories.category.Category._sort_uniq" title="sage.categories.category.Category._sort_uniq"><code class="xref py py-meth docutils literal"><span class="pre">Category._sort_uniq()</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Rings</span><span class="p">()</span><span class="o">.</span><span class="n">_super_categories</span>
<span class="go">[Category of rngs, Category of semirings]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category._super_categories_for_classes">
<code class="descname">_super_categories_for_classes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category._super_categories_for_classes" title="Permalink to this definition">¶</a></dt>
<dd><p>The super categories of this category used for building classes.</p>
<p>This is a close variant of <a class="reference internal" href="#sage.categories.category.Category._super_categories" title="sage.categories.category.Category._super_categories"><code class="xref py py-meth docutils literal"><span class="pre">_super_categories()</span></code></a> used for
constructing the list of the bases for <a class="reference internal" href="#sage.categories.category.Category.parent_class" title="sage.categories.category.Category.parent_class"><code class="xref py py-meth docutils literal"><span class="pre">parent_class()</span></code></a>,
<a class="reference internal" href="#sage.categories.category.Category.element_class" title="sage.categories.category.Category.element_class"><code class="xref py py-meth docutils literal"><span class="pre">element_class()</span></code></a>, and friends. The purpose is ensure that
Python will find a proper Method Resolution Order for those
classes. For background, see <a class="reference external" href="../../../misc/sage/misc/c3_controlled.html#module-sage.misc.c3_controlled" title="(in Sage Reference Manual: Utilities v8.0)"><code class="xref py py-mod docutils literal"><span class="pre">sage.misc.c3_controlled</span></code></a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">_cmp_key()</span></code>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This attribute is calculated as a by-product of computing
<a class="reference internal" href="#sage.categories.category.Category._all_super_categories" title="sage.categories.category.Category._all_super_categories"><code class="xref py py-meth docutils literal"><span class="pre">_all_super_categories()</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Rings</span><span class="p">()</span><span class="o">.</span><span class="n">_super_categories_for_classes</span>
<span class="go">[Category of rngs, Category of semirings]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category._all_super_categories">
<code class="descname">_all_super_categories</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category._all_super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>All the super categories of this category, including this category.</p>
<p>Since <a class="reference external" href="https://trac.sagemath.org/11943">trac ticket #11943</a>, the order of super categories is
determined by Python&#8217;s method resolution order C3 algorithm.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.categories.category.Category.all_super_categories" title="sage.categories.category.Category.all_super_categories"><code class="xref py py-meth docutils literal"><span class="pre">all_super_categories()</span></code></a></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this attribute is likely to eventually become a tuple.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this sets <a class="reference internal" href="#sage.categories.category.Category._super_categories_for_classes" title="sage.categories.category.Category._super_categories_for_classes"><code class="xref py py-meth docutils literal"><span class="pre">_super_categories_for_classes()</span></code></a> as a side effect</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Rings</span><span class="p">();</span> <span class="n">C</span>
<span class="go">Category of rings</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">_all_super_categories</span>
<span class="go">[Category of rings, Category of rngs, Category of semirings, ...</span>
<span class="go"> Category of monoids, ...</span>
<span class="go"> Category of commutative additive groups, ...</span>
<span class="go"> Category of sets, Category of sets with partial maps,</span>
<span class="go"> Category of objects]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category._all_super_categories_proper">
<code class="descname">_all_super_categories_proper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category._all_super_categories_proper" title="Permalink to this definition">¶</a></dt>
<dd><p>All the proper super categories of this category.</p>
<p>Since <a class="reference external" href="https://trac.sagemath.org/11943">trac ticket #11943</a>, the order of super categories is
determined by Python&#8217;s method resolution order C3 algorithm.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.categories.category.Category.all_super_categories" title="sage.categories.category.Category.all_super_categories"><code class="xref py py-meth docutils literal"><span class="pre">all_super_categories()</span></code></a></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this attribute is likely to eventually become a tuple.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Rings</span><span class="p">();</span> <span class="n">C</span>
<span class="go">Category of rings</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">_all_super_categories_proper</span>
<span class="go">[Category of rngs, Category of semirings, ...</span>
<span class="go"> Category of monoids, ...</span>
<span class="go"> Category of commutative additive groups, ...</span>
<span class="go"> Category of sets, Category of sets with partial maps,</span>
<span class="go"> Category of objects]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category._set_of_super_categories">
<code class="descname">_set_of_super_categories</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category._set_of_super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>The frozen set of all proper super categories of this category.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this is used for speeding up category containment tests.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.categories.category.Category.all_super_categories" title="sage.categories.category.Category.all_super_categories"><code class="xref py py-meth docutils literal"><span class="pre">all_super_categories()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Groups</span><span class="p">()</span><span class="o">.</span><span class="n">_set_of_super_categories</span>
<span class="go">frozenset({Category of inverse unital magmas,</span>
<span class="go">           Category of unital magmas,</span>
<span class="go">           Category of magmas,</span>
<span class="go">           Category of monoids,</span>
<span class="go">           Category of objects,</span>
<span class="go">           Category of semigroups,</span>
<span class="go">           Category of sets with partial maps,</span>
<span class="go">           Category of sets})</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">Groups</span><span class="p">()</span><span class="o">.</span><span class="n">_set_of_super_categories</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="go">[Category of inverse unital magmas, Category of magmas, Category of monoids,</span>
<span class="go"> Category of objects, Category of semigroups, Category of sets,</span>
<span class="go"> Category of sets with partial maps, Category of unital magmas]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category._make_named_class">
<code class="descname">_make_named_class</code><span class="sig-paren">(</span><em>name</em>, <em>method_provider</em>, <em>cache=False</em>, <em>picklable=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category._make_named_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Construction of the parent/element/... class of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">name</span></code> &#8211; a string; the name of the class as an attribute of
<code class="docutils literal"><span class="pre">self</span></code>. E.g. &#8220;parent_class&#8221;</li>
<li><code class="docutils literal"><span class="pre">method_provider</span></code> &#8211; a string; the name of an attribute of
<code class="docutils literal"><span class="pre">self</span></code> that provides methods for the new class (in
addition to those coming from the super categories).
E.g. &#8220;ParentMethods&#8221;</li>
<li><code class="docutils literal"><span class="pre">cache</span></code> &#8211; a boolean or <code class="docutils literal"><span class="pre">ignore_reduction</span></code> (default: <code class="docutils literal"><span class="pre">False</span></code>)
(passed down to dynamic_class; for internal use only)</li>
<li><code class="docutils literal"><span class="pre">picklable</span></code> &#8211; a boolean (default: <code class="docutils literal"><span class="pre">True</span></code>)</li>
</ul>
<p>ASSUMPTION:</p>
<p>It is assumed that this method is only called from a lazy
attribute whose name coincides with the given <code class="docutils literal"><span class="pre">name</span></code>.</p>
<p>OUTPUT:</p>
<p>A dynamic class with bases given by the corresponding named
classes of <code class="docutils literal"><span class="pre">self</span></code>&#8216;s super_categories, and methods taken from
the class <code class="docutils literal"><span class="pre">getattr(self,method_provider)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>In this default implementation, the reduction data of
the named class makes it depend on <code class="docutils literal"><span class="pre">self</span></code>. Since the
result is going to be stored in a lazy attribute of
<code class="docutils literal"><span class="pre">self</span></code> anyway, we may as well disable the caching in
<code class="docutils literal"><span class="pre">dynamic_class</span></code> (hence the default value
<code class="docutils literal"><span class="pre">cache=False</span></code>).</li>
<li><a class="reference internal" href="#sage.categories.category.CategoryWithParameters" title="sage.categories.category.CategoryWithParameters"><code class="xref py py-class docutils literal"><span class="pre">CategoryWithParameters</span></code></a> overrides this method so
that the same parent/element/... classes can be shared
between closely related categories.</li>
<li>The bases of the named class may also contain the named
classes of some indirect super categories, according to
<a class="reference internal" href="#sage.categories.category.Category._super_categories_for_classes" title="sage.categories.category.Category._super_categories_for_classes"><code class="xref py py-meth docutils literal"><span class="pre">_super_categories_for_classes()</span></code></a>. This is to
guarantee that Python will build consistent method
resolution orders. For background, see
<a class="reference external" href="../../../misc/sage/misc/c3_controlled.html#module-sage.misc.c3_controlled" title="(in Sage Reference Manual: Utilities v8.0)"><code class="xref py py-mod docutils literal"><span class="pre">sage.misc.c3_controlled</span></code></a>.</li>
</ul>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.categories.category.CategoryWithParameters._make_named_class" title="sage.categories.category.CategoryWithParameters._make_named_class"><code class="xref py py-meth docutils literal"><span class="pre">CategoryWithParameters._make_named_class()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">PC</span> <span class="o">=</span> <span class="n">Rings</span><span class="p">()</span><span class="o">.</span><span class="n">_make_named_class</span><span class="p">(</span><span class="s2">&quot;parent_class&quot;</span><span class="p">,</span> <span class="s2">&quot;ParentMethods&quot;</span><span class="p">);</span> <span class="n">PC</span>
<span class="go">&lt;class &#39;sage.categories.rings.Rings.parent_class&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">PC</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.structure.dynamic_class.DynamicMetaclass&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">PC</span><span class="o">.</span><span class="vm">__bases__</span>
<span class="go">(&lt;class &#39;sage.categories.rngs.Rngs.parent_class&#39;&gt;,</span>
<span class="go"> &lt;class &#39;sage.categories.semirings.Semirings.parent_class&#39;&gt;)</span>
</pre></div>
</div>
<p>Note that, by default, the result is not cached:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">PC</span> <span class="ow">is</span> <span class="n">Rings</span><span class="p">()</span><span class="o">.</span><span class="n">_make_named_class</span><span class="p">(</span><span class="s2">&quot;parent_class&quot;</span><span class="p">,</span> <span class="s2">&quot;ParentMethods&quot;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Indeed this method is only meant to construct lazy attributes
like <code class="docutils literal"><span class="pre">parent_class</span></code> which already handle this caching:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Rings</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span>
<span class="go">&lt;class &#39;sage.categories.rings.Rings.parent_class&#39;&gt;</span>
</pre></div>
</div>
<p>Reduction for pickling also assumes the existence of this lazy
attribute:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">PC</span><span class="o">.</span><span class="n">_reduction</span>
<span class="go">(&lt;built-in function getattr&gt;, (Category of rings, &#39;parent_class&#39;))</span>
<span class="gp">sage: </span><span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">PC</span><span class="p">))</span> <span class="ow">is</span> <span class="n">Rings</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category._repr_">
<code class="descname">_repr_</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category._repr_" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the print representation of this category.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span> <span class="c1"># indirect doctest</span>
<span class="go">Category of sets</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category._repr_object_names">
<code class="descname">_repr_object_names</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category._repr_object_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the objects of this category.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FiniteGroups</span><span class="p">()</span><span class="o">.</span><span class="n">_repr_object_names</span><span class="p">()</span>
<span class="go">&#39;finite groups&#39;</span>
<span class="gp">sage: </span><span class="n">AlgebrasWithBasis</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">_repr_object_names</span><span class="p">()</span>
<span class="go">&#39;algebras with basis over Rational Field&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category._test_category">
<code class="descname">_test_category</code><span class="sig-paren">(</span><em>**options</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category._test_category" title="Permalink to this definition">¶</a></dt>
<dd><p>Run generic tests on this category</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference external" href="../../../misc/sage/misc/sage_unittest.html#sage.misc.sage_unittest.TestSuite" title="(in Sage Reference Manual: Utilities v8.0)"><code class="xref py py-class docutils literal"><span class="pre">TestSuite</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">_test_category</span><span class="p">()</span>
</pre></div>
</div>
<p>Let us now write a couple broken categories:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyObjects</span><span class="p">(</span><span class="n">Category</span><span class="p">):</span>
<span class="go">....:      pass</span>
<span class="gp">sage: </span><span class="n">MyObjects</span><span class="p">()</span><span class="o">.</span><span class="n">_test_category</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">&lt;abstract method super_categories at ...&gt;</span>

<span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyObjects</span><span class="p">(</span><span class="n">Category</span><span class="p">):</span>
<span class="go">....:      def super_categories(self):</span>
<span class="go">....:          return tuple()</span>
<span class="gp">sage: </span><span class="n">MyObjects</span><span class="p">()</span><span class="o">.</span><span class="n">_test_category</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AssertionError</span>: <span class="n">Category of my objects.super_categories() should return a list</span>

<span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyObjects</span><span class="p">(</span><span class="n">Category</span><span class="p">):</span>
<span class="go">....:      def super_categories(self):</span>
<span class="go">....:          return []</span>
<span class="gp">sage: </span><span class="n">MyObjects</span><span class="p">()</span><span class="o">.</span><span class="n">_test_category</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AssertionError</span>: <span class="n">Category of my objects is not a subcategory of Objects()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category._with_axiom">
<code class="descname">_with_axiom</code><span class="sig-paren">(</span><em>axiom</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category._with_axiom" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the subcategory of the objects of <code class="docutils literal"><span class="pre">self</span></code> satisfying
the given <code class="docutils literal"><span class="pre">axiom</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">axiom</span></code> &#8211; a string, the name of an axiom</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">_with_axiom</span><span class="p">(</span><span class="s2">&quot;Finite&quot;</span><span class="p">)</span>
<span class="go">Category of finite sets</span>

<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span><span class="o">.</span><span class="n">Commutative</span><span class="p">())</span>
<span class="go">&lt;class &#39;sage.categories.category.JoinCategory_with_category&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span><span class="o">.</span><span class="n">Commutative</span><span class="p">()</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of commutative magmas, Category of finite sets]</span>
<span class="gp">sage: </span><span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">WithBasis</span><span class="p">()</span><span class="o">.</span><span class="n">Commutative</span><span class="p">()</span> <span class="ow">is</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Commutative</span><span class="p">()</span><span class="o">.</span><span class="n">WithBasis</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>When <code class="docutils literal"><span class="pre">axiom</span></code> is not defined for <code class="docutils literal"><span class="pre">self</span></code>, <code class="docutils literal"><span class="pre">self</span></code> is returned:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">_with_axiom</span><span class="p">(</span><span class="s2">&quot;Associative&quot;</span><span class="p">)</span>
<span class="go">Category of sets</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This may be changed in the future to raising an error.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category._with_axiom_as_tuple">
<code class="descname">_with_axiom_as_tuple</code><span class="sig-paren">(</span><em>axiom</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category._with_axiom_as_tuple" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tuple of categories whose join is <code class="docutils literal"><span class="pre">self._with_axiom()</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">axiom</span></code> &#8211; a string, the name of an axiom</li>
</ul>
<p>This is a lazy version of <a class="reference internal" href="#sage.categories.category.Category._with_axiom" title="sage.categories.category.Category._with_axiom"><code class="xref py py-meth docutils literal"><span class="pre">_with_axiom()</span></code></a> which is used to
avoid recursion loops during join calculations.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The order in the result is irrelevant.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">_with_axiom_as_tuple</span><span class="p">(</span><span class="s1">&#39;Finite&#39;</span><span class="p">)</span>
<span class="go">(Category of finite sets,)</span>
<span class="gp">sage: </span><span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">_with_axiom_as_tuple</span><span class="p">(</span><span class="s1">&#39;Finite&#39;</span><span class="p">)</span>
<span class="go">(Category of magmas, Category of finite sets)</span>
<span class="gp">sage: </span><span class="n">Rings</span><span class="p">()</span><span class="o">.</span><span class="n">Division</span><span class="p">()</span><span class="o">.</span><span class="n">_with_axiom_as_tuple</span><span class="p">(</span><span class="s1">&#39;Finite&#39;</span><span class="p">)</span>
<span class="go">(Category of division rings,</span>
<span class="go"> Category of finite monoids,</span>
<span class="go"> Category of commutative magmas,</span>
<span class="go"> Category of finite additive groups)</span>
<span class="gp">sage: </span><span class="n">HopfAlgebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">_with_axiom_as_tuple</span><span class="p">(</span><span class="s1">&#39;FiniteDimensional&#39;</span><span class="p">)</span>
<span class="go">(Category of hopf algebras over Rational Field,</span>
<span class="go"> Category of finite dimensional modules over Rational Field)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category._without_axioms">
<code class="descname">_without_axioms</code><span class="sig-paren">(</span><em>named=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category._without_axioms" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the category without the axioms that have been added
to create it.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">named</span></code> &#8211; a boolean (default: <code class="docutils literal"><span class="pre">False</span></code>)</li>
</ul>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">Improve this explanation.</p>
</div>
<p>If <code class="docutils literal"><span class="pre">named</span></code> is <code class="docutils literal"><span class="pre">True</span></code>, then this stops at the first
category that has an explicit name of its own. See
<a class="reference internal" href="category_with_axiom.html#sage.categories.category_with_axiom.CategoryWithAxiom._without_axioms" title="sage.categories.category_with_axiom.CategoryWithAxiom._without_axioms"><code class="xref py py-meth docutils literal"><span class="pre">category_with_axiom.CategoryWithAxiom._without_axioms()</span></code></a></p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">_without_axioms</span><span class="p">()</span>
<span class="go">Category of sets</span>
<span class="gp">sage: </span><span class="n">Semigroups</span><span class="p">()</span><span class="o">.</span><span class="n">_without_axioms</span><span class="p">()</span>
<span class="go">Category of magmas</span>
<span class="gp">sage: </span><span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Commutative</span><span class="p">()</span><span class="o">.</span><span class="n">WithBasis</span><span class="p">()</span><span class="o">.</span><span class="n">_without_axioms</span><span class="p">()</span>
<span class="go">Category of magmatic algebras over Rational Field</span>
<span class="gp">sage: </span><span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Commutative</span><span class="p">()</span><span class="o">.</span><span class="n">WithBasis</span><span class="p">()</span><span class="o">.</span><span class="n">_without_axioms</span><span class="p">(</span><span class="n">named</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Category of algebras over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="sage.categories.category.Category._sort">
<em class="property">static </em><code class="descname">_sort</code><span class="sig-paren">(</span><em>categories</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category._sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the categories after sorting them decreasingly according
to their comparison key.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">_cmp_key()</span></code></p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">categories</span></code> &#8211; a list (or iterable) of non-join categories</li>
</ul>
<p>OUTPUT:</p>
<p>A sorted tuple of categories, possibly with repeats.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The auxiliary function <span class="math">\(_flatten_categories\)</span> used in the test
below expects a second argument, which is a type such that
instances of that type will be replaced by its super
categories. Usually, this type is <a class="reference internal" href="#sage.categories.category.JoinCategory" title="sage.categories.category.JoinCategory"><code class="xref py py-class docutils literal"><span class="pre">JoinCategory</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Category</span><span class="o">.</span><span class="n">_sort</span><span class="p">([</span><span class="n">Sets</span><span class="p">(),</span> <span class="n">Objects</span><span class="p">(),</span> <span class="n">Coalgebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">),</span> <span class="n">Monoids</span><span class="p">(),</span> <span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()])</span>
<span class="go">(Category of monoids,</span>
<span class="go"> Category of coalgebras over Rational Field,</span>
<span class="go"> Category of finite sets,</span>
<span class="go"> Category of sets,</span>
<span class="go"> Category of objects)</span>
<span class="gp">sage: </span><span class="n">Category</span><span class="o">.</span><span class="n">_sort</span><span class="p">([</span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">(),</span> <span class="n">Semigroups</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">(),</span> <span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">Facade</span><span class="p">(),</span><span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Commutative</span><span class="p">()])</span>
<span class="go">(Category of finite semigroups,</span>
<span class="go"> Category of commutative magmas,</span>
<span class="go"> Category of finite sets,</span>
<span class="go"> Category of facade sets)</span>
<span class="gp">sage: </span><span class="n">Category</span><span class="o">.</span><span class="n">_sort</span><span class="p">(</span><span class="n">Category</span><span class="o">.</span><span class="n">_flatten_categories</span><span class="p">([</span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">(),</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">WithBasis</span><span class="p">(),</span> <span class="n">Semigroups</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">(),</span> <span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">Facade</span><span class="p">(),</span><span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Commutative</span><span class="p">(),</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Graded</span><span class="p">()</span><span class="o">.</span><span class="n">WithBasis</span><span class="p">()],</span> <span class="n">sage</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">category</span><span class="o">.</span><span class="n">JoinCategory</span><span class="p">))</span>
<span class="go">(Category of algebras with basis over Rational Field,</span>
<span class="go"> Category of algebras with basis over Rational Field,</span>
<span class="go"> Category of graded algebras over Rational Field,</span>
<span class="go"> Category of commutative algebras over Rational Field,</span>
<span class="go"> Category of finite semigroups,</span>
<span class="go"> Category of finite sets,</span>
<span class="go"> Category of facade sets)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category._sort_uniq">
<code class="descname">_sort_uniq</code><span class="sig-paren">(</span><em>categories</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category._sort_uniq" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the categories after sorting them and removing redundant categories.</p>
<p>Redundant categories include duplicates and categories which
are super categories of other categories in the input.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">categories</span></code> &#8211; a list (or iterable) of categories</li>
</ul>
<p>OUTPUT: a sorted tuple of mutually incomparable categories</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Category</span><span class="o">.</span><span class="n">_sort_uniq</span><span class="p">([</span><span class="n">Rings</span><span class="p">(),</span> <span class="n">Monoids</span><span class="p">(),</span> <span class="n">Coalgebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)])</span>
<span class="go">(Category of rings, Category of coalgebras over Rational Field)</span>
</pre></div>
</div>
<p>Note that, in the above example, <code class="docutils literal"><span class="pre">Monoids()</span></code> does not appear
in the result because it is a super category of <code class="docutils literal"><span class="pre">Rings()</span></code>.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="sage.categories.category.Category.__classcall__">
<em class="property">static </em><code class="descname">__classcall__</code><span class="sig-paren">(</span><em>*args</em>, <em>**options</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category.__classcall__" title="Permalink to this definition">¶</a></dt>
<dd><p>Input mangling for unique representation.</p>
<p>Let <code class="docutils literal"><span class="pre">C</span> <span class="pre">=</span> <span class="pre">Cs(...)</span></code> be a category. Since <a class="reference external" href="https://trac.sagemath.org/12895">trac ticket #12895</a>, the
class of <code class="docutils literal"><span class="pre">C</span></code> is a dynamic subclass <code class="docutils literal"><span class="pre">Cs_with_category</span></code> of
<code class="docutils literal"><span class="pre">Cs</span></code> in order for <code class="docutils literal"><span class="pre">C</span></code> to inherit code from the
<code class="docutils literal"><span class="pre">SubcategoryMethods</span></code> nested classes of its super categories.</p>
<p>The purpose of this <code class="docutils literal"><span class="pre">__classcall__</span></code> method is to ensure that
reconstructing <code class="docutils literal"><span class="pre">C</span></code> from its class with
<code class="docutils literal"><span class="pre">Cs_with_category(...)</span></code> actually calls properly <code class="docutils literal"><span class="pre">Cs(...)</span></code>
and gives back <code class="docutils literal"><span class="pre">C</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.categories.category.Category.subcategory_class" title="sage.categories.category.Category.subcategory_class"><code class="xref py py-meth docutils literal"><span class="pre">subcategory_class()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="vm">__class__</span>
<span class="go">&lt;class &#39;sage.categories.algebras.Algebras_with_category&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="ow">is</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="ow">is</span> <span class="n">A</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>s=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes this category.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">SemiprimitiveRings</span><span class="p">(</span><span class="n">Category</span><span class="p">):</span>
<span class="go">....:     def super_categories(self):</span>
<span class="go">....:         return [Rings()]</span>
<span class="go">....:</span>
<span class="go">....:     class ParentMethods:</span>
<span class="go">....:         def jacobson_radical(self):</span>
<span class="go">....:             return self.ideal(0)</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">SemiprimitiveRings</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span>
<span class="go">Category of semiprimitive rings</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="vm">__class__</span>
<span class="go">&lt;class &#39;__main__.SemiprimitiveRings_with_category&#39;&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Specifying the name of this category by passing a string
is deprecated. If the default name (built from the name of
the class) is not adequate, please use
<a class="reference internal" href="#sage.categories.category.Category._repr_object_names" title="sage.categories.category.Category._repr_object_names"><code class="xref py py-meth docutils literal"><span class="pre">_repr_object_names()</span></code></a> to customize it.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category.Realizations">
<code class="descname">Realizations</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category.Realizations" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the category of realizations of the parent <code class="docutils literal"><span class="pre">self</span></code> or of objects
of the category <code class="docutils literal"><span class="pre">self</span></code></p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">self</span></code> &#8211; a parent or a concrete category</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this <em>function</em> is actually inserted as a <em>method</em> in the class
<a class="reference internal" href="#sage.categories.category.Category" title="sage.categories.category.Category"><code class="xref py py-class docutils literal"><span class="pre">Category</span></code></a> (see
<a class="reference internal" href="#sage.categories.category.Category.Realizations" title="sage.categories.category.Category.Realizations"><code class="xref py py-meth docutils literal"><span class="pre">Realizations()</span></code></a>). It is defined
here for code locality reasons.</p>
</div>
<p>EXAMPLES:</p>
<p>The category of realizations of some algebra:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Realizations</span><span class="p">()</span>
<span class="go">Join of Category of algebras over Rational Field and Category of realizations of unital magmas</span>
</pre></div>
</div>
<p>The category of realizations of a given algebra:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">WithRealizations</span><span class="p">()</span><span class="o">.</span><span class="n">example</span><span class="p">();</span> <span class="n">A</span>
<span class="go">The subset algebra of {1, 2, 3} over Rational Field</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">Realizations</span><span class="p">()</span>
<span class="go">Category of realizations of The subset algebra of {1, 2, 3} over Rational Field</span>

<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">GradedHopfAlgebrasWithBasis</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Realizations</span><span class="p">();</span> <span class="n">C</span>
<span class="go">Join of Category of graded hopf algebras with basis over Rational Field and Category of realizations of hopf algebras over Rational Field</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of graded hopf algebras with basis over Rational Field, Category of realizations of hopf algebras over Rational Field]</span>

<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">C</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="with_realizations.html#sage.categories.with_realizations.WithRealizations" title="sage.categories.with_realizations.WithRealizations"><code class="xref py py-func docutils literal"><span class="pre">Sets().WithRealizations</span></code></a></li>
<li><code class="xref py py-class docutils literal"><span class="pre">ClasscallMetaclass</span></code></li>
</ul>
</div>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p>Add an optional argument to allow for:</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Realizations</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">category</span> <span class="o">=</span> <span class="n">Blahs</span><span class="p">())</span> <span class="c1"># todo: not implemented</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category.WithRealizations">
<code class="descname">WithRealizations</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category.WithRealizations" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the category of parents in <code class="docutils literal"><span class="pre">self</span></code> endowed with multiple realizations.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">self</span></code> &#8211; a category</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li>The documentation and code
(<a class="reference internal" href="examples/with_realizations.html#module-sage.categories.examples.with_realizations" title="sage.categories.examples.with_realizations"><code class="xref py py-mod docutils literal"><span class="pre">sage.categories.examples.with_realizations</span></code></a>) of
<code class="docutils literal"><span class="pre">Sets().WithRealizations().example()</span></code> for more on how to use and
implement a parent with several realizations.</li>
<li>Various use cases:<ul>
<li><a class="reference external" href="../../../combinat/sage/combinat/sf/sf.html#sage.combinat.sf.sf.SymmetricFunctions" title="(in Sage Reference Manual: Combinatorics v8.0)"><code class="xref py py-class docutils literal"><span class="pre">SymmetricFunctions</span></code></a></li>
<li><a class="reference external" href="../../../combinat/sage/combinat/ncsf_qsym/qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions" title="(in Sage Reference Manual: Combinatorics v8.0)"><code class="xref py py-class docutils literal"><span class="pre">QuasiSymmetricFunctions</span></code></a></li>
<li><a class="reference external" href="../../../combinat/sage/combinat/ncsf_qsym/ncsf.html#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions" title="(in Sage Reference Manual: Combinatorics v8.0)"><code class="xref py py-class docutils literal"><span class="pre">NonCommutativeSymmetricFunctions</span></code></a></li>
<li><a class="reference external" href="../../../combinat/sage/combinat/ncsym/ncsym.html#sage.combinat.ncsym.ncsym.SymmetricFunctionsNonCommutingVariables" title="(in Sage Reference Manual: Combinatorics v8.0)"><code class="xref py py-class docutils literal"><span class="pre">SymmetricFunctionsNonCommutingVariables</span></code></a></li>
<li><a class="reference external" href="../../../combinat/sage/combinat/descent_algebra.html#sage.combinat.descent_algebra.DescentAlgebra" title="(in Sage Reference Manual: Combinatorics v8.0)"><code class="xref py py-class docutils literal"><span class="pre">DescentAlgebra</span></code></a></li>
<li><code class="xref py py-class docutils literal"><span class="pre">algebras.Moebius</span></code></li>
<li><a class="reference external" href="../../../algebras/sage/algebras/iwahori_hecke_algebra.html#sage.algebras.iwahori_hecke_algebra.IwahoriHeckeAlgebra" title="(in Sage Reference Manual: Algebras v8.0)"><code class="xref py py-class docutils literal"><span class="pre">IwahoriHeckeAlgebra</span></code></a></li>
<li><code class="xref py py-class docutils literal"><span class="pre">ExtendedAffineWeylGroup</span></code></li>
</ul>
</li>
<li>The <a class="reference external" href="../../../../../thematic_tutorials/tutorial-implementing-algebraic-structures">Implementing Algebraic Structures</a>
thematic tutorial.</li>
<li><a class="reference internal" href="realizations.html#module-sage.categories.realizations" title="sage.categories.realizations"><code class="xref py py-mod docutils literal"><span class="pre">sage.categories.realizations</span></code></a></li>
</ul>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this <em>function</em> is actually inserted as a <em>method</em> in the class
<a class="reference internal" href="#sage.categories.category.Category" title="sage.categories.category.Category"><code class="xref py py-class docutils literal"><span class="pre">Category</span></code></a> (see
<a class="reference internal" href="#sage.categories.category.Category.WithRealizations" title="sage.categories.category.Category.WithRealizations"><code class="xref py py-meth docutils literal"><span class="pre">WithRealizations()</span></code></a>). It is defined
here for code locality reasons.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">WithRealizations</span><span class="p">()</span>
<span class="go">Category of sets with realizations</span>
</pre></div>
</div>
<p class="rubric">Parent with realizations</p>
<p>Let us now explain the concept of realizations. A <em>parent with
realizations</em> is a facade parent (see <a class="reference internal" href="sets_cat.html#sage.categories.sets_cat.Sets.Facade" title="sage.categories.sets_cat.Sets.Facade"><code class="xref py py-class docutils literal"><span class="pre">Sets.Facade</span></code></a>)
admitting multiple concrete realizations where its elements are
represented. Consider for example an algebra <span class="math">\(A\)</span> which admits
several natural bases:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">WithRealizations</span><span class="p">()</span><span class="o">.</span><span class="n">example</span><span class="p">();</span> <span class="n">A</span>
<span class="go">The subset algebra of {1, 2, 3} over Rational Field</span>
</pre></div>
</div>
<p>For each such basis <span class="math">\(B\)</span> one implements a parent <span class="math">\(P_B\)</span> which
realizes <span class="math">\(A\)</span> with its elements represented by expanding them on
the basis <span class="math">\(B\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">F</span><span class="p">()</span>
<span class="go">The subset algebra of {1, 2, 3} over Rational Field in the Fundamental basis</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">Out</span><span class="p">()</span>
<span class="go">The subset algebra of {1, 2, 3} over Rational Field in the Out basis</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">In</span><span class="p">()</span>
<span class="go">The subset algebra of {1, 2, 3} over Rational Field in the In basis</span>

<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="go">F[{}] + 2*F[{1}] + 3*F[{2}] + F[{1, 2}]</span>
</pre></div>
</div>
<p>If <span class="math">\(B\)</span> and <span class="math">\(B'\)</span> are two bases, then the change of basis from <span class="math">\(B\)</span>
to <span class="math">\(B'\)</span> is implemented by a canonical coercion between <span class="math">\(P_B\)</span> and
<span class="math">\(P_{B'}\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">F</span><span class="p">();</span> <span class="n">In</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">In</span><span class="p">();</span> <span class="n">Out</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">Out</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">i</span> <span class="o">=</span> <span class="n">In</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">i</span>
<span class="go">In[{}] + 2*In[{1}] + 3*In[{2}] + In[{1, 2}]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">7*F[{}] + 3*F[{1}] + 4*F[{2}] + F[{1, 2}]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">coerce_map_from</span><span class="p">(</span><span class="n">Out</span><span class="p">)</span>
<span class="go">Generic morphism:</span>
<span class="go">  From: The subset algebra of {1, 2, 3} over Rational Field in the Out basis</span>
<span class="go">  To:   The subset algebra of {1, 2, 3} over Rational Field in the Fundamental basis</span>
</pre></div>
</div>
<p>allowing for mixed arithmetic:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">Out</span><span class="o">.</span><span class="n">from_set</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">In</span><span class="o">.</span><span class="n">from_set</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Out[{}] + 2*Out[{1}] + 2*Out[{2}] + 2*Out[{3}] + 2*Out[{1, 2}] + 2*Out[{1, 3}] + 4*Out[{2, 3}] + 4*Out[{1, 2, 3}]</span>
</pre></div>
</div>
<p>In our example, there are three realizations:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">realizations</span><span class="p">()</span>
<span class="go">[The subset algebra of {1, 2, 3} over Rational Field in the Fundamental basis,</span>
<span class="go"> The subset algebra of {1, 2, 3} over Rational Field in the In basis,</span>
<span class="go"> The subset algebra of {1, 2, 3} over Rational Field in the Out basis]</span>
</pre></div>
</div>
<p>Instead of manually defining the shorthands <code class="docutils literal"><span class="pre">F</span></code>, <code class="docutils literal"><span class="pre">In</span></code>, and
<code class="docutils literal"><span class="pre">Out</span></code>, as above one can just do:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">inject_shorthands</span><span class="p">()</span>
<span class="go">Defining F as shorthand for The subset algebra of {1, 2, 3} over Rational Field in the Fundamental basis</span>
<span class="go">Defining In as shorthand for The subset algebra of {1, 2, 3} over Rational Field in the In basis</span>
<span class="go">Defining Out as shorthand for The subset algebra of {1, 2, 3} over Rational Field in the Out basis</span>
</pre></div>
</div>
<p class="rubric">Rationale</p>
<p>Besides some goodies described below, the role of <span class="math">\(A\)</span> is threefold:</p>
<ul class="simple">
<li>To provide, as illustrated above, a single entry point for the
algebra as a whole: documentation, access to its properties and
different realizations, etc.</li>
<li>To provide a natural location for the initialization of the
bases and the coercions between, and other methods that are
common to all bases.</li>
<li>To let other objects refer to <span class="math">\(A\)</span> while allowing elements to be
represented in any of the realizations.</li>
</ul>
<p>We now illustrate this second point by defining the polynomial
ring with coefficients in <span class="math">\(A\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">];</span> <span class="n">P</span>
<span class="go">Univariate Polynomial Ring in x over The subset algebra of {1, 2, 3} over Rational Field</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">gen</span><span class="p">()</span>
</pre></div>
</div>
<p>In the following examples, the coefficients turn out to be all
represented in the <span class="math">\(F\)</span> basis:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
<span class="go">F[{}]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span>
<span class="go">F[{}]*x^2 + 2*F[{}]*x + F[{}]</span>
</pre></div>
</div>
<p>However we can create a polynomial with mixed coefficients, and
compute with it:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">P</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">In</span><span class="p">[{</span><span class="mi">1</span><span class="p">}],</span> <span class="n">Out</span><span class="p">[{</span><span class="mi">2</span><span class="p">}]</span> <span class="p">]);</span> <span class="n">p</span>
<span class="go">Out[{2}]*x^2 + In[{1}]*x + F[{}]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">^</span><span class="mi">2</span>
<span class="go">Out[{2}]*x^4</span>
<span class="go">+ (-8*In[{}] + 4*In[{1}] + 8*In[{2}] + 4*In[{3}] - 4*In[{1, 2}] - 2*In[{1, 3}] - 4*In[{2, 3}] + 2*In[{1, 2, 3}])*x^3</span>
<span class="go">+ (F[{}] + 3*F[{1}] + 2*F[{2}] - 2*F[{1, 2}] - 2*F[{2, 3}] + 2*F[{1, 2, 3}])*x^2</span>
<span class="go">+ (2*F[{}] + 2*F[{1}])*x</span>
<span class="go">+ F[{}]</span>
</pre></div>
</div>
<p>Note how each coefficient involves a single basis which need not
be that of the other coefficients. Which basis is used depends on
how coercion happened during mixed arithmetic and needs not be
deterministic.</p>
<p>One can easily coerce all coefficient to a given basis with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">map_coefficients</span><span class="p">(</span><span class="n">In</span><span class="p">)</span>
<span class="go">(-4*In[{}] + 2*In[{1}] + 4*In[{2}] + 2*In[{3}] - 2*In[{1, 2}] - In[{1, 3}] - 2*In[{2, 3}] + In[{1, 2, 3}])*x^2 + In[{1}]*x + In[{}]</span>
</pre></div>
</div>
<p>Alas, the natural notation for constructing such polynomials does
not yet work:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">In</span><span class="p">[{</span><span class="mi">1</span><span class="p">}]</span> <span class="o">*</span> <span class="n">x</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">unsupported operand parent(s) for *: &#39;The subset algebra of {1, 2, 3} over Rational Field in the In basis&#39; and &#39;Univariate Polynomial Ring in x over The subset algebra of {1, 2, 3} over Rational Field&#39;</span>
</pre></div>
</div>
<p class="rubric">The category of realizations of <span class="math">\(A\)</span></p>
<p>The set of all realizations of <span class="math">\(A\)</span>, together with the coercion morphisms
is a category (whose class inherits from
<a class="reference internal" href="realizations.html#sage.categories.realizations.Category_realization_of_parent" title="sage.categories.realizations.Category_realization_of_parent"><code class="xref py py-class docutils literal"><span class="pre">Category_realization_of_parent</span></code></a>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">Realizations</span><span class="p">()</span>
<span class="go">Category of realizations of The subset algebra of {1, 2, 3} over Rational Field</span>
</pre></div>
</div>
<p>The various parent realizing <span class="math">\(A\)</span> belong to this category:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">F</span><span class="p">()</span> <span class="ow">in</span> <span class="n">A</span><span class="o">.</span><span class="n">Realizations</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p><span class="math">\(A\)</span> itself is in the category of algebras with realizations:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="ow">in</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">WithRealizations</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The (mostly technical) <code class="docutils literal"><span class="pre">WithRealizations</span></code> categories are the
analogs of the <code class="docutils literal"><span class="pre">*WithSeveralBases</span></code> categories in
MuPAD-Combinat. They provide support tools for handling the
different realizations and the morphisms between them.</p>
<p>Typically, <code class="docutils literal"><span class="pre">VectorSpaces(QQ).FiniteDimensional().WithRealizations()</span></code>
will eventually be in charge, whenever a coercion <span class="math">\(\phi: A\mapsto B\)</span> is
registered, to register <span class="math">\(\phi^{-1}\)</span> as coercion <span class="math">\(B \mapsto A\)</span>
if there is none defined yet. To achieve this,
<code class="docutils literal"><span class="pre">FiniteDimensionalVectorSpaces</span></code> would provide a nested class
<code class="docutils literal"><span class="pre">WithRealizations</span></code> implementing the appropriate logic.</p>
<p><code class="docutils literal"><span class="pre">WithRealizations</span></code> is a <a class="reference internal" href="covariant_functorial_construction.html#module-sage.categories.covariant_functorial_construction" title="sage.categories.covariant_functorial_construction"><code class="xref py py-mod docutils literal"><span class="pre">regressive</span> <span class="pre">covariant</span> <span class="pre">functorial</span>
<span class="pre">construction</span></code></a>.
On our example, this simply means that <span class="math">\(A\)</span> is automatically in the
category of rings with realizations (covariance):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="ow">in</span> <span class="n">Rings</span><span class="p">()</span><span class="o">.</span><span class="n">WithRealizations</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>and in the category of algebras (regressiveness):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="ow">in</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For <code class="docutils literal"><span class="pre">C</span></code> a category, <code class="docutils literal"><span class="pre">C.WithRealizations()</span></code> in fact calls
<code class="docutils literal"><span class="pre">sage.categories.with_realizations.WithRealizations(C)</span></code>. The
later is responsible for building the hierarchy of the
categories with realizations in parallel to that of their base
categories, optimizing away those categories that do not
provide a <code class="docutils literal"><span class="pre">WithRealizations</span></code> nested class. See
<a class="reference internal" href="covariant_functorial_construction.html#module-sage.categories.covariant_functorial_construction" title="sage.categories.covariant_functorial_construction"><code class="xref py py-mod docutils literal"><span class="pre">sage.categories.covariant_functorial_construction</span></code></a> for
the technical details.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Design question: currently <code class="docutils literal"><span class="pre">WithRealizations</span></code> is a
regressive construction. That is <code class="docutils literal"><span class="pre">self.WithRealizations()</span></code>
is a subcategory of <code class="docutils literal"><span class="pre">self</span></code> by default:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">WithRealizations</span><span class="p">()</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of algebras over Rational Field,</span>
<span class="go"> Category of monoids with realizations,</span>
<span class="go"> Category of additive unital additive magmas with realizations]</span>
</pre></div>
</div>
<p class="last">Is this always desirable? For example,
<code class="docutils literal"><span class="pre">AlgebrasWithBasis(QQ).WithRealizations()</span></code> should certainly
be a subcategory of <code class="docutils literal"><span class="pre">Algebras(QQ)</span></code>, but not of
<code class="docutils literal"><span class="pre">AlgebrasWithBasis(QQ)</span></code>. This is because
<code class="docutils literal"><span class="pre">AlgebrasWithBasis(QQ)</span></code> is specifying something about the
concrete realization.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category.additional_structure">
<code class="descname">additional_structure</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category.additional_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether <code class="docutils literal"><span class="pre">self</span></code> defines additional structure.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">self</span></code> if <code class="docutils literal"><span class="pre">self</span></code> defines additional structure and
<code class="docutils literal"><span class="pre">None</span></code> otherwise. This default implementation returns
<code class="docutils literal"><span class="pre">self</span></code>.</li>
</ul>
<p>A category <span class="math">\(C\)</span> <em>defines additional structure</em> if <span class="math">\(C\)</span>-morphisms
shall preserve more structure (e.g. operations) than that
specified by the super categories of <span class="math">\(C\)</span>. For example, the
category of magmas defines additional structure, namely the
operation <span class="math">\(*\)</span> that shall be preserved by magma morphisms. On
the other hand the category of rings does not define additional
structure: a function between two rings that is both a unital
magma morphism and a unital additive magma morphism is
automatically a ring morphism.</p>
<p>Formally speaking <span class="math">\(C\)</span> <em>defines additional structure</em>, if <span class="math">\(C\)</span>
is <em>not</em> a full subcategory of the join of its super
categories: the morphisms need to preserve more structure, and
thus the homsets are smaller.</p>
<p>By default, a category is considered as defining additional
structure, unless it is a <a class="reference internal" href="primer.html#category-primer-axioms"><span class="std std-ref">category with axiom</span></a>.</p>
<p>EXAMPLES:</p>
<p>Here are some typical structure categories, with the
additional structure they define:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">additional_structure</span><span class="p">()</span>
<span class="go">Category of sets</span>
<span class="gp">sage: </span><span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">additional_structure</span><span class="p">()</span>         <span class="c1"># `*`</span>
<span class="go">Category of magmas</span>
<span class="gp">sage: </span><span class="n">AdditiveMagmas</span><span class="p">()</span><span class="o">.</span><span class="n">additional_structure</span><span class="p">()</span> <span class="c1"># `+`</span>
<span class="go">Category of additive magmas</span>
<span class="gp">sage: </span><span class="n">LeftModules</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">additional_structure</span><span class="p">()</span>  <span class="c1"># left multiplication by scalar</span>
<span class="go">Category of left modules over Integer Ring</span>
<span class="gp">sage: </span><span class="n">Coalgebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">additional_structure</span><span class="p">()</span>   <span class="c1"># coproduct</span>
<span class="go">Category of coalgebras over Rational Field</span>
<span class="gp">sage: </span><span class="n">Crystals</span><span class="p">()</span><span class="o">.</span><span class="n">additional_structure</span><span class="p">()</span>       <span class="c1"># crystal operators</span>
<span class="go">Category of crystals</span>
</pre></div>
</div>
<p>On the other hand, the category of semigroups is not a
structure category, since its operation <span class="math">\(+\)</span> is already defined
by the category of magmas:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Semigroups</span><span class="p">()</span><span class="o">.</span><span class="n">additional_structure</span><span class="p">()</span>
</pre></div>
</div>
<p>Most <a class="reference internal" href="primer.html#category-primer-axioms"><span class="std std-ref">categories with axiom</span></a>
don&#8217;t define additional structure:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span><span class="o">.</span><span class="n">additional_structure</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Rings</span><span class="p">()</span><span class="o">.</span><span class="n">Commutative</span><span class="p">()</span><span class="o">.</span><span class="n">additional_structure</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Modules</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">FiniteDimensional</span><span class="p">()</span><span class="o">.</span><span class="n">additional_structure</span><span class="p">()</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.magmatic_algebras</span> <span class="kn">import</span> <span class="n">MagmaticAlgebras</span>
<span class="gp">sage: </span><span class="n">MagmaticAlgebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Unital</span><span class="p">()</span><span class="o">.</span><span class="n">additional_structure</span><span class="p">()</span>
</pre></div>
</div>
<p>As of Sage 6.4, the only exceptions are the category of unital
magmas or the category of unital additive magmas (both define
a unit which shall be preserved by morphisms):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Unital</span><span class="p">()</span><span class="o">.</span><span class="n">additional_structure</span><span class="p">()</span>
<span class="go">Category of unital magmas</span>
<span class="gp">sage: </span><span class="n">AdditiveMagmas</span><span class="p">()</span><span class="o">.</span><span class="n">AdditiveUnital</span><span class="p">()</span><span class="o">.</span><span class="n">additional_structure</span><span class="p">()</span>
<span class="go">Category of additive unital additive magmas</span>
</pre></div>
</div>
<p>Similarly, <a class="reference internal" href="primer.html#category-primer-functorial-constructions"><span class="std std-ref">functorial construction categories</span></a> don&#8217;t define
additional structure, unless the construction is actually
defined by their base category. For example, the category of
graded modules defines a grading which shall be preserved by
morphisms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Modules</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">Graded</span><span class="p">()</span><span class="o">.</span><span class="n">additional_structure</span><span class="p">()</span>
<span class="go">Category of graded modules over Integer Ring</span>
</pre></div>
</div>
<p>On the other hand, the category of graded algebras does not
define additional structure; indeed an algebra morphism which
is also a module morphism is a graded algebra morphism:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Algebras</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">Graded</span><span class="p">()</span><span class="o">.</span><span class="n">additional_structure</span><span class="p">()</span>
</pre></div>
</div>
<p>Similarly, morphisms are requested to preserve the structure
given by the following constructions:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">Quotients</span><span class="p">()</span><span class="o">.</span><span class="n">additional_structure</span><span class="p">()</span>
<span class="go">Category of quotients of sets</span>
<span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">CartesianProducts</span><span class="p">()</span><span class="o">.</span><span class="n">additional_structure</span><span class="p">()</span>
<span class="go">Category of Cartesian products of sets</span>
<span class="gp">sage: </span><span class="n">Modules</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">TensorProducts</span><span class="p">()</span><span class="o">.</span><span class="n">additional_structure</span><span class="p">()</span>
</pre></div>
</div>
<p>This might change, as we are lacking enough data points to
guarantee that this was the correct design decision.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>In some cases a category defines additional structure,
where the structure can be useful to manipulate morphisms
but where, in most use cases, we don&#8217;t want the morphisms
to necessarily preserve it. For example, in the context of
finite dimensional vector spaces, having a distinguished
basis allows for representing morphisms by matrices; yet
considering only morphisms that preserve that
distinguished basis would be boring.</p>
<p>In such cases, we might want to eventually have two
categories, one where the additional structure is
preserved, and one where it&#8217;s not necessarily preserved
(we would need to find an idiom for this).</p>
<p>At this point, a choice is to be made each time, according
to the main use cases. Some of those choices are yet to be
settled. For example, should by default:</p>
<ul class="last">
<li><p class="first">an euclidean domain morphism preserve euclidean
division?</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">EuclideanDomains</span><span class="p">()</span><span class="o">.</span><span class="n">additional_structure</span><span class="p">()</span>
<span class="go">Category of euclidean domains</span>
</pre></div>
</div>
</li>
<li><p class="first">an enumerated set morphism preserve the distinguished
enumeration?</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">EnumeratedSets</span><span class="p">()</span><span class="o">.</span><span class="n">additional_structure</span><span class="p">()</span>
</pre></div>
</div>
</li>
<li><p class="first">a module with basis morphism preserve the distinguished
basis?</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Modules</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">WithBasis</span><span class="p">()</span><span class="o">.</span><span class="n">additional_structure</span><span class="p">()</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p>This method together with the methods overloading it
provide the basic data to determine, for a given category,
the super categories that define some structure (see
<a class="reference internal" href="#sage.categories.category.Category.structure" title="sage.categories.category.Category.structure"><code class="xref py py-meth docutils literal"><span class="pre">structure()</span></code></a>), and to test whether a category is a
full subcategory of some other category (see
<a class="reference internal" href="#sage.categories.category.Category.is_full_subcategory" title="sage.categories.category.Category.is_full_subcategory"><code class="xref py py-meth docutils literal"><span class="pre">is_full_subcategory()</span></code></a>). For example, the category of
Coxeter groups is not full subcategory of the category of
groups since morphisms need to preserve the distinguished
generators:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">CoxeterGroups</span><span class="p">()</span><span class="o">.</span><span class="n">is_full_subcategory</span><span class="p">(</span><span class="n">Groups</span><span class="p">())</span>
<span class="go">False</span>
</pre></div>
</div>
<p class="last">The support for modeling full subcategories has been
introduced in <a class="reference external" href="https://trac.sagemath.org/16340">trac ticket #16340</a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category.all_super_categories">
<code class="descname">all_super_categories</code><span class="sig-paren">(</span><em>proper=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category.all_super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the list of all super categories of this category.</p>
<p>INPUT:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">proper</span></code> &#8211; a boolean (default: <code class="docutils literal"><span class="pre">False</span></code>); whether to exclude this category.</li>
</ul>
</div></blockquote>
<p>Since <a class="reference external" href="https://trac.sagemath.org/11943">trac ticket #11943</a>, the order of super categories is
determined by Python&#8217;s method resolution order C3 algorithm.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Whenever speed matters, the developers are advised to use
instead the lazy attributes <a class="reference internal" href="#sage.categories.category.Category._all_super_categories" title="sage.categories.category.Category._all_super_categories"><code class="xref py py-meth docutils literal"><span class="pre">_all_super_categories()</span></code></a>,
<a class="reference internal" href="#sage.categories.category.Category._all_super_categories_proper" title="sage.categories.category.Category._all_super_categories_proper"><code class="xref py py-meth docutils literal"><span class="pre">_all_super_categories_proper()</span></code></a>, or
<a class="reference internal" href="#sage.categories.category.Category._set_of_super_categories" title="sage.categories.category.Category._set_of_super_categories"><code class="xref py py-meth docutils literal"><span class="pre">_set_of_super_categories()</span></code></a>, as
appropriate. Simply because lazy attributes are much
faster than any method.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Rings</span><span class="p">();</span> <span class="n">C</span>
<span class="go">Category of rings</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">all_super_categories</span><span class="p">()</span>
<span class="go">[Category of rings, Category of rngs, Category of semirings, ...</span>
<span class="go"> Category of monoids, ...</span>
<span class="go"> Category of commutative additive groups, ...</span>
<span class="go"> Category of sets, Category of sets with partial maps,</span>
<span class="go"> Category of objects]</span>

<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">all_super_categories</span><span class="p">(</span><span class="n">proper</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="go">[Category of rngs, Category of semirings, ...</span>
<span class="go"> Category of monoids, ...</span>
<span class="go"> Category of commutative additive groups, ...</span>
<span class="go"> Category of sets, Category of sets with partial maps,</span>
<span class="go"> Category of objects]</span>

<span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">all_super_categories</span><span class="p">()</span>
<span class="go">[Category of sets, Category of sets with partial maps, Category of objects]</span>
<span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">all_super_categories</span><span class="p">(</span><span class="n">proper</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[Category of sets with partial maps, Category of objects]</span>
<span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">all_super_categories</span><span class="p">()</span> <span class="ow">is</span> <span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">_all_super_categories</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">all_super_categories</span><span class="p">(</span><span class="n">proper</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">_all_super_categories_proper</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="sage.categories.category.Category.an_instance">
<em class="property">classmethod </em><code class="descname">an_instance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category.an_instance" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an instance of this class.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Rings</span><span class="o">.</span><span class="n">an_instance</span><span class="p">()</span>
<span class="go">Category of rings</span>
</pre></div>
</div>
<p>Parametrized categories should overload this default
implementation to provide appropriate arguments:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Algebras</span><span class="o">.</span><span class="n">an_instance</span><span class="p">()</span>
<span class="go">Category of algebras over Rational Field</span>
<span class="gp">sage: </span><span class="n">Bimodules</span><span class="o">.</span><span class="n">an_instance</span><span class="p">()</span>
<span class="go">Category of bimodules over Rational Field on the left and Real Field with 53 bits of precision on the right</span>
<span class="gp">sage: </span><span class="n">AlgebraIdeals</span><span class="o">.</span><span class="n">an_instance</span><span class="p">()</span>
<span class="go">Category of algebra ideals in Univariate Polynomial Ring in x over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category.axioms">
<code class="descname">axioms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category.axioms" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the axioms known to be satisfied by all the objects of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>Technically, this is the set of all the axioms <code class="docutils literal"><span class="pre">A</span></code> such that, if
<code class="docutils literal"><span class="pre">Cs</span></code> is the category defining <code class="docutils literal"><span class="pre">A</span></code>, then <code class="docutils literal"><span class="pre">self</span></code> is a subcategory
of <code class="docutils literal"><span class="pre">Cs().A()</span></code>. Any additional axiom <code class="docutils literal"><span class="pre">A</span></code> would yield a strict
subcategory of <code class="docutils literal"><span class="pre">self</span></code>, at the very least <code class="docutils literal"><span class="pre">self</span> <span class="pre">&amp;</span> <span class="pre">Cs().A()</span></code> where
<code class="docutils literal"><span class="pre">Cs</span></code> is the category defining <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Monoids</span><span class="p">()</span><span class="o">.</span><span class="n">axioms</span><span class="p">()</span>
<span class="go">frozenset({&#39;Associative&#39;, &#39;Unital&#39;})</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">EnumeratedSets</span><span class="p">()</span><span class="o">.</span><span class="n">Infinite</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">Facade</span><span class="p">())</span><span class="o">.</span><span class="n">axioms</span><span class="p">()</span>
<span class="go">frozenset({&#39;Enumerated&#39;, &#39;Facade&#39;, &#39;Infinite&#39;})</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category.category">
<code class="descname">category</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category.category" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the category of this category. So far, all categories
are in the category of objects.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of objects</span>
<span class="gp">sage: </span><span class="n">VectorSpaces</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of objects</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category.category_graph">
<code class="descname">category_graph</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category.category_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the graph of all super categories of this category</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">category_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_directed_acyclic</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">girth</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category.element_class">
<code class="descname">element_class</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category.element_class" title="Permalink to this definition">¶</a></dt>
<dd><p>A common super class for all elements of parents in this category
(and its subcategories).</p>
<p>This class contains the methods defined in the nested class
<code class="docutils literal"><span class="pre">self.ElementMethods</span></code> (if it exists), and has as bases the
element classes of the super categories of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.categories.category.Category.parent_class" title="sage.categories.category.Category.parent_class"><code class="xref py py-meth docutils literal"><span class="pre">parent_class()</span></code></a>, <a class="reference internal" href="#sage.categories.category.Category.morphism_class" title="sage.categories.category.Category.morphism_class"><code class="xref py py-meth docutils literal"><span class="pre">morphism_class()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.category.Category" title="sage.categories.category.Category"><code class="xref py py-class docutils literal"><span class="pre">Category</span></code></a> for details</li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">element_class</span><span class="p">;</span> <span class="n">C</span>
<span class="go">&lt;class &#39;sage.categories.algebras.Algebras.element_class&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.structure.dynamic_class.DynamicMetaclass&#39;&gt;</span>
</pre></div>
</div>
<p>By <a class="reference external" href="https://trac.sagemath.org/11935">trac ticket #11935</a>, some categories share their element
classes. For example, the element class of an algebra only
depends on the category of the base. A typical example is the
category of algebras over a field versus algebras over a
non-field:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Algebras</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">element_class</span> <span class="ow">is</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">element_class</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">element_class</span> <span class="ow">is</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">element_class</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Algebras</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">element_class</span> <span class="ow">is</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">element_class</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.categories.category.Category.parent_class" title="sage.categories.category.Category.parent_class"><code class="xref py py-meth docutils literal"><span class="pre">parent_class()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category.example">
<code class="descname">example</code><span class="sig-paren">(</span><em>*args</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category.example" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an object in this category. Most of the time, this is a parent.</p>
<p>This serves three purposes:</p>
<ul class="simple">
<li>Give a typical example to better explain what the category is all about.
(and by the way prove that the category is non empty :-) )</li>
<li>Provide a minimal template for implementing other objects in this category</li>
<li>Provide an object on which to test generic code implemented by the category</li>
</ul>
<p>For all those applications, the implementation of the object
shall be kept to a strict minimum. The object is therefore not
meant to be used for other applications; most of the time a
full featured version is available elsewhere in Sage, and
should be used insted.</p>
<p>Technical note: by default <code class="docutils literal"><span class="pre">FooBar(...).example()</span></code> is
constructed by looking up
<code class="docutils literal"><span class="pre">sage.categories.examples.foo_bar.Example</span></code> and calling it as
<code class="docutils literal"><span class="pre">Example()</span></code>. Extra positional or named parameters are also
passed down. For a category over base ring, the base ring is
further passed down as an optional argument.</p>
<p>Categories are welcome to override this default implementation.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Semigroups</span><span class="p">()</span><span class="o">.</span><span class="n">example</span><span class="p">()</span>
<span class="go">An example of a semigroup: the left zero semigroup</span>

<span class="gp">sage: </span><span class="n">Monoids</span><span class="p">()</span><span class="o">.</span><span class="n">Subquotients</span><span class="p">()</span><span class="o">.</span><span class="n">example</span><span class="p">()</span>
<span class="go">NotImplemented</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category.full_super_categories">
<code class="descname">full_super_categories</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category.full_super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <em>immediate</em> full super categories of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.categories.category.Category.super_categories" title="sage.categories.category.Category.super_categories"><code class="xref py py-meth docutils literal"><span class="pre">super_categories()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.category.Category.is_full_subcategory" title="sage.categories.category.Category.is_full_subcategory"><code class="xref py py-meth docutils literal"><span class="pre">is_full_subcategory()</span></code></a></li>
</ul>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>The current implementation selects the full subcategories
among the immediate super categories of <code class="docutils literal"><span class="pre">self</span></code>. This
assumes that, if <span class="math">\(C\subset B\subset A\)</span> is a chain of
categories and <span class="math">\(C\)</span> is a full subcategory of <span class="math">\(A\)</span>, then <span class="math">\(C\)</span>
is a full subcategory of <span class="math">\(B\)</span> and <span class="math">\(B\)</span> is a full subcategory
of <span class="math">\(A\)</span>.</p>
<p class="last">This assumption is guaranteed to hold with the current
model and implementation of full subcategories in
Sage. However, mathematically speaking, this is too
restrictive. This indeed prevents the complete modelling
of situations where any <span class="math">\(A\)</span> morphism between elements of
<span class="math">\(C\)</span> automatically preserves the <span class="math">\(B\)</span> structure. See below
for an example.</p>
</div>
<p>EXAMPLES:</p>
<p>A semigroup morphism between two finite semigroups is a finite
semigroup morphism:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Semigroups</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span><span class="o">.</span><span class="n">full_super_categories</span><span class="p">()</span>
<span class="go">[Category of semigroups]</span>
</pre></div>
</div>
<p>On the other hand, a semigroup morphism between two monoids is
not necessarily a monoid morphism (which must map the unit to
the unit):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Monoids</span><span class="p">()</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of semigroups, Category of unital magmas]</span>
<span class="gp">sage: </span><span class="n">Monoids</span><span class="p">()</span><span class="o">.</span><span class="n">full_super_categories</span><span class="p">()</span>
<span class="go">[Category of unital magmas]</span>
</pre></div>
</div>
<p>Any semigroup morphism between two groups is automatically a
monoid morphism (in a group the unit is the unique idempotent,
so it has to be mapped to the unit). Yet, due to the
limitation of the model advertised above, Sage currently can&#8217;t
be taught that the category of groups is a full subcategory of
the category of semigroups:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Groups</span><span class="p">()</span><span class="o">.</span><span class="n">full_super_categories</span><span class="p">()</span>     <span class="c1"># todo: not implemented</span>
<span class="go">[Category of monoids, Category of semigroups, Category of inverse unital magmas]</span>
<span class="gp">sage: </span><span class="n">Groups</span><span class="p">()</span><span class="o">.</span><span class="n">full_super_categories</span><span class="p">()</span>
<span class="go">[Category of monoids, Category of inverse unital magmas]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category.is_abelian">
<code class="descname">is_abelian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category.is_abelian" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether this category is abelian.</p>
<p>An abelian category is a category satisfying:</p>
<ul class="simple">
<li>It has a zero object;</li>
<li>It has all pullbacks and pushouts;</li>
<li>All monomorphisms and epimorphisms are normal.</li>
</ul>
<p>Equivalently, one can define an increasing sequence of conditions:</p>
<ul class="simple">
<li>A category is pre-additive if it is enriched over abelian groups
(all homsets are abelian groups and composition is bilinear);</li>
<li>A pre-additive category is additive if every finite set of objects
has a biproduct (we can form direct sums and direct products);</li>
<li>An additive category is pre-abelian if every morphism has both a
kernel and a cokernel;</li>
<li>A pre-abelian category is abelian if every monomorphism is the
kernel of some morphism and every epimorphism is the cokernel of
some morphism.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Modules</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">is_abelian</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">FreeModules</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">is_abelian</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">FreeModules</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">is_abelian</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">CommutativeAdditiveGroups</span><span class="p">()</span><span class="o">.</span><span class="n">is_abelian</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Semigroups</span><span class="p">()</span><span class="o">.</span><span class="n">is_abelian</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="gr">NotImplementedError</span>: <span class="n">is_abelian</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category.is_full_subcategory">
<code class="descname">is_full_subcategory</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category.is_full_subcategory" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether <code class="docutils literal"><span class="pre">self</span></code> is a full subcategory of <code class="docutils literal"><span class="pre">other</span></code>.</p>
<p>A subcategory <span class="math">\(B\)</span> of a category <span class="math">\(A\)</span> is a <em>full subcategory</em> if
any <span class="math">\(A\)</span>-morphism between two objects of <span class="math">\(B\)</span> is also a
<span class="math">\(B\)</span>-morphism (the reciprocal always holds: any <span class="math">\(B\)</span>-morphism
between two objects of <span class="math">\(B\)</span> is an <span class="math">\(A\)</span>-morphism).</p>
<p>This is computed by testing whether <code class="docutils literal"><span class="pre">self</span></code> is a subcategory
of <code class="docutils literal"><span class="pre">other</span></code> and whether they have the same structure, as
determined by <a class="reference internal" href="#sage.categories.category.Category.structure" title="sage.categories.category.Category.structure"><code class="xref py py-meth docutils literal"><span class="pre">structure()</span></code></a> from the
result of <a class="reference internal" href="#sage.categories.category.Category.additional_structure" title="sage.categories.category.Category.additional_structure"><code class="xref py py-meth docutils literal"><span class="pre">additional_structure()</span></code></a> on the super
categories.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">A positive answer is guaranteed to be mathematically
correct. A negative answer may mean that Sage has not been
taught enough information (or can not yet within the
current model) to derive this information. See
<a class="reference internal" href="#sage.categories.category.Category.full_super_categories" title="sage.categories.category.Category.full_super_categories"><code class="xref py py-meth docutils literal"><span class="pre">full_super_categories()</span></code></a> for a discussion.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.categories.category.Category.is_subcategory" title="sage.categories.category.Category.is_subcategory"><code class="xref py py-meth docutils literal"><span class="pre">is_subcategory()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.category.Category.full_super_categories" title="sage.categories.category.Category.full_super_categories"><code class="xref py py-meth docutils literal"><span class="pre">full_super_categories()</span></code></a></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Associative</span><span class="p">()</span><span class="o">.</span><span class="n">is_full_subcategory</span><span class="p">(</span><span class="n">Magmas</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Unital</span><span class="p">()</span><span class="o">.</span><span class="n">is_full_subcategory</span><span class="p">(</span><span class="n">Magmas</span><span class="p">())</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Rings</span><span class="p">()</span><span class="o">.</span><span class="n">is_full_subcategory</span><span class="p">(</span><span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Unital</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">AdditiveMagmas</span><span class="p">()</span><span class="o">.</span><span class="n">AdditiveUnital</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Here are two typical examples of false negatives:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Groups</span><span class="p">()</span><span class="o">.</span><span class="n">is_full_subcategory</span><span class="p">(</span><span class="n">Semigroups</span><span class="p">())</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Groups</span><span class="p">()</span><span class="o">.</span><span class="n">is_full_subcategory</span><span class="p">(</span><span class="n">Semigroups</span><span class="p">())</span> <span class="c1"># todo: not implemented</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Fields</span><span class="p">()</span><span class="o">.</span><span class="n">is_full_subcategory</span><span class="p">(</span><span class="n">Rings</span><span class="p">())</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Fields</span><span class="p">()</span><span class="o">.</span><span class="n">is_full_subcategory</span><span class="p">(</span><span class="n">Rings</span><span class="p">())</span>      <span class="c1"># todo: not implemented</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-2">
<p class="first admonition-title">Todo</p>
<p>The latter is a consequence of <a class="reference internal" href="euclidean_domains.html#sage.categories.euclidean_domains.EuclideanDomains" title="sage.categories.euclidean_domains.EuclideanDomains"><code class="xref py py-class docutils literal"><span class="pre">EuclideanDomains</span></code></a>
currently being a structure category. Is this what we
want?</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">EuclideanDomains</span><span class="p">()</span><span class="o">.</span><span class="n">is_full_subcategory</span><span class="p">(</span><span class="n">Rings</span><span class="p">())</span>
<span class="go">False</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category.is_subcategory">
<code class="descname">is_subcategory</code><span class="sig-paren">(</span><em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category.is_subcategory" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if self is naturally embedded as a subcategory of c.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">AbGrps</span> <span class="o">=</span> <span class="n">CommutativeAdditiveGroups</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Rings</span><span class="p">()</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="n">AbGrps</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">AbGrps</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="n">Rings</span><span class="p">())</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">is_subcategory</span></code> function takes into account the
base.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M3</span> <span class="o">=</span> <span class="n">VectorSpaces</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">M9</span> <span class="o">=</span> <span class="n">VectorSpaces</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">M3</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="n">M9</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Join categories are properly handled:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">CatJ</span> <span class="o">=</span> <span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">CommutativeAdditiveGroups</span><span class="p">(),</span> <span class="n">Semigroups</span><span class="p">()))</span>
<span class="gp">sage: </span><span class="n">Rings</span><span class="p">()</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="n">CatJ</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">V3</span> <span class="o">=</span> <span class="n">VectorSpaces</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">POSet</span> <span class="o">=</span> <span class="n">PartiallyOrderedSets</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">PoV3</span> <span class="o">=</span> <span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">V3</span><span class="p">,</span> <span class="n">POSet</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">A3</span> <span class="o">=</span> <span class="n">AlgebrasWithBasis</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">PoA3</span> <span class="o">=</span> <span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">A3</span><span class="p">,</span> <span class="n">POSet</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">PoA3</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="n">PoV3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">PoV3</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="n">PoV3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">PoV3</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="n">PoA3</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="sage.categories.category.Category.join">
<em class="property">static </em><code class="descname">join</code><span class="sig-paren">(</span><em>categories</em>, <em>as_list=False</em>, <em>ignore_axioms=()</em>, <em>axioms=()</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the join of the input categories in the lattice of categories.</p>
<p>At the level of objects and morphisms, this operation
corresponds to intersection: the objects and morphisms of a
join category are those that belong to all its super
categories.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">categories</span></code> &#8211; a list (or iterable) of categories</li>
<li><code class="docutils literal"><span class="pre">as_list</span></code> &#8211; a boolean (default: <code class="docutils literal"><span class="pre">False</span></code>);
whether the result should be returned as a list</li>
<li><code class="docutils literal"><span class="pre">axioms</span></code> &#8211; a tuple of strings; the names of some
supplementary axioms</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">__and__()</span></code> for a shortcut</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">Groups</span><span class="p">(),</span> <span class="n">CommutativeAdditiveMonoids</span><span class="p">()));</span> <span class="n">J</span>
<span class="go">Join of Category of groups and Category of commutative additive monoids</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of groups, Category of commutative additive monoids]</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">all_super_categories</span><span class="p">(</span><span class="n">proper</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[Category of groups, ..., Category of magmas,</span>
<span class="go"> Category of commutative additive monoids, ..., Category of additive magmas,</span>
<span class="go"> Category of sets, ...]</span>
</pre></div>
</div>
<p>As a short hand, one can use:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Groups</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">CommutativeAdditiveMonoids</span><span class="p">()</span>
<span class="go">Join of Category of groups and Category of commutative additive monoids</span>
</pre></div>
</div>
<p>This is a commutative and associative operation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Groups</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">Posets</span><span class="p">()</span>
<span class="go">Join of Category of groups and Category of posets</span>
<span class="gp">sage: </span><span class="n">Posets</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">Groups</span><span class="p">()</span>
<span class="go">Join of Category of groups and Category of posets</span>

<span class="gp">sage: </span><span class="n">Groups</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CommutativeAdditiveMonoids</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">Posets</span><span class="p">())</span>
<span class="go">Join of Category of groups</span>
<span class="go">    and Category of commutative additive monoids</span>
<span class="go">    and Category of posets</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Groups</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">CommutativeAdditiveMonoids</span><span class="p">())</span> <span class="o">&amp;</span> <span class="n">Posets</span><span class="p">()</span>
<span class="go">Join of Category of groups</span>
<span class="go">    and Category of commutative additive monoids</span>
<span class="go">    and Category of posets</span>
</pre></div>
</div>
<p>The join of a single category is the category itself:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">Monoids</span><span class="p">()])</span>
<span class="go">Category of monoids</span>
</pre></div>
</div>
<p>Similarly, the join of several mutually comparable categories is
the smallest one:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">Sets</span><span class="p">(),</span> <span class="n">Rings</span><span class="p">(),</span> <span class="n">Monoids</span><span class="p">()))</span>
<span class="go">Category of rings</span>
</pre></div>
</div>
<p>In particular, the unit is the top category <a class="reference internal" href="objects.html#sage.categories.objects.Objects" title="sage.categories.objects.Objects"><code class="xref py py-class docutils literal"><span class="pre">Objects</span></code></a>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Groups</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">Objects</span><span class="p">()</span>
<span class="go">Category of groups</span>
</pre></div>
</div>
<p>If the optional parameter <code class="docutils literal"><span class="pre">as_list</span></code> is <code class="docutils literal"><span class="pre">True</span></code>, this
returns the super categories of the join as a list, without
constructing the join category itself:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">Groups</span><span class="p">(),</span> <span class="n">CommutativeAdditiveMonoids</span><span class="p">()),</span> <span class="n">as_list</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[Category of groups, Category of commutative additive monoids]</span>
<span class="gp">sage: </span><span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">Sets</span><span class="p">(),</span> <span class="n">Rings</span><span class="p">(),</span> <span class="n">Monoids</span><span class="p">()),</span> <span class="n">as_list</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[Category of rings]</span>
<span class="gp">sage: </span><span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">Modules</span><span class="p">(</span><span class="n">ZZ</span><span class="p">),</span> <span class="n">FiniteFields</span><span class="p">()),</span> <span class="n">as_list</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[Category of finite enumerated fields, Category of modules over Integer Ring]</span>
<span class="gp">sage: </span><span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">([],</span> <span class="n">as_list</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">Groups</span><span class="p">()],</span> <span class="n">as_list</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[Category of groups]</span>
<span class="gp">sage: </span><span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">Groups</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">Posets</span><span class="p">()],</span> <span class="n">as_list</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[Category of groups, Category of posets]</span>
</pre></div>
</div>
<p>Support for axiom categories (TODO: put here meaningfull examples):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">Facade</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">Infinite</span><span class="p">()</span>
<span class="go">Category of facade infinite sets</span>
<span class="gp">sage: </span><span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Infinite</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">Facade</span><span class="p">()</span>
<span class="go">Category of facade infinite magmas</span>

<span class="gp">sage: </span><span class="n">FiniteSets</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">Monoids</span><span class="p">()</span>
<span class="go">Category of finite monoids</span>
<span class="gp">sage: </span><span class="n">Rings</span><span class="p">()</span><span class="o">.</span><span class="n">Commutative</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span>
<span class="go">Category of finite commutative rings</span>
</pre></div>
</div>
<p>Note that several of the above examples are actually join
categories; they are just nicely displayed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">AlgebrasWithBasis</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FiniteSets</span><span class="p">()</span><span class="o">.</span><span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">Join of Category of finite dimensional algebras with basis over Rational Field</span>
<span class="go">    and Category of finite set algebras over Rational Field</span>

<span class="gp">sage: </span><span class="n">UniqueFactorizationDomains</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">Join of Category of unique factorization domains</span>
<span class="go">    and Category of commutative algebras over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="sage.categories.category.Category.meet">
<em class="property">static </em><code class="descname">meet</code><span class="sig-paren">(</span><em>categories</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category.meet" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the meet of a list of categories</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">categories</span></code> - a non empty list (or iterable) of categories</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">__or__()</span></code> for a shortcut</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Category</span><span class="o">.</span><span class="n">meet</span><span class="p">([</span><span class="n">Algebras</span><span class="p">(</span><span class="n">ZZ</span><span class="p">),</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">),</span> <span class="n">Groups</span><span class="p">()])</span>
<span class="go">Category of monoids</span>
</pre></div>
</div>
<p>That meet of an empty list should be a category which is a
subcategory of all categories, which does not make practical sense:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Category</span><span class="o">.</span><span class="n">meet</span><span class="p">([])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The meet of an empty list of categories is not implemented</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category.morphism_class">
<code class="descname">morphism_class</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category.morphism_class" title="Permalink to this definition">¶</a></dt>
<dd><p>A common super class for all morphisms between parents in this
category (and its subcategories).</p>
<p>This class contains the methods defined in the nested class
<code class="docutils literal"><span class="pre">self.MorphismMethods</span></code> (if it exists), and has as bases the
morphims classes of the super categories of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.categories.category.Category.parent_class" title="sage.categories.category.Category.parent_class"><code class="xref py py-meth docutils literal"><span class="pre">parent_class()</span></code></a>, <a class="reference internal" href="#sage.categories.category.Category.element_class" title="sage.categories.category.Category.element_class"><code class="xref py py-meth docutils literal"><span class="pre">element_class()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.category.Category" title="sage.categories.category.Category"><code class="xref py py-class docutils literal"><span class="pre">Category</span></code></a> for details</li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">morphism_class</span><span class="p">;</span> <span class="n">C</span>
<span class="go">&lt;class &#39;sage.categories.algebras.Algebras.morphism_class&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.structure.dynamic_class.DynamicMetaclass&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category.or_subcategory">
<code class="descname">or_subcategory</code><span class="sig-paren">(</span><em>category=None</em>, <em>join=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category.or_subcategory" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">category</span></code> or <code class="docutils literal"><span class="pre">self</span></code> if <code class="docutils literal"><span class="pre">category</span></code> is <code class="docutils literal"><span class="pre">None</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">category</span></code> &#8211; a sub category of <code class="docutils literal"><span class="pre">self</span></code>, tuple/list thereof,
or <code class="docutils literal"><span class="pre">None</span></code></li>
<li><code class="docutils literal"><span class="pre">join</span></code> &#8211; a boolean (default: <code class="docutils literal"><span class="pre">False</span></code>)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>a category</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Monoids</span><span class="p">()</span><span class="o">.</span><span class="n">or_subcategory</span><span class="p">(</span><span class="n">Groups</span><span class="p">())</span>
<span class="go">Category of groups</span>
<span class="gp">sage: </span><span class="n">Monoids</span><span class="p">()</span><span class="o">.</span><span class="n">or_subcategory</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="go">Category of monoids</span>
</pre></div>
</div>
<p>If category is a list/tuple, then a join category is returned:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Monoids</span><span class="p">()</span><span class="o">.</span><span class="n">or_subcategory</span><span class="p">((</span><span class="n">CommutativeAdditiveMonoids</span><span class="p">(),</span> <span class="n">Groups</span><span class="p">()))</span>
<span class="go">Join of Category of groups and Category of commutative additive monoids</span>
</pre></div>
</div>
<p>If <code class="docutils literal"><span class="pre">join</span></code> is <code class="docutils literal"><span class="pre">False</span></code>, an error if raised if category is not a
subcategory of <code class="docutils literal"><span class="pre">self</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Monoids</span><span class="p">()</span><span class="o">.</span><span class="n">or_subcategory</span><span class="p">(</span><span class="n">EnumeratedSets</span><span class="p">())</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Subcategory of `Category of monoids` required; got `Category of enumerated sets`</span>
</pre></div>
</div>
<p>Otherwise, the two categories are joined together:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Monoids</span><span class="p">()</span><span class="o">.</span><span class="n">or_subcategory</span><span class="p">(</span><span class="n">EnumeratedSets</span><span class="p">(),</span> <span class="n">join</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Category of enumerated monoids</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category.parent_class">
<code class="descname">parent_class</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category.parent_class" title="Permalink to this definition">¶</a></dt>
<dd><p>A common super class for all parents in this category (and its
subcategories).</p>
<p>This class contains the methods defined in the nested class
<code class="docutils literal"><span class="pre">self.ParentMethods</span></code> (if it exists), and has as bases the
parent classes of the super categories of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.categories.category.Category.element_class" title="sage.categories.category.Category.element_class"><code class="xref py py-meth docutils literal"><span class="pre">element_class()</span></code></a>, <a class="reference internal" href="#sage.categories.category.Category.morphism_class" title="sage.categories.category.Category.morphism_class"><code class="xref py py-meth docutils literal"><span class="pre">morphism_class()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.category.Category" title="sage.categories.category.Category"><code class="xref py py-class docutils literal"><span class="pre">Category</span></code></a> for details</li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">parent_class</span><span class="p">;</span> <span class="n">C</span>
<span class="go">&lt;class &#39;sage.categories.algebras.Algebras.parent_class&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.structure.dynamic_class.DynamicMetaclass&#39;&gt;</span>
</pre></div>
</div>
<p>By <a class="reference external" href="https://trac.sagemath.org/11935">trac ticket #11935</a>, some categories share their parent
classes. For example, the parent class of an algebra only
depends on the category of the base ring. A typical example is
the category of algebras over a finite field versus algebras
over a non-field:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Algebras</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span><span class="o">.</span><span class="n">parent_class</span> <span class="ow">is</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">parent_class</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">parent_class</span> <span class="ow">is</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">parent_class</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Algebras</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">parent_class</span> <span class="ow">is</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">parent_class</span>
<span class="go">True</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#sage.categories.category.CategoryWithParameters" title="sage.categories.category.CategoryWithParameters"><code class="xref py py-class docutils literal"><span class="pre">CategoryWithParameters</span></code></a> for an abstract base class for
categories that depend on parameters, even though the parent
and element classes only depend on the parent or element
classes of its super categories. It is used in
<a class="reference internal" href="bimodules.html#sage.categories.bimodules.Bimodules" title="sage.categories.bimodules.Bimodules"><code class="xref py py-class docutils literal"><span class="pre">Bimodules</span></code></a>,
<a class="reference internal" href="category_types.html#sage.categories.category_types.Category_over_base" title="sage.categories.category_types.Category_over_base"><code class="xref py py-class docutils literal"><span class="pre">Category_over_base</span></code></a> and
<a class="reference internal" href="#sage.categories.category.JoinCategory" title="sage.categories.category.JoinCategory"><code class="xref py py-class docutils literal"><span class="pre">sage.categories.category.JoinCategory</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category.required_methods">
<code class="descname">required_methods</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category.required_methods" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the methods that are required and optional for parents
in this category and their elements.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">required_methods</span><span class="p">()</span>
<span class="go">{&#39;element&#39;: {&#39;optional&#39;: [&#39;_add_&#39;, &#39;_mul_&#39;], &#39;required&#39;: [&#39;__nonzero__&#39;]},</span>
<span class="go"> &#39;parent&#39;: {&#39;optional&#39;: [&#39;algebra_generators&#39;], &#39;required&#39;: [&#39;__contains__&#39;]}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category.structure">
<code class="descname">structure</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category.structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the structure <code class="docutils literal"><span class="pre">self</span></code> is endowed with.</p>
<p>This method returns the structure that morphisms in this
category shall be preserving. For example, it tells that a
ring is a set endowed with a structure of both a unital magma
and an additive unital magma which satisfies some further
axioms. In other words, a ring morphism is a function that
preserves the unital magma and additive unital magma
structure.</p>
<p>In practice, this returns the collection of all the super
categories of <code class="docutils literal"><span class="pre">self</span></code> that define some additional structure,
as a frozen set.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Objects</span><span class="p">()</span><span class="o">.</span><span class="n">structure</span><span class="p">()</span>
<span class="go">frozenset()</span>

<span class="gp">sage: </span><span class="k">def</span> <span class="nf">structure</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
<span class="go">....:     return Category._sort(C.structure())</span>

<span class="gp">sage: </span><span class="n">structure</span><span class="p">(</span><span class="n">Sets</span><span class="p">())</span>
<span class="go">(Category of sets, Category of sets with partial maps)</span>
<span class="gp">sage: </span><span class="n">structure</span><span class="p">(</span><span class="n">Magmas</span><span class="p">())</span>
<span class="go">(Category of magmas, Category of sets, Category of sets with partial maps)</span>
</pre></div>
</div>
<p>In the following example, we only list the smallest structure
categories to get a more readable output:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">structure</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
<span class="go">....:     return Category._sort_uniq(C.structure())</span>

<span class="gp">sage: </span><span class="n">structure</span><span class="p">(</span><span class="n">Magmas</span><span class="p">())</span>
<span class="go">(Category of magmas,)</span>
<span class="gp">sage: </span><span class="n">structure</span><span class="p">(</span><span class="n">Rings</span><span class="p">())</span>
<span class="go">(Category of unital magmas, Category of additive unital additive magmas)</span>
<span class="gp">sage: </span><span class="n">structure</span><span class="p">(</span><span class="n">Fields</span><span class="p">())</span>
<span class="go">(Category of euclidean domains,)</span>
<span class="gp">sage: </span><span class="n">structure</span><span class="p">(</span><span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">))</span>
<span class="go">(Category of unital magmas,</span>
<span class="go"> Category of right modules over Rational Field,</span>
<span class="go"> Category of left modules over Rational Field)</span>
<span class="gp">sage: </span><span class="n">structure</span><span class="p">(</span><span class="n">HopfAlgebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Graded</span><span class="p">()</span><span class="o">.</span><span class="n">WithBasis</span><span class="p">()</span><span class="o">.</span><span class="n">Connected</span><span class="p">())</span>
<span class="go">(Category of hopf algebras over Rational Field,</span>
<span class="go"> Category of graded modules over Rational Field)</span>
</pre></div>
</div>
<p>This method is used in <a class="reference internal" href="#sage.categories.category.Category.is_full_subcategory" title="sage.categories.category.Category.is_full_subcategory"><code class="xref py py-meth docutils literal"><span class="pre">is_full_subcategory()</span></code></a> for
deciding whether a category is a full subcategory of some
other category, and for documentation purposes. It is computed
recursively from the result of <a class="reference internal" href="#sage.categories.category.Category.additional_structure" title="sage.categories.category.Category.additional_structure"><code class="xref py py-meth docutils literal"><span class="pre">additional_structure()</span></code></a>
on the super categories of <code class="docutils literal"><span class="pre">self</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category.subcategory_class">
<code class="descname">subcategory_class</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category.subcategory_class" title="Permalink to this definition">¶</a></dt>
<dd><p>A common superclass for all subcategories of this category (including this one).</p>
<p>This class derives from <code class="docutils literal"><span class="pre">D.subcategory_class</span></code> for each super
category <span class="math">\(D\)</span> of <code class="docutils literal"><span class="pre">self</span></code>, and includes all the methods from
the nested class <code class="docutils literal"><span class="pre">self.SubcategoryMethods</span></code>, if it exists.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="https://trac.sagemath.org/12895">trac ticket #12895</a></li>
<li><a class="reference internal" href="#sage.categories.category.Category.parent_class" title="sage.categories.category.Category.parent_class"><code class="xref py py-meth docutils literal"><span class="pre">parent_class()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.category.Category.element_class" title="sage.categories.category.Category.element_class"><code class="xref py py-meth docutils literal"><span class="pre">element_class()</span></code></a></li>
<li><a class="reference internal" href="#sage.categories.category.Category._make_named_class" title="sage.categories.category.Category._make_named_class"><code class="xref py py-meth docutils literal"><span class="pre">_make_named_class()</span></code></a></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="bp">cls</span> <span class="o">=</span> <span class="n">Rings</span><span class="p">()</span><span class="o">.</span><span class="n">subcategory_class</span><span class="p">;</span> <span class="bp">cls</span>
<span class="go">&lt;class &#39;sage.categories.rings.Rings.subcategory_class&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.structure.dynamic_class.DynamicMetaclass&#39;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Rings()</span></code> is an instance of this class, as well as all its subcategories:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">Rings</span><span class="p">(),</span> <span class="bp">cls</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">AlgebrasWithBasis</span><span class="p">(</span><span class="n">QQ</span><span class="p">),</span> <span class="bp">cls</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.Category.super_categories">
<code class="descname">super_categories</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.Category.super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <em>immediate</em> super categories of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>a duplicate-free list of categories.</li>
</ul>
<p>Every category should implement this method.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Groups</span><span class="p">()</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of monoids, Category of inverse unital magmas]</span>
<span class="gp">sage: </span><span class="n">Objects</span><span class="p">()</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Since <a class="reference external" href="https://trac.sagemath.org/10963">trac ticket #10963</a>, the order of the categories in the
result is irrelevant. For details, see
<a class="reference internal" href="primer.html#category-primer-category-order"><span class="std std-ref">On the order of super categories</span></a>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Whenever speed matters, developers are advised to use the
lazy attribute <a class="reference internal" href="#sage.categories.category.Category._super_categories" title="sage.categories.category.Category._super_categories"><code class="xref py py-meth docutils literal"><span class="pre">_super_categories()</span></code></a> instead of
calling this method.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.categories.category.CategoryWithParameters">
<em class="property">class </em><code class="descclassname">sage.categories.category.</code><code class="descname">CategoryWithParameters</code><span class="sig-paren">(</span><em>s=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.CategoryWithParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.category.Category" title="sage.categories.category.Category"><code class="xref py py-class docutils literal"><span class="pre">sage.categories.category.Category</span></code></a></p>
<p>A parametrized category whose parent/element classes depend only on
its super categories.</p>
<p>Many categories in Sage are parametrized, like <code class="docutils literal"><span class="pre">C</span> <span class="pre">=</span> <span class="pre">Algebras(K)</span></code>
which takes a base ring as parameter. In many cases, however, the
operations provided by <code class="docutils literal"><span class="pre">C</span></code> in the parent class and element class
depend only on the super categories of <code class="docutils literal"><span class="pre">C</span></code>. For example, the
vector space operations are provided if and only if <code class="docutils literal"><span class="pre">K</span></code> is a
field, since <code class="docutils literal"><span class="pre">VectorSpaces(K)</span></code> is a super category of <code class="docutils literal"><span class="pre">C</span></code> only
in that case. In such cases, and as an optimization (see <a class="reference external" href="https://trac.sagemath.org/11935">trac ticket #11935</a>),
we want to use the same parent and element class for all fields.
This is the purpose of this abstract class.</p>
<p>Currently, <a class="reference internal" href="#sage.categories.category.JoinCategory" title="sage.categories.category.JoinCategory"><code class="xref py py-class docutils literal"><span class="pre">JoinCategory</span></code></a>,
<a class="reference internal" href="category_types.html#sage.categories.category_types.Category_over_base" title="sage.categories.category_types.Category_over_base"><code class="xref py py-class docutils literal"><span class="pre">Category_over_base</span></code></a> and
<a class="reference internal" href="bimodules.html#sage.categories.bimodules.Bimodules" title="sage.categories.bimodules.Bimodules"><code class="xref py py-class docutils literal"><span class="pre">Bimodules</span></code></a> inherit from this
class.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C1</span> <span class="o">=</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">C2</span> <span class="o">=</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">C3</span> <span class="o">=</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.category</span> <span class="kn">import</span> <span class="n">CategoryWithParameters</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">C1</span><span class="p">,</span> <span class="n">CategoryWithParameters</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C1</span><span class="o">.</span><span class="n">parent_class</span> <span class="ow">is</span> <span class="n">C2</span><span class="o">.</span><span class="n">parent_class</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C1</span><span class="o">.</span><span class="n">parent_class</span> <span class="ow">is</span> <span class="n">C3</span><span class="o">.</span><span class="n">parent_class</span>
<span class="go">False</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.categories.category.CategoryWithParameters._make_named_class">
<code class="descname">_make_named_class</code><span class="sig-paren">(</span><em>name</em>, <em>method_provider</em>, <em>cache=False</em>, <em>**options</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.CategoryWithParameters._make_named_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the parent/element/... class of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">name</span></code> &#8211; a string; the name of the class as an attribute
of <code class="docutils literal"><span class="pre">self</span></code></li>
<li><code class="docutils literal"><span class="pre">method_provider</span></code> &#8211; a string; the name of an attribute of
<code class="docutils literal"><span class="pre">self</span></code> that provides methods for the new class (in
addition to what comes from the super categories)</li>
<li><code class="docutils literal"><span class="pre">**options</span></code> &#8211; other named options to pass down to
<a class="reference internal" href="#sage.categories.category.Category._make_named_class" title="sage.categories.category.Category._make_named_class"><code class="xref py py-meth docutils literal"><span class="pre">Category._make_named_class()</span></code></a>.</li>
</ul>
<p>ASSUMPTION:</p>
<p>It is assumed that this method is only called from a lazy
attribute whose name coincides with the given <code class="docutils literal"><span class="pre">name</span></code>.</p>
<p>OUTPUT:</p>
<p>A dynamic class that has the corresponding named classes of
the super categories of <code class="docutils literal"><span class="pre">self</span></code> as bases and contains the
methods provided by <code class="docutils literal"><span class="pre">getattr(self,</span> <span class="pre">method_provider)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method overrides <a class="reference internal" href="#sage.categories.category.Category._make_named_class" title="sage.categories.category.Category._make_named_class"><code class="xref py py-meth docutils literal"><span class="pre">Category._make_named_class()</span></code></a>
so that the returned class <em>only</em> depends on the
corresponding named classes of the super categories and on
the provided methods. This allows for sharing the named
classes across closely related categories providing the
same code to their parents, elements and so on.</p>
</div>
<p>EXAMPLES:</p>
<p>The categories of bimodules over the fields <code class="docutils literal"><span class="pre">CC</span></code> or <code class="docutils literal"><span class="pre">RR</span></code>
provide the same methods to their parents and elements:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Bimodules</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span><span class="n">RR</span><span class="p">)</span><span class="o">.</span><span class="n">parent_class</span> <span class="ow">is</span> <span class="n">Bimodules</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span><span class="n">RDF</span><span class="p">)</span><span class="o">.</span><span class="n">parent_class</span> <span class="c1">#indirect doctest</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Bimodules</span><span class="p">(</span><span class="n">CC</span><span class="p">,</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">element_class</span> <span class="ow">is</span> <span class="n">Bimodules</span><span class="p">(</span><span class="n">RR</span><span class="p">,</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">element_class</span>
<span class="go">True</span>
</pre></div>
</div>
<p>On the other hand, modules over a field have more methods than
modules over a ring:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Modules</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">parent_class</span> <span class="ow">is</span> <span class="n">Modules</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">parent_class</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Modules</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">element_class</span> <span class="ow">is</span> <span class="n">Modules</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">element_class</span>
<span class="go">False</span>
</pre></div>
</div>
<p>For a more subtle example, one could possibly share the classes for
<code class="docutils literal"><span class="pre">GF(3)</span></code> and <code class="docutils literal"><span class="pre">GF(2^3,</span> <span class="pre">'x')</span></code>, but this is not currently the case:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Modules</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">parent_class</span> <span class="ow">is</span> <span class="n">Modules</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">3</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">parent_class</span>
<span class="go">False</span>
</pre></div>
</div>
<p>This is because those two fields do not have the exact same category:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Join of Category of finite enumerated fields</span>
<span class="go"> and Category of subquotients of monoids</span>
<span class="go"> and Category of quotients of semigroups</span>
<span class="gp">sage: </span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">3</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of finite enumerated fields</span>
</pre></div>
</div>
<p>Similarly for <code class="docutils literal"><span class="pre">QQ</span></code> and <code class="docutils literal"><span class="pre">RR</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QQ</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Join of Category of quotient fields and Category of metric spaces</span>
<span class="gp">sage: </span><span class="n">RR</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Join of Category of fields and Category of complete metric spaces</span>
<span class="gp">sage: </span><span class="n">Modules</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">parent_class</span> <span class="ow">is</span> <span class="n">Modules</span><span class="p">(</span><span class="n">RR</span><span class="p">)</span><span class="o">.</span><span class="n">parent_class</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Some other cases where one could potentially share those classes:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Modules</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">dispatch</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">parent_class</span>  <span class="ow">is</span> <span class="n">Modules</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">parent_class</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Modules</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">dispatch</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">element_class</span> <span class="ow">is</span> <span class="n">Modules</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">element_class</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.categories.category.JoinCategory">
<em class="property">class </em><code class="descclassname">sage.categories.category.</code><code class="descname">JoinCategory</code><span class="sig-paren">(</span><em>super_categories</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.JoinCategory" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.category.CategoryWithParameters" title="sage.categories.category.CategoryWithParameters"><code class="xref py py-class docutils literal"><span class="pre">sage.categories.category.CategoryWithParameters</span></code></a></p>
<p>A class for joins of several categories. Do not use directly;
see Category.join instead.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.category</span> <span class="kn">import</span> <span class="n">JoinCategory</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">JoinCategory</span><span class="p">((</span><span class="n">Groups</span><span class="p">(),</span> <span class="n">CommutativeAdditiveMonoids</span><span class="p">()));</span> <span class="n">J</span>
<span class="go">Join of Category of groups and Category of commutative additive monoids</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of groups, Category of commutative additive monoids]</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">all_super_categories</span><span class="p">(</span><span class="n">proper</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[Category of groups, ..., Category of magmas,</span>
<span class="go"> Category of commutative additive monoids, ..., Category of additive magmas,</span>
<span class="go"> Category of sets, Category of sets with partial maps, Category of objects]</span>
</pre></div>
</div>
<p>By <a class="reference external" href="https://trac.sagemath.org/11935">trac ticket #11935</a>, join categories and categories over base rings
inherit from <a class="reference internal" href="#sage.categories.category.CategoryWithParameters" title="sage.categories.category.CategoryWithParameters"><code class="xref py py-class docutils literal"><span class="pre">CategoryWithParameters</span></code></a>. This allows for
sharing parent and element classes between similar categories. For
example, since group algebras belong to a join category and since
the underlying implementation is the same for all finite fields,
we have:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">SymmetricGroup</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A3</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">algebra</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">A5</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">algebra</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">A3</span><span class="o">.</span><span class="n">category</span><span class="p">())</span>
<span class="go">&lt;class &#39;sage.categories.category.JoinCategory_with_category&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">A3</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">A5</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.categories.category.JoinCategory._repr_object_names">
<code class="descname">_repr_object_names</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.JoinCategory._repr_object_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the objects of this category.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.categories.category.Category._repr_object_names" title="sage.categories.category.Category._repr_object_names"><code class="xref py py-meth docutils literal"><span class="pre">Category._repr_object_names()</span></code></a>, <a class="reference internal" href="#sage.categories.category.JoinCategory._repr_" title="sage.categories.category.JoinCategory._repr_"><code class="xref py py-meth docutils literal"><span class="pre">_repr_()</span></code></a>, <a class="reference internal" href="#sage.categories.category.JoinCategory._without_axioms" title="sage.categories.category.JoinCategory._without_axioms"><code class="xref py py-meth docutils literal"><span class="pre">_without_axioms()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Groups</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span><span class="o">.</span><span class="n">Commutative</span><span class="p">()</span><span class="o">.</span><span class="n">_repr_</span><span class="p">(</span><span class="n">as_join</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">&#39;Join of Category of finite groups and Category of commutative groups&#39;</span>
<span class="gp">sage: </span><span class="n">Groups</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span><span class="o">.</span><span class="n">Commutative</span><span class="p">()</span><span class="o">.</span><span class="n">_repr_object_names</span><span class="p">()</span>
<span class="go">&#39;finite commutative groups&#39;</span>
</pre></div>
</div>
<p>This uses <a class="reference internal" href="#sage.categories.category.JoinCategory._without_axioms" title="sage.categories.category.JoinCategory._without_axioms"><code class="xref py py-meth docutils literal"><span class="pre">_without_axioms()</span></code></a> which may fail if this
category is not obtained by adjoining axioms to some super
categories:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">Groups</span><span class="p">(),</span> <span class="n">CommutativeAdditiveMonoids</span><span class="p">()))</span><span class="o">.</span><span class="n">_repr_object_names</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">This join category isn&#39;t built by adding axioms to a single category</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.JoinCategory._repr_">
<code class="descname">_repr_</code><span class="sig-paren">(</span><em>as_join=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.JoinCategory._repr_" title="Permalink to this definition">¶</a></dt>
<dd><p>Print representation.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">as_join</span></code> &#8211; a boolean (default: False)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">Groups</span><span class="p">(),</span> <span class="n">CommutativeAdditiveMonoids</span><span class="p">()))</span> <span class="c1">#indirect doctest</span>
<span class="go">Join of Category of groups and Category of commutative additive monoids</span>
</pre></div>
</div>
<p>By default, when a join category is built from category by
adjoining axioms, a nice name is printed out:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Groups</span><span class="p">()</span><span class="o">.</span><span class="n">Facade</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span>
<span class="go">Category of facade finite groups</span>
</pre></div>
</div>
<p>But this is in fact really a join category:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Groups</span><span class="p">()</span><span class="o">.</span><span class="n">Facade</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span><span class="o">.</span><span class="n">_repr_</span><span class="p">(</span><span class="n">as_join</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="go">&#39;Join of Category of finite groups and Category of facade sets&#39;</span>
</pre></div>
</div>
<p>The rationale is to make it more readable, and hide the
technical details of how this category is constructed
internally, especially since this construction is likely to
change over time when new axiom categories are implemented.</p>
<p>This join category may possibly be obtained by adding axioms
to different categories; so the result is not guaranteed to be
unique; when this is not the case the first found is used.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.categories.category.Category._repr_" title="sage.categories.category.Category._repr_"><code class="xref py py-meth docutils literal"><span class="pre">Category._repr_()</span></code></a>, <a class="reference internal" href="#sage.categories.category.JoinCategory._repr_object_names" title="sage.categories.category.JoinCategory._repr_object_names"><code class="xref py py-meth docutils literal"><span class="pre">_repr_object_names()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.JoinCategory._without_axioms">
<code class="descname">_without_axioms</code><span class="sig-paren">(</span><em>named=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.JoinCategory._without_axioms" title="Permalink to this definition">¶</a></dt>
<dd><p>When adjoining axioms to a category, one often gets a join
category; this method tries to recover the original
category from this join category.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">named</span></code> &#8211; a boolean (default: <code class="docutils literal"><span class="pre">False</span></code>)</li>
</ul>
<p>See <a class="reference internal" href="#sage.categories.category.Category._without_axioms" title="sage.categories.category.Category._without_axioms"><code class="xref py py-meth docutils literal"><span class="pre">Category._without_axioms()</span></code></a> for the description
of the <code class="docutils literal"><span class="pre">named</span></code> parameter.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">Monoids</span><span class="p">(),</span> <span class="n">Posets</span><span class="p">()])</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">_repr_</span><span class="p">(</span><span class="n">as_join</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">&#39;Join of Category of finite monoids and Category of finite posets&#39;</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">_without_axioms</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">This join category isn&#39;t built by adding axioms to a single category</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Monoids</span><span class="p">()</span><span class="o">.</span><span class="n">Infinite</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">_repr_</span><span class="p">(</span><span class="n">as_join</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">&#39;Join of Category of monoids and Category of infinite sets&#39;</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">_without_axioms</span><span class="p">()</span>
<span class="go">Category of magmas</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">_without_axioms</span><span class="p">(</span><span class="n">named</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Category of monoids</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.JoinCategory.additional_structure">
<code class="descname">additional_structure</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.JoinCategory.additional_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">None</span></code>.</p>
<p>Indeed, a join category defines no additional structure.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.categories.category.Category.additional_structure" title="sage.categories.category.Category.additional_structure"><code class="xref py py-meth docutils literal"><span class="pre">Category.additional_structure()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Modules</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">additional_structure</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.JoinCategory.is_subcategory">
<code class="descname">is_subcategory</code><span class="sig-paren">(</span><em>C</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.JoinCategory.is_subcategory" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether this join category is subcategory of another
category <code class="docutils literal"><span class="pre">C</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">Rings</span><span class="p">(),</span><span class="n">Modules</span><span class="p">(</span><span class="n">QQ</span><span class="p">)])</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="n">Category</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">Rngs</span><span class="p">(),</span><span class="n">Bimodules</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span><span class="n">QQ</span><span class="p">)]))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.category.JoinCategory.super_categories">
<code class="descname">super_categories</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.JoinCategory.super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the immediate super categories, as per <a class="reference internal" href="#sage.categories.category.Category.super_categories" title="sage.categories.category.Category.super_categories"><code class="xref py py-meth docutils literal"><span class="pre">Category.super_categories()</span></code></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.category</span> <span class="kn">import</span> <span class="n">JoinCategory</span>
<span class="gp">sage: </span><span class="n">JoinCategory</span><span class="p">((</span><span class="n">Semigroups</span><span class="p">(),</span> <span class="n">FiniteEnumeratedSets</span><span class="p">()))</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of semigroups, Category of finite enumerated sets]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.categories.category.category_graph">
<code class="descclassname">sage.categories.category.</code><code class="descname">category_graph</code><span class="sig-paren">(</span><em>categories=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.category_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the graph of the categories in Sage.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">categories</span></code> &#8211; a list (or iterable) of categories</li>
</ul>
<p>If <code class="docutils literal"><span class="pre">categories</span></code> is specified, then the graph contains the
mentioned categories together with all their super
categories. Otherwise the graph contains (an instance of) each
category in <code class="xref py py-mod docutils literal"><span class="pre">sage.categories.all</span></code> (e.g. <code class="docutils literal"><span class="pre">Algebras(QQ)</span></code> for
algebras).</p>
<p>For readability, the names of the category are shortened.</p>
<div class="admonition-todo admonition" id="index-3">
<p class="first admonition-title">Todo</p>
<p class="last">Further remove the base ring (see also <a class="reference external" href="https://trac.sagemath.org/15801">trac ticket #15801</a>).</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">category</span><span class="o">.</span><span class="n">category_graph</span><span class="p">(</span><span class="n">categories</span> <span class="o">=</span> <span class="p">[</span><span class="n">Groups</span><span class="p">()])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[&#39;groups&#39;, &#39;inverse unital magmas&#39;, &#39;magmas&#39;, &#39;monoids&#39;, &#39;objects&#39;,</span>
<span class="go"> &#39;semigroups&#39;, &#39;sets&#39;, &#39;sets with partial maps&#39;, &#39;unital magmas&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="go">Graphics object consisting of 20 graphics primitives</span>

<span class="gp">sage: </span><span class="n">sage</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">category</span><span class="o">.</span><span class="n">category_graph</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="go">Graphics object consisting of ... graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.categories.category.category_sample">
<code class="descclassname">sage.categories.category.</code><code class="descname">category_sample</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.category_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sample of categories.</p>
<p>It is constructed by looking for all concrete category classes declared in
<code class="docutils literal"><span class="pre">sage.categories.all</span></code>, calling <a class="reference internal" href="#sage.categories.category.Category.an_instance" title="sage.categories.category.Category.an_instance"><code class="xref py py-meth docutils literal"><span class="pre">Category.an_instance()</span></code></a> on those and
taking all their super categories.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.category</span> <span class="kn">import</span> <span class="n">category_sample</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">category_sample</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="go">[Category of G-sets for Symmetric group of order 8! as a permutation group,</span>
<span class="go"> Category of Hecke modules over Rational Field,</span>
<span class="go"> Category of Lie algebras over Rational Field,</span>
<span class="go"> Category of additive magmas, ...,</span>
<span class="go"> Category of fields, ...,</span>
<span class="go"> Category of graded hopf algebras with basis over Rational Field, ...,</span>
<span class="go"> Category of modular abelian varieties over Rational Field, ...,</span>
<span class="go"> Category of simplicial complexes, ...,</span>
<span class="go"> Category of vector spaces over Rational Field, ...,</span>
<span class="go"> Category of weyl groups, ...</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.categories.category.is_Category">
<code class="descclassname">sage.categories.category.</code><code class="descname">is_Category</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category.is_Category" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if x is a category.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">sage</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">category</span><span class="o">.</span><span class="n">is_Category</span><span class="p">(</span><span class="n">CommutativeAdditiveSemigroups</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">sage</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">category</span><span class="o">.</span><span class="n">is_Category</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <h4>Previous topic</h4>
            <p class="topless"><a href="primer.html"
                                  title="previous chapter">Elements, parents, and categories in Sage: a (draft of) primer</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="category_with_axiom.html"
                                  title="next chapter">Axioms</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../_sources/sage/categories/category.rst.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="category_with_axiom.html" title="Axioms"
             >next</a> |</li>
        <li class="right" >
          <a href="primer.html" title="Elements, parents, and categories in Sage: a (draft of) primer"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Category Framework</a> &#187;</li>
 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2017, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.3.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>