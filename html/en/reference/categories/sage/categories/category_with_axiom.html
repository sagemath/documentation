
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Axioms &#8212; Sage 9.5 Reference Manual: Category Framework</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sage.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <script data-url_root="../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script async="async" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Functors" href="functor.html" />
    <link rel="prev" title="Categories" href="category.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="functor.html" title="Functors"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="category.html" title="Categories"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Sage 9.5 Reference Manual: Category Framework</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">Axioms</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="axioms">
<span id="sage-categories-category-with-axiom"></span><h1>Axioms<a class="headerlink" href="#axioms" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.categories.category_with_axiom"></span><p>This documentation covers how to implement axioms and proceeds with an
overview of the implementation of the axiom infrastructure. It assumes
that the reader is familiar with the <a class="reference internal" href="primer.html#sage-categories-primer"><span class="std std-ref">category primer</span></a>, and in particular its <a class="reference internal" href="primer.html#category-primer-axioms"><span class="std std-ref">section about
axioms</span></a>.</p>
<section id="implementing-axioms">
<h2>Implementing axioms<a class="headerlink" href="#implementing-axioms" title="Permalink to this headline">¶</a></h2>
<section id="simple-case-involving-a-single-predefined-axiom">
<h3>Simple case involving a single predefined axiom<a class="headerlink" href="#simple-case-involving-a-single-predefined-axiom" title="Permalink to this headline">¶</a></h3>
<p>Suppose that one wants to provide code (and documentation, tests, …)
for the objects of some existing category <code class="docutils literal notranslate"><span class="pre">Cs()</span></code> that satisfy some
predefined axiom <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<p>The first step is to open the hood and check whether there already
exists a class implementing the category <code class="docutils literal notranslate"><span class="pre">Cs().A()</span></code>. For example,
taking <code class="docutils literal notranslate"><span class="pre">Cs=Semigroups</span></code> and the <code class="docutils literal notranslate"><span class="pre">Finite</span></code> axiom, there already
exists a class for the category of finite semigroups:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Semigroups</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span>
<span class="go">Category of finite semigroups</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">Semigroups</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">())</span>
<span class="go">&lt;class &#39;sage.categories.finite_semigroups.FiniteSemigroups_with_category&#39;&gt;</span>
</pre></div>
</div>
<p>In this case, we say that the category of semigroups <em>implements</em> the
axiom <code class="docutils literal notranslate"><span class="pre">Finite</span></code>, and code about finite semigroups should go in the
class <a class="reference internal" href="finite_semigroups.html#sage.categories.finite_semigroups.FiniteSemigroups" title="sage.categories.finite_semigroups.FiniteSemigroups"><code class="xref py py-class docutils literal notranslate"><span class="pre">FiniteSemigroups</span></code></a> (or, as usual, in its nested classes
<code class="docutils literal notranslate"><span class="pre">ParentMethods</span></code>, <code class="docutils literal notranslate"><span class="pre">ElementMethods</span></code>, and so on).</p>
<p>On the other hand, there is no class for the category of infinite
semigroups:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Semigroups</span><span class="p">()</span><span class="o">.</span><span class="n">Infinite</span><span class="p">()</span>
<span class="go">Category of infinite semigroups</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">Semigroups</span><span class="p">()</span><span class="o">.</span><span class="n">Infinite</span><span class="p">())</span>
<span class="go">&lt;class &#39;sage.categories.category.JoinCategory_with_category&#39;&gt;</span>
</pre></div>
</div>
<p>This category is indeed just constructed as the intersection of the
categories of semigroups and of infinite sets respectively:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Semigroups</span><span class="p">()</span><span class="o">.</span><span class="n">Infinite</span><span class="p">()</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of semigroups, Category of infinite sets]</span>
</pre></div>
</div>
<p>In this case, one needs to create a new class to implement the axiom
<code class="docutils literal notranslate"><span class="pre">Infinite</span></code> for this category. This boils down to adding a nested
class <code class="docutils literal notranslate"><span class="pre">Semigroups.Infinite</span></code> inheriting from <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom" title="sage.categories.category_with_axiom.CategoryWithAxiom"><code class="xref py py-class docutils literal notranslate"><span class="pre">CategoryWithAxiom</span></code></a>.</p>
<p>In the following example, we implement a category <code class="docutils literal notranslate"><span class="pre">Cs</span></code>, with a
subcategory for the objects satisfying the <code class="docutils literal notranslate"><span class="pre">Finite</span></code> axiom defined in
the super category <code class="docutils literal notranslate"><span class="pre">Sets</span></code> (we will see later on how to <em>define</em> new
axioms):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.category_with_axiom</span> <span class="kn">import</span> <span class="n">CategoryWithAxiom</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">Cs</span><span class="p">(</span><span class="n">Category</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="p">[</span><span class="n">Sets</span><span class="p">()]</span>
<span class="gp">....: </span>    <span class="k">class</span> <span class="nc">Finite</span><span class="p">(</span><span class="n">CategoryWithAxiom</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">class</span> <span class="nc">ParentMethods</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;I am a method on finite C&#39;s&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Cs</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span>
<span class="go">Category of finite cs</span>
<span class="gp">sage: </span><span class="n">Cs</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of finite sets, Category of cs]</span>
<span class="gp">sage: </span><span class="n">Cs</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span><span class="o">.</span><span class="n">all_super_categories</span><span class="p">()</span>
<span class="go">[Category of finite cs, Category of finite sets,</span>
<span class="go"> Category of cs, Category of sets, ...]</span>
<span class="gp">sage: </span><span class="n">Cs</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span><span class="o">.</span><span class="n">axioms</span><span class="p">()</span>
<span class="go">frozenset({&#39;Finite&#39;})</span>
</pre></div>
</div>
<p>Now a parent declared in the category <code class="docutils literal notranslate"><span class="pre">Cs().Finite()</span></code> inherits from
all the methods of finite sets and of finite <span class="math notranslate nohighlight">\(C\)</span>’s, as desired:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Parent</span><span class="p">(</span><span class="n">category</span><span class="o">=</span><span class="n">Cs</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_finite</span><span class="p">()</span>             <span class="c1"># Provided by Sets.Finite.ParentMethods</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">foo</span><span class="p">()</span>                   <span class="c1"># Provided by Cs.Finite.ParentMethods</span>
<span class="go">I am a method on finite C&#39;s</span>
</pre></div>
</div>
<div class="admonition note" id="category-with-axiom-design">
<p class="admonition-title">Note</p>
<ul>
<li><p>This follows the same idiom as for
<a class="reference internal" href="covariant_functorial_construction.html#sage-categories-covariant-functorial-construction"><span class="std std-ref">Covariant Functorial Constructions</span></a>.</p></li>
<li><p>From an object oriented point of view, any subcategory <code class="docutils literal notranslate"><span class="pre">Cs()</span></code>
of <a class="reference internal" href="sets_cat.html#sage.categories.sets_cat.Sets" title="sage.categories.sets_cat.Sets"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sets</span></code></a> inherits a <code class="docutils literal notranslate"><span class="pre">Finite</span></code> method.  Usually <code class="docutils literal notranslate"><span class="pre">Cs</span></code>
could complement this method by overriding it with a method
<code class="docutils literal notranslate"><span class="pre">Cs.Finite</span></code> which would make a super call to <code class="docutils literal notranslate"><span class="pre">Sets.Finite</span></code>
and then do extra stuff.</p>
<p>In the above example, <code class="docutils literal notranslate"><span class="pre">Cs</span></code> also wants to complement
<code class="docutils literal notranslate"><span class="pre">Sets.Finite</span></code>, though not by doing more stuff, but by
providing it with an additional mixin class containing the code
for finite <code class="docutils literal notranslate"><span class="pre">Cs</span></code>. To keep the analogy, this mixin class is to
be put in <code class="docutils literal notranslate"><span class="pre">Cs.Finite</span></code>.</p>
</li>
<li><p>By defining the axiom <code class="docutils literal notranslate"><span class="pre">Finite</span></code>, <a class="reference internal" href="sets_cat.html#sage.categories.sets_cat.Sets" title="sage.categories.sets_cat.Sets"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sets</span></code></a> fixes the
semantic of <code class="docutils literal notranslate"><span class="pre">Cs.Finite()</span></code> for all its subcategories <code class="docutils literal notranslate"><span class="pre">Cs</span></code>:
namely “the category of <code class="docutils literal notranslate"><span class="pre">Cs</span></code> which are finite as sets”. Hence,
for example, <code class="docutils literal notranslate"><span class="pre">Modules.Free.Finite</span></code> cannot be used to model the
category of free modules of finite rank, even though their
traditional name “finite free modules” might suggest it.</p></li>
<li><p>It may come as a surprise that we can actually use the same name
<code class="docutils literal notranslate"><span class="pre">Finite</span></code> for the mixin class and for the method defining the
axiom; indeed, by default a class does not have a binding
behavior and would completely override the method. See the
section <a class="reference internal" href="#axioms-defining-a-new-axiom"><span class="std std-ref">Defining a new axiom</span></a> for details and the
rationale behind it.</p>
<p>An alternative would have been to give another name to the mixin
class, like <code class="docutils literal notranslate"><span class="pre">FiniteCategory</span></code>. However this would have resulted
in more namespace pollution, whereas using <code class="docutils literal notranslate"><span class="pre">Finite</span></code> is already
clear, explicit, and easier to remember.</p>
</li>
<li><p>Under the hood, the category <code class="docutils literal notranslate"><span class="pre">Cs().Finite()</span></code> is aware that it
has been constructed from the category <code class="docutils literal notranslate"><span class="pre">Cs()</span></code> by adding the
axiom <code class="docutils literal notranslate"><span class="pre">Finite</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Cs</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span><span class="o">.</span><span class="n">base_category</span><span class="p">()</span>
<span class="go">Category of cs</span>
<span class="gp">sage: </span><span class="n">Cs</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span><span class="o">.</span><span class="n">_axiom</span>
<span class="go">&#39;Finite&#39;</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>Over time, the nested class <code class="docutils literal notranslate"><span class="pre">Cs.Finite</span></code> may become large and too
cumbersome to keep as a nested subclass of <code class="docutils literal notranslate"><span class="pre">Cs</span></code>. Or the category with
axiom may have a name of its own in the literature, like <em>semigroups</em>
rather than <em>associative magmas</em>, or <em>fields</em> rather than <em>commutative
division rings</em>. In this case, the category with axiom can be put
elsewhere, typically in a separate file, with just a link from
<code class="docutils literal notranslate"><span class="pre">Cs</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">Cs</span><span class="p">(</span><span class="n">Category</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="p">[</span><span class="n">Sets</span><span class="p">()]</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">FiniteCs</span><span class="p">(</span><span class="n">CategoryWithAxiom</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">class</span> <span class="nc">ParentMethods</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;I am a method on finite C&#39;s&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Cs</span><span class="o">.</span><span class="n">Finite</span> <span class="o">=</span> <span class="n">FiniteCs</span>
<span class="gp">sage: </span><span class="n">Cs</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span>
<span class="go">Category of finite cs</span>
</pre></div>
</div>
<p>For a real example, see the code of the class <a class="reference internal" href="finite_groups.html#sage.categories.finite_groups.FiniteGroups" title="sage.categories.finite_groups.FiniteGroups"><code class="xref py py-class docutils literal notranslate"><span class="pre">FiniteGroups</span></code></a> and the
link to it in <a class="reference internal" href="groups.html#sage.categories.groups.Groups" title="sage.categories.groups.Groups"><code class="xref py py-class docutils literal notranslate"><span class="pre">Groups</span></code></a>. Note that the link is implemented using
<a class="reference external" href="../../../misc/sage/misc/lazy_import.html#sage.misc.lazy_import.LazyImport" title="(in Sage 9.5 Reference Manual: Utilities v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyImport</span></code></a>; this is highly recommended: it
makes sure that <a class="reference internal" href="finite_groups.html#sage.categories.finite_groups.FiniteGroups" title="sage.categories.finite_groups.FiniteGroups"><code class="xref py py-class docutils literal notranslate"><span class="pre">FiniteGroups</span></code></a> is imported after <a class="reference internal" href="groups.html#sage.categories.groups.Groups" title="sage.categories.groups.Groups"><code class="xref py py-class docutils literal notranslate"><span class="pre">Groups</span></code></a> it
depends upon, and makes it explicit that the class <a class="reference internal" href="groups.html#sage.categories.groups.Groups" title="sage.categories.groups.Groups"><code class="xref py py-class docutils literal notranslate"><span class="pre">Groups</span></code></a> can be
imported and is fully functional without importing <a class="reference internal" href="finite_groups.html#sage.categories.finite_groups.FiniteGroups" title="sage.categories.finite_groups.FiniteGroups"><code class="xref py py-class docutils literal notranslate"><span class="pre">FiniteGroups</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Some categories with axioms are created upon Sage’s startup. In such a
case, one needs to pass the <code class="docutils literal notranslate"><span class="pre">at_startup=True</span></code> option to
<a class="reference external" href="../../../misc/sage/misc/lazy_import.html#sage.misc.lazy_import.LazyImport" title="(in Sage 9.5 Reference Manual: Utilities v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyImport</span></code></a>, in order to quiet the warning
about that lazy import being resolved upon startup. See for example
<code class="docutils literal notranslate"><span class="pre">Sets.Finite</span></code>.</p>
<p>This is undoubtedly a code smell. Nevertheless, it is preferable
to stick to lazy imports, first to resolve the import order
properly, and more importantly as a reminder that the category
would be best not constructed upon Sage’s startup. This is to spur
developers to reduce the number of parents (and therefore
categories) that are constructed upon startup. Each
<code class="docutils literal notranslate"><span class="pre">at_startup=True</span></code> that will be removed will be a measure of
progress in this direction.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In principle, due to a limitation of
<a class="reference external" href="../../../misc/sage/misc/lazy_import.html#sage.misc.lazy_import.LazyImport" title="(in Sage 9.5 Reference Manual: Utilities v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyImport</span></code></a> with nested classes (see
<a class="reference external" href="https://trac.sagemath.org/15648">trac ticket #15648</a>), one should pass the option <code class="docutils literal notranslate"><span class="pre">as_name</span></code> to
<a class="reference external" href="../../../misc/sage/misc/lazy_import.html#sage.misc.lazy_import.LazyImport" title="(in Sage 9.5 Reference Manual: Utilities v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyImport</span></code></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">Finite = LazyImport(&#39;sage.categories.finite_groups&#39;, &#39;FiniteGroups&#39;, as_name=&#39;Finite&#39;)</span>
</pre></div>
</div>
<p>in order to prevent <code class="docutils literal notranslate"><span class="pre">Groups.Finite</span></code> to keep on reimporting
<code class="docutils literal notranslate"><span class="pre">FiniteGroups</span></code>.</p>
<p>Given that passing this option introduces some redundancy and is
error prone, the axiom infrastructure includes a little workaround
which makes the <code class="docutils literal notranslate"><span class="pre">as_name</span></code> unnecessary in this case.</p>
</div>
<section id="making-the-category-with-axiom-directly-callable">
<h4>Making the category with axiom directly callable<a class="headerlink" href="#making-the-category-with-axiom-directly-callable" title="Permalink to this headline">¶</a></h4>
<p>If desired, a category with axiom can be constructed directly through
its class rather than through its base category:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Semigroups</span><span class="p">()</span>
<span class="go">Category of semigroups</span>
<span class="gp">sage: </span><span class="n">Semigroups</span><span class="p">()</span> <span class="ow">is</span> <span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Associative</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">FiniteGroups</span><span class="p">()</span>
<span class="go">Category of finite groups</span>
<span class="gp">sage: </span><span class="n">FiniteGroups</span><span class="p">()</span> <span class="ow">is</span> <span class="n">Groups</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>For this notation to work, the class <a class="reference internal" href="semigroups.html#sage.categories.semigroups.Semigroups" title="sage.categories.semigroups.Semigroups"><code class="xref py py-class docutils literal notranslate"><span class="pre">Semigroups</span></code></a> needs to be
aware of the base category class (here, <a class="reference internal" href="magmas.html#sage.categories.magmas.Magmas" title="sage.categories.magmas.Magmas"><code class="xref py py-class docutils literal notranslate"><span class="pre">Magmas</span></code></a>) and of the
axiom (here, <code class="docutils literal notranslate"><span class="pre">Associative</span></code>):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Semigroups</span><span class="o">.</span><span class="n">_base_category_class_and_axiom</span>
<span class="go">(&lt;class &#39;sage.categories.magmas.Magmas&#39;&gt;, &#39;Associative&#39;)</span>
<span class="gp">sage: </span><span class="n">Fields</span><span class="o">.</span><span class="n">_base_category_class_and_axiom</span>
<span class="go">(&lt;class &#39;sage.categories.division_rings.DivisionRings&#39;&gt;, &#39;Commutative&#39;)</span>
<span class="gp">sage: </span><span class="n">FiniteGroups</span><span class="o">.</span><span class="n">_base_category_class_and_axiom</span>
<span class="go">(&lt;class &#39;sage.categories.groups.Groups&#39;&gt;, &#39;Finite&#39;)</span>
<span class="gp">sage: </span><span class="n">FiniteDimensionalAlgebrasWithBasis</span><span class="o">.</span><span class="n">_base_category_class_and_axiom</span>
<span class="go">(&lt;class &#39;sage.categories.algebras_with_basis.AlgebrasWithBasis&#39;&gt;, &#39;FiniteDimensional&#39;)</span>
</pre></div>
</div>
<p>In our example, the attribute <code class="docutils literal notranslate"><span class="pre">_base_category_class_and_axiom</span></code> was
set upon calling <code class="docutils literal notranslate"><span class="pre">Cs().Finite()</span></code>, which makes the notation seemingly
work:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FiniteCs</span><span class="p">()</span>
<span class="go">Category of finite cs</span>
<span class="gp">sage: </span><span class="n">FiniteCs</span><span class="o">.</span><span class="n">_base_category_class_and_axiom</span>
<span class="go">(&lt;class &#39;__main__.Cs&#39;&gt;, &#39;Finite&#39;)</span>
<span class="gp">sage: </span><span class="n">FiniteCs</span><span class="o">.</span><span class="n">_base_category_class_and_axiom_origin</span>
<span class="go">&#39;set by __classget__&#39;</span>
</pre></div>
</div>
<p>But calling <code class="docutils literal notranslate"><span class="pre">FiniteCs()</span></code> right after defining the class would have
failed (try it!). In general, one needs to set the attribute explicitly:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">FiniteCs</span><span class="p">(</span><span class="n">CategoryWithAxiom</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">_base_category_class_and_axiom</span> <span class="o">=</span> <span class="p">(</span><span class="n">Cs</span><span class="p">,</span> <span class="s1">&#39;Finite&#39;</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">class</span> <span class="nc">ParentMethods</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;I am a method on finite C&#39;s&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Having to set explicitly this link back from <code class="docutils literal notranslate"><span class="pre">FiniteCs</span></code> to <code class="docutils literal notranslate"><span class="pre">Cs</span></code>
introduces redundancy in the code. It would therefore be desirable to
have the infrastructure set the link automatically instead (a
difficulty is to achieve this while supporting lazy imported
categories with axiom).</p>
<p>As a first step, the link is set automatically upon accessing the
class from the base category class:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Algebras</span><span class="o">.</span><span class="n">WithBasis</span><span class="o">.</span><span class="n">_base_category_class_and_axiom</span>
<span class="go">(&lt;class &#39;sage.categories.algebras.Algebras&#39;&gt;, &#39;WithBasis&#39;)</span>
<span class="gp">sage: </span><span class="n">Algebras</span><span class="o">.</span><span class="n">WithBasis</span><span class="o">.</span><span class="n">_base_category_class_and_axiom_origin</span>
<span class="go">&#39;set by __classget__&#39;</span>
</pre></div>
</div>
<p>Hence, for whatever this notation is worth, one can currently do:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Algebras</span><span class="o">.</span><span class="n">WithBasis</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">Category of algebras with basis over Rational Field</span>
</pre></div>
</div>
<p>We don’t recommend using syntax like <code class="docutils literal notranslate"><span class="pre">Algebras.WithBasis(QQ)</span></code>, as it
may eventually be deprecated.</p>
<p>As a second step, Sage tries some obvious heuristics to deduce the link
from the name of the category with axiom (see
<a class="reference internal" href="#sage.categories.category_with_axiom.base_category_class_and_axiom" title="sage.categories.category_with_axiom.base_category_class_and_axiom"><code class="xref py py-func docutils literal notranslate"><span class="pre">base_category_class_and_axiom()</span></code></a> for the details). This typically
covers the following examples:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FiniteCoxeterGroups</span><span class="p">()</span>
<span class="go">Category of finite coxeter groups</span>
<span class="gp">sage: </span><span class="n">FiniteCoxeterGroups</span><span class="p">()</span> <span class="ow">is</span> <span class="n">CoxeterGroups</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">FiniteCoxeterGroups</span><span class="o">.</span><span class="n">_base_category_class_and_axiom_origin</span>
<span class="go">&#39;deduced by base_category_class_and_axiom&#39;</span>

<span class="gp">sage: </span><span class="n">FiniteDimensionalAlgebrasWithBasis</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">Category of finite dimensional algebras with basis over Rational Field</span>
<span class="gp">sage: </span><span class="n">FiniteDimensionalAlgebrasWithBasis</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">FiniteDimensional</span><span class="p">()</span><span class="o">.</span><span class="n">WithBasis</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If the heuristic succeeds, the result is guaranteed to be correct. If
it fails, typically because the category has a name of its own like
<a class="reference internal" href="fields.html#sage.categories.fields.Fields" title="sage.categories.fields.Fields"><code class="xref py py-class docutils literal notranslate"><span class="pre">Fields</span></code></a>, the attribute <code class="docutils literal notranslate"><span class="pre">_base_category_class_and_axiom</span></code>
should be set explicitly. For more examples, see the code of the
classes <a class="reference internal" href="semigroups.html#sage.categories.semigroups.Semigroups" title="sage.categories.semigroups.Semigroups"><code class="xref py py-class docutils literal notranslate"><span class="pre">Semigroups</span></code></a> or <a class="reference internal" href="fields.html#sage.categories.fields.Fields" title="sage.categories.fields.Fields"><code class="xref py py-class docutils literal notranslate"><span class="pre">Fields</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When printing out a category with axiom, the heuristic determines
whether a category has a name of its own by checking out how
<code class="docutils literal notranslate"><span class="pre">_base_category_class_and_axiom</span></code> was set:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Fields</span><span class="o">.</span><span class="n">_base_category_class_and_axiom_origin</span>
<span class="go">&#39;hardcoded&#39;</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom._without_axioms" title="sage.categories.category_with_axiom.CategoryWithAxiom._without_axioms"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CategoryWithAxiom._without_axioms()</span></code></a>,
<a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom._repr_object_names../_static" title="sage.categories.category_with_axiom.CategoryWithAxiom._repr_object_names_static"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CategoryWithAxiom._repr_object_names_static()</span></code></a>.</p>
</div>
<p>In our running example <code class="docutils literal notranslate"><span class="pre">FiniteCs</span></code>, Sage failed to deduce
automatically the base category class and axiom because the class
<code class="docutils literal notranslate"><span class="pre">Cs</span></code> is not in the standard location <code class="docutils literal notranslate"><span class="pre">sage.categories.cs</span></code>.</p>
<div class="topic">
<p class="topic-title">Design discussion</p>
<p>The above deduction, based on names, is undoubtedly inelegant. But
it’s safe (either the result is guaranteed to be correct, or an
error is raised), it saves on some redundant information, and it
is only used for the simple shorthands like <code class="docutils literal notranslate"><span class="pre">FiniteGroups()</span></code> for
<code class="docutils literal notranslate"><span class="pre">Groups().Finite()</span></code>. Finally, most if not all of these
shorthands are likely to eventually disappear (see <a class="reference external" href="https://trac.sagemath.org/15741">trac ticket #15741</a>
and the <a class="reference internal" href="primer.html#category-primer-axioms-single-entry-point"><span class="std std-ref">related discussion in the primer</span></a>).</p>
</div>
</section>
</section>
<section id="defining-a-new-axiom">
<span id="axioms-defining-a-new-axiom"></span><h3>Defining a new axiom<a class="headerlink" href="#defining-a-new-axiom" title="Permalink to this headline">¶</a></h3>
<p>We describe now how to define a new axiom. The first step is to figure
out the largest category where the axiom makes sense. For example
<code class="docutils literal notranslate"><span class="pre">Sets</span></code> for <code class="docutils literal notranslate"><span class="pre">Finite</span></code>, <code class="docutils literal notranslate"><span class="pre">Magmas</span></code> for <code class="docutils literal notranslate"><span class="pre">Associative</span></code>, or
<code class="docutils literal notranslate"><span class="pre">Modules</span></code> for <code class="docutils literal notranslate"><span class="pre">FiniteDimensional</span></code>. Here we define the axiom
<code class="docutils literal notranslate"><span class="pre">Green</span></code> for the category <code class="docutils literal notranslate"><span class="pre">Cs</span></code> and its subcategories:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.category_with_axiom</span> <span class="kn">import</span> <span class="n">CategoryWithAxiom</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">Cs</span><span class="p">(</span><span class="n">Category</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="p">[</span><span class="n">Sets</span><span class="p">()]</span>
<span class="gp">....: </span>    <span class="k">class</span> <span class="nc">SubcategoryMethods</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="k">def</span> <span class="nf">Green</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>            <span class="s1">&#39;&lt;documentation of the axiom Green&gt;&#39;</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_with_axiom</span><span class="p">(</span><span class="s2">&quot;Green&quot;</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">class</span> <span class="nc">Green</span><span class="p">(</span><span class="n">CategoryWithAxiom</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">class</span> <span class="nc">ParentMethods</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;I am a method on green C&#39;s&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>With the current implementation, the name of the axiom must also be
added to a global container:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">all_axioms</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">category_with_axiom</span><span class="o">.</span><span class="n">all_axioms</span>
<span class="gp">sage: </span><span class="n">all_axioms</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;Green&quot;</span><span class="p">,)</span>
</pre></div>
</div>
<p>We can now use the axiom as usual:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Cs</span><span class="p">()</span><span class="o">.</span><span class="n">Green</span><span class="p">()</span>
<span class="go">Category of green cs</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Parent</span><span class="p">(</span><span class="n">category</span><span class="o">=</span><span class="n">Cs</span><span class="p">()</span><span class="o">.</span><span class="n">Green</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">foo</span><span class="p">()</span>
<span class="go">I am a method on green C&#39;s</span>
</pre></div>
</div>
<p>Compared with our first example, the only newcomer is the method
<code class="docutils literal notranslate"><span class="pre">.Green()</span></code> that can be used by any subcategory <code class="docutils literal notranslate"><span class="pre">Ds()</span></code> of <code class="docutils literal notranslate"><span class="pre">Cs()</span></code>
to add the axiom <code class="docutils literal notranslate"><span class="pre">Green</span></code>. Note that the expression <code class="docutils literal notranslate"><span class="pre">Ds().Green</span></code>
always evaluates to this method, regardless of whether <code class="docutils literal notranslate"><span class="pre">Ds</span></code> has a
nested class <code class="docutils literal notranslate"><span class="pre">Ds.Green</span></code> or not (an implementation detail):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Cs</span><span class="p">()</span><span class="o">.</span><span class="n">Green</span>
<span class="go">&lt;bound method Cs.SubcategoryMethods.Green of Category of cs&gt;</span>
</pre></div>
</div>
<p>Thanks to this feature (implemented in <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom.__classget__" title="sage.categories.category_with_axiom.CategoryWithAxiom.__classget__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CategoryWithAxiom.__classget__()</span></code></a>),
the user is systematically referred to the documentation of this
method when doing introspection on <code class="docutils literal notranslate"><span class="pre">Ds().Green</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Cs</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">Green</span><span class="err">?</span>             <span class="c1"># not tested</span>
<span class="gp">sage: </span><span class="n">Cs</span><span class="p">()</span><span class="o">.</span><span class="n">Green</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="go">&#39;&lt;documentation of the axiom Green&gt;&#39;</span>
</pre></div>
</div>
<p>It is therefore the natural spot for the documentation of the axiom.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The presence of the nested class <code class="docutils literal notranslate"><span class="pre">Green</span></code> in <code class="docutils literal notranslate"><span class="pre">Cs</span></code> is currently
mandatory even if it is empty.</p>
</div>
<div class="admonition-todo admonition" id="id1">
<p class="admonition-title">Todo</p>
<p>Specify whether or not one should systematically use
&#64;cached_method in the definition of the axiom. And make sure all
the definition of axioms in Sage are consistent in this respect!</p>
</div>
<div class="admonition-todo admonition" id="id2">
<p class="admonition-title">Todo</p>
<p>We could possibly define an &#64;axiom decorator? This could hide two
little implementation details: whether or not to make the method a
cached method, and the call to _with_axiom(…) under the hood. It
could do possibly do some more magic. The gain is not obvious though.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">all_axioms</span></code> is only used marginally, for sanity checks and when
trying to derive automatically the base category class. The order
of the axioms in this tuple also controls the order in which they
appear when printing out categories with axioms (see
<a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom._repr_object_names../_static" title="sage.categories.category_with_axiom.CategoryWithAxiom._repr_object_names_static"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CategoryWithAxiom._repr_object_names_static()</span></code></a>).</p>
<p>During a Sage session, new axioms should only be added at the <em>end</em>
of <code class="docutils literal notranslate"><span class="pre">all_axioms</span></code>, as above, so as to not break the cache of
<code class="xref py py-func docutils literal notranslate"><span class="pre">axioms_rank()</span></code>. Otherwise, they can be inserted statically
anywhere in the tuple. For axioms defined within the Sage library,
the name is best inserted by editing directly the definition of
<code class="docutils literal notranslate"><span class="pre">all_axioms</span></code> in <a class="reference internal" href="#module-sage.categories.category_with_axiom" title="sage.categories.category_with_axiom"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.categories.category_with_axiom</span></code></a>.</p>
</div>
<div class="topic">
<p class="topic-title">Design note</p>
<p>Let us state again that, unlike what the existence of
<code class="docutils literal notranslate"><span class="pre">all_axioms</span></code> might suggest, the definition of an axiom is local
to a category and its subcategories. In particular, two
independent categories <code class="docutils literal notranslate"><span class="pre">Cs()</span></code> and <code class="docutils literal notranslate"><span class="pre">Ds()</span></code> can very well define
axioms with the same name and different semantics. As long as the
two hierarchies of subcategories don’t intersect, this is not a
problem. And if they do intersect naturally (that is if one is
likely to create a parent belonging to both categories), this
probably means that the categories <code class="docutils literal notranslate"><span class="pre">Cs</span></code> and <code class="docutils literal notranslate"><span class="pre">Ds</span></code> are about
related enough areas of mathematics that one should clear the
ambiguity by having either the same semantic or different names.</p>
<p>This caveat is no different from that of name clashes in hierarchy
of classes involving multiple inheritance.</p>
</div>
<div class="admonition-todo admonition" id="id3">
<p class="admonition-title">Todo</p>
<p>Explore ways to get rid of this global <code class="docutils literal notranslate"><span class="pre">all_axioms</span></code> tuple,
and/or have automatic registration there, and/or having a
register_axiom(…) method.</p>
</div>
<section id="special-case-defining-an-axiom-depending-on-several-categories">
<h4>Special case: defining an axiom depending on several categories<a class="headerlink" href="#special-case-defining-an-axiom-depending-on-several-categories" title="Permalink to this headline">¶</a></h4>
<p>In some cases, the largest category where the axiom makes sense is the
intersection of two categories. This is typically the case for axioms
specifying compatibility conditions between two otherwise unrelated
operations, like <code class="docutils literal notranslate"><span class="pre">Distributive</span></code> which specifies a compatibility
between <span class="math notranslate nohighlight">\(*\)</span> and <span class="math notranslate nohighlight">\(+\)</span>. Ideally, we would want the <code class="docutils literal notranslate"><span class="pre">Distributive</span></code> axiom
to be defined by:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Magmas</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">AdditiveMagmas</span><span class="p">()</span>
<span class="go">Join of Category of magmas and Category of additive magmas</span>
</pre></div>
</div>
<p>The current infrastructure does not support this perfectly: indeed,
defining an axiom for a category <span class="math notranslate nohighlight">\(C\)</span> requires <span class="math notranslate nohighlight">\(C\)</span> to have a class of
its own; hence a <a class="reference internal" href="category.html#sage.categories.category.JoinCategory" title="sage.categories.category.JoinCategory"><code class="xref py py-class docutils literal notranslate"><span class="pre">JoinCategory</span></code></a> as above won’t do;
we need to implement a new class like
<a class="reference internal" href="magmas_and_additive_magmas.html#sage.categories.magmas_and_additive_magmas.MagmasAndAdditiveMagmas" title="sage.categories.magmas_and_additive_magmas.MagmasAndAdditiveMagmas"><code class="xref py py-class docutils literal notranslate"><span class="pre">MagmasAndAdditiveMagmas</span></code></a>;
furthermore, we cannot yet model the fact that <code class="docutils literal notranslate"><span class="pre">MagmasAndAdditiveMagmas()</span></code>
<em>is</em> the intersection of <code class="docutils literal notranslate"><span class="pre">Magmas()</span></code> and <code class="docutils literal notranslate"><span class="pre">AdditiveMagmas()</span></code> rather than a
mere subcategory:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.magmas_and_additive_magmas</span> <span class="kn">import</span> <span class="n">MagmasAndAdditiveMagmas</span>
<span class="gp">sage: </span><span class="n">Magmas</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">AdditiveMagmas</span><span class="p">()</span> <span class="ow">is</span> <span class="n">MagmasAndAdditiveMagmas</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Magmas</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">AdditiveMagmas</span><span class="p">()</span>             <span class="c1"># todo: not implemented</span>
<span class="go">Category of magmas and additive magmas</span>
</pre></div>
</div>
<p>Still, there is a workaround to get the natural notations:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">Magmas</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">AdditiveMagmas</span><span class="p">())</span><span class="o">.</span><span class="n">Distributive</span><span class="p">()</span>
<span class="go">Category of distributive magmas and additive magmas</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Monoids</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">CommutativeAdditiveGroups</span><span class="p">())</span><span class="o">.</span><span class="n">Distributive</span><span class="p">()</span>
<span class="go">Category of rings</span>
</pre></div>
</div>
<p>The trick is to define <code class="docutils literal notranslate"><span class="pre">Distributive</span></code> as usual in
<a class="reference internal" href="magmas_and_additive_magmas.html#sage.categories.magmas_and_additive_magmas.MagmasAndAdditiveMagmas" title="sage.categories.magmas_and_additive_magmas.MagmasAndAdditiveMagmas"><code class="xref py py-class docutils literal notranslate"><span class="pre">MagmasAndAdditiveMagmas</span></code></a>, and to
add a method <a class="reference internal" href="magmas.html#sage.categories.magmas.Magmas.SubcategoryMethods.Distributive" title="sage.categories.magmas.Magmas.SubcategoryMethods.Distributive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Magmas.SubcategoryMethods.Distributive()</span></code></a> which
checks that <code class="docutils literal notranslate"><span class="pre">self</span></code> is a subcategory of both <code class="docutils literal notranslate"><span class="pre">Magmas()</span></code> and
<code class="docutils literal notranslate"><span class="pre">AdditiveMagmas()</span></code>, complains if not, and otherwise takes the
intersection of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">MagmasAndAdditiveMagmas()</span></code> before
calling <code class="docutils literal notranslate"><span class="pre">Distributive</span></code>.</p>
<p>The downsides of this workaround are:</p>
<ul>
<li><p>Creation of an otherwise empty class
<a class="reference internal" href="magmas_and_additive_magmas.html#sage.categories.magmas_and_additive_magmas.MagmasAndAdditiveMagmas" title="sage.categories.magmas_and_additive_magmas.MagmasAndAdditiveMagmas"><code class="xref py py-class docutils literal notranslate"><span class="pre">MagmasAndAdditiveMagmas</span></code></a>.</p></li>
<li><p>Pollution of the namespace of <code class="docutils literal notranslate"><span class="pre">Magmas()</span></code> (and subcategories like
<code class="docutils literal notranslate"><span class="pre">Groups()</span></code>) with a method that is irrelevant (but safely complains
if called).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">C._with_axiom('Distributive')</span></code> is not strictly equivalent to
<code class="docutils literal notranslate"><span class="pre">C.Distributive()</span></code>, which can be unpleasantly surprising:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">Monoids</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">CommutativeAdditiveGroups</span><span class="p">())</span><span class="o">.</span><span class="n">Distributive</span><span class="p">()</span>
<span class="go">Category of rings</span>

<span class="gp">sage: </span><span class="p">(</span><span class="n">Monoids</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">CommutativeAdditiveGroups</span><span class="p">())</span><span class="o">.</span><span class="n">_with_axiom</span><span class="p">(</span><span class="s1">&#39;Distributive&#39;</span><span class="p">)</span>
<span class="go">Join of Category of monoids and Category of commutative additive groups</span>
</pre></div>
</div>
</li>
</ul>
<div class="admonition-todo admonition" id="id4">
<p class="admonition-title">Todo</p>
<p>Other categories that would be better implemented via an axiom
depending on a join category include:</p>
<ul class="simple">
<li><p><a class="reference internal" href="algebras.html#sage.categories.algebras.Algebras" title="sage.categories.algebras.Algebras"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algebras</span></code></a>: defining an associative unital algebra as a
ring and a module satisfying the suitable compatibility axiom
between inner multiplication and multiplication by scalars
(bilinearity). Of course this should be implemented at the level
of <a class="reference internal" href="magmatic_algebras.html#sage.categories.magmatic_algebras.MagmaticAlgebras" title="sage.categories.magmatic_algebras.MagmaticAlgebras"><code class="xref py py-class docutils literal notranslate"><span class="pre">MagmaticAlgebras</span></code></a>, if not higher.</p></li>
<li><p><a class="reference internal" href="bialgebras.html#sage.categories.bialgebras.Bialgebras" title="sage.categories.bialgebras.Bialgebras"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bialgebras</span></code></a>: defining an bialgebra as an algebra and
coalgebra where the coproduct is a morphism for the product.</p></li>
<li><p><a class="reference internal" href="bimodules.html#sage.categories.bimodules.Bimodules" title="sage.categories.bimodules.Bimodules"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bimodules</span></code></a>: defining a bimodule as a left and right
module where the two actions commute.</p></li>
</ul>
</div>
<div class="admonition-todo admonition" id="id5">
<p class="admonition-title">Todo</p>
<ul class="simple">
<li><p>Design and implement an idiom for the definition of an axiom by a join
category.</p></li>
<li><p>Or support more advanced joins, through some hook or registration
process to specify that a given category <em>is</em> the intersection of two
(or more) categories.</p></li>
<li><p>Or at least improve the above workaround to avoid the last issue; this
possibly could be achieved using a class <code class="docutils literal notranslate"><span class="pre">Magmas.Distributive</span></code> with a
bit of <code class="docutils literal notranslate"><span class="pre">__classcall__</span></code> magic.</p></li>
</ul>
</div>
</section>
</section>
<section id="handling-multiple-axioms-arborescence-structure-of-the-code">
<h3>Handling multiple axioms, arborescence structure of the code<a class="headerlink" href="#handling-multiple-axioms-arborescence-structure-of-the-code" title="Permalink to this headline">¶</a></h3>
<section id="prelude">
<h4>Prelude<a class="headerlink" href="#prelude" title="Permalink to this headline">¶</a></h4>
<p>Let us consider the category of magmas, together with two of its
axioms, namely <code class="docutils literal notranslate"><span class="pre">Associative</span></code> and <code class="docutils literal notranslate"><span class="pre">Unital</span></code>. An associative magma is
a <em>semigroup</em> and a unital semigroup is a <em>monoid</em>. We have also seen
that axioms commute:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Unital</span><span class="p">()</span>
<span class="go">Category of unital magmas</span>
<span class="gp">sage: </span><span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Associative</span><span class="p">()</span>
<span class="go">Category of semigroups</span>
<span class="gp">sage: </span><span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Associative</span><span class="p">()</span><span class="o">.</span><span class="n">Unital</span><span class="p">()</span>
<span class="go">Category of monoids</span>
<span class="gp">sage: </span><span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Unital</span><span class="p">()</span><span class="o">.</span><span class="n">Associative</span><span class="p">()</span>
<span class="go">Category of monoids</span>
</pre></div>
</div>
<p>At the level of the classes implementing these categories, the
following comes as a general naturalization of the previous section:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Magmas</span><span class="o">.</span><span class="n">Unital</span>
<span class="go">&lt;class &#39;sage.categories.magmas.Magmas.Unital&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">Magmas</span><span class="o">.</span><span class="n">Associative</span>
<span class="go">&lt;class &#39;sage.categories.semigroups.Semigroups&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">Magmas</span><span class="o">.</span><span class="n">Associative</span><span class="o">.</span><span class="n">Unital</span>
<span class="go">&lt;class &#39;sage.categories.monoids.Monoids&#39;&gt;</span>
</pre></div>
</div>
<p>However, the following may look suspicious at first:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Magmas</span><span class="o">.</span><span class="n">Unital</span><span class="o">.</span><span class="n">Associative</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">AttributeError: type object &#39;Magmas.Unital&#39; has no attribute &#39;Associative&#39;</span>
</pre></div>
</div>
<p>The purpose of this section is to explain the design of the code
layout and the rationale for this mismatch.</p>
</section>
<section id="abstract-model">
<h4>Abstract model<a class="headerlink" href="#abstract-model" title="Permalink to this headline">¶</a></h4>
<p>As we have seen in the <a class="reference internal" href="primer.html#category-primer-axioms-explosion"><span class="std std-ref">Primer</span></a>,
the objects of a category <code class="docutils literal notranslate"><span class="pre">Cs()</span></code> can usually satisfy, or not, many
different axioms. Out of all combinations of axioms, only a small
number are relevant in practice, in the sense that we actually want to
provide features for the objects satisfying these axioms.</p>
<p>Therefore, in the context of the category class <code class="docutils literal notranslate"><span class="pre">Cs</span></code>, we want to
provide the system with a collection <span class="math notranslate nohighlight">\((D_S)_{S\in \mathcal S}\)</span> where
each <span class="math notranslate nohighlight">\(S\)</span> is a subset of the axioms and the corresponding <span class="math notranslate nohighlight">\(D_S\)</span> is a
class for the subcategory of the objects of <code class="docutils literal notranslate"><span class="pre">Cs()</span></code> satisfying the
axioms in <span class="math notranslate nohighlight">\(S\)</span>. For example, if <code class="docutils literal notranslate"><span class="pre">Cs()</span></code> is the category of magmas, the
pairs <span class="math notranslate nohighlight">\((S, D_S)\)</span> would include:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">{Associative}                 : Semigroups</span>
<span class="go">{Associative, Unital}         : Monoids</span>
<span class="go">{Associative, Unital, Inverse}: Groups</span>
<span class="go">{Associative, Commutative}    : Commutative Semigroups</span>
<span class="go">{Unital,      Inverse}        : Loops</span>
</pre></div>
</div>
<p>Then, given a subset <span class="math notranslate nohighlight">\(T\)</span> of axioms, we want the system to be able to
select automatically the relevant classes
<span class="math notranslate nohighlight">\((D_S)_{S\in \mathcal S, S\subset T}\)</span>,
and build from them a category for the objects of <code class="docutils literal notranslate"><span class="pre">Cs</span></code> satisfying
the axioms in <span class="math notranslate nohighlight">\(T\)</span>, together with its hierarchy of super categories. If
<span class="math notranslate nohighlight">\(T\)</span> is in the indexing set <span class="math notranslate nohighlight">\(\mathcal S\)</span>, then the class of the
resulting category is directly <span class="math notranslate nohighlight">\(D_T\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Unital</span><span class="p">()</span><span class="o">.</span><span class="n">Inverse</span><span class="p">()</span><span class="o">.</span><span class="n">Associative</span><span class="p">();</span> <span class="n">C</span>
<span class="go">Category of groups</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.categories.groups.Groups_with_category&#39;&gt;</span>
</pre></div>
</div>
<p>Otherwise, we get a join category:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Infinite</span><span class="p">()</span><span class="o">.</span><span class="n">Unital</span><span class="p">()</span><span class="o">.</span><span class="n">Associative</span><span class="p">();</span> <span class="n">C</span>
<span class="go">Category of infinite monoids</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.categories.category.JoinCategory_with_category&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of monoids, Category of infinite sets]</span>
</pre></div>
</div>
</section>
<section id="concrete-model-as-an-arborescence-of-nested-classes">
<h4>Concrete model as an arborescence of nested classes<a class="headerlink" href="#concrete-model-as-an-arborescence-of-nested-classes" title="Permalink to this headline">¶</a></h4>
<p>We further want the construction to be efficient and amenable to
laziness. This led us to the following design decision: the collection
<span class="math notranslate nohighlight">\((D_S)_{S\in \mathcal S}\)</span> of classes should be structured as an
arborescence (or equivalently a <em>rooted forest</em>). The root is <code class="docutils literal notranslate"><span class="pre">Cs</span></code>,
corresponding to <span class="math notranslate nohighlight">\(S=\emptyset\)</span>. Any other class <span class="math notranslate nohighlight">\(D_S\)</span> should be the
child of a single class <span class="math notranslate nohighlight">\(D_{S'}\)</span> where <span class="math notranslate nohighlight">\(S'\)</span> is obtained from <span class="math notranslate nohighlight">\(S\)</span> by
removing a single axiom <span class="math notranslate nohighlight">\(A\)</span>. Of course, <span class="math notranslate nohighlight">\(D_{S'}\)</span> and <span class="math notranslate nohighlight">\(A\)</span> are
respectively the base category class and axiom of the category with
axiom <span class="math notranslate nohighlight">\(D_S\)</span> that we have met in the first section.</p>
<p>At this point, we urge the reader to explore the code of
<a class="reference internal" href="magmas.html#sage.categories.magmas.Magmas" title="sage.categories.magmas.Magmas"><code class="xref py py-class docutils literal notranslate"><span class="pre">Magmas</span></code></a> and
<a class="reference internal" href="distributive_magmas_and_additive_magmas.html#sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas" title="sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas"><code class="xref py py-class docutils literal notranslate"><span class="pre">DistributiveMagmasAndAdditiveMagmas</span></code></a>
and see how the arborescence structure on the categories with axioms
is reflected by the nesting of category classes.</p>
</section>
<section id="discussion-of-the-design">
<h4>Discussion of the design<a class="headerlink" href="#discussion-of-the-design" title="Permalink to this headline">¶</a></h4>
<section id="performance">
<h5>Performance<a class="headerlink" href="#performance" title="Permalink to this headline">¶</a></h5>
<p>Thanks to the arborescence structure on subsets of axioms,
constructing the hierarchy of categories and computing intersections
can be made efficient with, roughly speaking, a linear/quadratic
complexity in the size of the involved category hierarchy multiplied
by the number of axioms (see Section <a class="reference internal" href="#axioms-algorithmic"><span class="std std-ref">Algorithms</span></a>). This
is to be put in perspective with the manipulation of arbitrary
collections of subsets (aka boolean functions) which can easily raise
NP-hard problems.</p>
<p>Furthermore, thanks to its locality, the algorithms can be made
suitably lazy: in particular, only the involved category classes need
to be imported.</p>
</section>
<section id="flexibility">
<h5>Flexibility<a class="headerlink" href="#flexibility" title="Permalink to this headline">¶</a></h5>
<p>This design also brings in quite some flexibility, with the
possibility to support features such as defining new axioms depending
on other axioms and deduction rules. See below.</p>
</section>
<section id="asymmetry">
<h5>Asymmetry<a class="headerlink" href="#asymmetry" title="Permalink to this headline">¶</a></h5>
<p>As we have seen at the beginning of this section, this design
introduces an asymmetry. It’s not so bad in practice, since in most
practical cases, we want to work incrementally. It’s for example more
natural to describe <a class="reference internal" href="finite_fields.html#sage.categories.finite_fields.FiniteFields" title="sage.categories.finite_fields.FiniteFields"><code class="xref py py-class docutils literal notranslate"><span class="pre">FiniteFields</span></code></a> as <a class="reference internal" href="fields.html#sage.categories.fields.Fields" title="sage.categories.fields.Fields"><code class="xref py py-class docutils literal notranslate"><span class="pre">Fields</span></code></a> with the
axiom <code class="docutils literal notranslate"><span class="pre">Finite</span></code> rather than <a class="reference internal" href="magmas.html#sage.categories.magmas.Magmas" title="sage.categories.magmas.Magmas"><code class="xref py py-class docutils literal notranslate"><span class="pre">Magmas</span></code></a> and
<a class="reference internal" href="additive_magmas.html#sage.categories.additive_magmas.AdditiveMagmas" title="sage.categories.additive_magmas.AdditiveMagmas"><code class="xref py py-class docutils literal notranslate"><span class="pre">AdditiveMagmas</span></code></a> with all (or at least sufficiently many) of
the following axioms:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">Fields</span><span class="p">()</span><span class="o">.</span><span class="n">axioms</span><span class="p">())</span>
<span class="go">[&#39;AdditiveAssociative&#39;, &#39;AdditiveCommutative&#39;, &#39;AdditiveInverse&#39;,</span>
<span class="go"> &#39;AdditiveUnital&#39;, &#39;Associative&#39;, &#39;Commutative&#39;, &#39;Distributive&#39;,</span>
<span class="go"> &#39;Division&#39;, &#39;NoZeroDivisors&#39;, &#39;Unital&#39;]</span>
</pre></div>
</div>
<p>The main limitation is that the infrastructure currently imposes to be
incremental by steps of a single axiom.</p>
<p>In practice, among the roughly 60 categories with axioms that are
currently implemented in Sage, most admitted a (rather) natural choice
of a base category and single axiom to add. For example, one usually
thinks more naturally of a monoid as a semigroup which is unital
rather than as a unital magma which is associative. Modeling this
asymmetry in the code actually brings a bonus: it is used for printing
out categories in a (heuristically) mathematician-friendly way:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Commutative</span><span class="p">()</span><span class="o">.</span><span class="n">Associative</span><span class="p">()</span>
<span class="go">Category of commutative semigroups</span>
</pre></div>
</div>
<p>Only in a few cases is a choice made that feels mathematically
arbitrary. This is essentially in the chain of nested classes
<a class="reference internal" href="distributive_magmas_and_additive_magmas.html#sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative.AdditiveCommutative.AdditiveUnital.Associative" title="sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative.AdditiveCommutative.AdditiveUnital.Associative"><code class="xref py py-class docutils literal notranslate"><span class="pre">distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative.AdditiveCommutative.AdditiveUnital.Associative</span></code></a>.</p>
</section>
<section id="placeholder-classes">
<h5>Placeholder classes<a class="headerlink" href="#placeholder-classes" title="Permalink to this headline">¶</a></h5>
<p>Given that we can only add a single axiom at a time when implementing
a <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom" title="sage.categories.category_with_axiom.CategoryWithAxiom"><code class="xref py py-class docutils literal notranslate"><span class="pre">CategoryWithAxiom</span></code></a>, we need to create a few category classes
that are just placeholders. For the worst example, see the chain of
nested classes
<a class="reference internal" href="distributive_magmas_and_additive_magmas.html#sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative.AdditiveCommutative.AdditiveUnital.Associative" title="sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative.AdditiveCommutative.AdditiveUnital.Associative"><code class="xref py py-class docutils literal notranslate"><span class="pre">distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative.AdditiveCommutative.AdditiveUnital.Associative</span></code></a>.</p>
<p>This is suboptimal, but fits within the scope of the axiom
infrastructure which is to reduce a potentially exponential number of
placeholder category classes to just a couple.</p>
<p>Note also that, in the above example, it’s likely that some of the
intermediate classes will grow to non placeholder ones, as people will
explore more weaker variants of rings.</p>
</section>
<section id="mismatch-between-the-arborescence-of-nested-classes-and-the-hierarchy-of-categories">
<h5>Mismatch between the arborescence of nested classes and the hierarchy of categories<a class="headerlink" href="#mismatch-between-the-arborescence-of-nested-classes-and-the-hierarchy-of-categories" title="Permalink to this headline">¶</a></h5>
<p>The fact that the hierarchy relation between categories is not
reflected directly as a relation between the classes may sound
suspicious at first! However, as mentioned in the primer, this is
actually a big selling point of the axioms infrastructure: by
calculating automatically the hierarchy relation between categories
with axioms one avoids the nightmare of maintaining it by hand.
Instead, only a rather minimal number of links needs to be maintained
in the code (one per category with axiom).</p>
<p>Besides, with the flexibility introduced by runtime deduction rules
(see below), the hierarchy of categories may depend on the parameters
of the categories and not just their class. So it’s fine to make it
clear from the onset that the two relations do not match.</p>
</section>
<section id="evolutivity">
<h5>Evolutivity<a class="headerlink" href="#evolutivity" title="Permalink to this headline">¶</a></h5>
<p>At this point, the arborescence structure has to be hardcoded by hand
with the annoyances we have seen. This does not preclude, in a future
iteration, to design and implement some idiom for categories with
axioms that adds several axioms at once to a base category; maybe some
variation around:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">class DistributiveMagmasAndAdditiveMagmas:</span>
<span class="go">    ...</span>

<span class="go">    @category_with_axiom(</span>
<span class="go">        AdditiveAssociative,</span>
<span class="go">        AdditiveCommutative,</span>
<span class="go">        AdditiveUnital,</span>
<span class="go">        AdditiveInverse,</span>
<span class="go">        Associative)</span>
<span class="go">    def _(): return LazyImport(&#39;sage.categories.rngs&#39;, &#39;Rngs&#39;, at_startup=True)</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">register_axiom_category(DistributiveMagmasAndAdditiveMagmas,</span>
<span class="go">                        {AdditiveAssociative,</span>
<span class="go">                         AdditiveCommutative,</span>
<span class="go">                         AdditiveUnital,</span>
<span class="go">                         AdditiveInverse,</span>
<span class="go">                         Associative},</span>
<span class="go">                        &#39;sage.categories.rngs&#39;, &#39;Rngs&#39;, at_startup=True)</span>
</pre></div>
</div>
<p>The infrastructure would then be in charge of building the appropriate
arborescence under the hood. Or rely on some database (see discussion
on <a class="reference external" href="https://trac.sagemath.org/10963">trac ticket #10963</a>, in particular at the end of comment 332).</p>
</section>
</section>
<section id="axioms-defined-upon-other-axioms">
<h4>Axioms defined upon other axioms<a class="headerlink" href="#axioms-defined-upon-other-axioms" title="Permalink to this headline">¶</a></h4>
<p>Sometimes an axiom can only be defined when some other axiom
holds. For example, the axiom <code class="docutils literal notranslate"><span class="pre">NoZeroDivisors</span></code> only makes sense if
there is a zero, that is if the axiom <code class="docutils literal notranslate"><span class="pre">AdditiveUnital</span></code> holds. Hence,
for the category
<a class="reference internal" href="magmas_and_additive_magmas.html#sage.categories.magmas_and_additive_magmas.MagmasAndAdditiveMagmas" title="sage.categories.magmas_and_additive_magmas.MagmasAndAdditiveMagmas"><code class="xref py py-class docutils literal notranslate"><span class="pre">MagmasAndAdditiveMagmas</span></code></a>, we
consider in the abstract model only those subsets of axioms where the
presence of <code class="docutils literal notranslate"><span class="pre">NoZeroDivisors</span></code> implies that of <code class="docutils literal notranslate"><span class="pre">AdditiveUnital</span></code>.  We
also want the axiom to be only available if meaningful:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Rings</span><span class="p">()</span><span class="o">.</span><span class="n">NoZeroDivisors</span><span class="p">()</span>
<span class="go">Category of domains</span>
<span class="gp">sage: </span><span class="n">Rings</span><span class="p">()</span><span class="o">.</span><span class="n">Commutative</span><span class="p">()</span><span class="o">.</span><span class="n">NoZeroDivisors</span><span class="p">()</span>
<span class="go">Category of integral domains</span>
<span class="gp">sage: </span><span class="n">Semirings</span><span class="p">()</span><span class="o">.</span><span class="n">NoZeroDivisors</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">AttributeError: &#39;Semirings_with_category&#39; object has no attribute &#39;NoZeroDivisors&#39;</span>
</pre></div>
</div>
<p>Concretely, this is to be implemented by defining the new axiom in the
(<code class="docutils literal notranslate"><span class="pre">SubcategoryMethods</span></code> nested class of the) appropriate category with
axiom. For example the axiom <code class="docutils literal notranslate"><span class="pre">NoZeroDivisors</span></code> would be naturally
defined in
<code class="xref py py-class docutils literal notranslate"><span class="pre">magmas_and_additive_magmas.MagmasAndAdditiveMagmas.Distributive.AdditiveUnital</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The axiom <code class="docutils literal notranslate"><span class="pre">NoZeroDivisors</span></code> is currently defined in
<a class="reference internal" href="rings.html#sage.categories.rings.Rings" title="sage.categories.rings.Rings"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rings</span></code></a>, by simple lack of need for the feature; it should
be lifted up as soon as relevant, that is when some code will be
available for parents with no zero divisors that are not
necessarily rings.</p>
</div>
</section>
<section id="deduction-rules">
<span id="axioms-deduction-rules"></span><h4>Deduction rules<a class="headerlink" href="#deduction-rules" title="Permalink to this headline">¶</a></h4>
<p>A similar situation is when an axiom <code class="docutils literal notranslate"><span class="pre">A</span></code> of a category <code class="docutils literal notranslate"><span class="pre">Cs</span></code>
implies some other axiom <code class="docutils literal notranslate"><span class="pre">B</span></code>, with the same consequence as above on
the subsets of axioms appearing in the abstract model. For example, a
division ring necessarily has no zero divisors:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="s1">&#39;NoZeroDivisors&#39;</span> <span class="ow">in</span> <span class="n">Rings</span><span class="p">()</span><span class="o">.</span><span class="n">Division</span><span class="p">()</span><span class="o">.</span><span class="n">axioms</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="s1">&#39;NoZeroDivisors&#39;</span> <span class="ow">in</span> <span class="n">Rings</span><span class="p">()</span><span class="o">.</span><span class="n">axioms</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>This deduction rule is implemented by the method
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Rings.Division.extra_super_categories()</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Rings</span><span class="p">()</span><span class="o">.</span><span class="n">Division</span><span class="p">()</span><span class="o">.</span><span class="n">extra_super_categories</span><span class="p">()</span>
<span class="go">(Category of domains,)</span>
</pre></div>
</div>
<p>In general, this is to be implemented by a method
<code class="docutils literal notranslate"><span class="pre">Cs.A.extra_super_categories</span></code> returning a tuple <code class="docutils literal notranslate"><span class="pre">(Cs().B(),)</span></code>, or
preferably <code class="docutils literal notranslate"><span class="pre">(Ds().B(),)</span></code> where <code class="docutils literal notranslate"><span class="pre">Ds</span></code> is the category defining the
axiom <code class="docutils literal notranslate"><span class="pre">B</span></code>.</p>
<p>This follows the same idiom as for deduction rules about functorial
constructions (see <code class="xref py py-meth docutils literal notranslate"><span class="pre">covariant_functorial_construction.CovariantConstructionCategory.extra_super_categories()</span></code>).
For example, the fact that a Cartesian product of associative magmas
(i.e. of semigroups) is an associative magma is implemented in
<a class="reference internal" href="semigroups.html#sage.categories.semigroups.Semigroups.CartesianProducts.extra_super_categories" title="sage.categories.semigroups.Semigroups.CartesianProducts.extra_super_categories"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Semigroups.CartesianProducts.extra_super_categories()</span></code></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Associative</span><span class="p">()</span>
<span class="go">Category of semigroups</span>
<span class="gp">sage: </span><span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Associative</span><span class="p">()</span><span class="o">.</span><span class="n">CartesianProducts</span><span class="p">()</span><span class="o">.</span><span class="n">extra_super_categories</span><span class="p">()</span>
<span class="go">[Category of semigroups]</span>
</pre></div>
</div>
<p>Similarly, the fact that the algebra of a commutative magma is
commutative is implemented in
<a class="reference internal" href="magmas.html#sage.categories.magmas.Magmas.Commutative.Algebras.extra_super_categories" title="sage.categories.magmas.Magmas.Commutative.Algebras.extra_super_categories"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Magmas.Commutative.Algebras.extra_super_categories()</span></code></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Commutative</span><span class="p">()</span><span class="o">.</span><span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">extra_super_categories</span><span class="p">()</span>
<span class="go">[Category of commutative magmas]</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In some situations this idiom is inapplicable as it would require
to implement two classes for the same category. This is the
purpose of the next section.</p>
</div>
<section id="special-case">
<h5>Special case<a class="headerlink" href="#special-case" title="Permalink to this headline">¶</a></h5>
<p>In the previous examples, the deduction rule only had an influence on
the super categories of the category with axiom being constructed. For
example, when constructing <code class="docutils literal notranslate"><span class="pre">Rings().Division()</span></code>, the rule
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Rings.Division.extra_super_categories()</span></code> simply adds
<code class="docutils literal notranslate"><span class="pre">Rings().NoZeroDivisors()</span></code> as a super category thereof.</p>
<p>In some situations this idiom is inapplicable because a class for the
category with axiom under construction already exists elsewhere. Take
for example Wedderburn’s theorem: any finite division ring is
commutative, i.e. is a finite field. In other words,
<code class="docutils literal notranslate"><span class="pre">DivisionRings().Finite()</span></code> <em>coincides</em> with <code class="docutils literal notranslate"><span class="pre">Fields().Finite()</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">DivisionRings</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span>
<span class="go">Category of finite enumerated fields</span>
<span class="gp">sage: </span><span class="n">DivisionRings</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span> <span class="ow">is</span> <span class="n">Fields</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Therefore we cannot create a class <code class="docutils literal notranslate"><span class="pre">DivisionRings.Finite</span></code> to hold
the desired <code class="docutils literal notranslate"><span class="pre">extra_super_categories</span></code> method, because there is
already a class for this category with axiom, namely
<code class="docutils literal notranslate"><span class="pre">Fields.Finite</span></code>.</p>
<p>A natural idiom would be to have <code class="docutils literal notranslate"><span class="pre">DivisionRings.Finite</span></code> be a link to
<code class="docutils literal notranslate"><span class="pre">Fields.Finite</span></code> (locally introducing an undirected cycle in the
arborescence of nested classes). It would be a bit tricky to implement
though, since one would need to detect, upon constructing
<code class="docutils literal notranslate"><span class="pre">DivisionRings().Finite()</span></code>, that <code class="docutils literal notranslate"><span class="pre">DivisionRings.Finite</span></code> is
actually <code class="docutils literal notranslate"><span class="pre">Fields.Finite</span></code>, in order to construct appropriately
<code class="docutils literal notranslate"><span class="pre">Fields().Finite()</span></code>; and reciprocally, upon computing the super
categories of <code class="docutils literal notranslate"><span class="pre">Fields().Finite()</span></code>, to not try to add
<code class="docutils literal notranslate"><span class="pre">DivisionRings().Finite()</span></code> as a super category.</p>
<p>Instead the current idiom is to have a method
<code class="docutils literal notranslate"><span class="pre">DivisionRings.Finite_extra_super_categories</span></code> which mimics the
behavior of the would-be
<code class="docutils literal notranslate"><span class="pre">DivisionRings.Finite.extra_super_categories</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">DivisionRings</span><span class="p">()</span><span class="o">.</span><span class="n">Finite_extra_super_categories</span><span class="p">()</span>
<span class="go">(Category of commutative magmas,)</span>
</pre></div>
</div>
<p>This idiom is admittedly rudimentary, but consistent with how
mathematical facts specifying non trivial inclusion relations between
categories are implemented elsewhere in the various
<code class="docutils literal notranslate"><span class="pre">extra_super_categories</span></code> methods of axiom categories and covariant
functorial constructions. Besides, it gives a natural spot (the
docstring of the method) to document and test the modeling of the
mathematical fact. Finally, Wedderburn’s theorem is arguably a theorem
about division rings (in the context of division rings, finiteness
implies commutativity) and therefore lives naturally in
<a class="reference internal" href="division_rings.html#sage.categories.division_rings.DivisionRings" title="sage.categories.division_rings.DivisionRings"><code class="xref py py-class docutils literal notranslate"><span class="pre">DivisionRings</span></code></a>.</p>
<p>An alternative would be to implement the category of finite division
rings (i.e. finite fields) in a class <code class="docutils literal notranslate"><span class="pre">DivisionRings.Finite</span></code> rather
than <code class="docutils literal notranslate"><span class="pre">Fields.Finite</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.category_with_axiom</span> <span class="kn">import</span> <span class="n">CategoryWithAxiom</span>

<span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyDivisionRings</span><span class="p">(</span><span class="n">Category</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="p">[</span><span class="n">Rings</span><span class="p">()]</span>

<span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyFields</span><span class="p">(</span><span class="n">Category</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="p">[</span><span class="n">MyDivisionRings</span><span class="p">()]</span>

<span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyFiniteFields</span><span class="p">(</span><span class="n">CategoryWithAxiom</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">_base_category_class_and_axiom</span> <span class="o">=</span> <span class="p">(</span><span class="n">MyDivisionRings</span><span class="p">,</span> <span class="s2">&quot;Finite&quot;</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">extra_super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># Wedderburn&#39;s theorem</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="p">[</span><span class="n">MyFields</span><span class="p">()]</span>

<span class="gp">sage: </span><span class="n">MyDivisionRings</span><span class="o">.</span><span class="n">Finite</span> <span class="o">=</span> <span class="n">MyFiniteFields</span>

<span class="gp">sage: </span><span class="n">MyDivisionRings</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span>
<span class="go">Category of my finite fields</span>
<span class="gp">sage: </span><span class="n">MyFields</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span> <span class="ow">is</span> <span class="n">MyDivisionRings</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In general, if several categories <code class="docutils literal notranslate"><span class="pre">C1s()</span></code>, <code class="docutils literal notranslate"><span class="pre">C2s()</span></code>, … are mapped to
the same category when applying some axiom <code class="docutils literal notranslate"><span class="pre">A</span></code> (that is <code class="docutils literal notranslate"><span class="pre">C1s().A()</span>
<span class="pre">==</span> <span class="pre">C2s().A()</span> <span class="pre">==</span> <span class="pre">...</span></code>), then one should be careful to implement this
category in a single class <code class="docutils literal notranslate"><span class="pre">Cs.A</span></code>, and set up methods
<code class="docutils literal notranslate"><span class="pre">extra_super_categories</span></code> or <code class="docutils literal notranslate"><span class="pre">A_extra_super_categories</span></code> methods as
appropriate. Each such method should return something like
<code class="docutils literal notranslate"><span class="pre">[C2s()]</span></code> and not <code class="docutils literal notranslate"><span class="pre">[C2s().A()]</span></code> for the latter would likely lead
to an infinite recursion.</p>
<div class="topic">
<p class="topic-title">Design discussion</p>
<p>Supporting similar deduction rules will be an important feature in
the future, with quite a few occurrences already implemented in
upcoming tickets. For the time being though there is a single
occurrence of this idiom outside of the tests. So this would be an
easy thing to refactor after <a class="reference external" href="https://trac.sagemath.org/10963">trac ticket #10963</a> if a better idiom is
found.</p>
</div>
</section>
<section id="larger-synthetic-examples">
<h5>Larger synthetic examples<a class="headerlink" href="#larger-synthetic-examples" title="Permalink to this headline">¶</a></h5>
<p>We now consider some larger synthetic examples to check that the
machinery works as expected. Let us start with a category defining a
bunch of axioms, using <a class="reference internal" href="#sage.categories.category_with_axiom.axiom" title="sage.categories.category_with_axiom.axiom"><code class="xref py py-func docutils literal notranslate"><span class="pre">axiom()</span></code></a> for conciseness (don’t do it for
real axioms; they deserve a full documentation!):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.category_singleton</span> <span class="kn">import</span> <span class="n">Category_singleton</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.category_with_axiom</span> <span class="kn">import</span> <span class="n">axiom</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">sage.categories.category_with_axiom</span>
<span class="gp">sage: </span><span class="n">all_axioms</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">category_with_axiom</span><span class="o">.</span><span class="n">all_axioms</span>
<span class="gp">sage: </span><span class="n">all_axioms</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">,</span><span class="s2">&quot;C&quot;</span><span class="p">,</span><span class="s2">&quot;D&quot;</span><span class="p">,</span><span class="s2">&quot;E&quot;</span><span class="p">,</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>

<span class="gp">sage: </span><span class="k">class</span> <span class="nc">As</span><span class="p">(</span><span class="n">Category_singleton</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="p">[</span><span class="n">Objects</span><span class="p">()]</span>
<span class="gp">....:</span>
<span class="gp">....: </span>    <span class="k">class</span> <span class="nc">SubcategoryMethods</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="n">B</span> <span class="o">=</span> <span class="n">axiom</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">)</span>
<span class="gp">....: </span>        <span class="n">C</span> <span class="o">=</span> <span class="n">axiom</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
<span class="gp">....: </span>        <span class="n">D</span> <span class="o">=</span> <span class="n">axiom</span><span class="p">(</span><span class="s2">&quot;D&quot;</span><span class="p">)</span>
<span class="gp">....: </span>        <span class="n">E</span> <span class="o">=</span> <span class="n">axiom</span><span class="p">(</span><span class="s2">&quot;E&quot;</span><span class="p">)</span>
<span class="gp">....: </span>        <span class="n">F</span> <span class="o">=</span> <span class="n">axiom</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>
<span class="gp">....:</span>
<span class="gp">....: </span>    <span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">CategoryWithAxiom</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">pass</span>
<span class="gp">....: </span>    <span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">CategoryWithAxiom</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">pass</span>
<span class="gp">....: </span>    <span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="n">CategoryWithAxiom</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">pass</span>
<span class="gp">....: </span>    <span class="k">class</span> <span class="nc">E</span><span class="p">(</span><span class="n">CategoryWithAxiom</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">pass</span>
<span class="gp">....: </span>    <span class="k">class</span> <span class="nc">F</span><span class="p">(</span><span class="n">CategoryWithAxiom</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">pass</span>
</pre></div>
</div>
<p>Now we construct a subcategory where, by some theorem of William,
axioms <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">C</span></code> together are equivalent to <code class="docutils literal notranslate"><span class="pre">E</span></code> and <code class="docutils literal notranslate"><span class="pre">F</span></code>
together:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">A1s</span><span class="p">(</span><span class="n">Category_singleton</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="p">[</span><span class="n">As</span><span class="p">()]</span>
<span class="gp">....:</span>
<span class="gp">....: </span>    <span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">CategoryWithAxiom</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">def</span> <span class="nf">C_extra_super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="p">[</span><span class="n">As</span><span class="p">()</span><span class="o">.</span><span class="n">E</span><span class="p">(),</span> <span class="n">As</span><span class="p">()</span><span class="o">.</span><span class="n">F</span><span class="p">()]</span>
<span class="gp">....:</span>
<span class="gp">....: </span>    <span class="k">class</span> <span class="nc">E</span><span class="p">(</span><span class="n">CategoryWithAxiom</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">def</span> <span class="nf">F_extra_super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="p">[</span><span class="n">As</span><span class="p">()</span><span class="o">.</span><span class="n">B</span><span class="p">(),</span> <span class="n">As</span><span class="p">()</span><span class="o">.</span><span class="n">C</span><span class="p">()]</span>

<span class="gp">sage: </span><span class="n">A1s</span><span class="p">()</span><span class="o">.</span><span class="n">B</span><span class="p">()</span><span class="o">.</span><span class="n">C</span><span class="p">()</span>
<span class="go">Category of e f a1s</span>
</pre></div>
</div>
<p>The axioms <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">C</span></code> do not show up in the name of the obtained
category because, for concision, the printing uses some heuristics to
not show axioms that are implied by others. But they are satisfied:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">A1s</span><span class="p">()</span><span class="o">.</span><span class="n">B</span><span class="p">()</span><span class="o">.</span><span class="n">C</span><span class="p">()</span><span class="o">.</span><span class="n">axioms</span><span class="p">())</span>
<span class="go">[&#39;B&#39;, &#39;C&#39;, &#39;E&#39;, &#39;F&#39;]</span>
</pre></div>
</div>
<p>Note also that this is a join category:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">A1s</span><span class="p">()</span><span class="o">.</span><span class="n">B</span><span class="p">()</span><span class="o">.</span><span class="n">C</span><span class="p">())</span>
<span class="go">&lt;class &#39;sage.categories.category.JoinCategory_with_category&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">A1s</span><span class="p">()</span><span class="o">.</span><span class="n">B</span><span class="p">()</span><span class="o">.</span><span class="n">C</span><span class="p">()</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of e a1s,</span>
<span class="go"> Category of f as,</span>
<span class="go"> Category of b a1s,</span>
<span class="go"> Category of c as]</span>
</pre></div>
</div>
<p>As desired, William’s theorem holds:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A1s</span><span class="p">()</span><span class="o">.</span><span class="n">B</span><span class="p">()</span><span class="o">.</span><span class="n">C</span><span class="p">()</span> <span class="ow">is</span> <span class="n">A1s</span><span class="p">()</span><span class="o">.</span><span class="n">E</span><span class="p">()</span><span class="o">.</span><span class="n">F</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>and propagates appropriately to subcategories:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span>  <span class="n">A1s</span><span class="p">()</span><span class="o">.</span><span class="n">E</span><span class="p">()</span><span class="o">.</span><span class="n">F</span><span class="p">()</span><span class="o">.</span><span class="n">D</span><span class="p">()</span><span class="o">.</span><span class="n">B</span><span class="p">()</span><span class="o">.</span><span class="n">C</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="ow">is</span> <span class="n">A1s</span><span class="p">()</span><span class="o">.</span><span class="n">B</span><span class="p">()</span><span class="o">.</span><span class="n">C</span><span class="p">()</span><span class="o">.</span><span class="n">E</span><span class="p">()</span><span class="o">.</span><span class="n">F</span><span class="p">()</span><span class="o">.</span><span class="n">D</span><span class="p">()</span>  <span class="c1"># commutativity</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="ow">is</span> <span class="n">A1s</span><span class="p">()</span><span class="o">.</span><span class="n">E</span><span class="p">()</span><span class="o">.</span><span class="n">F</span><span class="p">()</span><span class="o">.</span><span class="n">E</span><span class="p">()</span><span class="o">.</span><span class="n">F</span><span class="p">()</span><span class="o">.</span><span class="n">D</span><span class="p">()</span>  <span class="c1"># William&#39;s theorem</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="ow">is</span> <span class="n">A1s</span><span class="p">()</span><span class="o">.</span><span class="n">E</span><span class="p">()</span><span class="o">.</span><span class="n">E</span><span class="p">()</span><span class="o">.</span><span class="n">F</span><span class="p">()</span><span class="o">.</span><span class="n">F</span><span class="p">()</span><span class="o">.</span><span class="n">D</span><span class="p">()</span>  <span class="c1"># commutativity</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="ow">is</span> <span class="n">A1s</span><span class="p">()</span><span class="o">.</span><span class="n">E</span><span class="p">()</span><span class="o">.</span><span class="n">F</span><span class="p">()</span><span class="o">.</span><span class="n">D</span><span class="p">()</span>          <span class="c1"># idempotency</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="ow">is</span> <span class="n">A1s</span><span class="p">()</span><span class="o">.</span><span class="n">D</span><span class="p">()</span><span class="o">.</span><span class="n">E</span><span class="p">()</span><span class="o">.</span><span class="n">F</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In this quick variant, we actually implement the category of <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">c</span>
<span class="pre">a2s</span></code>, and choose to do so in <code class="docutils literal notranslate"><span class="pre">A2s.B.C</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">A2s</span><span class="p">(</span><span class="n">Category_singleton</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="p">[</span><span class="n">As</span><span class="p">()]</span>
<span class="gp">....:</span>
<span class="gp">....: </span>    <span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">CategoryWithAxiom</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">CategoryWithAxiom</span><span class="p">):</span>
<span class="gp">....: </span>            <span class="k">def</span> <span class="nf">extra_super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>                <span class="k">return</span> <span class="p">[</span><span class="n">As</span><span class="p">()</span><span class="o">.</span><span class="n">E</span><span class="p">(),</span> <span class="n">As</span><span class="p">()</span><span class="o">.</span><span class="n">F</span><span class="p">()]</span>
<span class="gp">....:</span>
<span class="gp">....: </span>    <span class="k">class</span> <span class="nc">E</span><span class="p">(</span><span class="n">CategoryWithAxiom</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">def</span> <span class="nf">F_extra_super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="p">[</span><span class="n">As</span><span class="p">()</span><span class="o">.</span><span class="n">B</span><span class="p">(),</span> <span class="n">As</span><span class="p">()</span><span class="o">.</span><span class="n">C</span><span class="p">()]</span>


<span class="gp">sage: </span><span class="n">A2s</span><span class="p">()</span><span class="o">.</span><span class="n">B</span><span class="p">()</span><span class="o">.</span><span class="n">C</span><span class="p">()</span>
<span class="go">Category of e f a2s</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">A2s</span><span class="p">()</span><span class="o">.</span><span class="n">B</span><span class="p">()</span><span class="o">.</span><span class="n">C</span><span class="p">()</span><span class="o">.</span><span class="n">axioms</span><span class="p">())</span>
<span class="go">[&#39;B&#39;, &#39;C&#39;, &#39;E&#39;, &#39;F&#39;]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">A2s</span><span class="p">()</span><span class="o">.</span><span class="n">B</span><span class="p">()</span><span class="o">.</span><span class="n">C</span><span class="p">())</span>
<span class="go">&lt;class &#39;__main__.A2s.B.C_with_category&#39;&gt;</span>
</pre></div>
</div>
<p>As desired, William’s theorem and its consequences hold:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A2s</span><span class="p">()</span><span class="o">.</span><span class="n">B</span><span class="p">()</span><span class="o">.</span><span class="n">C</span><span class="p">()</span> <span class="ow">is</span> <span class="n">A2s</span><span class="p">()</span><span class="o">.</span><span class="n">E</span><span class="p">()</span><span class="o">.</span><span class="n">F</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span>  <span class="n">A2s</span><span class="p">()</span><span class="o">.</span><span class="n">E</span><span class="p">()</span><span class="o">.</span><span class="n">F</span><span class="p">()</span><span class="o">.</span><span class="n">D</span><span class="p">()</span><span class="o">.</span><span class="n">B</span><span class="p">()</span><span class="o">.</span><span class="n">C</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="ow">is</span> <span class="n">A2s</span><span class="p">()</span><span class="o">.</span><span class="n">B</span><span class="p">()</span><span class="o">.</span><span class="n">C</span><span class="p">()</span><span class="o">.</span><span class="n">E</span><span class="p">()</span><span class="o">.</span><span class="n">F</span><span class="p">()</span><span class="o">.</span><span class="n">D</span><span class="p">()</span>  <span class="c1"># commutativity</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="ow">is</span> <span class="n">A2s</span><span class="p">()</span><span class="o">.</span><span class="n">E</span><span class="p">()</span><span class="o">.</span><span class="n">F</span><span class="p">()</span><span class="o">.</span><span class="n">E</span><span class="p">()</span><span class="o">.</span><span class="n">F</span><span class="p">()</span><span class="o">.</span><span class="n">D</span><span class="p">()</span>  <span class="c1"># William&#39;s theorem</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="ow">is</span> <span class="n">A2s</span><span class="p">()</span><span class="o">.</span><span class="n">E</span><span class="p">()</span><span class="o">.</span><span class="n">E</span><span class="p">()</span><span class="o">.</span><span class="n">F</span><span class="p">()</span><span class="o">.</span><span class="n">F</span><span class="p">()</span><span class="o">.</span><span class="n">D</span><span class="p">()</span>  <span class="c1"># commutativity</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="ow">is</span> <span class="n">A2s</span><span class="p">()</span><span class="o">.</span><span class="n">E</span><span class="p">()</span><span class="o">.</span><span class="n">F</span><span class="p">()</span><span class="o">.</span><span class="n">D</span><span class="p">()</span>          <span class="c1"># idempotency</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="ow">is</span> <span class="n">A2s</span><span class="p">()</span><span class="o">.</span><span class="n">D</span><span class="p">()</span><span class="o">.</span><span class="n">E</span><span class="p">()</span><span class="o">.</span><span class="n">F</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Finally, we “accidentally” implement the category of <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">c</span> <span class="pre">a1s</span></code>, both
in <code class="docutils literal notranslate"><span class="pre">A3s.B.C</span></code> and <code class="docutils literal notranslate"><span class="pre">A3s.E.F</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">A3s</span><span class="p">(</span><span class="n">Category_singleton</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="p">[</span><span class="n">As</span><span class="p">()]</span>
<span class="gp">....:</span>
<span class="gp">....: </span>    <span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">CategoryWithAxiom</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">CategoryWithAxiom</span><span class="p">):</span>
<span class="gp">....: </span>            <span class="k">def</span> <span class="nf">extra_super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>                <span class="k">return</span> <span class="p">[</span><span class="n">As</span><span class="p">()</span><span class="o">.</span><span class="n">E</span><span class="p">(),</span> <span class="n">As</span><span class="p">()</span><span class="o">.</span><span class="n">F</span><span class="p">()]</span>
<span class="gp">....:</span>
<span class="gp">....: </span>    <span class="k">class</span> <span class="nc">E</span><span class="p">(</span><span class="n">CategoryWithAxiom</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">class</span> <span class="nc">F</span><span class="p">(</span><span class="n">CategoryWithAxiom</span><span class="p">):</span>
<span class="gp">....: </span>            <span class="k">def</span> <span class="nf">extra_super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>                <span class="k">return</span> <span class="p">[</span><span class="n">As</span><span class="p">()</span><span class="o">.</span><span class="n">B</span><span class="p">(),</span> <span class="n">As</span><span class="p">()</span><span class="o">.</span><span class="n">C</span><span class="p">()]</span>
</pre></div>
</div>
<p>We can still construct, say:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A3s</span><span class="p">()</span><span class="o">.</span><span class="n">B</span><span class="p">()</span>
<span class="go">Category of b a3s</span>
<span class="gp">sage: </span><span class="n">A3s</span><span class="p">()</span><span class="o">.</span><span class="n">C</span><span class="p">()</span>
<span class="go">Category of c a3s</span>
</pre></div>
</div>
<p>However,</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A3s</span><span class="p">()</span><span class="o">.</span><span class="n">B</span><span class="p">()</span><span class="o">.</span><span class="n">C</span><span class="p">()</span>           <span class="c1"># not tested</span>
</pre></div>
</div>
<p>runs into an infinite recursion loop, as <code class="docutils literal notranslate"><span class="pre">A3s().B().C()</span></code> wants to
have <code class="docutils literal notranslate"><span class="pre">A3s().E().F()</span></code> as super category and reciprocally.</p>
<div class="admonition-todo admonition" id="id6">
<p class="admonition-title">Todo</p>
<p>The above example violates the specifications (a category should
be modelled by at most one class), so it’s appropriate that it
fails. Yet, the error message could be usefully complemented by
some hint at what the source of the problem is (a category
implemented in two distinct classes). Leaving a large enough piece
of the backtrace would be useful though, so that one can explore
where the issue comes from (e.g. with post mortem debugging).</p>
</div>
</section>
</section>
</section>
</section>
<section id="specifications">
<h2>Specifications<a class="headerlink" href="#specifications" title="Permalink to this headline">¶</a></h2>
<p>After fixing some vocabulary, we summarize here some specifications
about categories and axioms.</p>
<section id="the-lattice-of-constructible-categories">
<h3>The lattice of constructible categories<a class="headerlink" href="#the-lattice-of-constructible-categories" title="Permalink to this headline">¶</a></h3>
<p>A mathematical category <span class="math notranslate nohighlight">\(C\)</span> is <em>implemented</em> if there is a class in
Sage modelling it; it is <em>constructible</em> if it is either implemented,
or is the intersection of <em>implemented</em> categories; in the latter case
it is modelled by a <a class="reference internal" href="category.html#sage.categories.category.JoinCategory" title="sage.categories.category.JoinCategory"><code class="xref py py-class docutils literal notranslate"><span class="pre">JoinCategory</span></code></a>. The comparison of two
constructible categories with the <a class="reference internal" href="category.html#sage.categories.category.Category.is_subcategory" title="sage.categories.category.Category.is_subcategory"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Category.is_subcategory()</span></code></a>
method is supposed to model the comparison of the corresponding
mathematical categories for inclusion of the objects (see
<a class="reference internal" href="primer.html#category-primer-subcategory"><span class="std std-ref">On the category hierarchy: subcategories and super categories</span></a> for details). For example:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Fields</span><span class="p">()</span><span class="o">.</span><span class="n">is_subcategory</span><span class="p">(</span><span class="n">Rings</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
<p>However this modelling may be incomplete. It can happen that a
mathematical fact implying that a category <span class="math notranslate nohighlight">\(A\)</span> is a subcategory of a
category <span class="math notranslate nohighlight">\(B\)</span> is not implemented. Still, the comparison should endow
the set of constructible categories with a poset structure and in fact
a lattice structure.</p>
<p>In this lattice, the join of two categories (<a class="reference internal" href="category.html#sage.categories.category.Category.join" title="sage.categories.category.Category.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Category.join()</span></code></a>) is
supposed to model their intersection. Given that we compare categories
for inclusion, it would be more natural to call this operation the
<em>meet</em>; blames go to me (Nicolas) for originally comparing categories
by <em>amount of structure</em> rather than by <em>inclusion</em>. In practice, the
join of two categories may be a strict super category of their
intersection; first because this intersection might not be
constructible; second because Sage might miss some mathematical
information to recover the smallest constructible super category of
the intersection.</p>
</section>
<section id="id7">
<h3>Axioms<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>We say that an axiom <code class="docutils literal notranslate"><span class="pre">A</span></code> is <em>defined by</em> a category <code class="docutils literal notranslate"><span class="pre">Cs()</span></code> if
<code class="docutils literal notranslate"><span class="pre">Cs</span></code> defines an appropriate method <code class="docutils literal notranslate"><span class="pre">Cs.SubcategoryMethods.A</span></code>, with
the semantic of the axiom specified in the documentation; for any
subcategory <code class="docutils literal notranslate"><span class="pre">Ds()</span></code>, <code class="docutils literal notranslate"><span class="pre">Ds().A()</span></code> models the subcategory of the
objects of <code class="docutils literal notranslate"><span class="pre">Ds()</span></code> satisfying <code class="docutils literal notranslate"><span class="pre">A</span></code>. In this case, we say that the
axiom <code class="docutils literal notranslate"><span class="pre">A</span></code> is <em>defined for</em> the category <code class="docutils literal notranslate"><span class="pre">Ds()</span></code>. Furthermore,
<code class="docutils literal notranslate"><span class="pre">Ds</span></code> <em>implements the axiom</em> <code class="docutils literal notranslate"><span class="pre">A</span></code> if <code class="docutils literal notranslate"><span class="pre">Ds</span></code> has a category with
axiom as nested class <code class="docutils literal notranslate"><span class="pre">Ds.A</span></code>. The category <code class="docutils literal notranslate"><span class="pre">Ds()</span></code> <em>satisfies</em> the
axiom if <code class="docutils literal notranslate"><span class="pre">Ds()</span></code> is a subcategory of <code class="docutils literal notranslate"><span class="pre">Cs().A()</span></code> (meaning that all
the objects of <code class="docutils literal notranslate"><span class="pre">Ds()</span></code> are known to satisfy the axiom <code class="docutils literal notranslate"><span class="pre">A</span></code>).</p>
<section id="a-digression-on-the-structure-of-fibers-when-adding-an-axiom">
<h4>A digression on the structure of fibers when adding an axiom<a class="headerlink" href="#a-digression-on-the-structure-of-fibers-when-adding-an-axiom" title="Permalink to this headline">¶</a></h4>
<p>Consider the application <span class="math notranslate nohighlight">\(\phi_A\)</span> which maps a category to its
category of objects satisfying <span class="math notranslate nohighlight">\(A\)</span>. Equivalently, <span class="math notranslate nohighlight">\(\phi_A\)</span> is
computing the intersection with the defining category with axiom of
<span class="math notranslate nohighlight">\(A\)</span>. It follows immediately from the latter that <span class="math notranslate nohighlight">\(\phi_A\)</span> is a
regressive endomorphism of the lattice of categories. It restricts
to a regressive endomorphism <code class="docutils literal notranslate"><span class="pre">Cs()</span> <span class="pre">|-&gt;</span> <span class="pre">Cs().A()</span></code>
on the lattice of constructible categories.</p>
<p>This endomorphism may have non trivial fibers, as in our favorite
example: <code class="docutils literal notranslate"><span class="pre">DivisionRings()</span></code> and <code class="docutils literal notranslate"><span class="pre">Fields()</span></code> are in the same fiber
for the axiom <code class="docutils literal notranslate"><span class="pre">Finite</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">DivisionRings</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span> <span class="ow">is</span> <span class="n">Fields</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Consider the intersection <span class="math notranslate nohighlight">\(S\)</span> of such a fiber of <span class="math notranslate nohighlight">\(\phi_A\)</span> with the
upper set <span class="math notranslate nohighlight">\(I_A\)</span> of categories that do not satisfy <code class="docutils literal notranslate"><span class="pre">A</span></code>. The fiber
itself is a sublattice. However <span class="math notranslate nohighlight">\(I_A\)</span> is not guaranteed to be stable
under intersection (though exceptions should be rare). Therefore,
there is a priori no guarantee that <span class="math notranslate nohighlight">\(S\)</span> would be stable under
intersection. Also it’s presumably finite, in fact small, but this is
not guaranteed either.</p>
</section>
</section>
<section id="id8">
<h3>Specifications<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>Any constructible category <code class="docutils literal notranslate"><span class="pre">C</span></code> should admit a finite number of
larger constructible categories.</p></li>
<li><p>The methods <code class="docutils literal notranslate"><span class="pre">super_categories</span></code>, <code class="docutils literal notranslate"><span class="pre">extra_super_categories</span></code>, and
friends should always return strict supercategories.</p>
<p>For example, to specify that a finite division ring is a finite
field, <code class="docutils literal notranslate"><span class="pre">DivisionRings.Finite_extra_super_categories</span></code> should not
return <code class="docutils literal notranslate"><span class="pre">Fields().Finite()</span></code>! It could possibly return <code class="docutils literal notranslate"><span class="pre">Fields()</span></code>;
but it’s preferable to return the largest category that contains the
relevant information, in this case <code class="docutils literal notranslate"><span class="pre">Magmas().Commutative()</span></code>, and
to let the infrastructure apply the derivations.</p>
</li>
<li><p>The base category of a <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom" title="sage.categories.category_with_axiom.CategoryWithAxiom"><code class="xref py py-class docutils literal notranslate"><span class="pre">CategoryWithAxiom</span></code></a> should be an
implemented category (i.e. not a
<a class="reference internal" href="category.html#sage.categories.category.JoinCategory" title="sage.categories.category.JoinCategory"><code class="xref py py-class docutils literal notranslate"><span class="pre">JoinCategory</span></code></a>). This is checked by
<a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom._test_category_with_axiom" title="sage.categories.category_with_axiom.CategoryWithAxiom._test_category_with_axiom"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CategoryWithAxiom._test_category_with_axiom()</span></code></a>.</p></li>
<li><p>Arborescent structure: Let <code class="docutils literal notranslate"><span class="pre">Cs()</span></code> be a category, and <span class="math notranslate nohighlight">\(S\)</span> be some
set of axioms defined in some super categories of <code class="docutils literal notranslate"><span class="pre">Cs()</span></code> but not
satisfied by <code class="docutils literal notranslate"><span class="pre">Cs()</span></code>. Suppose we want to provide a category with
axiom for the elements of <code class="docutils literal notranslate"><span class="pre">Cs()</span></code> satisfying the axioms in
<span class="math notranslate nohighlight">\(S\)</span>. Then, there should be a single enumeration <code class="docutils literal notranslate"><span class="pre">A1,</span> <span class="pre">A2,</span> <span class="pre">...,</span> <span class="pre">Ak</span></code>
without repetition of axioms in <span class="math notranslate nohighlight">\(S\)</span> such that
<code class="docutils literal notranslate"><span class="pre">Cs.A1.A2....Ak</span></code> is an implemented category.
Furthermore, every intermediate step
<code class="docutils literal notranslate"><span class="pre">Cs.A1.A2....Ai</span></code> with <span class="math notranslate nohighlight">\(i\leq k\)</span> should be a category with axiom
having <code class="docutils literal notranslate"><span class="pre">Ai</span></code> as axiom and <code class="docutils literal notranslate"><span class="pre">Cs.A1.A2....Ai-1</span></code> as base category
class; this base category class should not satisfy <code class="docutils literal notranslate"><span class="pre">Ai</span></code>. In
particular, when some axioms of <span class="math notranslate nohighlight">\(S\)</span> can be deduced from previous
ones by deduction rules, they should not appear in the enumeration
<code class="docutils literal notranslate"><span class="pre">A1,</span> <span class="pre">A2,</span> <span class="pre">...,</span> <span class="pre">Ak</span></code>.</p></li>
<li><p>In particular, if <code class="docutils literal notranslate"><span class="pre">Cs()</span></code> is a category that satisfies some axiom
<code class="docutils literal notranslate"><span class="pre">A</span></code> (e.g. from one of its super categories), then it should not
implement that axiom. For example, a category class <code class="docutils literal notranslate"><span class="pre">Cs</span></code> can never
have a nested class <code class="docutils literal notranslate"><span class="pre">Cs.A.A</span></code>. Similarly, applying the
specification recursively, a category satisfying <code class="docutils literal notranslate"><span class="pre">A</span></code> cannot have a
nested class <code class="docutils literal notranslate"><span class="pre">Cs.A1.A2.A3.A</span></code> where <code class="docutils literal notranslate"><span class="pre">A1</span></code>, <code class="docutils literal notranslate"><span class="pre">A2</span></code>, <code class="docutils literal notranslate"><span class="pre">A3</span></code> are
axioms.</p></li>
<li><p>A category can only implement an axiom if this axiom is defined by
some super category. The code has not been systematically checked to
support having two super categories defining the same axiom (which
should of course have the same semantic). You are welcome to try, at
your own risk. :-)</p></li>
<li><p>When a category defines an axiom or functorial construction <code class="docutils literal notranslate"><span class="pre">A</span></code>,
this fixes the semantic of <code class="docutils literal notranslate"><span class="pre">A</span></code> for all the subcategories. In
particular, if two categories define <code class="docutils literal notranslate"><span class="pre">A</span></code>, then these categories
should be independent, and either the semantic of <code class="docutils literal notranslate"><span class="pre">A</span></code> should be
the same, or there should be no natural intersection between the two
hierarchies of subcategories.</p></li>
<li><p>Any super category of a
<a class="reference internal" href="category.html#sage.categories.category.CategoryWithParameters" title="sage.categories.category.CategoryWithParameters"><code class="xref py py-class docutils literal notranslate"><span class="pre">CategoryWithParameters</span></code></a> should either be a
<a class="reference internal" href="category.html#sage.categories.category.CategoryWithParameters" title="sage.categories.category.CategoryWithParameters"><code class="xref py py-class docutils literal notranslate"><span class="pre">CategoryWithParameters</span></code></a> or a
<a class="reference internal" href="category_singleton.html#sage.categories.category_singleton.Category_singleton" title="sage.categories.category_singleton.Category_singleton"><code class="xref py py-class docutils literal notranslate"><span class="pre">Category_singleton</span></code></a>.</p></li>
<li><p>A <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom" title="sage.categories.category_with_axiom.CategoryWithAxiom"><code class="xref py py-class docutils literal notranslate"><span class="pre">CategoryWithAxiom</span></code></a> having a
<a class="reference internal" href="category_singleton.html#sage.categories.category_singleton.Category_singleton" title="sage.categories.category_singleton.Category_singleton"><code class="xref py py-class docutils literal notranslate"><span class="pre">Category_singleton</span></code></a> as base
category should be a <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom_singleton" title="sage.categories.category_with_axiom.CategoryWithAxiom_singleton"><code class="xref py py-class docutils literal notranslate"><span class="pre">CategoryWithAxiom_singleton</span></code></a>. This is handled
automatically by <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom.__init__" title="sage.categories.category_with_axiom.CategoryWithAxiom.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CategoryWithAxiom.__init__()</span></code></a> and checked in
<a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom._test_category_with_axiom" title="sage.categories.category_with_axiom.CategoryWithAxiom._test_category_with_axiom"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CategoryWithAxiom._test_category_with_axiom()</span></code></a>.</p></li>
<li><p>A <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom" title="sage.categories.category_with_axiom.CategoryWithAxiom"><code class="xref py py-class docutils literal notranslate"><span class="pre">CategoryWithAxiom</span></code></a> having a
<a class="reference internal" href="category_types.html#sage.categories.category_types.Category_over_base_ring" title="sage.categories.category_types.Category_over_base_ring"><code class="xref py py-class docutils literal notranslate"><span class="pre">Category_over_base_ring</span></code></a> as base category should be a
<a class="reference internal" href="category_types.html#sage.categories.category_types.Category_over_base_ring" title="sage.categories.category_types.Category_over_base_ring"><code class="xref py py-class docutils literal notranslate"><span class="pre">Category_over_base_ring</span></code></a>. This currently has to be handled
by hand, using <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring" title="sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring"><code class="xref py py-class docutils literal notranslate"><span class="pre">CategoryWithAxiom_over_base_ring</span></code></a>. This is
checked in <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom._test_category_with_axiom" title="sage.categories.category_with_axiom.CategoryWithAxiom._test_category_with_axiom"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CategoryWithAxiom._test_category_with_axiom()</span></code></a>.</p></li>
</ul>
<div class="admonition-todo admonition" id="id9">
<p class="admonition-title">Todo</p>
<p>The following specifications would be desirable but are not yet
implemented:</p>
<ul>
<li><p>A functorial construction category (Graded, CartesianProducts,
…) having a <a class="reference internal" href="category_singleton.html#sage.categories.category_singleton.Category_singleton" title="sage.categories.category_singleton.Category_singleton"><code class="xref py py-class docutils literal notranslate"><span class="pre">Category_singleton</span></code></a> as base category
should be a <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom_singleton" title="sage.categories.category_with_axiom.CategoryWithAxiom_singleton"><code class="xref py py-class docutils literal notranslate"><span class="pre">CategoryWithAxiom_singleton</span></code></a>.</p>
<p>Nothing difficult to implement, but this will need to rework the
current “no subclass of a concrete class” assertion test of
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Category_singleton.__classcall__()</span></code>.</p>
</li>
<li><p>Similarly, a covariant functorial construction category having a
<a class="reference internal" href="category_types.html#sage.categories.category_types.Category_over_base_ring" title="sage.categories.category_types.Category_over_base_ring"><code class="xref py py-class docutils literal notranslate"><span class="pre">Category_over_base_ring</span></code></a> as base category should be a
<a class="reference internal" href="category_types.html#sage.categories.category_types.Category_over_base_ring" title="sage.categories.category_types.Category_over_base_ring"><code class="xref py py-class docutils literal notranslate"><span class="pre">Category_over_base_ring</span></code></a>.</p></li>
</ul>
<p>The following specification might be desirable, or not:</p>
<ul class="simple">
<li><p>A join category involving a <a class="reference internal" href="category_types.html#sage.categories.category_types.Category_over_base_ring" title="sage.categories.category_types.Category_over_base_ring"><code class="xref py py-class docutils literal notranslate"><span class="pre">Category_over_base_ring</span></code></a>
should be a <a class="reference internal" href="category_types.html#sage.categories.category_types.Category_over_base_ring" title="sage.categories.category_types.Category_over_base_ring"><code class="xref py py-class docutils literal notranslate"><span class="pre">Category_over_base_ring</span></code></a>. In the mean
time, a <code class="docutils literal notranslate"><span class="pre">base_ring</span></code> method is automatically provided for most
of those by <a class="reference internal" href="modules.html#sage.categories.modules.Modules.SubcategoryMethods.base_ring" title="sage.categories.modules.Modules.SubcategoryMethods.base_ring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Modules.SubcategoryMethods.base_ring()</span></code></a>.</p></li>
</ul>
</div>
</section>
</section>
<section id="design-goals">
<h2>Design goals<a class="headerlink" href="#design-goals" title="Permalink to this headline">¶</a></h2>
<p>As pointed out in the primer, the main design goal of the axioms
infrastructure is to subdue the potential combinatorial explosion of
the category hierarchy by letting the developer focus on implementing
a few bookshelves for which there is actual code or mathematical
information, and let Sage <em>compose dynamically and lazily</em> these
building blocks to construct the minimal hierarchy of classes needed
for the computation at hand. This allows for the infrastructure to
scale smoothly as bookshelves are added, extended, or reorganized.</p>
<p>Other design goals include:</p>
<blockquote>
<div><ul>
<li><p>Flexibility in the code layout: the category of, say, finite sets
can be implemented either within the Sets category (in a nested
class <code class="docutils literal notranslate"><span class="pre">Sets.Finite</span></code>), or in a separate file (typically in a class
<code class="docutils literal notranslate"><span class="pre">FiniteSets</span></code> in a lazily imported module
sage.categories.finite_sets).</p></li>
<li><p>Single point of truth: a theorem, like Wedderburn’s, should be
implemented in a single spot.</p></li>
<li><p>Single entry point: for example, from the entry <a class="reference internal" href="rings.html#sage.categories.rings.Rings" title="sage.categories.rings.Rings"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rings</span></code></a>, one
can explore a whole range of related categories just by applying
axioms and constructions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Rings</span><span class="p">()</span><span class="o">.</span><span class="n">Commutative</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span><span class="o">.</span><span class="n">NoZeroDivisors</span><span class="p">()</span>
<span class="go">Category of finite integral domains</span>
<span class="gp">sage: </span><span class="n">Rings</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span><span class="o">.</span><span class="n">Division</span><span class="p">()</span>
<span class="go">Category of finite enumerated fields</span>
</pre></div>
</div>
<p>This will allow for progressively getting rid of all the entries
like <a class="reference internal" href="graded_hopf_algebras_with_basis.html#sage.categories.graded_hopf_algebras_with_basis.GradedHopfAlgebrasWithBasis" title="sage.categories.graded_hopf_algebras_with_basis.GradedHopfAlgebrasWithBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradedHopfAlgebrasWithBasis</span></code></a> which are polluting the
global name space.</p>
<p>Note that this is not about precluding the existence of multiple
natural ways to construct the same category:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Groups</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span>
<span class="go">Category of finite groups</span>
<span class="gp">sage: </span><span class="n">Monoids</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span><span class="o">.</span><span class="n">Inverse</span><span class="p">()</span>
<span class="go">Category of finite groups</span>
<span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">Monoids</span><span class="p">()</span><span class="o">.</span><span class="n">Inverse</span><span class="p">()</span>
<span class="go">Category of finite groups</span>
</pre></div>
</div>
</li>
<li><p>Concise idioms for the users (adding axioms, …)</p></li>
<li><p>Concise idioms and well highlighted hierarchy of bookshelves for
the developer (especially with code folding)</p></li>
<li><p>Introspection friendly (listing the axioms, recovering the mixins)</p></li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The constructor for instances of this class takes as input the
base category. Hence, they should in principle be constructed
as:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FiniteSets</span><span class="p">(</span><span class="n">Sets</span><span class="p">())</span>
<span class="go">Category of finite sets</span>

<span class="gp">sage: </span><span class="n">Sets</span><span class="o">.</span><span class="n">Finite</span><span class="p">(</span><span class="n">Sets</span><span class="p">())</span>
<span class="go">Category of finite sets</span>
</pre></div>
</div>
<p>None of these idioms are really practical for the user. So instead,
this object is to be constructed using any of the following idioms:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">_with_axiom</span><span class="p">(</span><span class="s1">&#39;Finite&#39;</span><span class="p">)</span>
<span class="go">Category of finite sets</span>
<span class="gp">sage: </span><span class="n">FiniteSets</span><span class="p">()</span>
<span class="go">Category of finite sets</span>
<span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span>
<span class="go">Category of finite sets</span>
</pre></div>
</div>
<p>The later two are implemented using respectively
<a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom.__classcall__" title="sage.categories.category_with_axiom.CategoryWithAxiom.__classcall__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CategoryWithAxiom.__classcall__()</span></code></a> and
<a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom.__classget__" title="sage.categories.category_with_axiom.CategoryWithAxiom.__classget__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CategoryWithAxiom.__classget__()</span></code></a>.</p>
</div>
</section>
<section id="upcoming-features">
<h2>Upcoming features<a class="headerlink" href="#upcoming-features" title="Permalink to this headline">¶</a></h2>
<div class="admonition-todo admonition" id="id10">
<p class="admonition-title">Todo</p>
<ul>
<li><p>Implement compatibility axiom / functorial constructions. For
example, one would want to have:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">A.CartesianProducts() &amp; B.CartesianProducts() = (A&amp;B).CartesianProducts()</span>
</pre></div>
</div>
</li>
<li><p>Once full subcategories are implemented (see <a class="reference external" href="https://trac.sagemath.org/10668">trac ticket #10668</a>),
make the relevant categories with axioms be such. This can be
done systematically for, e.g., the axioms <code class="docutils literal notranslate"><span class="pre">Associative</span></code> or
<code class="docutils literal notranslate"><span class="pre">Commutative</span></code>, but not for the axiom <code class="docutils literal notranslate"><span class="pre">Unital</span></code>: a semigroup
morphism between two monoids need not preserve the unit.</p>
<p>Should all full subcategories be implemented in term of axioms?</p>
</li>
</ul>
</div>
</section>
<section id="algorithms">
<span id="axioms-algorithmic"></span><h2>Algorithms<a class="headerlink" href="#algorithms" title="Permalink to this headline">¶</a></h2>
<section id="computing-joins">
<h3>Computing joins<a class="headerlink" href="#computing-joins" title="Permalink to this headline">¶</a></h3>
<p>The workhorse of the axiom infrastructure is the algorithm for
computing the join <span class="math notranslate nohighlight">\(J\)</span> of a set <span class="math notranslate nohighlight">\(C_1, \ldots, C_k\)</span> of categories (see
<a class="reference internal" href="category.html#sage.categories.category.Category.join" title="sage.categories.category.Category.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Category.join()</span></code></a>). Formally, <span class="math notranslate nohighlight">\(J\)</span> is defined as the largest
constructible category such that <span class="math notranslate nohighlight">\(J \subset C_i\)</span> for all <span class="math notranslate nohighlight">\(i\)</span>, and
<span class="math notranslate nohighlight">\(J \subset C.A()\)</span> for every constructible category <span class="math notranslate nohighlight">\(C \supset J\)</span>
and any axiom <span class="math notranslate nohighlight">\(A\)</span> satisfied by <span class="math notranslate nohighlight">\(J\)</span>.</p>
<p>The join <span class="math notranslate nohighlight">\(J\)</span> is naturally computed as a closure in the lattice of
constructible categories: it starts with the <span class="math notranslate nohighlight">\(C_i\)</span>’s, gathers the set
<span class="math notranslate nohighlight">\(S\)</span> of all the axioms satisfied by them, and repeatedly adds each
axiom <span class="math notranslate nohighlight">\(A\)</span> to those categories that do not yet satisfy <span class="math notranslate nohighlight">\(A\)</span> using
<a class="reference internal" href="category.html#sage.categories.category.Category._with_axiom" title="sage.categories.category.Category._with_axiom"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Category._with_axiom()</span></code></a>. Due to deduction rules or (extra) super
categories, new categories or new axioms may appear in the
process. The process stops when each remaining category has been
combined with each axiom. In practice, only the smallest categories
are kept along the way; this is correct because adding an axiom is
covariant: <code class="docutils literal notranslate"><span class="pre">C.A()</span></code> is a subcategory of <code class="docutils literal notranslate"><span class="pre">D.A()</span></code> whenever <code class="docutils literal notranslate"><span class="pre">C</span></code> is a
subcategory of <code class="docutils literal notranslate"><span class="pre">D</span></code>.</p>
<p>As usual in such closure computations, the result does not depend on
the order of execution. Furthermore, given that adding an axiom is an
idempotent and regressive operation, the process is guaranteed to stop
in a number of steps which is bounded by the number of super
categories of <span class="math notranslate nohighlight">\(J\)</span>. In particular, it is a finite process.</p>
<div class="admonition-todo admonition" id="id11">
<p class="admonition-title">Todo</p>
<p>Detail this a bit. What could typically go wrong is a situation
where, for some category <code class="docutils literal notranslate"><span class="pre">C1</span></code>, <code class="docutils literal notranslate"><span class="pre">C1.A()</span></code> specifies a category
<code class="docutils literal notranslate"><span class="pre">C2</span></code> as super category such that <code class="docutils literal notranslate"><span class="pre">C2.A()</span></code> specifies <code class="docutils literal notranslate"><span class="pre">C3</span></code> as
super category such that …; this would clearly cause an infinite
execution. Note that this situation violates the specifications
since <code class="docutils literal notranslate"><span class="pre">C1.A()</span></code> is supposed to be a subcategory of <code class="docutils literal notranslate"><span class="pre">C2.A()</span></code>,
… so we would have an infinite increasing chain of constructible
categories.</p>
<p>It’s reasonable to assume that there is a finite number of axioms
defined in the code. There remains to use this assumption to argue
that any infinite execution of the algorithm would give rise to
such an infinite sequence.</p>
</div>
</section>
<section id="adding-an-axiom">
<h3>Adding an axiom<a class="headerlink" href="#adding-an-axiom" title="Permalink to this headline">¶</a></h3>
<p>Let <code class="docutils literal notranslate"><span class="pre">Cs</span></code> be a category and <code class="docutils literal notranslate"><span class="pre">A</span></code> an axiom defined for this
category. To compute <code class="docutils literal notranslate"><span class="pre">Cs().A()</span></code>, there are two cases.</p>
<section id="adding-an-axiom-a-to-a-category-cs-not-implementing-it">
<h4>Adding an axiom <code class="docutils literal notranslate"><span class="pre">A</span></code> to a category <code class="docutils literal notranslate"><span class="pre">Cs()</span></code> not implementing it<a class="headerlink" href="#adding-an-axiom-a-to-a-category-cs-not-implementing-it" title="Permalink to this headline">¶</a></h4>
<p>In this case, <code class="docutils literal notranslate"><span class="pre">Cs().A()</span></code> returns the join of:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Cs()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Bs().A()</span></code> for every direct super category <code class="docutils literal notranslate"><span class="pre">Bs()</span></code> of <code class="docutils literal notranslate"><span class="pre">Cs()</span></code></p></li>
<li><p>the categories appearing in <code class="docutils literal notranslate"><span class="pre">Cs().A_extra_super_categories()</span></code></p></li>
</ul>
<p>This is a highly recursive process. In fact, as such, it would run
right away into an infinite loop! Indeed, the join of <code class="docutils literal notranslate"><span class="pre">Cs()</span></code> with
<code class="docutils literal notranslate"><span class="pre">Bs().A()</span></code> would trigger the construction of <code class="docutils literal notranslate"><span class="pre">Cs().A()</span></code> and
reciprocally. To avoid this, the <a class="reference internal" href="category.html#sage.categories.category.Category.join" title="sage.categories.category.Category.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Category.join()</span></code></a> method itself
does not use <a class="reference internal" href="category.html#sage.categories.category.Category._with_axiom" title="sage.categories.category.Category._with_axiom"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Category._with_axiom()</span></code></a> to add axioms, but its
sister <a class="reference internal" href="category.html#sage.categories.category.Category._with_axiom_as_tuple" title="sage.categories.category.Category._with_axiom_as_tuple"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Category._with_axiom_as_tuple()</span></code></a>; the latter builds a
tuple of categories that should be joined together but leaves the
computation of the join to its caller, the master join calculation.</p>
</section>
<section id="adding-an-axiom-a-to-a-category-cs-implementing-it">
<h4>Adding an axiom <code class="docutils literal notranslate"><span class="pre">A</span></code> to a category <code class="docutils literal notranslate"><span class="pre">Cs()</span></code> implementing it<a class="headerlink" href="#adding-an-axiom-a-to-a-category-cs-implementing-it" title="Permalink to this headline">¶</a></h4>
<p>In this case <code class="docutils literal notranslate"><span class="pre">Cs().A()</span></code> simply constructs an instance <span class="math notranslate nohighlight">\(D\)</span> of
<code class="docutils literal notranslate"><span class="pre">Cs.A</span></code> which models the desired category. The non trivial part is
the construction of the super categories of <span class="math notranslate nohighlight">\(D\)</span>. Very much like
above, this includes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Cs()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Bs().A()</span></code> for every super category <code class="docutils literal notranslate"><span class="pre">Bs()</span></code> of <code class="docutils literal notranslate"><span class="pre">Cs()</span></code></p></li>
<li><p>the categories appearing in <code class="docutils literal notranslate"><span class="pre">D.extra_super_categories()</span></code></p></li>
</ul>
<p>This by itself may not be sufficient, due in particular to deduction
rules. On may for example discover a new axiom <code class="docutils literal notranslate"><span class="pre">A1</span></code> satisfied by
<span class="math notranslate nohighlight">\(D\)</span>, imposing to add <code class="docutils literal notranslate"><span class="pre">A1</span></code> to all of the above categories. Therefore
the super categories are computed as the join of the above categories.
Up to one twist: as is, the computation of this join would trigger
recursively a recalculation of <code class="docutils literal notranslate"><span class="pre">Cs().A()</span></code>! To avoid this,
<a class="reference internal" href="category.html#sage.categories.category.Category.join" title="sage.categories.category.Category.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Category.join()</span></code></a> is given an optional argument to specify that
the axiom <code class="docutils literal notranslate"><span class="pre">A</span></code> should <em>not</em> be applied to <code class="docutils literal notranslate"><span class="pre">Cs()</span></code>.</p>
</section>
<section id="sketch-of-proof-of-correctness-and-evaluation-of-complexity">
<h4>Sketch of proof of correctness and evaluation of complexity<a class="headerlink" href="#sketch-of-proof-of-correctness-and-evaluation-of-complexity" title="Permalink to this headline">¶</a></h4>
<p>As we have seen, this is a highly recursive process! In particular,
one needs to argue that, as long as the specifications are satisfied,
the algorithm won’t run in an infinite recursion, in particular in
case of deduction rule.</p>
<div class="topic">
<p class="topic-title">Theorem</p>
<p>Consider the construction of a category <span class="math notranslate nohighlight">\(C\)</span> by adding an axiom to
a category (or computing of a join). Let <span class="math notranslate nohighlight">\(H\)</span> be the hierarchy of
implemented categories above <span class="math notranslate nohighlight">\(C\)</span>. Let <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(m\)</span> be respectively
the number of categories and the number of inheritance edges in
<span class="math notranslate nohighlight">\(H\)</span>.</p>
<p>Assuming that the specifications are satisfied, the construction
of <span class="math notranslate nohighlight">\(C\)</span> involves constructing the categories in <span class="math notranslate nohighlight">\(H\)</span> exactly once
(and no other category), and at most <span class="math notranslate nohighlight">\(n\)</span> join calculations. In
particular, the time complexity should be, roughly speaking,
bounded by <span class="math notranslate nohighlight">\(n^2\)</span>. In particular, it’s finite.</p>
</div>
<div class="topic">
<p class="topic-title">Remark</p>
<p>It’s actually to be expected that the complexity is more of the
order of magnitude of <span class="math notranslate nohighlight">\(na+m\)</span>, where <span class="math notranslate nohighlight">\(a\)</span> is the number of axioms
satisfied by <span class="math notranslate nohighlight">\(C\)</span>. But this is to be checked in detail, in
particular due to the many category inclusion tests involved.</p>
</div>
<p>The key argument is that <a class="reference internal" href="category.html#sage.categories.category.Category.join" title="sage.categories.category.Category.join"><code class="xref py py-class docutils literal notranslate"><span class="pre">Category.join</span></code></a> cannot call itself
recursively without going through the construction of some implemented
category. In turn, the construction of some implemented category <span class="math notranslate nohighlight">\(C\)</span>
only involves constructing strictly smaller categories, and possibly a
direct join calculation whose result is strictly smaller than
<span class="math notranslate nohighlight">\(C\)</span>. This statement is obvious if <span class="math notranslate nohighlight">\(C\)</span> implements the
<code class="docutils literal notranslate"><span class="pre">super_categories</span></code> method directly, and easy to check for functorial
construction categories. It requires a proof for categories with
axioms since there is a recursive join involved.</p>
<div class="topic">
<p class="topic-title">Lemma</p>
<p>Let <span class="math notranslate nohighlight">\(C\)</span> be a category implementing an axiom <span class="math notranslate nohighlight">\(A\)</span>. Recall that the
construction of <code class="docutils literal notranslate"><span class="pre">C.A()</span></code> involves a single direct join
calculation for computing the super categories. No other direct
join calculation occur, and the calculation involves only
implemented categories that are strictly smaller than <code class="docutils literal notranslate"><span class="pre">C.A()</span></code>.</p>
</div>
<div class="topic">
<p class="topic-title">Proof</p>
<p>Let <span class="math notranslate nohighlight">\(D\)</span> be a category involved in the join calculation for the
super categories of <code class="docutils literal notranslate"><span class="pre">C.A()</span></code>, and assume by induction that <span class="math notranslate nohighlight">\(D\)</span> is
strictly smaller than <code class="docutils literal notranslate"><span class="pre">C.A()</span></code>. A category <span class="math notranslate nohighlight">\(E\)</span> newly constructed
from <span class="math notranslate nohighlight">\(D\)</span> can come from:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">D.(extra_)super_categories()</span></code></p>
<p>In this case, the specifications impose that <span class="math notranslate nohighlight">\(E\)</span> should be
strictly smaller than <span class="math notranslate nohighlight">\(D\)</span> and therefore strictly smaller than
<span class="math notranslate nohighlight">\(C\)</span>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">D.with_axiom_as_tuple('B')</span></code> or <code class="docutils literal notranslate"><span class="pre">D.B_extra_super_categories()</span></code>
for some axiom <span class="math notranslate nohighlight">\(B\)</span></p>
<p>In this case, the axiom <span class="math notranslate nohighlight">\(B\)</span> is satisfied by some subcategory of
<code class="docutils literal notranslate"><span class="pre">C.A()</span></code>, and therefore must be satisfied by <code class="docutils literal notranslate"><span class="pre">C.A()</span></code> itself.
Since adding an axiom is a regressive construction, <span class="math notranslate nohighlight">\(E\)</span> must be a
subcategory of <code class="docutils literal notranslate"><span class="pre">C.A()</span></code>. If there is equality, then <span class="math notranslate nohighlight">\(E\)</span> and
<code class="docutils literal notranslate"><span class="pre">C.A()</span></code> must have the same class, and therefore, <span class="math notranslate nohighlight">\(E\)</span> must be
directly constructed as <code class="docutils literal notranslate"><span class="pre">C.A()</span></code>. However the join construction
explicitly prevents this call.</p>
</li>
</ul>
<p>Note that a call to <code class="docutils literal notranslate"><span class="pre">D.with_axiom_as_tuple('B')</span></code> does not trigger
a direct join calculation; but of course, if <span class="math notranslate nohighlight">\(D\)</span> implements <span class="math notranslate nohighlight">\(B\)</span>,
the construction of the implemented category <code class="docutils literal notranslate"><span class="pre">E</span> <span class="pre">=</span> <span class="pre">D.B()</span></code> will
involve a strictly smaller join calculation.</p>
</div>
</section>
</section>
</section>
<section id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h2>
<p>This is the end of the axioms documentation. Congratulations on
having read that far!</p>
</section>
<section id="tests">
<h2>Tests<a class="headerlink" href="#tests" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Quite a few categories with axioms are constructed early on during
Sage’s startup. Therefore, when playing around with the
implementation of the axiom infrastructure, it is easy to break
Sage. The following sequence of tests is designed to test the
infrastructure from the ground up even in a partially broken
Sage. Please don’t remove the imports!</p>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.Bars">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sage.categories.category_with_axiom.</span></span><span class="sig-name descname"><span class="pre">Bars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.Bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="category_singleton.html#sage.categories.category_singleton.Category_singleton" title="sage.categories.category_singleton.Category_singleton"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_singleton.Category_singleton</span></code></a></p>
<p>A toy singleton category, for testing purposes.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.categories.category_with_axiom.Blahs" title="sage.categories.category_with_axiom.Blahs"><code class="xref py py-class docutils literal notranslate"><span class="pre">Blahs</span></code></a></p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.Bars.Unital_extra_super_categories">
<span class="sig-name descname"><span class="pre">Unital_extra_super_categories</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.Bars.Unital_extra_super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>Return extraneous super categories for the unital objects of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This method specifies that a unital bar is a test object.
Thus, the categories of unital bars and of unital test objects
coincide.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.category_with_axiom</span> <span class="kn">import</span> <span class="n">Bars</span><span class="p">,</span> <span class="n">TestObjects</span>
<span class="gp">sage: </span><span class="n">Bars</span><span class="p">()</span><span class="o">.</span><span class="n">Unital_extra_super_categories</span><span class="p">()</span>
<span class="go">[Category of test objects]</span>
<span class="gp">sage: </span><span class="n">Bars</span><span class="p">()</span><span class="o">.</span><span class="n">Unital</span><span class="p">()</span>
<span class="go">Category of unital test objects</span>
<span class="gp">sage: </span><span class="n">TestObjects</span><span class="p">()</span><span class="o">.</span><span class="n">Unital</span><span class="p">()</span><span class="o">.</span><span class="n">all_super_categories</span><span class="p">()</span>
<span class="go">[Category of unital test objects,</span>
<span class="go"> Category of unital blahs,</span>
<span class="go"> Category of test objects,</span>
<span class="go"> Category of bars,</span>
<span class="go"> Category of blahs,</span>
<span class="go"> Category of sets,</span>
<span class="go"> Category of sets with partial maps,</span>
<span class="go"> Category of objects]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.Bars.super_categories">
<span class="sig-name descname"><span class="pre">super_categories</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.Bars.super_categories" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.Blahs">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sage.categories.category_with_axiom.</span></span><span class="sig-name descname"><span class="pre">Blahs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.Blahs" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="category_singleton.html#sage.categories.category_singleton.Category_singleton" title="sage.categories.category_singleton.Category_singleton"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_singleton.Category_singleton</span></code></a></p>
<p>A toy singleton category, for testing purposes.</p>
<p>This is the root of a hierarchy of mathematically meaningless
categories, used for testing Sage’s category framework:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.categories.category_with_axiom.Bars" title="sage.categories.category_with_axiom.Bars"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bars</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.categories.category_with_axiom.TestObjects" title="sage.categories.category_with_axiom.TestObjects"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestObjects</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.categories.category_with_axiom.TestObjectsOverBaseRing" title="sage.categories.category_with_axiom.TestObjectsOverBaseRing"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestObjectsOverBaseRing</span></code></a></p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.Blahs.Blue_extra_super_categories">
<span class="sig-name descname"><span class="pre">Blue_extra_super_categories</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.Blahs.Blue_extra_super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>Illustrates a current limitation in the way to have an axiom
imply another one.</p>
<p>Here, we would want <code class="docutils literal notranslate"><span class="pre">Blue</span></code> to imply <code class="docutils literal notranslate"><span class="pre">Unital</span></code>, and to put
the class for the category of unital blue blahs in
<code class="docutils literal notranslate"><span class="pre">Blahs.Unital.Blue</span></code> rather than <code class="docutils literal notranslate"><span class="pre">Blahs.Blue</span></code>.</p>
<p>This currently fails because <code class="docutils literal notranslate"><span class="pre">Blahs</span></code> is the category where
the axiom <code class="docutils literal notranslate"><span class="pre">Blue</span></code> is defined, and the specifications
currently impose that a category defining an axiom should also
implement it (here in an category with axiom
<code class="docutils literal notranslate"><span class="pre">Blahs.Blue</span></code>). In practice, due to this violation of the
specifications, the axiom is lost during the join calculation.</p>
<div class="admonition-todo admonition" id="id12">
<p class="admonition-title">Todo</p>
<p>Decide whether we care about this feature. In such a
situation, we are not really defining a new axiom, but
just defining an axiom as an alias for a couple others,
which might not be that useful.</p>
</div>
<div class="admonition-todo admonition" id="id13">
<p class="admonition-title">Todo</p>
<p>Improve the infrastructure to detect and report this
violation of the specifications, if this is
easy. Otherwise, it’s not so bad: when defining an axiom A
in a category <code class="docutils literal notranslate"><span class="pre">Cs</span></code> the first thing one is supposed to
doctest is that <code class="docutils literal notranslate"><span class="pre">Cs().A()</span></code> works. So the problem should
not go unnoticed.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.Blahs.Commutative">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">Commutative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.Blahs.Commutative" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom" title="sage.categories.category_with_axiom.CategoryWithAxiom"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.Blahs.Connected">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">Connected</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.Blahs.Connected" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom" title="sage.categories.category_with_axiom.CategoryWithAxiom"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.Blahs.FiniteDimensional">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">FiniteDimensional</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.Blahs.FiniteDimensional" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom" title="sage.categories.category_with_axiom.CategoryWithAxiom"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.Blahs.Flying">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">Flying</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.Blahs.Flying" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom" title="sage.categories.category_with_axiom.CategoryWithAxiom"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.Blahs.Flying.extra_super_categories">
<span class="sig-name descname"><span class="pre">extra_super_categories</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.Blahs.Flying.extra_super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>This illustrates a way to have an axiom imply another one.</p>
<p>Here, we want <code class="docutils literal notranslate"><span class="pre">Flying</span></code> to imply <code class="docutils literal notranslate"><span class="pre">Unital</span></code>, and to put
the class for the category of unital flying blahs in
<code class="docutils literal notranslate"><span class="pre">Blahs.Flying</span></code> rather than <code class="docutils literal notranslate"><span class="pre">Blahs.Unital.Flying</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.Blahs.SubcategoryMethods">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">SubcategoryMethods</span></span><a class="headerlink" href="#sage.categories.category_with_axiom.Blahs.SubcategoryMethods" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.Blahs.SubcategoryMethods.Blue">
<span class="sig-name descname"><span class="pre">Blue</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.Blahs.SubcategoryMethods.Blue" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.Blahs.SubcategoryMethods.Commutative">
<span class="sig-name descname"><span class="pre">Commutative</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.Blahs.SubcategoryMethods.Commutative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.Blahs.SubcategoryMethods.Connected">
<span class="sig-name descname"><span class="pre">Connected</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.Blahs.SubcategoryMethods.Connected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.Blahs.SubcategoryMethods.FiniteDimensional">
<span class="sig-name descname"><span class="pre">FiniteDimensional</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.Blahs.SubcategoryMethods.FiniteDimensional" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.Blahs.SubcategoryMethods.Flying">
<span class="sig-name descname"><span class="pre">Flying</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.Blahs.SubcategoryMethods.Flying" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.Blahs.SubcategoryMethods.Unital">
<span class="sig-name descname"><span class="pre">Unital</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.Blahs.SubcategoryMethods.Unital" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.Blahs.Unital">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">Unital</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.Blahs.Unital" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom" title="sage.categories.category_with_axiom.CategoryWithAxiom"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom</span></code></a></p>
<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.Blahs.Unital.Blue">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">Blue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.Blahs.Unital.Blue" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom" title="sage.categories.category_with_axiom.CategoryWithAxiom"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.Blahs.super_categories">
<span class="sig-name descname"><span class="pre">super_categories</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.Blahs.super_categories" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.CategoryWithAxiom">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sage.categories.category_with_axiom.</span></span><span class="sig-name descname"><span class="pre">CategoryWithAxiom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.CategoryWithAxiom" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="category.html#sage.categories.category.Category" title="sage.categories.category.Category"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category.Category</span></code></a></p>
<p>An abstract class for categories obtained by adding an axiom
to a base category.</p>
<p>See the <a class="reference internal" href="primer.html#module-sage.categories.primer" title="sage.categories.primer"><code class="xref py py-mod docutils literal notranslate"><span class="pre">category</span> <span class="pre">primer</span></code></a>, and in
particular its <a class="reference internal" href="primer.html#category-primer-axioms"><span class="std std-ref">section about axioms</span></a>
for an introduction to axioms, and <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom" title="sage.categories.category_with_axiom.CategoryWithAxiom"><code class="xref py py-class docutils literal notranslate"><span class="pre">CategoryWithAxiom</span></code></a> for
how to implement axioms and the documentation of the axiom
infrastructure.</p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.CategoryWithAxiom.__classcall__">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">__classcall__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.CategoryWithAxiom.__classcall__" title="Permalink to this definition">¶</a></dt>
<dd><p>Make <code class="docutils literal notranslate"><span class="pre">FoosBar(**)</span></code> an alias for <code class="docutils literal notranslate"><span class="pre">Foos(**)._with_axiom(&quot;Bar&quot;)</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FiniteGroups</span><span class="p">()</span>
<span class="go">Category of finite groups</span>
<span class="gp">sage: </span><span class="n">ModulesWithBasis</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">Category of modules with basis over Integer Ring</span>
<span class="gp">sage: </span><span class="n">AlgebrasWithBasis</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">Category of algebras with basis over Rational Field</span>
</pre></div>
</div>
<p>This is relevant when e.g. <code class="docutils literal notranslate"><span class="pre">Foos(**)</span></code> does some non trivial
transformations:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Modules</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span> <span class="ow">is</span> <span class="n">VectorSpaces</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">Modules</span><span class="p">(</span><span class="n">QQ</span><span class="p">))</span>
<span class="go">&lt;class &#39;sage.categories.vector_spaces.VectorSpaces_with_category&#39;&gt;</span>

<span class="gp">sage: </span><span class="n">ModulesWithBasis</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span> <span class="ow">is</span> <span class="n">VectorSpaces</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">WithBasis</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">ModulesWithBasis</span><span class="p">(</span><span class="n">QQ</span><span class="p">))</span>
<span class="go">&lt;class &#39;sage.categories.vector_spaces.VectorSpaces.WithBasis_with_category&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.CategoryWithAxiom.__classget__">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">__classget__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_category_class</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.CategoryWithAxiom.__classget__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the binding behavior for categories with axioms.</p>
<p>This method implements a binding behavior on category with
axioms so that, when a category <code class="docutils literal notranslate"><span class="pre">Cs</span></code> implements an axiom
<code class="docutils literal notranslate"><span class="pre">A</span></code> with a nested class <code class="docutils literal notranslate"><span class="pre">Cs.A</span></code>, the expression <code class="docutils literal notranslate"><span class="pre">Cs().A</span></code>
evaluates to the method defining the axiom <code class="docutils literal notranslate"><span class="pre">A</span></code> and not the
nested class. See <a class="reference external" href="category-with-axiom-design">those design notes</a> for the rationale behind this
behavior.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">Infinite</span><span class="p">()</span>
<span class="go">Category of infinite sets</span>
<span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">Infinite</span>
<span class="go">Cached version of &lt;function ...Infinite at ...&gt;</span>
<span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">Infinite</span><span class="o">.</span><span class="n">f</span> <span class="o">==</span> <span class="n">Sets</span><span class="o">.</span><span class="n">SubcategoryMethods</span><span class="o">.</span><span class="n">Infinite</span><span class="o">.</span><span class="n">f</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We check that this also works when the class is implemented in
a separate file, and lazy imported:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span>
<span class="go">Cached version of &lt;function ...Finite at ...&gt;</span>
</pre></div>
</div>
<p>There is no binding behavior when accessing <code class="docutils literal notranslate"><span class="pre">Finite</span></code> or
<code class="docutils literal notranslate"><span class="pre">Infinite</span></code> from the class of the category instead of the
category itself:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sets</span><span class="o">.</span><span class="n">Finite</span>
<span class="go">&lt;class &#39;sage.categories.finite_sets.FiniteSets&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">Sets</span><span class="o">.</span><span class="n">Infinite</span>
<span class="go">&lt;class &#39;sage.categories.sets_cat.Sets.Infinite&#39;&gt;</span>
</pre></div>
</div>
<p>This method also initializes the attribute
<code class="docutils literal notranslate"><span class="pre">_base_category_class_and_axiom</span></code> if not already set:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sets</span><span class="o">.</span><span class="n">Infinite</span><span class="o">.</span><span class="n">_base_category_class_and_axiom</span>
<span class="go">(&lt;class &#39;sage.categories.sets_cat.Sets&#39;&gt;, &#39;Infinite&#39;)</span>
<span class="gp">sage: </span><span class="n">Sets</span><span class="o">.</span><span class="n">Infinite</span><span class="o">.</span><span class="n">_base_category_class_and_axiom_origin</span>
<span class="go">&#39;set by __classget__&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.CategoryWithAxiom.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.CategoryWithAxiom.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.CategoryWithAxiom._repr_object_names">
<span class="sig-name descname"><span class="pre">_repr_object_names</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.CategoryWithAxiom._repr_object_names" title="Permalink to this definition">¶</a></dt>
<dd><p>The names of the objects of this category, as used by <code class="docutils literal notranslate"><span class="pre">_repr_</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="category.html#sage.categories.category.Category._repr_object_names" title="sage.categories.category.Category._repr_object_names"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Category._repr_object_names()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FiniteSets</span><span class="p">()</span><span class="o">.</span><span class="n">_repr_object_names</span><span class="p">()</span>
<span class="go">&#39;finite sets&#39;</span>
<span class="gp">sage: </span><span class="n">AlgebrasWithBasis</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">FiniteDimensional</span><span class="p">()</span><span class="o">.</span><span class="n">_repr_object_names</span><span class="p">()</span>
<span class="go">&#39;finite dimensional algebras with basis over Rational Field&#39;</span>
<span class="gp">sage: </span><span class="n">Monoids</span><span class="p">()</span><span class="o">.</span><span class="n">_repr_object_names</span><span class="p">()</span>
<span class="go">&#39;monoids&#39;</span>
<span class="gp">sage: </span><span class="n">Semigroups</span><span class="p">()</span><span class="o">.</span><span class="n">Unital</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span><span class="o">.</span><span class="n">_repr_object_names</span><span class="p">()</span>
<span class="go">&#39;finite monoids&#39;</span>
<span class="gp">sage: </span><span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Commutative</span><span class="p">()</span><span class="o">.</span><span class="n">_repr_object_names</span><span class="p">()</span>
<span class="go">&#39;commutative algebras over Rational Field&#39;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is implemented by taking _repr_object_names from
self._without_axioms(named=True), and adding the names
of the relevant axioms in appropriate order.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.CategoryWithAxiom._repr_object_names../_static">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">_repr_object_names../_static</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">category</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axioms</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.CategoryWithAxiom._repr_object_names_static" title="Permalink to this definition">¶</a></dt>
<dd><p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">base_category</span></code> – a category</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">axioms</span></code> – a list or iterable of strings</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.category_with_axiom</span> <span class="kn">import</span> <span class="n">CategoryWithAxiom</span>
<span class="gp">sage: </span><span class="n">CategoryWithAxiom</span><span class="o">.</span><span class="n">_repr_object_names../_static</span><span class="p">(</span><span class="n">Semigroups</span><span class="p">(),</span> <span class="p">[</span><span class="s2">&quot;Flying&quot;</span><span class="p">,</span> <span class="s2">&quot;Blue&quot;</span><span class="p">])</span>
<span class="go">&#39;flying blue semigroups&#39;</span>
<span class="gp">sage: </span><span class="n">CategoryWithAxiom</span><span class="o">.</span><span class="n">_repr_object_names../_static</span><span class="p">(</span><span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">),</span> <span class="p">[</span><span class="s2">&quot;Flying&quot;</span><span class="p">,</span> <span class="s2">&quot;WithBasis&quot;</span><span class="p">,</span> <span class="s2">&quot;Blue&quot;</span><span class="p">])</span>
<span class="go">&#39;flying blue algebras with basis over Rational Field&#39;</span>
<span class="gp">sage: </span><span class="n">CategoryWithAxiom</span><span class="o">.</span><span class="n">_repr_object_names../_static</span><span class="p">(</span><span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">),</span> <span class="p">[</span><span class="s2">&quot;WithBasis&quot;</span><span class="p">])</span>
<span class="go">&#39;algebras with basis over Rational Field&#39;</span>
<span class="gp">sage: </span><span class="n">CategoryWithAxiom</span><span class="o">.</span><span class="n">_repr_object_names../_static</span><span class="p">(</span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span><span class="o">.</span><span class="n">Subquotients</span><span class="p">(),</span> <span class="p">[</span><span class="s2">&quot;Finite&quot;</span><span class="p">])</span>
<span class="go">&#39;subquotients of finite sets&#39;</span>
<span class="gp">sage: </span><span class="n">CategoryWithAxiom</span><span class="o">.</span><span class="n">_repr_object_names../_static</span><span class="p">(</span><span class="n">Monoids</span><span class="p">(),</span> <span class="p">[</span><span class="s2">&quot;Unital&quot;</span><span class="p">])</span>
<span class="go">&#39;monoids&#39;</span>
<span class="gp">sage: </span><span class="n">CategoryWithAxiom</span><span class="o">.</span><span class="n">_repr_object_names../_static</span><span class="p">(</span><span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">][</span><span class="s1">&#39;y&#39;</span><span class="p">]),</span> <span class="p">[</span><span class="s2">&quot;Flying&quot;</span><span class="p">,</span> <span class="s2">&quot;WithBasis&quot;</span><span class="p">,</span> <span class="s2">&quot;Blue&quot;</span><span class="p">])</span>
<span class="go">&#39;flying blue algebras with basis over Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Rational Field&#39;</span>
</pre></div>
</div>
<p>If the axioms is a set or frozen set, then they are first
sorted using <a class="reference internal" href="category_cy_helper.html#sage.categories.category_cy_helper.canonicalize_axioms" title="sage.categories.category_cy_helper.canonicalize_axioms"><code class="xref py py-func docutils literal notranslate"><span class="pre">canonicalize_axioms()</span></code></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">CategoryWithAxiom</span><span class="o">.</span><span class="n">_repr_object_names../_static</span><span class="p">(</span><span class="n">Semigroups</span><span class="p">(),</span> <span class="nb">set</span><span class="p">([</span><span class="s2">&quot;Finite&quot;</span><span class="p">,</span> <span class="s2">&quot;Commutative&quot;</span><span class="p">,</span> <span class="s2">&quot;Facade&quot;</span><span class="p">]))</span>
<span class="go">&#39;facade finite commutative semigroups&#39;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom._repr_object_names" title="sage.categories.category_with_axiom.CategoryWithAxiom._repr_object_names"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_repr_object_names()</span></code></a></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The logic here is shared between <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom._repr_object_names" title="sage.categories.category_with_axiom.CategoryWithAxiom._repr_object_names"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_repr_object_names()</span></code></a>
and <code class="xref py py-meth docutils literal notranslate"><span class="pre">category.JoinCategory._repr_object_names()</span></code></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.CategoryWithAxiom._test_category_with_axiom">
<span class="sig-name descname"><span class="pre">_test_category_with_axiom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.CategoryWithAxiom._test_category_with_axiom" title="Permalink to this definition">¶</a></dt>
<dd><p>Run generic tests on this category with axioms.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="../../../misc/sage/misc/sage_unittest.html#sage.misc.sage_unittest.TestSuite" title="(in Sage 9.5 Reference Manual: Utilities v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a>.</p>
</div>
<p>This check that an axiom category of a
<a class="reference internal" href="category_singleton.html#sage.categories.category_singleton.Category_singleton" title="sage.categories.category_singleton.Category_singleton"><code class="xref py py-class docutils literal notranslate"><span class="pre">Category_singleton</span></code></a> is a singleton category, and
similarwise for <a class="reference internal" href="category_types.html#sage.categories.category_types.Category_over_base_ring" title="sage.categories.category_types.Category_over_base_ring"><code class="xref py py-class docutils literal notranslate"><span class="pre">Category_over_base_ring</span></code></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span><span class="o">.</span><span class="n">_test_category_with_axiom</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Modules</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">FiniteDimensional</span><span class="p">()</span><span class="o">.</span><span class="n">_test_category_with_axiom</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.CategoryWithAxiom._without_axioms">
<span class="sig-name descname"><span class="pre">_without_axioms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">named</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.CategoryWithAxiom._without_axioms" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the category without the axioms that have been
added to create it.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span><span class="o">.</span><span class="n">_without_axioms</span><span class="p">()</span>
<span class="go">Category of sets</span>
<span class="gp">sage: </span><span class="n">Monoids</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span><span class="o">.</span><span class="n">_without_axioms</span><span class="p">()</span>
<span class="go">Category of magmas</span>
</pre></div>
</div>
<p>This is because:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Semigroups</span><span class="p">()</span><span class="o">.</span><span class="n">Unital</span><span class="p">()</span> <span class="ow">is</span> <span class="n">Monoids</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">named</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then <code class="docutils literal notranslate"><span class="pre">_without_axioms</span></code> stops at the
first category that has an explicit name of its own:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span><span class="o">.</span><span class="n">_without_axioms</span><span class="p">(</span><span class="n">named</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Category of sets</span>
<span class="gp">sage: </span><span class="n">Monoids</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span><span class="o">.</span><span class="n">_without_axioms</span><span class="p">(</span><span class="n">named</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Category of monoids</span>
</pre></div>
</div>
<p>Technically we test this by checking if the class specifies
explicitly the attribute <code class="docutils literal notranslate"><span class="pre">_base_category_class_and_axiom</span></code>
by looking up <code class="docutils literal notranslate"><span class="pre">_base_category_class_and_axiom_origin</span></code>.</p>
<p>Some more examples:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Commutative</span><span class="p">()</span><span class="o">.</span><span class="n">_without_axioms</span><span class="p">()</span>
<span class="go">Category of magmatic algebras over Rational Field</span>
<span class="gp">sage: </span><span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Commutative</span><span class="p">()</span><span class="o">.</span><span class="n">_without_axioms</span><span class="p">(</span><span class="n">named</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Category of algebras over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.CategoryWithAxiom.additional_structure">
<span class="sig-name descname"><span class="pre">additional_structure</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.CategoryWithAxiom.additional_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the additional structure defined by <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>OUTPUT: <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
<p>By default, a category with axiom defines no additional
structure.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="category.html#sage.categories.category.Category.additional_structure" title="sage.categories.category.Category.additional_structure"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Category.additional_structure()</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span><span class="o">.</span><span class="n">additional_structure</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Monoids</span><span class="p">()</span><span class="o">.</span><span class="n">additional_structure</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.CategoryWithAxiom.axioms">
<span class="sig-name descname"><span class="pre">axioms</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.CategoryWithAxiom.axioms" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the axioms known to be satisfied by all the
objects of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="category.html#sage.categories.category.Category.axioms" title="sage.categories.category.Category.axioms"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Category.axioms()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Sets</span><span class="o">.</span><span class="n">Finite</span><span class="p">();</span> <span class="n">C</span>
<span class="go">Category of finite sets</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">axioms</span><span class="p">()</span>
<span class="go">frozenset({&#39;Finite&#39;})</span>

<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Modules</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">FiniteDimensional</span><span class="p">();</span> <span class="n">C</span>
<span class="go">Category of finite dimensional vector spaces over Finite Field of size 5</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">axioms</span><span class="p">())</span>
<span class="go">[&#39;AdditiveAssociative&#39;, &#39;AdditiveCommutative&#39;, &#39;AdditiveInverse&#39;,</span>
<span class="go"> &#39;AdditiveUnital&#39;, &#39;Finite&#39;, &#39;FiniteDimensional&#39;]</span>

<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">FiniteMonoids</span><span class="p">()</span><span class="o">.</span><span class="n">Algebras</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">axioms</span><span class="p">())</span>
<span class="go">[&#39;AdditiveAssociative&#39;, &#39;AdditiveCommutative&#39;, &#39;AdditiveInverse&#39;,</span>
<span class="go"> &#39;AdditiveUnital&#39;, &#39;Associative&#39;, &#39;Distributive&#39;,</span>
<span class="go"> &#39;FiniteDimensional&#39;, &#39;Unital&#39;, &#39;WithBasis&#39;]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">FiniteMonoids</span><span class="p">()</span><span class="o">.</span><span class="n">Algebras</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">axioms</span><span class="p">())</span>
<span class="go">[&#39;AdditiveAssociative&#39;, &#39;AdditiveCommutative&#39;, &#39;AdditiveInverse&#39;,</span>
<span class="go"> &#39;AdditiveUnital&#39;, &#39;Associative&#39;, &#39;Distributive&#39;, &#39;Finite&#39;,</span>
<span class="go"> &#39;FiniteDimensional&#39;, &#39;Unital&#39;, &#39;WithBasis&#39;]</span>

<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.magmas_and_additive_magmas</span> <span class="kn">import</span> <span class="n">MagmasAndAdditiveMagmas</span>
<span class="gp">sage: </span><span class="n">MagmasAndAdditiveMagmas</span><span class="p">()</span><span class="o">.</span><span class="n">Distributive</span><span class="p">()</span><span class="o">.</span><span class="n">Unital</span><span class="p">()</span><span class="o">.</span><span class="n">axioms</span><span class="p">()</span>
<span class="go">frozenset({&#39;Distributive&#39;, &#39;Unital&#39;})</span>

<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">MagmasAndAdditiveMagmas</span><span class="p">()</span><span class="o">.</span><span class="n">Distributive</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">AdditiveAssociative</span><span class="p">()</span><span class="o">.</span><span class="n">AdditiveCommutative</span><span class="p">()</span><span class="o">.</span><span class="n">Associative</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">Unital</span><span class="p">()</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">Category of monoids</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">Unital</span><span class="p">()</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">Monoids</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.CategoryWithAxiom.base_category">
<span class="sig-name descname"><span class="pre">base_category</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.CategoryWithAxiom.base_category" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the base category of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Sets</span><span class="o">.</span><span class="n">Finite</span><span class="p">();</span> <span class="n">C</span>
<span class="go">Category of finite sets</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">base_category</span><span class="p">()</span>
<span class="go">Category of sets</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">_without_axioms</span><span class="p">()</span>
<span class="go">Category of sets</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.CategoryWithAxiom.extra_super_categories">
<span class="sig-name descname"><span class="pre">extra_super_categories</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.CategoryWithAxiom.extra_super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the extra super categories of a category with axiom.</p>
<p>Default implementation which returns <code class="docutils literal notranslate"><span class="pre">[]</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FiniteSets</span><span class="p">()</span><span class="o">.</span><span class="n">extra_super_categories</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.CategoryWithAxiom.super_categories">
<span class="sig-name descname"><span class="pre">super_categories</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.CategoryWithAxiom.super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the (immediate) super categories of
<code class="docutils literal notranslate"><span class="pre">self</span></code>, as per <a class="reference internal" href="category.html#sage.categories.category.Category.super_categories" title="sage.categories.category.Category.super_categories"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Category.super_categories()</span></code></a>.</p>
<p>This implements the property that if <code class="docutils literal notranslate"><span class="pre">As</span></code> is a subcategory
of <code class="docutils literal notranslate"><span class="pre">Bs</span></code>, then the intersection of <code class="docutils literal notranslate"><span class="pre">As</span></code> with <code class="docutils literal notranslate"><span class="pre">FiniteSets()</span></code>
is a subcategory of <code class="docutils literal notranslate"><span class="pre">As</span></code> and of the intersection of <code class="docutils literal notranslate"><span class="pre">Bs</span></code>
with <code class="docutils literal notranslate"><span class="pre">FiniteSets()</span></code>.</p>
<p>EXAMPLES:</p>
<p>A finite magma is both a magma and a finite set:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Magmas</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of magmas, Category of finite sets]</span>
</pre></div>
</div>
<p>Variants:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of sets]</span>

<span class="gp">sage: </span><span class="n">Monoids</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of monoids, Category of finite semigroups]</span>
</pre></div>
</div>
<p>EXAMPLES:</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sage.categories.category_with_axiom.</span></span><span class="sig-name descname"><span class="pre">CategoryWithAxiom_over_base_ring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom" title="sage.categories.category_with_axiom.CategoryWithAxiom"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom</span></code></a>, <a class="reference internal" href="category_types.html#sage.categories.category_types.Category_over_base_ring" title="sage.categories.category_types.Category_over_base_ring"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_types.Category_over_base_ring</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.CategoryWithAxiom_singleton">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sage.categories.category_with_axiom.</span></span><span class="sig-name descname"><span class="pre">CategoryWithAxiom_singleton</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.CategoryWithAxiom_singleton" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="category_singleton.html#sage.categories.category_singleton.Category_singleton" title="sage.categories.category_singleton.Category_singleton"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_singleton.Category_singleton</span></code></a>, <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom" title="sage.categories.category_with_axiom.CategoryWithAxiom"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.TestObjects">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sage.categories.category_with_axiom.</span></span><span class="sig-name descname"><span class="pre">TestObjects</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.TestObjects" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="category_singleton.html#sage.categories.category_singleton.Category_singleton" title="sage.categories.category_singleton.Category_singleton"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_singleton.Category_singleton</span></code></a></p>
<p>A toy singleton category, for testing purposes.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.categories.category_with_axiom.Blahs" title="sage.categories.category_with_axiom.Blahs"><code class="xref py py-class docutils literal notranslate"><span class="pre">Blahs</span></code></a></p>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.TestObjects.Commutative">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">Commutative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.TestObjects.Commutative" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom" title="sage.categories.category_with_axiom.CategoryWithAxiom"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom</span></code></a></p>
<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.TestObjects.Commutative.Facade">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">Facade</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.TestObjects.Commutative.Facade" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom" title="sage.categories.category_with_axiom.CategoryWithAxiom"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.TestObjects.Commutative.Finite">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">Finite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.TestObjects.Commutative.Finite" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom" title="sage.categories.category_with_axiom.CategoryWithAxiom"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.TestObjects.Commutative.FiniteDimensional">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">FiniteDimensional</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.TestObjects.Commutative.FiniteDimensional" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom" title="sage.categories.category_with_axiom.CategoryWithAxiom"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.TestObjects.FiniteDimensional">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">FiniteDimensional</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.TestObjects.FiniteDimensional" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom" title="sage.categories.category_with_axiom.CategoryWithAxiom"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom</span></code></a></p>
<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.TestObjects.FiniteDimensional.Finite">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">Finite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.TestObjects.FiniteDimensional.Finite" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom" title="sage.categories.category_with_axiom.CategoryWithAxiom"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.TestObjects.FiniteDimensional.Unital">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">Unital</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.TestObjects.FiniteDimensional.Unital" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom" title="sage.categories.category_with_axiom.CategoryWithAxiom"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom</span></code></a></p>
<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.TestObjects.FiniteDimensional.Unital.Commutative">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">Commutative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.TestObjects.FiniteDimensional.Unital.Commutative" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom" title="sage.categories.category_with_axiom.CategoryWithAxiom"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom</span></code></a></p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.TestObjects.Unital">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">Unital</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.TestObjects.Unital" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom" title="sage.categories.category_with_axiom.CategoryWithAxiom"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.TestObjects.super_categories">
<span class="sig-name descname"><span class="pre">super_categories</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.TestObjects.super_categories" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.TestObjectsOverBaseRing">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sage.categories.category_with_axiom.</span></span><span class="sig-name descname"><span class="pre">TestObjectsOverBaseRing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.TestObjectsOverBaseRing" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="category_types.html#sage.categories.category_types.Category_over_base_ring" title="sage.categories.category_types.Category_over_base_ring"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_types.Category_over_base_ring</span></code></a></p>
<p>A toy singleton category, for testing purposes.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.categories.category_with_axiom.Blahs" title="sage.categories.category_with_axiom.Blahs"><code class="xref py py-class docutils literal notranslate"><span class="pre">Blahs</span></code></a></p>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.TestObjectsOverBaseRing.Commutative">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">Commutative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.TestObjectsOverBaseRing.Commutative" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring" title="sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring</span></code></a></p>
<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.TestObjectsOverBaseRing.Commutative.Facade">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">Facade</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.TestObjectsOverBaseRing.Commutative.Facade" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring" title="sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.TestObjectsOverBaseRing.Commutative.Finite">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">Finite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.TestObjectsOverBaseRing.Commutative.Finite" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring" title="sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.TestObjectsOverBaseRing.Commutative.FiniteDimensional">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">FiniteDimensional</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.TestObjectsOverBaseRing.Commutative.FiniteDimensional" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring" title="sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.TestObjectsOverBaseRing.FiniteDimensional">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">FiniteDimensional</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.TestObjectsOverBaseRing.FiniteDimensional" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring" title="sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring</span></code></a></p>
<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.TestObjectsOverBaseRing.FiniteDimensional.Finite">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">Finite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.TestObjectsOverBaseRing.FiniteDimensional.Finite" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring" title="sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.TestObjectsOverBaseRing.FiniteDimensional.Unital">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">Unital</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.TestObjectsOverBaseRing.FiniteDimensional.Unital" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring" title="sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring</span></code></a></p>
<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.TestObjectsOverBaseRing.FiniteDimensional.Unital.Commutative">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">Commutative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.TestObjectsOverBaseRing.FiniteDimensional.Unital.Commutative" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring" title="sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring</span></code></a></p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.TestObjectsOverBaseRing.Unital">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">Unital</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_category</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.TestObjectsOverBaseRing.Unital" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring" title="sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.TestObjectsOverBaseRing.super_categories">
<span class="sig-name descname"><span class="pre">super_categories</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.TestObjectsOverBaseRing.super_categories" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.axiom">
<span class="sig-prename descclassname"><span class="pre">sage.categories.category_with_axiom.</span></span><span class="sig-name descname"><span class="pre">axiom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axiom</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.axiom" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a function/method <code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">-&gt;</span> <span class="pre">self._with_axiom(axiom)</span></code>.</p>
<p>This can used as a shorthand to define axioms, in particular in
the tests below. Usually one will want to attach documentation to
an axiom, so the need for such a shorthand in real life might not
be that clear, unless we start creating lots of axioms.</p>
<p>In the long run maybe this could evolve into an <code class="docutils literal notranslate"><span class="pre">&#64;axiom</span></code> decorator.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.category_with_axiom</span> <span class="kn">import</span> <span class="n">axiom</span>
<span class="gp">sage: </span><span class="n">axiom</span><span class="p">(</span><span class="s2">&quot;Finite&quot;</span><span class="p">)(</span><span class="n">Semigroups</span><span class="p">())</span>
<span class="go">Category of finite semigroups</span>
</pre></div>
</div>
<p>Upon assigning the result to a class this becomes a method:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">As</span><span class="p">:</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">_with_axiom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axiom</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="n">axiom</span>
<span class="gp">....: </span>    <span class="n">Finite</span> <span class="o">=</span> <span class="n">axiom</span><span class="p">(</span><span class="s2">&quot;Finite&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">As</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span>
<span class="go">(&lt;__main__.As ... at ...&gt;, &#39;Finite&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.axiom_of_nested_class">
<span class="sig-prename descclassname"><span class="pre">sage.categories.category_with_axiom.</span></span><span class="sig-name descname"><span class="pre">axiom_of_nested_class</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nested_cls</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.axiom_of_nested_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a class and a nested axiom class, return the axiom.</p>
<p>EXAMPLES:</p>
<p>This uses some heuristics like checking if the nested_cls carries
the name of the axiom, or is built by appending or prepending the
name of the axiom to that of the class:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.category_with_axiom</span> <span class="kn">import</span> <span class="n">TestObjects</span><span class="p">,</span> <span class="n">axiom_of_nested_class</span>
<span class="gp">sage: </span><span class="n">axiom_of_nested_class</span><span class="p">(</span><span class="n">TestObjects</span><span class="p">,</span> <span class="n">TestObjects</span><span class="o">.</span><span class="n">FiniteDimensional</span><span class="p">)</span>
<span class="go">&#39;FiniteDimensional&#39;</span>
<span class="gp">sage: </span><span class="n">axiom_of_nested_class</span><span class="p">(</span><span class="n">TestObjects</span><span class="o">.</span><span class="n">FiniteDimensional</span><span class="p">,</span> <span class="n">TestObjects</span><span class="o">.</span><span class="n">FiniteDimensional</span><span class="o">.</span><span class="n">Finite</span><span class="p">)</span>
<span class="go">&#39;Finite&#39;</span>
<span class="gp">sage: </span><span class="n">axiom_of_nested_class</span><span class="p">(</span><span class="n">Sets</span><span class="p">,</span> <span class="n">FiniteSets</span><span class="p">)</span>
<span class="go">&#39;Finite&#39;</span>
<span class="gp">sage: </span><span class="n">axiom_of_nested_class</span><span class="p">(</span><span class="n">Algebras</span><span class="p">,</span> <span class="n">AlgebrasWithBasis</span><span class="p">)</span>
<span class="go">&#39;WithBasis&#39;</span>
</pre></div>
</div>
<p>In all other cases, the nested class should provide an attribute
<code class="docutils literal notranslate"><span class="pre">_base_category_class_and_axiom</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Semigroups</span><span class="o">.</span><span class="n">_base_category_class_and_axiom</span>
<span class="go">(&lt;class &#39;sage.categories.magmas.Magmas&#39;&gt;, &#39;Associative&#39;)</span>
<span class="gp">sage: </span><span class="n">axiom_of_nested_class</span><span class="p">(</span><span class="n">Magmas</span><span class="p">,</span> <span class="n">Semigroups</span><span class="p">)</span>
<span class="go">&#39;Associative&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.base_category_class_and_axiom">
<span class="sig-prename descclassname"><span class="pre">sage.categories.category_with_axiom.</span></span><span class="sig-name descname"><span class="pre">base_category_class_and_axiom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.base_category_class_and_axiom" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to deduce the base category and the axiom from the name of <code class="docutils literal notranslate"><span class="pre">cls</span></code>.</p>
<p>The heuristic is to try to decompose the name as the concatenation
of the name of a category and the name of an axiom, and looking up
that category in the standard location (i.e. in
<a class="reference internal" href="hopf_algebras.html#module-sage.categories.hopf_algebras" title="sage.categories.hopf_algebras"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.categories.hopf_algebras</span></code></a> for <a class="reference internal" href="hopf_algebras.html#sage.categories.hopf_algebras.HopfAlgebras" title="sage.categories.hopf_algebras.HopfAlgebras"><code class="xref py py-class docutils literal notranslate"><span class="pre">HopfAlgebras</span></code></a>,
and in <a class="reference internal" href="sets_cat.html#module-sage.categories.sets_cat" title="sage.categories.sets_cat"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.categories.sets_cat</span></code></a> as a special case
for <a class="reference internal" href="sets_cat.html#sage.categories.sets_cat.Sets" title="sage.categories.sets_cat.Sets"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sets</span></code></a>).</p>
<p>If the heuristic succeeds, the result is guaranteed to be
correct. Otherwise, an error is raised.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.category_with_axiom</span> <span class="kn">import</span> <span class="n">base_category_class_and_axiom</span><span class="p">,</span> <span class="n">CategoryWithAxiom</span>
<span class="gp">sage: </span><span class="n">base_category_class_and_axiom</span><span class="p">(</span><span class="n">FiniteSets</span><span class="p">)</span>
<span class="go">(&lt;class &#39;sage.categories.sets_cat.Sets&#39;&gt;, &#39;Finite&#39;)</span>
<span class="gp">sage: </span><span class="n">Sets</span><span class="o">.</span><span class="n">Finite</span>
<span class="go">&lt;class &#39;sage.categories.finite_sets.FiniteSets&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">base_category_class_and_axiom</span><span class="p">(</span><span class="n">Sets</span><span class="o">.</span><span class="n">Finite</span><span class="p">)</span>
<span class="go">(&lt;class &#39;sage.categories.sets_cat.Sets&#39;&gt;, &#39;Finite&#39;)</span>

<span class="gp">sage: </span><span class="n">base_category_class_and_axiom</span><span class="p">(</span><span class="n">FiniteDimensionalHopfAlgebrasWithBasis</span><span class="p">)</span>
<span class="go">(&lt;class &#39;sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis&#39;&gt;, &#39;FiniteDimensional&#39;)</span>

<span class="gp">sage: </span><span class="n">base_category_class_and_axiom</span><span class="p">(</span><span class="n">HopfAlgebrasWithBasis</span><span class="p">)</span>
<span class="go">(&lt;class &#39;sage.categories.hopf_algebras.HopfAlgebras&#39;&gt;, &#39;WithBasis&#39;)</span>
</pre></div>
</div>
<p>Along the way, this does some sanity checks:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">FacadeSemigroups</span><span class="p">(</span><span class="n">CategoryWithAxiom</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">pass</span>
<span class="gp">sage: </span><span class="n">base_category_class_and_axiom</span><span class="p">(</span><span class="n">FacadeSemigroups</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">AssertionError: Missing (lazy import) link for &lt;class &#39;sage.categories.semigroups.Semigroups&#39;&gt; to &lt;class &#39;__main__.FacadeSemigroups&#39;&gt; for axiom Facade?</span>

<span class="gp">sage: </span><span class="n">Semigroups</span><span class="o">.</span><span class="n">Facade</span> <span class="o">=</span> <span class="n">FacadeSemigroups</span>
<span class="gp">sage: </span><span class="n">base_category_class_and_axiom</span><span class="p">(</span><span class="n">FacadeSemigroups</span><span class="p">)</span>
<span class="go">(&lt;class &#39;sage.categories.semigroups.Semigroups&#39;&gt;, &#39;Facade&#39;)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the following example, we could possibly retrieve <code class="docutils literal notranslate"><span class="pre">Sets</span></code>
from the class name. However this cannot be implemented
robustly until <a class="reference external" href="https://trac.sagemath.org/9107">trac ticket #9107</a> is fixed. Anyway this feature
has not been needed so far:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sets</span><span class="o">.</span><span class="n">Infinite</span>
<span class="go">&lt;class &#39;sage.categories.sets_cat.Sets.Infinite&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">base_category_class_and_axiom</span><span class="p">(</span><span class="n">Sets</span><span class="o">.</span><span class="n">Infinite</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: Could not retrieve the base category class and axiom for &lt;class &#39;sage.categories.sets_cat.Sets.Infinite&#39;&gt;.</span>
<span class="go">...</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.categories.category_with_axiom.uncamelcase">
<span class="sig-prename descclassname"><span class="pre">sage.categories.category_with_axiom.</span></span><span class="sig-name descname"><span class="pre">uncamelcase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">separator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'</span> <span class="pre">'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.category_with_axiom.uncamelcase" title="Permalink to this definition">¶</a></dt>
<dd><p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">sage</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">category_with_axiom</span><span class="o">.</span><span class="n">uncamelcase</span><span class="p">(</span><span class="s2">&quot;FiniteDimensionalAlgebras&quot;</span><span class="p">)</span>
<span class="go">&#39;finite dimensional algebras&#39;</span>
<span class="gp">sage: </span><span class="n">sage</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">category_with_axiom</span><span class="o">.</span><span class="n">uncamelcase</span><span class="p">(</span><span class="s2">&quot;JTrivialMonoids&quot;</span><span class="p">)</span>
<span class="go">&#39;j trivial monoids&#39;</span>
<span class="gp">sage: </span><span class="n">sage</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">category_with_axiom</span><span class="o">.</span><span class="n">uncamelcase</span><span class="p">(</span><span class="s2">&quot;FiniteDimensionalAlgebras&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>
<span class="go">&#39;finite_dimensional_algebras&#39;</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Axioms</a><ul>
<li><a class="reference internal" href="#implementing-axioms">Implementing axioms</a><ul>
<li><a class="reference internal" href="#simple-case-involving-a-single-predefined-axiom">Simple case involving a single predefined axiom</a><ul>
<li><a class="reference internal" href="#making-the-category-with-axiom-directly-callable">Making the category with axiom directly callable</a></li>
</ul>
</li>
<li><a class="reference internal" href="#defining-a-new-axiom">Defining a new axiom</a><ul>
<li><a class="reference internal" href="#special-case-defining-an-axiom-depending-on-several-categories">Special case: defining an axiom depending on several categories</a></li>
</ul>
</li>
<li><a class="reference internal" href="#handling-multiple-axioms-arborescence-structure-of-the-code">Handling multiple axioms, arborescence structure of the code</a><ul>
<li><a class="reference internal" href="#prelude">Prelude</a></li>
<li><a class="reference internal" href="#abstract-model">Abstract model</a></li>
<li><a class="reference internal" href="#concrete-model-as-an-arborescence-of-nested-classes">Concrete model as an arborescence of nested classes</a></li>
<li><a class="reference internal" href="#discussion-of-the-design">Discussion of the design</a><ul>
<li><a class="reference internal" href="#performance">Performance</a></li>
<li><a class="reference internal" href="#flexibility">Flexibility</a></li>
<li><a class="reference internal" href="#asymmetry">Asymmetry</a></li>
<li><a class="reference internal" href="#placeholder-classes">Placeholder classes</a></li>
<li><a class="reference internal" href="#mismatch-between-the-arborescence-of-nested-classes-and-the-hierarchy-of-categories">Mismatch between the arborescence of nested classes and the hierarchy of categories</a></li>
<li><a class="reference internal" href="#evolutivity">Evolutivity</a></li>
</ul>
</li>
<li><a class="reference internal" href="#axioms-defined-upon-other-axioms">Axioms defined upon other axioms</a></li>
<li><a class="reference internal" href="#deduction-rules">Deduction rules</a><ul>
<li><a class="reference internal" href="#special-case">Special case</a></li>
<li><a class="reference internal" href="#larger-synthetic-examples">Larger synthetic examples</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#specifications">Specifications</a><ul>
<li><a class="reference internal" href="#the-lattice-of-constructible-categories">The lattice of constructible categories</a></li>
<li><a class="reference internal" href="#id7">Axioms</a><ul>
<li><a class="reference internal" href="#a-digression-on-the-structure-of-fibers-when-adding-an-axiom">A digression on the structure of fibers when adding an axiom</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id8">Specifications</a></li>
</ul>
</li>
<li><a class="reference internal" href="#design-goals">Design goals</a></li>
<li><a class="reference internal" href="#upcoming-features">Upcoming features</a></li>
<li><a class="reference internal" href="#algorithms">Algorithms</a><ul>
<li><a class="reference internal" href="#computing-joins">Computing joins</a></li>
<li><a class="reference internal" href="#adding-an-axiom">Adding an axiom</a><ul>
<li><a class="reference internal" href="#adding-an-axiom-a-to-a-category-cs-not-implementing-it">Adding an axiom <code class="docutils literal notranslate"><span class="pre">A</span></code> to a category <code class="docutils literal notranslate"><span class="pre">Cs()</span></code> not implementing it</a></li>
<li><a class="reference internal" href="#adding-an-axiom-a-to-a-category-cs-implementing-it">Adding an axiom <code class="docutils literal notranslate"><span class="pre">A</span></code> to a category <code class="docutils literal notranslate"><span class="pre">Cs()</span></code> implementing it</a></li>
<li><a class="reference internal" href="#sketch-of-proof-of-correctness-and-evaluation-of-complexity">Sketch of proof of correctness and evaluation of complexity</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#conclusion">Conclusion</a></li>
<li><a class="reference internal" href="#tests">Tests</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="category.html"
                        title="previous chapter">Categories</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="functor.html"
                        title="next chapter">Functors</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/sage/categories/category_with_axiom.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="functor.html" title="Functors"
             >next</a> |</li>
        <li class="right" >
          <a href="category.html" title="Categories"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Sage 9.5 Reference Manual: Category Framework</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">Axioms</a></li> 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2022, The Sage Development Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.2.0.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* The sidebar toggle adapts its height to the bodywrapper height. */
    const resizeObserver = new ResizeObserver(entries => {
        tog.height(bod.height());
    });
    resizeObserver.observe(bod[0]);

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>