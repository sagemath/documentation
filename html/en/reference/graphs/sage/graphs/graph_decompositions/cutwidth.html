<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Cutwidth &mdash; Sage Reference Manual v7.1: Graph Theory</title>
    
    <link rel="stylesheet" href="../../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '7.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v7.1: Graph Theory" href="../../../index.html" />
    <link rel="next" title="Products of graphs" href="graph_products.html" />
    <link rel="prev" title="Bandwidth of undirected graphs" href="bandwidth.html" />
    <link rel="icon" href="../../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="graph_products.html" title="Products of graphs"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="bandwidth.html" title="Bandwidth of undirected graphs"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../../index.html">Graph Theory</a> &raquo;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="cutwidth">
<span id="sage-graphs-graph-decompositions-cutwidth"></span><h1>Cutwidth<a class="headerlink" href="#cutwidth" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.graphs.graph_decompositions.cutwidth"></span><p>This module implements several algorithms to compute the cutwidth of a graph and
the corresponding ordering of the vertices. It also implements tests functions
for evaluation the width of a linear ordering (or layout).</p>
<p>Given an ordering
<span class="math">\(v_1,\cdots, v_n\)</span> of the vertices of <span class="math">\(V(G)\)</span>, its <em>cost</em> is defined as:</p>
<div class="math">
\[c(v_1, ..., v_n) = \max_{1\leq i \leq n-1} c'(\{v_1, ..., v_i\})\]</div>
<p>Where</p>
<div class="math">
\[c'(S) = |\{(u,w)\in E(G)\mid u\in S\text{ and }w\in V(G)\backslash S\}|\]</div>
<p>The <em>cutwidth</em> of a graph <span class="math">\(G\)</span> is equal to the minimum cost of an ordering of its
vertices.</p>
<p><strong>This module contains the following methods</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph_decompositions.cutwidth.cutwidth" title="sage.graphs.graph_decompositions.cutwidth.cutwidth"><tt class="xref py py-meth docutils literal"><span class="pre">cutwidth()</span></tt></a></td>
<td>Return the cutwidth of the graph and the corresponding vertex ordering.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph_decompositions.cutwidth.cutwidth_dyn" title="sage.graphs.graph_decompositions.cutwidth.cutwidth_dyn"><tt class="xref py py-meth docutils literal"><span class="pre">cutwidth_dyn()</span></tt></a></td>
<td>Compute the cutwidth of <span class="math">\(G\)</span> using an exponential time and space algorithm based on dynamic programming</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph_decompositions.cutwidth.cutwidth_MILP" title="sage.graphs.graph_decompositions.cutwidth.cutwidth_MILP"><tt class="xref py py-meth docutils literal"><span class="pre">cutwidth_MILP()</span></tt></a></td>
<td>Compute the cutwidth of <span class="math">\(G\)</span> and the optimal ordering of its vertices using an MILP formulation</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph_decompositions.cutwidth.width_of_cut_decomposition" title="sage.graphs.graph_decompositions.cutwidth.width_of_cut_decomposition"><tt class="xref py py-meth docutils literal"><span class="pre">width_of_cut_decomposition()</span></tt></a></td>
<td>Return the width of the cut decomposition induced by the linear ordering <span class="math">\(L\)</span> of the vertices of <span class="math">\(G\)</span></td>
</tr>
</tbody>
</table>
<div class="section" id="exponential-algorithm-for-cutwidth">
<h2>Exponential algorithm for cutwidth<a class="headerlink" href="#exponential-algorithm-for-cutwidth" title="Permalink to this headline">¶</a></h2>
<p>In order to find an optimal ordering of the vertices for the vertex separation,
this algorithm tries to save time by computing the function <span class="math">\(c'(S)\)</span> <strong>at most
once</strong> once for each of the sets <span class="math">\(S\subseteq V(G)\)</span>. These values are stored in
an array of size <span class="math">\(2^n\)</span> where reading the value of <span class="math">\(c'(S)\)</span> or updating it can be
done in constant time.</p>
<p>Assuming that we can compute the cost of a set <span class="math">\(S\)</span> and remember it, finding an
optimal ordering is an easy task. Indeed, we can think of the sequence <span class="math">\(v_1,
..., v_n\)</span> of vertices as a sequence of <em>sets</em> <span class="math">\(\{v_1\}, \{v_1,v_2\}, ...,
\{v_1,...,v_n\}\)</span>, whose cost is precisely <span class="math">\(\max c'(\{v_1\}), c'(\{v_1,v_2\}),
... , c'(\{v_1,...,v_n\})\)</span>. Hence, when considering the digraph on the <span class="math">\(2^n\)</span>
sets <span class="math">\(S\subseteq V(G)\)</span> where there is an arc from <span class="math">\(S\)</span> to <span class="math">\(S'\)</span> if <span class="math">\(S'=S\cap
\{v\}\)</span> for some <span class="math">\(v\)</span> (that is, if the sets <span class="math">\(S\)</span> and <span class="math">\(S'\)</span> can be consecutive in a
sequence), an ordering of the vertices of <span class="math">\(G\)</span> corresponds to a <em>path</em> from
<span class="math">\(\emptyset\)</span> to <span class="math">\(\{v_1,...,v_n\}\)</span>. In this setting, checking whether there exists
a ordering of cost less than <span class="math">\(k\)</span> can be achieved by checking whether there
exists a directed path <span class="math">\(\emptyset\)</span> to <span class="math">\(\{v_1,...,v_n\}\)</span> using only sets of cost
less than <span class="math">\(k\)</span>. This is just a depth-first-search, for each <span class="math">\(k\)</span>.</p>
<p><strong>Lazy evaluation of</strong> <span class="math">\(c'\)</span></p>
<p>In the previous algorithm, most of the time is actually spent on the computation
of <span class="math">\(c'(S)\)</span> for each set <span class="math">\(S\subseteq V(G)\)</span> &#8211; i.e. <span class="math">\(2^n\)</span> computations of
neighborhoods. This can be seen as a huge waste of time when noticing that it is
useless to know that the value <span class="math">\(c'(S)\)</span> for a set <span class="math">\(S\)</span> is less than <span class="math">\(k\)</span> if all the
paths leading to <span class="math">\(S\)</span> have a cost greater than <span class="math">\(k\)</span>. For this reason, the value of
<span class="math">\(c'(S)\)</span> is computed lazily during the depth-first search. Explanation :</p>
<p>When the depth-first search discovers a set of size less than <span class="math">\(k\)</span>, the costs of
its out-neighbors (the potential sets that could follow it in the optimal
ordering) are evaluated. When an out-neighbor is found that has a cost smaller
than <span class="math">\(k\)</span>, the depth-first search continues with this set, which is explored with
the hope that it could lead to a path toward <span class="math">\(\{v_1,...,v_n\}\)</span>. On the other
hand, if an out-neighbour has a cost larger than <span class="math">\(k\)</span> it is useless to attempt to
build a cheap sequence going though this set, and the exploration stops
there. This way, a large number of sets will never be evaluated and <em>a lot</em> of
computational time is saved this way.</p>
<p>Besides, some improvement is also made by &#8220;improving&#8221; the values found by
<span class="math">\(c'\)</span>. Indeed, <span class="math">\(c'(S)\)</span> is a lower bound on the cost of a sequence containing the
set <span class="math">\(S\)</span>, but if all out-neighbors of <span class="math">\(S\)</span> have a cost of <span class="math">\(c'(S) + 5\)</span> then one
knows that having <span class="math">\(S\)</span> in a sequence means a total cost of at least <span class="math">\(c'(S) +
5\)</span>. For this reason, for each set <span class="math">\(S\)</span> we store the value of <span class="math">\(c'(S)\)</span>, and replace
it by <span class="math">\(\max (c'(S), \min_{\text{next}})\)</span> (where <span class="math">\(\min_{\text{next}}\)</span> is the
minimum of the costs of the out-neighbors of <span class="math">\(S\)</span>) once the costs of these
out-neighbors have been evaluated by the algorithm.</p>
<p>This algorithm and its implementation are very similar to
<a class="reference internal" href="vertex_separation.html#sage.graphs.graph_decompositions.vertex_separation.vertex_separation_exp" title="sage.graphs.graph_decompositions.vertex_separation.vertex_separation_exp"><tt class="xref py py-meth docutils literal"><span class="pre">sage.graphs.graph_decompositions.vertex_separation.vertex_separation_exp()</span></tt></a>.
The main difference is in the computation of <span class="math">\(c'(S)\)</span>. See the <a class="reference internal" href="vertex_separation.html#module-sage.graphs.graph_decompositions.vertex_separation" title="sage.graphs.graph_decompositions.vertex_separation"><tt class="xref py py-mod docutils literal"><span class="pre">vertex</span>
<span class="pre">separation</span> <span class="pre">module's</span> <span class="pre">documentation</span></tt></a> for more details on this
algorithm.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Because of its current implementation, this algorithm only works on graphs
on strictly less than 32 vertices. This can be changed to 64 if necessary,
but 32 vertices already require 4GB of memory.</p>
</div>
</div>
<div class="section" id="milp-formulation-for-the-cutwidth">
<h2>MILP formulation for the cutwidth<a class="headerlink" href="#milp-formulation-for-the-cutwidth" title="Permalink to this headline">¶</a></h2>
<p>We describe a mixed integer linear program (MILP) for determining an
optimal layout for the cutwidth of <span class="math">\(G\)</span>.</p>
<p><strong>Variables:</strong></p>
<ul class="simple">
<li><span class="math">\(x_v^k\)</span> &#8211; Variable set to 1 if vertex <span class="math">\(v\)</span> is placed in the ordering at
position <span class="math">\(i\)</span> with <span class="math">\(i\leq k\)</span>, and 0 otherwise.</li>
<li><span class="math">\(y_{u,v}^{k}\)</span> &#8211; Variable set to 1 if one of <span class="math">\(u\)</span> or <span class="math">\(v\)</span> is at a position
<span class="math">\(i\leq k\)</span> and the other is at a position <span class="math">\(j&gt;k\)</span>, and so we have to count edge
<span class="math">\(uv\)</span> at position <span class="math">\(k\)</span>. Otherwise, <span class="math">\(y_{u,v}^{k}=0\)</span>. The value of <span class="math">\(y_{u,v}^{k}\)</span>
is a xor of the values of <span class="math">\(x_u^k\)</span> and <span class="math">\(x_v^k\)</span>.</li>
<li><span class="math">\(z\)</span> &#8211; Objective value to minimize. It is equal to the maximum over all
position <span class="math">\(k\)</span> of the number of edges with one extremity at position at most <span class="math">\(k\)</span>
and the other at position stricly more than <span class="math">\(k\)</span>, that is <span class="math">\(\sum_{uv\in
E}y_{u,v}^{k}\)</span>.</li>
</ul>
<p><strong>MILP formulation:</strong></p>
<div class="math">
\[\begin{alignat*}{2}
\intertext{Minimize:}
&z&\\
\intertext{Subject to:}
\sum_{i=0}^{k-1}x_v^i &\leq k*x_v^{k} & \forall v\in V,\ k\in[1,n-1] \quad(1)\\
x_v^n & =1  & \quad \forall v\in V \quad(2)\\
\sum_{v\in V}x_v^k & = k+1 &\quad  \forall k\in[0,n-1] \quad(3)\\
x_u^k - x_v^k & \leq y_{u,v}^k &\quad  \forall uv\in E,\ \forall k\in[0,n-1]  \quad(4)\\
x_v^k - x_u^k & \leq y_{u,v}^k &\quad  \forall uv\in E,\ \forall k\in[0,n-1] \quad(5)\\
\sum_{uv\in E}y_{u,v}^k &\leq z &\quad  \forall k\in[0,n-1] \quad(6)\\
0 \leq z &\leq |E|
\end{alignat*}\]</div><p>Constraints (1)-(3) ensure that all vertices have a distinct position.
Constraints (4)-(5) force variable <span class="math">\(y_{u,v}^k\)</span> to 1 if the edge is in the cut.
Constraint (6) count the number of edges starting at position at most <span class="math">\(k\)</span> and
ending at a position stricly larger than <span class="math">\(k\)</span>.</p>
<p>This formulation corresponds to method <a class="reference internal" href="#sage.graphs.graph_decompositions.cutwidth.cutwidth_MILP" title="sage.graphs.graph_decompositions.cutwidth.cutwidth_MILP"><tt class="xref py py-meth docutils literal"><span class="pre">cutwidth_MILP()</span></tt></a>.</p>
</div>
<div class="section" id="authors">
<h2>Authors<a class="headerlink" href="#authors" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>David Coudert (2015-06): Initial version</li>
</ul>
</div>
<div class="section" id="methods">
<h2>Methods<a class="headerlink" href="#methods" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="sage.graphs.graph_decompositions.cutwidth.cutwidth">
<tt class="descclassname">sage.graphs.graph_decompositions.cutwidth.</tt><tt class="descname">cutwidth</tt><big>(</big><em>G</em>, <em>algorithm='exponential'</em>, <em>cut_off=0</em>, <em>solver=None</em>, <em>verbose=False</em><big>)</big><a class="headerlink" href="#sage.graphs.graph_decompositions.cutwidth.cutwidth" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cutwidth of the graph and the corresponding vertex ordering.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">G</span></tt> &#8211; a Graph or a DiGraph</li>
<li><tt class="docutils literal"><span class="pre">algorithm</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">&quot;exponential&quot;</span></tt>) Specify the algorithm to use
among<ul>
<li><tt class="docutils literal"><span class="pre">exponential</span></tt> &#8211; Use an exponential time and space algorithm based on
dynamic programming. This algorithm only works on graphs with strictly
less than 32 vertices.</li>
<li><tt class="docutils literal"><span class="pre">MILP</span></tt> &#8211; Use a mixed integer linear programming formulation. This
algorithm has no size restriction but could take a very long time.</li>
</ul>
</li>
<li><tt class="docutils literal"><span class="pre">cut_off</span></tt> &#8211; (default: 0) This parameter is used to stop the search as
soon as a solution with width at most <tt class="docutils literal"><span class="pre">cut_off</span></tt> is found, if any. If
this bound cannot be reached, the best solution found is returned.</li>
<li><tt class="docutils literal"><span class="pre">solver</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) Specify a Linear Program (LP) solver to
be used. If set to <tt class="docutils literal"><span class="pre">None</span></tt>, the default one is used. This parameter is
used only when <tt class="docutils literal"><span class="pre">algorithm='MILP'</span></tt>. For more information on LP solvers
and which default solver is used, see the method
<a class="reference external" href="../../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-meth docutils literal"><span class="pre">solve</span></tt></a> of the
class
<a class="reference external" href="../../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">MixedIntegerLinearProgram</span></tt></a>.</li>
<li><tt class="docutils literal"><span class="pre">verbose</span></tt> (boolean) &#8211; whether to display information on the
computations.</li>
</ul>
<p>OUTPUT:</p>
<p>A pair <tt class="docutils literal"><span class="pre">(cost,</span> <span class="pre">ordering)</span></tt> representing the optimal ordering of the
vertices and its cost.</p>
<p>EXAMPLES:</p>
<p>Cutwidth of a Complete Graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions.cutwidth</span> <span class="kn">import</span> <span class="n">cutwidth</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">cw</span><span class="p">,</span><span class="n">L</span> <span class="o">=</span> <span class="n">cutwidth</span><span class="p">(</span><span class="n">G</span><span class="p">);</span> <span class="n">cw</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">cw</span><span class="p">,</span><span class="n">L</span> <span class="o">=</span> <span class="n">cutwidth</span><span class="p">(</span><span class="n">K</span><span class="p">);</span> <span class="n">cw</span>
<span class="go">9</span>
<span class="gp">sage: </span><span class="n">cw</span><span class="p">,</span><span class="n">L</span> <span class="o">=</span> <span class="n">cutwidth</span><span class="p">(</span><span class="n">K</span><span class="o">+</span><span class="n">K</span><span class="p">);</span> <span class="n">cw</span>
<span class="go">9</span>
</pre></div>
</div>
<p>The cutwidth of a <span class="math">\(p\times q\)</span> Grid Graph with <span class="math">\(p\leq q\)</span> is <span class="math">\(p+1\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions.cutwidth</span> <span class="kn">import</span> <span class="n">cutwidth</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">cw</span><span class="p">,</span><span class="n">L</span> <span class="o">=</span> <span class="n">cutwidth</span><span class="p">(</span><span class="n">G</span><span class="p">);</span> <span class="n">cw</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">cw</span><span class="p">,</span><span class="n">L</span> <span class="o">=</span> <span class="n">cutwidth</span><span class="p">(</span><span class="n">G</span><span class="p">);</span> <span class="n">cw</span>
<span class="go">4</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Comparison of algorithms:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions.cutwidth</span> <span class="kn">import</span> <span class="n">cutwidth</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>  <span class="c1"># long test</span>
<span class="go">....:     G = graphs.RandomGNP(7, 0.3)</span>
<span class="go">....:     ve, le = cutwidth(G, algorithm=&quot;exponential&quot;)</span>
<span class="go">....:     vm, lm = cutwidth(G, algorithm=&quot;MILP&quot;, solver=&#39;GLPK&#39;)</span>
<span class="go">....:     if ve != vm:</span>
<span class="go">....:        print &quot;Something goes wrong!&quot;</span>
</pre></div>
</div>
<p>Given a wrong algorithm:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions.cutwidth</span> <span class="kn">import</span> <span class="n">cutwidth</span>
<span class="gp">sage: </span><span class="n">cutwidth</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;SuperFast&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Algorithm &quot;SuperFast&quot; has not been implemented yet. Please contribute.</span>
</pre></div>
</div>
<p>Given anything else than a Graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions.cutwidth</span> <span class="kn">import</span> <span class="n">cutwidth</span>
<span class="gp">sage: </span><span class="n">cutwidth</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The parameter must be a Graph.</span>
</pre></div>
</div>
<p>Giving a wrong type cut off:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions.cutwidth</span> <span class="kn">import</span> <span class="n">cutwidth</span>
<span class="gp">sage: </span><span class="n">cutwidth</span><span class="p">(</span><span class="n">Graph</span><span class="p">(),</span> <span class="n">cut_off</span><span class="o">=</span><span class="s1">&#39;toto&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The specified cut off parameter must be an integer.</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.graphs.graph_decompositions.cutwidth.cutwidth_MILP">
<tt class="descclassname">sage.graphs.graph_decompositions.cutwidth.</tt><tt class="descname">cutwidth_MILP</tt><big>(</big><em>G</em>, <em>lower_bound=0</em>, <em>solver=None</em>, <em>verbose=0</em><big>)</big><a class="headerlink" href="#sage.graphs.graph_decompositions.cutwidth.cutwidth_MILP" title="Permalink to this definition">¶</a></dt>
<dd><p>MILP formulation for the cutwidth of a Graph.</p>
<p>This method uses a mixed integer linear program (MILP) for determining an
optimal layout for the cutwidth of <span class="math">\(G\)</span>. See the <a class="reference internal" href="#module-sage.graphs.graph_decompositions.cutwidth" title="sage.graphs.graph_decompositions.cutwidth"><tt class="xref py py-mod docutils literal"><span class="pre">module's</span> <span class="pre">documentation</span></tt></a> for more details on this MILP
formulation.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">G</span></tt> &#8211; a Graph</li>
<li><tt class="docutils literal"><span class="pre">lower_bound</span></tt> &#8211; (default: 0) the algorithm searches for a solution with
cost larger or equal to <tt class="docutils literal"><span class="pre">lower_bound</span></tt>. If the given bound is larger than
the optimal solution the returned solution might not be optimal. If the
given bound is too high, the algorithm might not be able to find a
feasible solution.</li>
<li><tt class="docutils literal"><span class="pre">solver</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) Specify a Linear Program (LP) solver to
be used. If set to <tt class="docutils literal"><span class="pre">None</span></tt>, the default one is used. For more information
on LP solvers and which default solver is used, see the method
<a class="reference external" href="../../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-meth docutils literal"><span class="pre">solve</span></tt></a> of the
class
<a class="reference external" href="../../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">MixedIntegerLinearProgram</span></tt></a>.</li>
<li><tt class="docutils literal"><span class="pre">verbose</span></tt> &#8211; integer (default: <tt class="docutils literal"><span class="pre">0</span></tt>). Sets the level of verbosity. Set
to 0 by default, which means quiet.</li>
</ul>
<p>OUTPUT:</p>
<p>A pair <tt class="docutils literal"><span class="pre">(cost,</span> <span class="pre">ordering)</span></tt> representing the optimal ordering of the
vertices and its cost.</p>
<p>EXAMPLE:</p>
<p>Cutwidth of a Cycle graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions</span> <span class="kn">import</span> <span class="n">cutwidth</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">cw</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">cutwidth</span><span class="o">.</span><span class="n">cutwidth_MILP</span><span class="p">(</span><span class="n">G</span><span class="p">);</span> <span class="n">cw</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">cw</span> <span class="o">==</span> <span class="n">cutwidth</span><span class="o">.</span><span class="n">width_of_cut_decomposition</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">cwe</span><span class="p">,</span> <span class="n">Le</span> <span class="o">=</span> <span class="n">cutwidth</span><span class="o">.</span><span class="n">cutwidth_dyn</span><span class="p">(</span><span class="n">G</span><span class="p">);</span> <span class="n">cwe</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Cutwidth of a Complete graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions</span> <span class="kn">import</span> <span class="n">cutwidth</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">cw</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">cutwidth</span><span class="o">.</span><span class="n">cutwidth_MILP</span><span class="p">(</span><span class="n">G</span><span class="p">);</span> <span class="n">cw</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">cw</span> <span class="o">==</span> <span class="n">cutwidth</span><span class="o">.</span><span class="n">width_of_cut_decomposition</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Cutwidth of a Path graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions</span> <span class="kn">import</span> <span class="n">cutwidth</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">cw</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">cutwidth</span><span class="o">.</span><span class="n">cutwidth_MILP</span><span class="p">(</span><span class="n">G</span><span class="p">);</span> <span class="n">cw</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">cw</span> <span class="o">==</span> <span class="n">cutwidth</span><span class="o">.</span><span class="n">width_of_cut_decomposition</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Comparison with exponential algorithm:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions</span> <span class="kn">import</span> <span class="n">cutwidth</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>  <span class="c1"># long test</span>
<span class="go">....:     G = graphs.RandomGNP(7, 0.3)</span>
<span class="go">....:     ve, le = cutwidth.cutwidth_dyn(G)</span>
<span class="go">....:     vm, lm = cutwidth.cutwidth_MILP(G, solver=&#39;GLPK&#39;)</span>
<span class="go">....:     if ve != vm:</span>
<span class="go">....:        print &quot;The solution is not optimal!&quot;</span>
</pre></div>
</div>
<p>Giving a too large lower bound:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions.cutwidth</span> <span class="kn">import</span> <span class="n">cutwidth_MILP</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">cutwidth_MILP</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">lower_bound</span><span class="o">=</span><span class="n">G</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">MIPSolverException</span>: <span class="n">...</span>
</pre></div>
</div>
<p>Giving anything else than a Graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions.cutwidth</span> <span class="kn">import</span> <span class="n">cutwidth_MILP</span>
<span class="gp">sage: </span><span class="n">cutwidth_MILP</span><span class="p">([])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The first input parameter must be a Graph.</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.graphs.graph_decompositions.cutwidth.cutwidth_dyn">
<tt class="descclassname">sage.graphs.graph_decompositions.cutwidth.</tt><tt class="descname">cutwidth_dyn</tt><big>(</big><em>G</em>, <em>lower_bound=0</em><big>)</big><a class="headerlink" href="#sage.graphs.graph_decompositions.cutwidth.cutwidth_dyn" title="Permalink to this definition">¶</a></dt>
<dd><p>Dynamic programming algorithm for the cutwidth of a Graph.</p>
<p>This function uses dynamic programming algorithm for determining an optimal
layout for the cutwidth of <span class="math">\(G\)</span>. See the <a class="reference internal" href="#module-sage.graphs.graph_decompositions.cutwidth" title="sage.graphs.graph_decompositions.cutwidth"><tt class="xref py py-mod docutils literal"><span class="pre">module's</span> <span class="pre">documentation</span></tt></a> for more details on this
method.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">G</span></tt> &#8211; a Graph</li>
<li><tt class="docutils literal"><span class="pre">lower_bound</span></tt> &#8211; (default: 0) the algorithm returns immediately if it
finds a solution lower or equal to <tt class="docutils literal"><span class="pre">lower_bound</span></tt> (in which case it may
not be optimal).</li>
</ul>
<p>OUTPUT:</p>
<p>A pair <tt class="docutils literal"><span class="pre">(cost,</span> <span class="pre">ordering)</span></tt> representing the optimal ordering of the
vertices and its cost.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Because of its current implementation, this algorithm only works on
graphs on strictly less than 32 vertices. This can be changed to 63 if
necessary, but 32 vertices already require 4GB of memory.</p>
</div>
<p>TESTS:</p>
<p>Giving anything else than a Graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions</span> <span class="kn">import</span> <span class="n">cutwidth</span>
<span class="gp">sage: </span><span class="n">cutwidth</span><span class="o">.</span><span class="n">cutwidth_dyn</span><span class="p">([])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The parameter must be a Graph.</span>
</pre></div>
</div>
<p>Giving a too large Graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions</span> <span class="kn">import</span> <span class="n">cutwidth</span>
<span class="gp">sage: </span><span class="n">cutwidth</span><span class="o">.</span><span class="n">cutwidth_dyn</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The graph should have at most 31 vertices !</span>
</pre></div>
</div>
<p>Giving a wrong type lower bound:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions</span> <span class="kn">import</span> <span class="n">cutwidth</span>
<span class="gp">sage: </span><span class="n">cutwidth</span><span class="o">.</span><span class="n">cutwidth_dyn</span><span class="p">(</span><span class="n">Graph</span><span class="p">(),</span> <span class="n">lower_bound</span><span class="o">=</span><span class="s1">&#39;toto&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The specified lower bound must be an integer.</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.graphs.graph_decompositions.cutwidth.width_of_cut_decomposition">
<tt class="descclassname">sage.graphs.graph_decompositions.cutwidth.</tt><tt class="descname">width_of_cut_decomposition</tt><big>(</big><em>G</em>, <em>L</em><big>)</big><a class="headerlink" href="#sage.graphs.graph_decompositions.cutwidth.width_of_cut_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the width of the cut decomposition induced by the linear ordering
<span class="math">\(L\)</span> of the vertices of <span class="math">\(G\)</span>.</p>
<p>If <span class="math">\(G\)</span> is an instance of <a class="reference internal" href="../graph.html#module-sage.graphs.graph" title="sage.graphs.graph"><tt class="xref py py-mod docutils literal"><span class="pre">Graph</span></tt></a>, this function
returns the width <span class="math">\(cw_L(G)\)</span> of the cut decomposition induced by the linear
ordering <span class="math">\(L\)</span> of the vertices of <span class="math">\(G\)</span>.</p>
<div class="math">
\[\begin{split}cw_L(G) =  \max_{0\leq i&lt; |V|-1} |\{(u,w)\in E(G)\mid u\in L[:i]\text{ and }w\in V(G)\setminus L[:i]\}|\end{split}\]</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">G</span></tt> &#8211; a Graph</li>
<li><tt class="docutils literal"><span class="pre">L</span></tt> &#8211; a linear ordering of the vertices of <tt class="docutils literal"><span class="pre">G</span></tt></li>
</ul>
<p>EXAMPLES:</p>
<p>Cut decomposition of a Cycle graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions</span> <span class="kn">import</span> <span class="n">cutwidth</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">cutwidth</span><span class="o">.</span><span class="n">width_of_cut_decomposition</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Cut decomposition of a Path graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions</span> <span class="kn">import</span> <span class="n">cutwidth</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">cutwidth</span><span class="o">.</span><span class="n">width_of_cut_decomposition</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">cutwidth</span><span class="o">.</span><span class="n">width_of_cut_decomposition</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">cutwidth</span><span class="o">.</span><span class="n">width_of_cut_decomposition</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="go">5</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Giving a wrong linear ordering:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions</span> <span class="kn">import</span> <span class="n">cutwidth</span>
<span class="gp">sage: </span><span class="n">cutwidth</span><span class="o">.</span><span class="n">width_of_cut_decomposition</span><span class="p">(</span><span class="n">Graph</span><span class="p">(),</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The input linear vertex ordering L is not valid for G.</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../../../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference internal" href="#">Cutwidth</a><ul>
<li><a class="reference internal" href="#exponential-algorithm-for-cutwidth">Exponential algorithm for cutwidth</a></li>
<li><a class="reference internal" href="#milp-formulation-for-the-cutwidth">MILP formulation for the cutwidth</a></li>
<li><a class="reference internal" href="#authors">Authors</a></li>
<li><a class="reference internal" href="#methods">Methods</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="bandwidth.html"
                                  title="previous chapter">Bandwidth of undirected graphs</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="graph_products.html"
                                  title="next chapter">Products of graphs</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../../_sources/sage/graphs/graph_decompositions/cutwidth.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="graph_products.html" title="Products of graphs"
             >next</a> |</li>
        <li class="right" >
          <a href="bandwidth.html" title="Bandwidth of undirected graphs"
             >previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../../index.html">Graph Theory</a> &raquo;</li>
 
      </ul>
    </div>
    
    <div class="footer">
        &copy; Copyright 2005--2016, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>