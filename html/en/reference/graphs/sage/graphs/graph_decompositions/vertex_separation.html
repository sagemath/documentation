
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Vertex separation &#8212; Graph Theory</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sage.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/thebelab.css" />
    
    <script data-url_root="../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
    <script async="async" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="Rank Decompositions of graphs" href="rankwidth.html" />
    <link rel="prev" title="Tree decompositions" href="tree_decomposition.html" />
  <link rel="icon" href="../../../../_static/sageicon.png" type="image/x-icon" />
  <!-- <script src="../../../../_static/thebe.js" type="text/javascript"></script> -->
  <!-- <script src="../../../../_static/thebe-sage.js" type="text/javascript"></script> -->

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="rankwidth.html" title="Rank Decompositions of graphs"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tree_decomposition.html" title="Tree decompositions"
             accesskey="P">previous</a> |</li>
  <li class="nav-item nav-item-0">
    <a href="http://www.sagemath.org"><img src="../../../../_static/logo_sagemath_black.svg" class="sage-logo" title="Sage Logo"></a>
    
      <a href="../../../../../index.html">Sage 9.6 Documentation</a> &#187;
      
      <a href="../../../../index.html">Reference Manual</a> &#187;
      
      <a href="../../../index.html">Graph Theory</a> &#187;
    
  </li>

        <li class="nav-item nav-item-this"><a href="">Vertex separation</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="vertex-separation">
<span id="sage-graphs-graph-decompositions-vertex-separation"></span><h1>Vertex separation<a class="headerlink" href="#vertex-separation" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.graphs.graph_decompositions.vertex_separation"></span><p>This module implements several algorithms to compute the vertex separation of a
digraph and the corresponding ordering of the vertices. It also implements tests
functions for evaluation the width of a linear ordering.</p>
<p>Given an ordering
<span class="math notranslate nohighlight">\(v_1,\cdots, v_n\)</span> of the vertices of <span class="math notranslate nohighlight">\(V(G)\)</span>, its <em>cost</em> is defined as:</p>
<div class="math notranslate nohighlight">
\[c(v_1, ..., v_n) = \max_{1\leq i \leq n} c'(\{v_1, ..., v_i\})\]</div>
<p>Where</p>
<div class="math notranslate nohighlight">
\[c'(S) = |N^+_G(S)\backslash S|\]</div>
<p>The <em>vertex separation</em> of a digraph <span class="math notranslate nohighlight">\(G\)</span> is equal to the minimum cost of an
ordering of its vertices.</p>
<p><strong>Vertex separation and pathwidth</strong></p>
<p>The vertex separation is defined on a digraph, but one can obtain from a graph
<span class="math notranslate nohighlight">\(G\)</span> a digraph <span class="math notranslate nohighlight">\(D\)</span> with the same vertex set, and in which each edge <span class="math notranslate nohighlight">\(uv\)</span> of <span class="math notranslate nohighlight">\(G\)</span>
is replaced by two edges <span class="math notranslate nohighlight">\(uv\)</span> and <span class="math notranslate nohighlight">\(vu\)</span> in <span class="math notranslate nohighlight">\(D\)</span>. The vertex separation of <span class="math notranslate nohighlight">\(D\)</span> is
equal to the pathwidth of <span class="math notranslate nohighlight">\(G\)</span>, and the corresponding ordering of the vertices of
<span class="math notranslate nohighlight">\(D\)</span>, also called a <em>layout</em>, encodes an optimal path-decomposition of <span class="math notranslate nohighlight">\(G\)</span>.
This is a result of Kinnersley <a class="reference internal" href="../../../../references/index.html#kin1992" id="id1"><span>[Kin1992]</span></a> and Bodlaender <a class="reference internal" href="../../../../references/index.html#bod1998" id="id2"><span>[Bod1998]</span></a>.</p>
<p><strong>This module contains the following methods</strong></p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.graph_decompositions.vertex_separation.pathwidth" title="sage.graphs.graph_decompositions.vertex_separation.pathwidth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pathwidth()</span></code></a></p></td>
<td><p>Compute the pathwidth of <code class="docutils literal notranslate"><span class="pre">self</span></code> (and provides a decomposition)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.graph_decompositions.vertex_separation.path_decomposition" title="sage.graphs.graph_decompositions.vertex_separation.path_decomposition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">path_decomposition()</span></code></a></p></td>
<td><p>Return the pathwidth of the given graph and the ordering of the vertices resulting in a corresponding path decomposition</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.graph_decompositions.vertex_separation.vertex_separation" title="sage.graphs.graph_decompositions.vertex_separation.vertex_separation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertex_separation()</span></code></a></p></td>
<td><p>Return an optimal ordering of the vertices and its cost for vertex-separation</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.graph_decompositions.vertex_separation.vertex_separation_exp" title="sage.graphs.graph_decompositions.vertex_separation.vertex_separation_exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertex_separation_exp()</span></code></a></p></td>
<td><p>Compute the vertex separation of <span class="math notranslate nohighlight">\(G\)</span> using an exponential time and space algorithm</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.graph_decompositions.vertex_separation.vertex_separation_MILP" title="sage.graphs.graph_decompositions.vertex_separation.vertex_separation_MILP"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertex_separation_MILP()</span></code></a></p></td>
<td><p>Compute the vertex separation of <span class="math notranslate nohighlight">\(G\)</span> and the optimal ordering of its vertices using an MILP formulation</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.graph_decompositions.vertex_separation.vertex_separation_BAB" title="sage.graphs.graph_decompositions.vertex_separation.vertex_separation_BAB"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertex_separation_BAB()</span></code></a></p></td>
<td><p>Compute the vertex separation of <span class="math notranslate nohighlight">\(G\)</span> and the optimal ordering of its vertices using a branch and bound algorithm</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.graph_decompositions.vertex_separation.lower_bound" title="sage.graphs.graph_decompositions.vertex_separation.lower_bound"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lower_bound()</span></code></a></p></td>
<td><p>Return a lower bound on the vertex separation of <span class="math notranslate nohighlight">\(G\)</span></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.graph_decompositions.vertex_separation.is_valid_ordering" title="sage.graphs.graph_decompositions.vertex_separation.is_valid_ordering"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_valid_ordering()</span></code></a></p></td>
<td><p>Test if the linear vertex ordering <span class="math notranslate nohighlight">\(L\)</span> is valid for (di)graph <span class="math notranslate nohighlight">\(G\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.graph_decompositions.vertex_separation.width_of_path_decomposition" title="sage.graphs.graph_decompositions.vertex_separation.width_of_path_decomposition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">width_of_path_decomposition()</span></code></a></p></td>
<td><p>Return the width of the path decomposition induced by the linear ordering <span class="math notranslate nohighlight">\(L\)</span> of the vertices of <span class="math notranslate nohighlight">\(G\)</span></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.graph_decompositions.vertex_separation.linear_ordering_to_path_decomposition" title="sage.graphs.graph_decompositions.vertex_separation.linear_ordering_to_path_decomposition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">linear_ordering_to_path_decomposition()</span></code></a></p></td>
<td><p>Return the path decomposition encoded in the ordering <span class="math notranslate nohighlight">\(L\)</span></p></td>
</tr>
</tbody>
</table>
<section id="exponential-algorithm-for-vertex-separation">
<h2>Exponential algorithm for vertex separation<a class="headerlink" href="#exponential-algorithm-for-vertex-separation" title="Permalink to this headline">¶</a></h2>
<p>In order to find an optimal ordering of the vertices for the vertex separation,
this algorithm tries to save time by computing the function <span class="math notranslate nohighlight">\(c'(S)\)</span> <strong>at most
once</strong> once for each of the sets <span class="math notranslate nohighlight">\(S\subseteq V(G)\)</span>. These values are stored in
an array of size <span class="math notranslate nohighlight">\(2^n\)</span> where reading the value of <span class="math notranslate nohighlight">\(c'(S)\)</span> or updating it can be
done in constant (and small) time.</p>
<p>Assuming that we can compute the cost of a set <span class="math notranslate nohighlight">\(S\)</span> and remember it, finding an
optimal ordering is an easy task. Indeed, we can think of the sequence <span class="math notranslate nohighlight">\(v_1,
..., v_n\)</span> of vertices as a sequence of <em>sets</em> <span class="math notranslate nohighlight">\(\{v_1\}, \{v_1,v_2\}, ...,
\{v_1,...,v_n\}\)</span>, whose cost is precisely <span class="math notranslate nohighlight">\(\max c'(\{v_1\}), c'(\{v_1,v_2\}),
... , c'(\{v_1,...,v_n\})\)</span>. Hence, when considering the digraph on the <span class="math notranslate nohighlight">\(2^n\)</span>
sets <span class="math notranslate nohighlight">\(S\subseteq V(G)\)</span> where there is an arc from <span class="math notranslate nohighlight">\(S\)</span> to <span class="math notranslate nohighlight">\(S'\)</span> if <span class="math notranslate nohighlight">\(S'=S\cap
\{v\}\)</span> for some <span class="math notranslate nohighlight">\(v\)</span> (that is, if the sets <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(S'\)</span> can be consecutive in a
sequence), an ordering of the vertices of <span class="math notranslate nohighlight">\(G\)</span> corresponds to a <em>path</em> from
<span class="math notranslate nohighlight">\(\emptyset\)</span> to <span class="math notranslate nohighlight">\(\{v_1,...,v_n\}\)</span>. In this setting, checking whether there exists
a ordering of cost less than <span class="math notranslate nohighlight">\(k\)</span> can be achieved by checking whether there
exists a directed path <span class="math notranslate nohighlight">\(\emptyset\)</span> to <span class="math notranslate nohighlight">\(\{v_1,...,v_n\}\)</span> using only sets of cost
less than <span class="math notranslate nohighlight">\(k\)</span>. This is just a depth-first-search, for each <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p><strong>Lazy evaluation of</strong> <span class="math notranslate nohighlight">\(c'\)</span></p>
<p>In the previous algorithm, most of the time is actually spent on the computation
of <span class="math notranslate nohighlight">\(c'(S)\)</span> for each set <span class="math notranslate nohighlight">\(S\subseteq V(G)\)</span> – i.e. <span class="math notranslate nohighlight">\(2^n\)</span> computations of
neighborhoods. This can be seen as a huge waste of time when noticing that it is
useless to know that the value <span class="math notranslate nohighlight">\(c'(S)\)</span> for a set <span class="math notranslate nohighlight">\(S\)</span> is less than <span class="math notranslate nohighlight">\(k\)</span> if all the
paths leading to <span class="math notranslate nohighlight">\(S\)</span> have a cost greater than <span class="math notranslate nohighlight">\(k\)</span>. For this reason, the value of
<span class="math notranslate nohighlight">\(c'(S)\)</span> is computed lazily during the depth-first search. Explanation :</p>
<p>When the depth-first search discovers a set of size less than <span class="math notranslate nohighlight">\(k\)</span>, the costs of
its out-neighbors (the potential sets that could follow it in the optimal
ordering) are evaluated. When an out-neighbor is found that has a cost smaller
than <span class="math notranslate nohighlight">\(k\)</span>, the depth-first search continues with this set, which is explored with
the hope that it could lead to a path toward <span class="math notranslate nohighlight">\(\{v_1,...,v_n\}\)</span>. On the other
hand, if an out-neighbour has a cost larger than <span class="math notranslate nohighlight">\(k\)</span> it is useless to attempt to
build a cheap sequence going though this set, and the exploration stops
there. This way, a large number of sets will never be evaluated and <em>a lot</em> of
computational time is saved this way.</p>
<p>Besides, some improvement is also made by “improving” the values found by
<span class="math notranslate nohighlight">\(c'\)</span>. Indeed, <span class="math notranslate nohighlight">\(c'(S)\)</span> is a lower bound on the cost of a sequence containing the
set <span class="math notranslate nohighlight">\(S\)</span>, but if all out-neighbors of <span class="math notranslate nohighlight">\(S\)</span> have a cost of <span class="math notranslate nohighlight">\(c'(S) + 5\)</span> then one
knows that having <span class="math notranslate nohighlight">\(S\)</span> in a sequence means a total cost of at least <span class="math notranslate nohighlight">\(c'(S) +
5\)</span>. For this reason, for each set <span class="math notranslate nohighlight">\(S\)</span> we store the value of <span class="math notranslate nohighlight">\(c'(S)\)</span>, and replace
it by <span class="math notranslate nohighlight">\(\max (c'(S), \min_{\text{next}})\)</span> (where <span class="math notranslate nohighlight">\(\min_{\text{next}}\)</span> is the
minimum of the costs of the out-neighbors of <span class="math notranslate nohighlight">\(S\)</span>) once the costs of these
out-neighbors have been evaluated by the algorithm.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Because of its current implementation, this algorithm only works on graphs
on less than 32 vertices. This can be changed to 64 if necessary, but 32
vertices already require 4GB of memory. Running it on 64 bits is not
expected to be doable by the computers of the next decade <span class="math notranslate nohighlight">\(:-D\)</span></p>
</div>
<p><strong>Lower bound on the vertex separation</strong></p>
<p>One can obtain a lower bound on the vertex separation of a graph in exponential
time but <em>small</em> memory by computing once the cost of each set <span class="math notranslate nohighlight">\(S\)</span>. Indeed, the
cost of a sequence <span class="math notranslate nohighlight">\(v_1, ..., v_n\)</span> corresponding to sets <span class="math notranslate nohighlight">\(\{v_1\}, \{v_1,v_2\},
..., \{v_1,...,v_n\}\)</span> is</p>
<div class="math notranslate nohighlight">
\[\max c'(\{v_1\}),c'(\{v_1,v_2\}),...,c'(\{v_1,...,v_n\})\geq\max c'_1,...,c'_n\]</div>
<p>where <span class="math notranslate nohighlight">\(c_i\)</span> is the minimum cost of a set <span class="math notranslate nohighlight">\(S\)</span> on <span class="math notranslate nohighlight">\(i\)</span> vertices. Evaluating the
<span class="math notranslate nohighlight">\(c_i\)</span> can take time (and in particular more than the previous exact algorithm),
but it does not need much memory to run.</p>
</section>
<section id="milp-formulation-for-the-vertex-separation">
<h2>MILP formulation for the vertex separation<a class="headerlink" href="#milp-formulation-for-the-vertex-separation" title="Permalink to this headline">¶</a></h2>
<p>We describe below a mixed integer linear program (MILP) for determining an
optimal layout for the vertex separation of <span class="math notranslate nohighlight">\(G\)</span>, which is an improved version of
the formulation proposed in <a class="reference internal" href="../../../../references/index.html#sp2010" id="id3"><span>[SP2010]</span></a>. It aims at building a sequence <span class="math notranslate nohighlight">\(S_t\)</span> of
sets such that an ordering <span class="math notranslate nohighlight">\(v_1, ..., v_n\)</span> of the vertices correspond to
<span class="math notranslate nohighlight">\(S_0=\{v_1\}, S_2=\{v_1,v_2\}, ..., S_{n-1}=\{v_1,...,v_n\}\)</span>.</p>
<p><strong>Variables:</strong></p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(y_v^t\)</span> – Variable set to 1 if <span class="math notranslate nohighlight">\(v\in S_t\)</span>, and 0 otherwise. The order of
<span class="math notranslate nohighlight">\(v\)</span> in the layout is the smallest <span class="math notranslate nohighlight">\(t\)</span> such that <span class="math notranslate nohighlight">\(y_v^t==1\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(u_v^t\)</span> – Variable set to 1 if <span class="math notranslate nohighlight">\(v\not \in S_t\)</span> and <span class="math notranslate nohighlight">\(v\)</span> has an in-neighbor in
<span class="math notranslate nohighlight">\(S_t\)</span>. It is set to 0 otherwise.</p></li>
<li><p><span class="math notranslate nohighlight">\(x_v^t\)</span> – Variable set to 1 if either <span class="math notranslate nohighlight">\(v\in S_t\)</span> or if <span class="math notranslate nohighlight">\(v\)</span> has an in-neighbor
in <span class="math notranslate nohighlight">\(S_t\)</span>. It is set to 0 otherwise.</p></li>
<li><p><span class="math notranslate nohighlight">\(z\)</span> – Objective value to minimize. It is equal to the maximum over all step
<span class="math notranslate nohighlight">\(t\)</span> of the number of vertices such that <span class="math notranslate nohighlight">\(u_v^t==1\)</span>.</p></li>
</ul>
<p><strong>MILP formulation:</strong></p>
<div class="math notranslate nohighlight">
\begin{alignat}{2}
\text{Minimize:}
&amp;z&amp;\\
\text{Such that:}
x_v^t &amp;\leq x_v^{t+1}&amp; \forall v\in V,\ 0\leq t\leq n-2\\
y_v^t &amp;\leq y_v^{t+1}&amp; \forall v\in V,\ 0\leq t\leq n-2\\
y_v^t &amp;\leq x_w^t&amp; \forall v\in V,\ \forall w\in N^+(v),\ 0\leq t\leq n-1\\
\sum_{v \in V} y_v^{t} &amp;= t+1&amp; 0\leq t\leq n-1\\
x_v^t-y_v^t&amp;\leq u_v^t &amp; \forall v \in V,\ 0\leq t\leq n-1\\
\sum_{v \in V} u_v^t &amp;\leq z&amp; 0\leq t\leq n-1\\
0 \leq x_v^t &amp;\leq 1&amp; \forall v\in V,\ 0\leq t\leq n-1\\
0 \leq u_v^t &amp;\leq 1&amp; \forall v\in V,\ 0\leq t\leq n-1\\
y_v^t &amp;\in \{0,1\}&amp; \forall v\in V,\ 0\leq t\leq n-1\\
0 \leq z &amp;\leq n&amp;
\end{alignat}</div><p>The vertex separation of <span class="math notranslate nohighlight">\(G\)</span> is given by the value of <span class="math notranslate nohighlight">\(z\)</span>, and the order of
vertex <span class="math notranslate nohighlight">\(v\)</span> in the optimal layout is given by the smallest <span class="math notranslate nohighlight">\(t\)</span> for which
<span class="math notranslate nohighlight">\(y_v^t==1\)</span>.</p>
</section>
<section id="branch-and-bound-algorithm-for-the-vertex-separation">
<h2>Branch and Bound algorithm for the vertex separation<a class="headerlink" href="#branch-and-bound-algorithm-for-the-vertex-separation" title="Permalink to this headline">¶</a></h2>
<p>We describe below the principle of a branch and bound algorithm (BAB) for
determining an optimal ordering for the vertex separation of <span class="math notranslate nohighlight">\(G\)</span>, as proposed in
<a class="reference internal" href="../../../../references/index.html#cmn2014" id="id4"><span>[CMN2014]</span></a>.</p>
<p><strong>Greedy steps:</strong></p>
<p>Let us denote <span class="math notranslate nohighlight">\({\cal L}(S)\)</span> the set of all possible orderings of the vertices in
<span class="math notranslate nohighlight">\(S\)</span>, and let <span class="math notranslate nohighlight">\({\cal L}_P(S)\subseteq {\cal L}(S)\)</span> be the orderings starting with
a prefix <span class="math notranslate nohighlight">\(P\)</span>. Let also <span class="math notranslate nohighlight">\(c(L)\)</span> be the cost of the ordering <span class="math notranslate nohighlight">\(L\in{\cal L}(V)\)</span> as
defined above.</p>
<p>Given a digraph <span class="math notranslate nohighlight">\(D=(V,A)\)</span>, a set <span class="math notranslate nohighlight">\(S\subset V\)</span>, and a prefix <span class="math notranslate nohighlight">\(P\)</span>, it has been
proved in <a class="reference internal" href="../../../../references/index.html#cmn2014" id="id5"><span>[CMN2014]</span></a> that <span class="math notranslate nohighlight">\(\min_{L\in{\cal L}_P(V)} c(L) = \min_{L\in{\cal
L}_{P+v}(V)} c(L)\)</span> holds in two (non exhaustive) cases:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\text{or} \begin{cases}
N^+(v)\subseteq S\cup N^+(S)\\
v\in N^+(S)\text{ and }N^+(v)\setminus(S\cup N^+(S)) = \{w\}
\end{cases}\end{split}\]</div>
<p>In other words, if we find a vertex <span class="math notranslate nohighlight">\(v\)</span> satisfying the above conditions, the
best possible ordering with prefix <span class="math notranslate nohighlight">\(P\)</span> has the same cost as the best possible
ordering with prefix <span class="math notranslate nohighlight">\(P+v\)</span>. So we can greedily extend the prefix with vertices
satisfying the conditions which results in a significant reduction of the search
space.</p>
<p><strong>The algorithm:</strong></p>
<p>Given the current prefix <span class="math notranslate nohighlight">\(P\)</span> and the current upper bound <span class="math notranslate nohighlight">\(UB\)</span> (either an input
upper bound or the cost of the best solution found so far), apply the following
steps:</p>
<ul class="simple">
<li><p>Extend the prefix <span class="math notranslate nohighlight">\(P\)</span> into a prefix <span class="math notranslate nohighlight">\(P'\)</span> using the greedy steps as described
above.</p></li>
<li><p>Sort the vertices <span class="math notranslate nohighlight">\(v\in V\setminus P'\)</span> by increasing values of <span class="math notranslate nohighlight">\(|N^+(P+v)|\)</span>,
and prune the vertices with a value larger or equal to <span class="math notranslate nohighlight">\(UB\)</span>. Let <span class="math notranslate nohighlight">\(\Delta\)</span> be
the resulting sorted list.</p></li>
<li><p>Repeat with prefix <span class="math notranslate nohighlight">\(P'+v\)</span> for all <span class="math notranslate nohighlight">\(v\in\Delta\)</span> and keep the best found
solution.</p></li>
</ul>
<p>If a lower bound is passed to the algorithm, it will stop as soon as a solution
with cost equal to that lower bound is found.</p>
<p><strong>Storing prefixes:</strong></p>
<p>If for a prefix <span class="math notranslate nohighlight">\(P\)</span> we have <span class="math notranslate nohighlight">\(c(P)&lt;\min_{L\in{\cal L}_P(V)} c(L)=C\)</span>, then for any
permutation <span class="math notranslate nohighlight">\(P'\)</span> of <span class="math notranslate nohighlight">\(P\)</span> we have <span class="math notranslate nohighlight">\(\min_{L\in{\cal L}_{P'}(V)} c(L)\geq C\)</span>.</p>
<p>Thus, given such a prefix <span class="math notranslate nohighlight">\(P\)</span> there is no need to explore any of the orderings
starting with one of its permutations. To do so, we store <span class="math notranslate nohighlight">\(P\)</span> (as a set of
vertices) to cut branches later. See <a class="reference internal" href="../../../../references/index.html#cmn2014" id="id6"><span>[CMN2014]</span></a> for more details.</p>
<p>Since the number of stored sets can get very large, one can control the maximum
length and the maximum number of stored prefixes.</p>
</section>
<section id="authors">
<h2>Authors<a class="headerlink" href="#authors" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Nathann Cohen (2011-10): Initial version and exact exponential algorithm</p></li>
<li><p>David Coudert (2012-04): MILP formulation and tests functions</p></li>
<li><p>David Coudert (2015-01): BAB formulation and tests functions</p></li>
</ul>
</section>
<section id="methods">
<h2>Methods<a class="headerlink" href="#methods" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.graph_decompositions.vertex_separation.is_valid_ordering">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.graph_decompositions.vertex_separation.</span></span><span class="sig-name descname"><span class="pre">is_valid_ordering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph_decompositions.vertex_separation.is_valid_ordering" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the linear vertex ordering <span class="math notranslate nohighlight">\(L\)</span> is valid for (di)graph <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>A linear ordering <span class="math notranslate nohighlight">\(L\)</span> of the vertices of a (di)graph <span class="math notranslate nohighlight">\(G\)</span> is valid if all
vertices of <span class="math notranslate nohighlight">\(G\)</span> are in <span class="math notranslate nohighlight">\(L\)</span>, and if <span class="math notranslate nohighlight">\(L\)</span> contains no other vertex and no
duplicated vertices.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a Graph or a DiGraph.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">L</span></code> – an ordered list of the vertices of <code class="docutils literal notranslate"><span class="pre">G</span></code>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <span class="math notranslate nohighlight">\(L\)</span> is a valid vertex ordering for <span class="math notranslate nohighlight">\(G\)</span>, and <code class="docutils literal notranslate"><span class="pre">False</span></code>
otherwise.</p>
<p>EXAMPLES:</p>
<p>Path decomposition of a cycle:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions</span> <span class="kn">import</span> <span class="n">vertex_separation</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="n">u</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">()]</span>
<span class="gp">sage: </span><span class="n">vertex_separation</span><span class="o">.</span><span class="n">is_valid_ordering</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">vertex_separation</span><span class="o">.</span><span class="n">is_valid_ordering</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.graph_decompositions.vertex_separation.linear_ordering_to_path_decomposition">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.graph_decompositions.vertex_separation.</span></span><span class="sig-name descname"><span class="pre">linear_ordering_to_path_decomposition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph_decompositions.vertex_separation.linear_ordering_to_path_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path decomposition encoded in the ordering L</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a Graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">L</span></code> – a linear ordering for G</p></li>
</ul>
<p>OUTPUT:</p>
<p>A path graph whose vertices are the bags of the path decomposition.</p>
<p>EXAMPLES:</p>
<p>The bags of an optimal path decomposition of a path-graph have two vertices
each:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions.vertex_separation</span> <span class="kn">import</span> <span class="n">vertex_separation</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions.vertex_separation</span> <span class="kn">import</span> <span class="n">linear_ordering_to_path_decomposition</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pw</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">vertex_separation</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;BAB&quot;</span><span class="p">);</span> <span class="n">pw</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">linear_ordering_to_path_decomposition</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="go">[{0, 1}, {1, 2}, {2, 3}, {3, 4}]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="go">[({0, 1}, {1, 2}), ({1, 2}, {2, 3}), ({2, 3}, {3, 4})]</span>
</pre></div>
</div>
<p>Giving a non-optimal linear ordering:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions.vertex_separation</span> <span class="kn">import</span> <span class="n">width_of_path_decomposition</span>
<span class="gp">sage: </span><span class="n">width_of_path_decomposition</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">linear_ordering_to_path_decomposition</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[{0, 2, 3, 4}, {0, 1, 2}]</span>
</pre></div>
</div>
<p>The bags of the path decomposition of a cycle have three vertices each:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pw</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">vertex_separation</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;BAB&quot;</span><span class="p">);</span> <span class="n">pw</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">linear_ordering_to_path_decomposition</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="go">[{0, 1, 5}, {1, 2, 5}, {2, 3, 4}, {2, 4, 5}]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="go">[({0, 1, 5}, {1, 2, 5}), ({1, 2, 5}, {2, 4, 5}), ({2, 4, 5}, {2, 3, 4})]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.graph_decompositions.vertex_separation.lower_bound">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.graph_decompositions.vertex_separation.</span></span><span class="sig-name descname"><span class="pre">lower_bound</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph_decompositions.vertex_separation.lower_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a lower bound on the vertex separation of <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a Graph or a DiGraph</p></li>
</ul>
<p>OUTPUT:</p>
<p>A lower bound on the vertex separation of <span class="math notranslate nohighlight">\(D\)</span> (see the module’s
documentation).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method runs in exponential time but has no memory constraint.</p>
</div>
<p>EXAMPLES:</p>
<p>On a circuit:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions.vertex_separation</span> <span class="kn">import</span> <span class="n">lower_bound</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">lower_bound</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.graph_decompositions.vertex_separation.path_decomposition">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.graph_decompositions.vertex_separation.</span></span><span class="sig-name descname"><span class="pre">path_decomposition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'BAB'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cut_off</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_prefix_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_prefix_number</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph_decompositions.vertex_separation.path_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the pathwidth of the given graph and the ordering of the vertices
resulting in a corresponding path decomposition.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a Graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">&quot;BAB&quot;</span></code>); algorithm to use among:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;BAB&quot;</span></code> – Use a branch-and-bound algorithm. This algorithm has no
size restriction but could take a very long time on large graphs. It can
also be used to test is the input (di)graph has vertex separation at
most <code class="docutils literal notranslate"><span class="pre">upper_bound</span></code> or to return the first found solution with vertex
separation less or equal to a <code class="docutils literal notranslate"><span class="pre">cut_off</span></code> value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">exponential</span></code> – Use an exponential time and space algorithm. This
algorithm only works of graphs on less than 32 vertices.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MILP</span></code> – Use a mixed integer linear programming formulation. This
algorithm has no size restriction but could take a very long time.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">upper_bound</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); parameter used by the
<code class="docutils literal notranslate"><span class="pre">&quot;BAB&quot;</span></code> algorithm. If specified, the algorithm searches for a solution
with <code class="docutils literal notranslate"><span class="pre">width</span> <span class="pre">&lt;</span> <span class="pre">upper_bound</span></code>. It helps cutting branches.  However, if the
given upper bound is too low, the algorithm may not be able to find a
solution.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cut_off</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); parameter used by the
<code class="docutils literal notranslate"><span class="pre">&quot;BAB&quot;</span></code> algorithm. This bound allows us to stop the search as soon as a
solution with width at most <code class="docutils literal notranslate"><span class="pre">cut_off</span></code> is found, if any. If this bound
cannot be reached, the best solution found is returned, unless a too low
<code class="docutils literal notranslate"><span class="pre">upper_bound</span></code> is given.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to display
information on the computations</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_prefix_length</span></code> – integer (default: 20); limits the length of the
stored prefixes to prevent storing too many prefixes. This parameter is
used only when <code class="docutils literal notranslate"><span class="pre">algorithm==&quot;BAB&quot;</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_prefix_number</span></code> – integer (default: 10**6); upper bound on the
number of stored prefixes used to prevent using too much memory. This
parameter is used only when <code class="docutils literal notranslate"><span class="pre">algorithm==&quot;BAB&quot;</span></code>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A pair <code class="docutils literal notranslate"><span class="pre">(cost,</span> <span class="pre">ordering)</span></code> representing the optimal ordering of the
vertices and its cost.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="../graph.html#sage.graphs.graph.Graph.treewidth" title="sage.graphs.graph.Graph.treewidth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.treewidth()</span></code></a> – computes the treewidth of a graph</p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>The pathwidth of a cycle is equal to 2:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions.vertex_separation</span> <span class="kn">import</span> <span class="n">path_decomposition</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pw</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">path_decomposition</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;BAB&quot;</span><span class="p">);</span> <span class="n">pw</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pw</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">path_decomposition</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;exponential&quot;</span><span class="p">);</span> <span class="n">pw</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pw</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">path_decomposition</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;MILP&quot;</span><span class="p">);</span> <span class="n">pw</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.graph_decompositions.vertex_separation.pathwidth">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.graph_decompositions.vertex_separation.</span></span><span class="sig-name descname"><span class="pre">pathwidth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'BAB'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_prefix_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_prefix_number</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph_decompositions.vertex_separation.pathwidth" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the pathwidth of <code class="docutils literal notranslate"><span class="pre">self</span></code> (and provides a decomposition)</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the width to be considered. When
<code class="docutils literal notranslate"><span class="pre">k</span></code> is an integer, the method checks that the graph has pathwidth
<span class="math notranslate nohighlight">\(\leq k\)</span>. If <code class="docutils literal notranslate"><span class="pre">k</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), the method computes the optimal
pathwidth.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
path-decomposition itself</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">&quot;BAB&quot;</span></code>); algorithm to use among:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;BAB&quot;</span></code> – Use a branch-and-bound algorithm. This algorithm has no
size restriction but could take a very long time on large graphs. It can
also be used to test is the input graph has pathwidth <span class="math notranslate nohighlight">\(\leq k\)</span>, in which
cas it will return the first found solution with width <span class="math notranslate nohighlight">\(\leq k\)</span> is
<code class="docutils literal notranslate"><span class="pre">certificate==True</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">exponential</span></code> – Use an exponential time and space algorithm. This
algorithm only works of graphs on less than 32 vertices.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MILP</span></code> – Use a mixed integer linear programming formulation. This
algorithm has no size restriction but could take a very long time.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to display
information on the computations</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_prefix_length</span></code> – integer (default: 20); limits the length of the
stored prefixes to prevent storing too many prefixes. This parameter is
used only when <code class="docutils literal notranslate"><span class="pre">algorithm==&quot;BAB&quot;</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_prefix_number</span></code> – integer (default: 10**6); upper bound on the
number of stored prefixes used to prevent using too much memory. This
parameter is used only when <code class="docutils literal notranslate"><span class="pre">algorithm==&quot;BAB&quot;</span></code>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>Return the pathwidth of <code class="docutils literal notranslate"><span class="pre">self</span></code>. When <code class="docutils literal notranslate"><span class="pre">k</span></code> is specified, it returns
<code class="docutils literal notranslate"><span class="pre">False</span></code> when no path-decomposition of width <span class="math notranslate nohighlight">\(\leq k\)</span> exists or <code class="docutils literal notranslate"><span class="pre">True</span></code>
otherwise. When <code class="docutils literal notranslate"><span class="pre">certificate=True</span></code>, the path-decomposition is also
returned.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="../graph.html#sage.graphs.graph.Graph.treewidth" title="sage.graphs.graph.Graph.treewidth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.treewidth()</span></code></a> – computes the treewidth of a graph</p></li>
<li><p><a class="reference internal" href="#sage.graphs.graph_decompositions.vertex_separation.vertex_separation" title="sage.graphs.graph_decompositions.vertex_separation.vertex_separation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertex_separation()</span></code></a>
– computes the vertex separation of a (di)graph</p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>The pathwidth of a cycle is equal to 2:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">pathwidth</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pw</span><span class="p">,</span> <span class="n">decomp</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">pathwidth</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">decomp</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="go">[{0, 1, 5}, {1, 2, 5}, {2, 3, 4}, {2, 4, 5}]</span>
</pre></div>
</div>
<p>The pathwidth of a Petersen graph is 5:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">pathwidth</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">pathwidth</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">pathwidth</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">pathwidth</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(True, Graph on 5 vertices)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.graph_decompositions.vertex_separation.vertex_separation">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.graph_decompositions.vertex_separation.</span></span><span class="sig-name descname"><span class="pre">vertex_separation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'BAB'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cut_off</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_prefix_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_prefix_number</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph_decompositions.vertex_separation.vertex_separation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an optimal ordering of the vertices and its cost for
vertex-separation.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a Graph or a DiGraph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">&quot;BAB&quot;</span></code>); algorithm to use among:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;BAB&quot;</span></code> – Use a branch-and-bound algorithm. This algorithm has no
size restriction but could take a very long time on large graphs. It can
also be used to test is the input (di)graph has vertex separation at
most <code class="docutils literal notranslate"><span class="pre">upper_bound</span></code> or to return the first found solution with vertex
separation less or equal to a <code class="docutils literal notranslate"><span class="pre">cut_off</span></code> value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">exponential</span></code> – Use an exponential time and space algorithm. This
algorithm only works of graphs on less than 32 vertices.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MILP</span></code> – Use a mixed integer linear programming formulation. This
algorithm has no size restriction but could take a very long time.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">upper_bound</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); parameter used by the
<code class="docutils literal notranslate"><span class="pre">&quot;BAB&quot;</span></code> algorithm. If specified, the algorithm searches for a solution
with <code class="docutils literal notranslate"><span class="pre">width</span> <span class="pre">&lt;</span> <span class="pre">upper_bound</span></code>. It helps cutting branches.  However, if the
given upper bound is too low, the algorithm may not be able to find a
solution.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cut_off</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); parameter used by the
<code class="docutils literal notranslate"><span class="pre">&quot;BAB&quot;</span></code> algorithm. This bound allows us to stop the search as soon as a
solution with width at most <code class="docutils literal notranslate"><span class="pre">cut_off</span></code> is found, if any. If this bound
cannot be reached, the best solution found is returned, unless a too low
<code class="docutils literal notranslate"><span class="pre">upper_bound</span></code> is given.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to display
information on the computations</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_prefix_length</span></code> – integer (default: 20); limits the length of the
stored prefixes to prevent storing too many prefixes. This parameter is
used only when <code class="docutils literal notranslate"><span class="pre">algorithm==&quot;BAB&quot;</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_prefix_number</span></code> – integer (default: 10**6); upper bound on the
number of stored prefixes used to prevent using too much memory. This
parameter is used only when <code class="docutils literal notranslate"><span class="pre">algorithm==&quot;BAB&quot;</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer Linear
Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one
is used. For more information on MILP solvers and which default solver is
used, see the method <a class="reference external" href="../../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Numerical Optimization v9.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Numerical Optimization v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP solvers
over an inexact base ring; see
<a class="reference external" href="../../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Numerical Optimization v9.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A pair <code class="docutils literal notranslate"><span class="pre">(cost,</span> <span class="pre">ordering)</span></code> representing the optimal ordering of the
vertices and its cost.</p>
<p>EXAMPLES:</p>
<p>Comparison of methods:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions.vertex_separation</span> <span class="kn">import</span> <span class="n">vertex_separation</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">DeBruijn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">vs</span><span class="p">,</span><span class="n">L</span> <span class="o">=</span> <span class="n">vertex_separation</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;BAB&quot;</span><span class="p">);</span> <span class="n">vs</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">vs</span><span class="p">,</span><span class="n">L</span> <span class="o">=</span> <span class="n">vertex_separation</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;exponential&quot;</span><span class="p">);</span> <span class="n">vs</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">vs</span><span class="p">,</span><span class="n">L</span> <span class="o">=</span> <span class="n">vertex_separation</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;MILP&quot;</span><span class="p">);</span> <span class="n">vs</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">vs</span><span class="p">,</span><span class="n">L</span> <span class="o">=</span> <span class="n">vertex_separation</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;BAB&quot;</span><span class="p">);</span> <span class="n">vs</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">vs</span><span class="p">,</span><span class="n">L</span> <span class="o">=</span> <span class="n">vertex_separation</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;exponential&quot;</span><span class="p">);</span> <span class="n">vs</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">vs</span><span class="p">,</span><span class="n">L</span> <span class="o">=</span> <span class="n">vertex_separation</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;MILP&quot;</span><span class="p">);</span> <span class="n">vs</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Digraphs with multiple strongly connected components:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions.vertex_separation</span> <span class="kn">import</span> <span class="n">vertex_separation</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">vertex_separation</span><span class="p">(</span><span class="n">D</span><span class="p">))</span>
<span class="go">(0, [7, 6, 5, 4, 3, 2, 1, 0])</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">RandomDirectedAcyclicGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mf">.5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">vs</span><span class="p">,</span><span class="n">L</span> <span class="o">=</span> <span class="n">vertex_separation</span><span class="p">(</span><span class="n">D</span><span class="p">);</span> <span class="n">vs</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">K4</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">K4</span><span class="o">+</span><span class="n">K4</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">vertex_separation</span><span class="p">(</span><span class="n">D</span><span class="p">))</span>
<span class="go">(3, [4, 5, 6, 7, 0, 1, 2, 3])</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">K4</span><span class="o">+</span><span class="n">K4</span><span class="o">+</span><span class="n">K4</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">vertex_separation</span><span class="p">(</span><span class="n">D</span><span class="p">))</span>
<span class="go">(3, [10, 11, 8, 9, 4, 5, 6, 7, 0, 1, 2, 3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.graph_decompositions.vertex_separation.vertex_separation_BAB">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.graph_decompositions.vertex_separation.</span></span><span class="sig-name descname"><span class="pre">vertex_separation_BAB</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cut_off</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_prefix_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_prefix_number</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph_decompositions.vertex_separation.vertex_separation_BAB" title="Permalink to this definition">¶</a></dt>
<dd><p>Branch and Bound algorithm for the vertex separation.</p>
<p>This method implements the branch and bound algorithm for the vertex
separation of directed graphs and the pathwidth of undirected graphs
proposed in <a class="reference internal" href="../../../../references/index.html#cmn2014" id="id7"><span>[CMN2014]</span></a>. The implementation is valid for both Graph and
DiGraph. See the documentation of the
<a class="reference internal" href="#module-sage.graphs.graph_decompositions.vertex_separation" title="sage.graphs.graph_decompositions.vertex_separation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vertex_separation</span></code></a> module.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a Graph or a DiGraph.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cut_off</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); bound to consider in the
branch and bound algorithm. This allows us to stop the search as soon as a
solution with width at most <code class="docutils literal notranslate"><span class="pre">cut_off</span></code> is found, if any. If this bound
cannot be reached, the best solution found is returned, unless a too low
<code class="docutils literal notranslate"><span class="pre">upper_bound</span></code> is given.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">upper_bound</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); if specified, the
algorithm searches for a solution with <code class="docutils literal notranslate"><span class="pre">width</span> <span class="pre">&lt;</span> <span class="pre">upper_bound</span></code>. It helps
cutting branches.  However, if the given upper bound is too low, the
algorithm may not be able to find a solution.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_prefix_length</span></code> – integer (default: 20); limits the length of the
stored prefixes to prevent storing too many prefixes</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_prefix_number</span></code> – integer (default: 10**6); upper bound on the
number of stored prefixes used to prevent using too much memory</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); display some information when
set to <code class="docutils literal notranslate"><span class="pre">True</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">width</span></code> – the computed vertex separation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">seq</span></code> – an ordering of the vertices of width <code class="docutils literal notranslate"><span class="pre">width</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<p>The algorithm is valid for the vertex separation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions</span> <span class="kn">import</span> <span class="n">vertex_separation</span> <span class="k">as</span> <span class="n">VS</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">RandomDirectedGNP</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mf">.2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">vb</span><span class="p">,</span> <span class="n">seqb</span> <span class="o">=</span> <span class="n">VS</span><span class="o">.</span><span class="n">vertex_separation_BAB</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">vd</span><span class="p">,</span> <span class="n">seqd</span> <span class="o">=</span> <span class="n">VS</span><span class="o">.</span><span class="n">vertex_separation_exp</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">vb</span> <span class="o">==</span> <span class="n">vd</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">vb</span> <span class="o">==</span> <span class="n">VS</span><span class="o">.</span><span class="n">width_of_path_decomposition</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">seqb</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The vertex separation of a <span class="math notranslate nohighlight">\(N\times N\)</span> grid is <span class="math notranslate nohighlight">\(N\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions</span> <span class="kn">import</span> <span class="n">vertex_separation</span> <span class="k">as</span> <span class="n">VS</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">vs</span><span class="p">,</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">VS</span><span class="o">.</span><span class="n">vertex_separation_BAB</span><span class="p">(</span><span class="n">G</span><span class="p">);</span> <span class="n">vs</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">vs</span> <span class="o">==</span> <span class="n">VS</span><span class="o">.</span><span class="n">width_of_path_decomposition</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">seq</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The vertex separation of a <span class="math notranslate nohighlight">\(N\times M\)</span> grid with <span class="math notranslate nohighlight">\(N&lt;M\)</span> is <span class="math notranslate nohighlight">\(N\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions</span> <span class="kn">import</span> <span class="n">vertex_separation</span> <span class="k">as</span> <span class="n">VS</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">vs</span><span class="p">,</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">VS</span><span class="o">.</span><span class="n">vertex_separation_BAB</span><span class="p">(</span><span class="n">G</span><span class="p">);</span> <span class="n">vs</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">vs</span> <span class="o">==</span> <span class="n">VS</span><span class="o">.</span><span class="n">width_of_path_decomposition</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">seq</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The vertex separation of circuit of order <span class="math notranslate nohighlight">\(N\geq 2\)</span> is 1:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions</span> <span class="kn">import</span> <span class="n">vertex_separation</span> <span class="k">as</span> <span class="n">VS</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">vs</span><span class="p">,</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">VS</span><span class="o">.</span><span class="n">vertex_separation_BAB</span><span class="p">(</span><span class="n">D</span><span class="p">);</span> <span class="n">vs</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">vs</span> <span class="o">==</span> <span class="n">VS</span><span class="o">.</span><span class="n">width_of_path_decomposition</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">seq</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The vertex separation of cycle of order <span class="math notranslate nohighlight">\(N\geq 3\)</span> is 2:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions</span> <span class="kn">import</span> <span class="n">vertex_separation</span> <span class="k">as</span> <span class="n">VS</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">vs</span><span class="p">,</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">VS</span><span class="o">.</span><span class="n">vertex_separation_BAB</span><span class="p">(</span><span class="n">G</span><span class="p">);</span> <span class="n">vs</span>
<span class="go">2</span>
</pre></div>
</div>
<p>The vertex separation of <code class="docutils literal notranslate"><span class="pre">MycielskiGraph(5)</span></code> is 10:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions</span> <span class="kn">import</span> <span class="n">vertex_separation</span> <span class="k">as</span> <span class="n">VS</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">MycielskiGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">vs</span><span class="p">,</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">VS</span><span class="o">.</span><span class="n">vertex_separation_BAB</span><span class="p">(</span><span class="n">G</span><span class="p">);</span> <span class="n">vs</span>
<span class="go">10</span>
</pre></div>
</div>
<p>Searching for any solution with width less or equal to <code class="docutils literal notranslate"><span class="pre">cut_off</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions</span> <span class="kn">import</span> <span class="n">vertex_separation</span> <span class="k">as</span> <span class="n">VS</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">MycielskiGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">VS</span><span class="o">.</span><span class="n">vertex_separation_BAB</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cut_off</span><span class="o">=</span><span class="mi">11</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">11</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">VS</span><span class="o">.</span><span class="n">vertex_separation_BAB</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cut_off</span><span class="o">=</span><span class="mi">10</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">10</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">VS</span><span class="o">.</span><span class="n">vertex_separation_BAB</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cut_off</span><span class="o">=</span><span class="mi">9</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">9</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Testing for the existence of a solution with width strictly less than <code class="docutils literal notranslate"><span class="pre">upper_bound</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions</span> <span class="kn">import</span> <span class="n">vertex_separation</span> <span class="k">as</span> <span class="n">VS</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">MycielskiGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">vs</span><span class="p">,</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">VS</span><span class="o">.</span><span class="n">vertex_separation_BAB</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">upper_bound</span><span class="o">=</span><span class="mi">11</span><span class="p">);</span> <span class="n">vs</span>
<span class="go">10</span>
<span class="gp">sage: </span><span class="n">vs</span><span class="p">,</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">VS</span><span class="o">.</span><span class="n">vertex_separation_BAB</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">upper_bound</span><span class="o">=</span><span class="mi">10</span><span class="p">);</span> <span class="n">vs</span>
<span class="go">-1</span>
<span class="gp">sage: </span><span class="n">vs</span><span class="p">,</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">VS</span><span class="o">.</span><span class="n">vertex_separation_BAB</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cut_off</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">upper_bound</span><span class="o">=</span><span class="mi">10</span><span class="p">);</span> <span class="n">vs</span>
<span class="go">-1</span>
</pre></div>
</div>
<p>Changing the parameters of the prefix storage:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions</span> <span class="kn">import</span> <span class="n">vertex_separation</span> <span class="k">as</span> <span class="n">VS</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">MycielskiGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">vs</span><span class="p">,</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">VS</span><span class="o">.</span><span class="n">vertex_separation_BAB</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">max_prefix_length</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span> <span class="n">vs</span>
<span class="go">10</span>
<span class="gp">sage: </span><span class="n">vs</span><span class="p">,</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">VS</span><span class="o">.</span><span class="n">vertex_separation_BAB</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">max_prefix_number</span><span class="o">=</span><span class="mi">5</span><span class="p">);</span> <span class="n">vs</span>
<span class="go">10</span>
<span class="gp">sage: </span><span class="n">vs</span><span class="p">,</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">VS</span><span class="o">.</span><span class="n">vertex_separation_BAB</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">max_prefix_number</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span> <span class="n">vs</span>
<span class="go">10</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.graph_decompositions.vertex_separation.vertex_separation_MILP">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.graph_decompositions.vertex_separation.</span></span><span class="sig-name descname"><span class="pre">vertex_separation_MILP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph_decompositions.vertex_separation.vertex_separation_MILP" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the vertex separation of <span class="math notranslate nohighlight">\(G\)</span> and the optimal ordering of its
vertices using an MILP formulation.</p>
<p>This function uses a mixed integer linear program (MILP) for determining an
optimal layout for the vertex separation of <span class="math notranslate nohighlight">\(G\)</span>. This MILP is an improved
version of the formulation proposed in <a class="reference internal" href="../../../../references/index.html#sp2010" id="id8"><span>[SP2010]</span></a>. See the <a class="reference internal" href="#module-sage.graphs.graph_decompositions.vertex_separation" title="sage.graphs.graph_decompositions.vertex_separation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">module's</span>
<span class="pre">documentation</span></code></a> for more
details on this MILP formulation.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a Graph or a DiGraph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); specify if variables
<span class="math notranslate nohighlight">\(x_v^t\)</span> and <span class="math notranslate nohighlight">\(u_v^t\)</span> must be integral or if they can be relaxed. This has
no impact on the validity of the solution, but it is sometimes faster to
solve the problem using binary variables only.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer Linear
Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one
is used. For more information on MILP solvers and which default solver is
used, see the method <a class="reference external" href="../../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Numerical Optimization v9.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Numerical Optimization v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of verbosity. Set
to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP solvers
over an inexact base ring; see
<a class="reference external" href="../../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Numerical Optimization v9.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A pair <code class="docutils literal notranslate"><span class="pre">(cost,</span> <span class="pre">ordering)</span></code> representing the optimal ordering of the
vertices and its cost.</p>
<p>EXAMPLES:</p>
<p>Vertex separation of a De Bruijn digraph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions</span> <span class="kn">import</span> <span class="n">vertex_separation</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">DeBruijn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">vs</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">vertex_separation</span><span class="o">.</span><span class="n">vertex_separation_MILP</span><span class="p">(</span><span class="n">G</span><span class="p">);</span> <span class="n">vs</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">vs</span> <span class="o">==</span> <span class="n">vertex_separation</span><span class="o">.</span><span class="n">width_of_path_decomposition</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">vse</span><span class="p">,</span> <span class="n">Le</span> <span class="o">=</span> <span class="n">vertex_separation</span><span class="o">.</span><span class="n">vertex_separation</span><span class="p">(</span><span class="n">G</span><span class="p">);</span> <span class="n">vse</span>
<span class="go">2</span>
</pre></div>
</div>
<p>The vertex separation of a circuit is 1:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions</span> <span class="kn">import</span> <span class="n">vertex_separation</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">vs</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">vertex_separation</span><span class="o">.</span><span class="n">vertex_separation_MILP</span><span class="p">(</span><span class="n">G</span><span class="p">);</span> <span class="n">vs</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.graph_decompositions.vertex_separation.vertex_separation_exp">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.graph_decompositions.vertex_separation.</span></span><span class="sig-name descname"><span class="pre">vertex_separation_exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph_decompositions.vertex_separation.vertex_separation_exp" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an optimal ordering of the vertices and its cost for
vertex-separation.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a Graph or a DiGraph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to display
information on the computations</p></li>
</ul>
<p>OUTPUT:</p>
<p>A pair <code class="docutils literal notranslate"><span class="pre">(cost,</span> <span class="pre">ordering)</span></code> representing the optimal ordering of the
vertices and its cost.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Because of its current implementation, this algorithm only works on
graphs on less than 32 vertices. This can be changed to 54 if necessary,
but 32 vertices already require 4GB of memory.</p>
</div>
<p>EXAMPLES:</p>
<p>The vertex separation of a circuit is equal to 1:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions.vertex_separation</span> <span class="kn">import</span> <span class="n">vertex_separation_exp</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">vertex_separation_exp</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">(1, [0, 1, 2, 3, 4, 5])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.graph_decompositions.vertex_separation.width_of_path_decomposition">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.graph_decompositions.vertex_separation.</span></span><span class="sig-name descname"><span class="pre">width_of_path_decomposition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph_decompositions.vertex_separation.width_of_path_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the width of the path decomposition induced by the linear ordering
<span class="math notranslate nohighlight">\(L\)</span> of the vertices of <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(G\)</span> is an instance of <a class="reference internal" href="../graph.html#module-sage.graphs.graph" title="sage.graphs.graph"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Graph</span></code></a>, this function
returns the width <span class="math notranslate nohighlight">\(pw_L(G)\)</span> of the path decomposition induced by the linear
ordering <span class="math notranslate nohighlight">\(L\)</span> of the vertices of <span class="math notranslate nohighlight">\(G\)</span>. If <span class="math notranslate nohighlight">\(G\)</span> is a <a class="reference internal" href="../digraph.html#module-sage.graphs.digraph" title="sage.graphs.digraph"><code class="xref py py-mod docutils literal notranslate"><span class="pre">DiGraph</span></code></a>, it returns instead the width <span class="math notranslate nohighlight">\(vs_L(G)\)</span> of the
directed path decomposition induced by the linear ordering <span class="math notranslate nohighlight">\(L\)</span> of the
vertices of <span class="math notranslate nohighlight">\(G\)</span>, where</p>
<div class="math notranslate nohighlight">
\[\begin{split}vs_L(G) &amp; =  \max_{0\leq i&lt; |V|-1} | N^+(L[:i])\setminus L[:i] |\\
pw_L(G) &amp; =  \max_{0\leq i&lt; |V|-1} | N(L[:i])\setminus L[:i] |\\\end{split}\]</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a Graph or a DiGraph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">L</span></code> – a linear ordering of the vertices of <code class="docutils literal notranslate"><span class="pre">G</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<p>Path decomposition of a cycle:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions</span> <span class="kn">import</span> <span class="n">vertex_separation</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="n">u</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">()]</span>
<span class="gp">sage: </span><span class="n">vertex_separation</span><span class="o">.</span><span class="n">width_of_path_decomposition</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Directed path decomposition of a circuit:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions</span> <span class="kn">import</span> <span class="n">vertex_separation</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="n">u</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">()]</span>
<span class="gp">sage: </span><span class="n">vertex_separation</span><span class="o">.</span><span class="n">width_of_path_decomposition</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Vertex separation</a><ul>
<li><a class="reference internal" href="#exponential-algorithm-for-vertex-separation">Exponential algorithm for vertex separation</a></li>
<li><a class="reference internal" href="#milp-formulation-for-the-vertex-separation">MILP formulation for the vertex separation</a></li>
<li><a class="reference internal" href="#branch-and-bound-algorithm-for-the-vertex-separation">Branch and Bound algorithm for the vertex separation</a></li>
<li><a class="reference internal" href="#authors">Authors</a></li>
<li><a class="reference internal" href="#methods">Methods</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="tree_decomposition.html"
                          title="previous chapter">Tree decompositions</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="rankwidth.html"
                          title="next chapter">Rank Decompositions of graphs</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/sage/graphs/graph_decompositions/vertex_separation.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="rankwidth.html" title="Rank Decompositions of graphs"
             >next</a> |</li>
        <li class="right" >
          <a href="tree_decomposition.html" title="Tree decompositions"
             >previous</a> |</li>
  <li class="nav-item nav-item-0">
    <a href="http://www.sagemath.org"><img src="../../../../_static/logo_sagemath_black.svg" class="sage-logo" title="Sage Logo"></a>
    
      <a href="../../../../../index.html">Sage 9.6 Documentation</a> &#187;
      
      <a href="../../../../index.html">Reference Manual</a> &#187;
      
      <a href="../../../index.html">Graph Theory</a> &#187;
    
  </li>

        <li class="nav-item nav-item-this"><a href="">Vertex separation</a></li> 
      </ul>
    </div>
  
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2022, The Sage Development Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* The sidebar toggle adapts its height to the bodywrapper height. */
    const resizeObserver = new ResizeObserver(entries => {
        tog.height(bod.height());
    });
    resizeObserver.observe(bod[0]);

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
  </script>
  <script type="text/javascript">
/* detex the document title by removing "\(", "\)", "\", "$" */
document.title = document.title.replace(/\\\(/g, '').replace(/\\\)/g, '').replace(/\\/g, '').replace(/\$/g, '');
  </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>