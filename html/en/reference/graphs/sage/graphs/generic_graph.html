
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Generic graphs (common to directed/undirected) &#8212; Sage 9.5 Reference Manual: Graph Theory</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sage.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <script data-url_root="../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script async="async" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Undirected graphs" href="graph.html" />
    <link rel="prev" title="Graph Theory" href="../../index.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="graph.html" title="Undirected graphs"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../../index.html" title="Graph Theory"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Sage 9.5 Reference Manual: Graph Theory</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">Generic graphs (common to directed/undirected)</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="generic-graphs-common-to-directed-undirected">
<span id="sage-graphs-generic-graph"></span><h1>Generic graphs (common to directed/undirected)<a class="headerlink" href="#generic-graphs-common-to-directed-undirected" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.graphs.generic_graph"></span><p>This module implements the base class for graphs and digraphs, and methods that
can be applied on both. Here is what it can do:</p>
<p><strong>Basic Graph operations:</strong></p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.networkx_graph" title="sage.graphs.generic_graph.GenericGraph.networkx_graph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">networkx_graph()</span></code></a></p></td>
<td><p>Return a new <code class="docutils literal notranslate"><span class="pre">NetworkX</span></code> graph from the Sage graph</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.igraph_graph" title="sage.graphs.generic_graph.GenericGraph.igraph_graph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">igraph_graph()</span></code></a></p></td>
<td><p>Return an <code class="docutils literal notranslate"><span class="pre">igraph</span></code> graph from the Sage graph</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.to_dictionary" title="sage.graphs.generic_graph.GenericGraph.to_dictionary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_dictionary()</span></code></a></p></td>
<td><p>Create a dictionary encoding the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.copy" title="sage.graphs.generic_graph.GenericGraph.copy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code></a></p></td>
<td><p>Return a copy of the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.export_to_file" title="sage.graphs.generic_graph.GenericGraph.export_to_file"><code class="xref py py-meth docutils literal notranslate"><span class="pre">export_to_file()</span></code></a></p></td>
<td><p>Export the graph to a file.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.adjacency_matrix" title="sage.graphs.generic_graph.GenericGraph.adjacency_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">adjacency_matrix()</span></code></a></p></td>
<td><p>Return the adjacency matrix of the (di)graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.incidence_matrix" title="sage.graphs.generic_graph.GenericGraph.incidence_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">incidence_matrix()</span></code></a></p></td>
<td><p>Return an incidence matrix of the (di)graph</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.distance_matrix" title="sage.graphs.generic_graph.GenericGraph.distance_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">distance_matrix()</span></code></a></p></td>
<td><p>Return the distance matrix of the (strongly) connected (di)graph</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.weighted_adjacency_matrix" title="sage.graphs.generic_graph.GenericGraph.weighted_adjacency_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">weighted_adjacency_matrix()</span></code></a></p></td>
<td><p>Return the weighted adjacency matrix of the graph</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.kirchhoff_matrix" title="sage.graphs.generic_graph.GenericGraph.kirchhoff_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kirchhoff_matrix()</span></code></a></p></td>
<td><p>Return the Kirchhoff matrix (a.k.a. the Laplacian) of the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.has_loops" title="sage.graphs.generic_graph.GenericGraph.has_loops"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_loops()</span></code></a></p></td>
<td><p>Return whether there are loops in the (di)graph</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.allows_loops" title="sage.graphs.generic_graph.GenericGraph.allows_loops"><code class="xref py py-meth docutils literal notranslate"><span class="pre">allows_loops()</span></code></a></p></td>
<td><p>Return whether loops are permitted in the (di)graph</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.allow_loops" title="sage.graphs.generic_graph.GenericGraph.allow_loops"><code class="xref py py-meth docutils literal notranslate"><span class="pre">allow_loops()</span></code></a></p></td>
<td><p>Change whether loops are permitted in the (di)graph</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.loops" title="sage.graphs.generic_graph.GenericGraph.loops"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loops()</span></code></a></p></td>
<td><p>Return a list of all loops in the (di)graph</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.loop_edges" title="sage.graphs.generic_graph.GenericGraph.loop_edges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop_edges()</span></code></a></p></td>
<td><p>Return a list of all loops in the (di)graph</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.number_of_loops" title="sage.graphs.generic_graph.GenericGraph.number_of_loops"><code class="xref py py-meth docutils literal notranslate"><span class="pre">number_of_loops()</span></code></a></p></td>
<td><p>Return the number of edges that are loops</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.loop_vertices" title="sage.graphs.generic_graph.GenericGraph.loop_vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop_vertices()</span></code></a></p></td>
<td><p>Return a list of vertices with loops</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.remove_loops" title="sage.graphs.generic_graph.GenericGraph.remove_loops"><code class="xref py py-meth docutils literal notranslate"><span class="pre">remove_loops()</span></code></a></p></td>
<td><p>Remove loops on vertices in <code class="docutils literal notranslate"><span class="pre">vertices</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.has_multiple_edges" title="sage.graphs.generic_graph.GenericGraph.has_multiple_edges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_multiple_edges()</span></code></a></p></td>
<td><p>Return whether there are multiple edges in the (di)graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.allows_multiple_edges" title="sage.graphs.generic_graph.GenericGraph.allows_multiple_edges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">allows_multiple_edges()</span></code></a></p></td>
<td><p>Return whether multiple edges are permitted in the (di)graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.allow_multiple_edges" title="sage.graphs.generic_graph.GenericGraph.allow_multiple_edges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">allow_multiple_edges()</span></code></a></p></td>
<td><p>Change whether multiple edges are permitted in the (di)graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.multiple_edges" title="sage.graphs.generic_graph.GenericGraph.multiple_edges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">multiple_edges()</span></code></a></p></td>
<td><p>Return any multiple edges in the (di)graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.name" title="sage.graphs.generic_graph.GenericGraph.name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">name()</span></code></a></p></td>
<td><p>Return or set the graph’s name.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_immutable" title="sage.graphs.generic_graph.GenericGraph.is_immutable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_immutable()</span></code></a></p></td>
<td><p>Return whether the graph is immutable.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.weighted" title="sage.graphs.generic_graph.GenericGraph.weighted"><code class="xref py py-meth docutils literal notranslate"><span class="pre">weighted()</span></code></a></p></td>
<td><p>Whether the (di)graph is to be considered as a weighted (di)graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.antisymmetric" title="sage.graphs.generic_graph.GenericGraph.antisymmetric"><code class="xref py py-meth docutils literal notranslate"><span class="pre">antisymmetric()</span></code></a></p></td>
<td><p>Test whether the graph is antisymmetric</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.density" title="sage.graphs.generic_graph.GenericGraph.density"><code class="xref py py-meth docutils literal notranslate"><span class="pre">density()</span></code></a></p></td>
<td><p>Return the density</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.order" title="sage.graphs.generic_graph.GenericGraph.order"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order()</span></code></a></p></td>
<td><p>Return the number of vertices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.size" title="sage.graphs.generic_graph.GenericGraph.size"><code class="xref py py-meth docutils literal notranslate"><span class="pre">size()</span></code></a></p></td>
<td><p>Return the number of edges.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.add_vertex" title="sage.graphs.generic_graph.GenericGraph.add_vertex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_vertex()</span></code></a></p></td>
<td><p>Create an isolated vertex.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.add_vertices" title="sage.graphs.generic_graph.GenericGraph.add_vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_vertices()</span></code></a></p></td>
<td><p>Add vertices to the (di)graph from an iterable container of vertices</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.delete_vertex" title="sage.graphs.generic_graph.GenericGraph.delete_vertex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">delete_vertex()</span></code></a></p></td>
<td><p>Delete vertex, removing all incident edges.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.delete_vertices" title="sage.graphs.generic_graph.GenericGraph.delete_vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">delete_vertices()</span></code></a></p></td>
<td><p>Delete vertices from the (di)graph taken from an iterable container of vertices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.has_vertex" title="sage.graphs.generic_graph.GenericGraph.has_vertex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_vertex()</span></code></a></p></td>
<td><p>Check if <code class="docutils literal notranslate"><span class="pre">vertex</span></code> is one of the vertices of this graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.random_vertex" title="sage.graphs.generic_graph.GenericGraph.random_vertex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">random_vertex()</span></code></a></p></td>
<td><p>Return a random vertex of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.random_vertex_iterator" title="sage.graphs.generic_graph.GenericGraph.random_vertex_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">random_vertex_iterator()</span></code></a></p></td>
<td><p>Return an iterator over random vertices of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.random_edge" title="sage.graphs.generic_graph.GenericGraph.random_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">random_edge()</span></code></a></p></td>
<td><p>Return a random edge of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.random_edge_iterator" title="sage.graphs.generic_graph.GenericGraph.random_edge_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">random_edge_iterator()</span></code></a></p></td>
<td><p>Return an iterator over random edges of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.vertex_boundary" title="sage.graphs.generic_graph.GenericGraph.vertex_boundary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertex_boundary()</span></code></a></p></td>
<td><p>Return a list of all vertices in the external boundary of <code class="docutils literal notranslate"><span class="pre">vertices1</span></code>, intersected with <code class="docutils literal notranslate"><span class="pre">vertices2</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.set_vertices" title="sage.graphs.generic_graph.GenericGraph.set_vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_vertices()</span></code></a></p></td>
<td><p>Associate arbitrary objects with each vertex</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.set_vertex" title="sage.graphs.generic_graph.GenericGraph.set_vertex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_vertex()</span></code></a></p></td>
<td><p>Associate an arbitrary object with a vertex.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.get_vertex" title="sage.graphs.generic_graph.GenericGraph.get_vertex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_vertex()</span></code></a></p></td>
<td><p>Retrieve the object associated with a given vertex.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.get_vertices" title="sage.graphs.generic_graph.GenericGraph.get_vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_vertices()</span></code></a></p></td>
<td><p>Return a dictionary of the objects associated to each vertex.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.vertex_iterator" title="sage.graphs.generic_graph.GenericGraph.vertex_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertex_iterator()</span></code></a></p></td>
<td><p>Return an iterator over the given vertices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.neighbor_iterator" title="sage.graphs.generic_graph.GenericGraph.neighbor_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">neighbor_iterator()</span></code></a></p></td>
<td><p>Return an iterator over neighbors of <code class="docutils literal notranslate"><span class="pre">vertex</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.vertices" title="sage.graphs.generic_graph.GenericGraph.vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertices()</span></code></a></p></td>
<td><p>Return a list of the vertices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.neighbors" title="sage.graphs.generic_graph.GenericGraph.neighbors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">neighbors()</span></code></a></p></td>
<td><p>Return a list of neighbors (in and out if directed) of <code class="docutils literal notranslate"><span class="pre">vertex</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.merge_vertices" title="sage.graphs.generic_graph.GenericGraph.merge_vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">merge_vertices()</span></code></a></p></td>
<td><p>Merge vertices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.add_edge" title="sage.graphs.generic_graph.GenericGraph.add_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_edge()</span></code></a></p></td>
<td><p>Add an edge from <code class="docutils literal notranslate"><span class="pre">u</span></code> to <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.add_edges" title="sage.graphs.generic_graph.GenericGraph.add_edges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_edges()</span></code></a></p></td>
<td><p>Add edges from an iterable container.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.subdivide_edge" title="sage.graphs.generic_graph.GenericGraph.subdivide_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subdivide_edge()</span></code></a></p></td>
<td><p>Subdivide an edge <span class="math notranslate nohighlight">\(k\)</span> times.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.subdivide_edges" title="sage.graphs.generic_graph.GenericGraph.subdivide_edges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subdivide_edges()</span></code></a></p></td>
<td><p>Subdivide <span class="math notranslate nohighlight">\(k\)</span> times edges from an iterable container.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.delete_edge" title="sage.graphs.generic_graph.GenericGraph.delete_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">delete_edge()</span></code></a></p></td>
<td><p>Delete the edge from <code class="docutils literal notranslate"><span class="pre">u</span></code> to <code class="docutils literal notranslate"><span class="pre">v</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.delete_edges" title="sage.graphs.generic_graph.GenericGraph.delete_edges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">delete_edges()</span></code></a></p></td>
<td><p>Delete edges from an iterable container.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.contract_edge" title="sage.graphs.generic_graph.GenericGraph.contract_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contract_edge()</span></code></a></p></td>
<td><p>Contract an edge from <code class="docutils literal notranslate"><span class="pre">u</span></code> to <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.contract_edges" title="sage.graphs.generic_graph.GenericGraph.contract_edges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contract_edges()</span></code></a></p></td>
<td><p>Contract edges from an iterable container.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.delete_multiedge" title="sage.graphs.generic_graph.GenericGraph.delete_multiedge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">delete_multiedge()</span></code></a></p></td>
<td><p>Delete all edges from <code class="docutils literal notranslate"><span class="pre">u</span></code> to <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.set_edge_label" title="sage.graphs.generic_graph.GenericGraph.set_edge_label"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_edge_label()</span></code></a></p></td>
<td><p>Set the edge label of a given edge.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.has_edge" title="sage.graphs.generic_graph.GenericGraph.has_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_edge()</span></code></a></p></td>
<td><p>Check whether <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v)</span></code> is an edge of the (di)graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.edges" title="sage.graphs.generic_graph.GenericGraph.edges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">edges()</span></code></a></p></td>
<td><p>Return a <a class="reference internal" href="views.html#sage.graphs.views.EdgesView" title="sage.graphs.views.EdgesView"><code class="xref py py-class docutils literal notranslate"><span class="pre">EdgesView</span></code></a> of edges.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.edge_boundary" title="sage.graphs.generic_graph.GenericGraph.edge_boundary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">edge_boundary()</span></code></a></p></td>
<td><p>Return a list of edges <code class="docutils literal notranslate"><span class="pre">(u,v,l)</span></code> with <code class="docutils literal notranslate"><span class="pre">u</span></code> in <code class="docutils literal notranslate"><span class="pre">vertices1</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.edge_iterator" title="sage.graphs.generic_graph.GenericGraph.edge_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">edge_iterator()</span></code></a></p></td>
<td><p>Return an iterator over edges.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.edges_incident" title="sage.graphs.generic_graph.GenericGraph.edges_incident"><code class="xref py py-meth docutils literal notranslate"><span class="pre">edges_incident()</span></code></a></p></td>
<td><p>Return incident edges to some vertices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.edge_label" title="sage.graphs.generic_graph.GenericGraph.edge_label"><code class="xref py py-meth docutils literal notranslate"><span class="pre">edge_label()</span></code></a></p></td>
<td><p>Return the label of an edge.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.edge_labels" title="sage.graphs.generic_graph.GenericGraph.edge_labels"><code class="xref py py-meth docutils literal notranslate"><span class="pre">edge_labels()</span></code></a></p></td>
<td><p>Return a list of the labels of all edges in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.remove_multiple_edges" title="sage.graphs.generic_graph.GenericGraph.remove_multiple_edges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">remove_multiple_edges()</span></code></a></p></td>
<td><p>Remove all multiple edges, retaining one edge for each.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.clear" title="sage.graphs.generic_graph.GenericGraph.clear"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clear()</span></code></a></p></td>
<td><p>Empty the graph of vertices and edges and removes name, associated objects, and position information.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.degree" title="sage.graphs.generic_graph.GenericGraph.degree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">degree()</span></code></a></p></td>
<td><p>Return the degree (in + out for digraphs) of a vertex or of vertices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.average_degree" title="sage.graphs.generic_graph.GenericGraph.average_degree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">average_degree()</span></code></a></p></td>
<td><p>Return the average degree of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.degree_histogram" title="sage.graphs.generic_graph.GenericGraph.degree_histogram"><code class="xref py py-meth docutils literal notranslate"><span class="pre">degree_histogram()</span></code></a></p></td>
<td><p>Return a list, whose ith entry is the frequency of degree i.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.degree_iterator" title="sage.graphs.generic_graph.GenericGraph.degree_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">degree_iterator()</span></code></a></p></td>
<td><p>Return an iterator over the degrees of the (di)graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.degree_sequence" title="sage.graphs.generic_graph.GenericGraph.degree_sequence"><code class="xref py py-meth docutils literal notranslate"><span class="pre">degree_sequence()</span></code></a></p></td>
<td><p>Return the degree sequence of this (di)graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.random_subgraph" title="sage.graphs.generic_graph.GenericGraph.random_subgraph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">random_subgraph()</span></code></a></p></td>
<td><p>Return a random subgraph containing each vertex with probability <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.add_clique" title="sage.graphs.generic_graph.GenericGraph.add_clique"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_clique()</span></code></a></p></td>
<td><p>Add a clique to the graph with the given vertices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.add_cycle" title="sage.graphs.generic_graph.GenericGraph.add_cycle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_cycle()</span></code></a></p></td>
<td><p>Add a cycle to the graph with the given vertices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.add_path" title="sage.graphs.generic_graph.GenericGraph.add_path"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_path()</span></code></a></p></td>
<td><p>Add a path to the graph with the given vertices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.complement" title="sage.graphs.generic_graph.GenericGraph.complement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">complement()</span></code></a></p></td>
<td><p>Return the complement of the (di)graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.line_graph" title="sage.graphs.generic_graph.GenericGraph.line_graph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">line_graph()</span></code></a></p></td>
<td><p>Return the line graph of the (di)graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.to_simple" title="sage.graphs.generic_graph.GenericGraph.to_simple"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_simple()</span></code></a></p></td>
<td><p>Return a simple version of itself (i.e., undirected and loops and multiple edges are removed).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.disjoint_union" title="sage.graphs.generic_graph.GenericGraph.disjoint_union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">disjoint_union()</span></code></a></p></td>
<td><p>Return the disjoint union of self and other.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.union" title="sage.graphs.generic_graph.GenericGraph.union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">union()</span></code></a></p></td>
<td><p>Return the union of self and other.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.relabel" title="sage.graphs.generic_graph.GenericGraph.relabel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relabel()</span></code></a></p></td>
<td><p>Relabel the vertices of <code class="docutils literal notranslate"><span class="pre">self</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.degree_to_cell" title="sage.graphs.generic_graph.GenericGraph.degree_to_cell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">degree_to_cell()</span></code></a></p></td>
<td><p>Return the number of edges from vertex to an edge in cell.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.subgraph" title="sage.graphs.generic_graph.GenericGraph.subgraph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subgraph()</span></code></a></p></td>
<td><p>Return the subgraph containing the given vertices and edges.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_subgraph" title="sage.graphs.generic_graph.GenericGraph.is_subgraph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_subgraph()</span></code></a></p></td>
<td><p>Check whether <code class="docutils literal notranslate"><span class="pre">self</span></code> is a subgraph of <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p></td>
</tr>
</tbody>
</table>
<p><strong>Graph products:</strong></p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.cartesian_product" title="sage.graphs.generic_graph.GenericGraph.cartesian_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cartesian_product()</span></code></a></p></td>
<td><p>Return the Cartesian product of self and other.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.tensor_product" title="sage.graphs.generic_graph.GenericGraph.tensor_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tensor_product()</span></code></a></p></td>
<td><p>Return the tensor product, also called the categorical product, of self and other.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.lexicographic_product" title="sage.graphs.generic_graph.GenericGraph.lexicographic_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lexicographic_product()</span></code></a></p></td>
<td><p>Return the lexicographic product of self and other.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.strong_product" title="sage.graphs.generic_graph.GenericGraph.strong_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">strong_product()</span></code></a></p></td>
<td><p>Return the strong product of self and other.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.disjunctive_product" title="sage.graphs.generic_graph.GenericGraph.disjunctive_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">disjunctive_product()</span></code></a></p></td>
<td><p>Return the disjunctive product of self and other.</p></td>
</tr>
</tbody>
</table>
<p><strong>Paths and cycles:</strong></p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.eulerian_orientation" title="sage.graphs.generic_graph.GenericGraph.eulerian_orientation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eulerian_orientation()</span></code></a></p></td>
<td><p>Return a DiGraph which is an Eulerian orientation of the current graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.eulerian_circuit" title="sage.graphs.generic_graph.GenericGraph.eulerian_circuit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eulerian_circuit()</span></code></a></p></td>
<td><p>Return a list of edges forming an Eulerian circuit if one exists.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.minimum_cycle_basis" title="sage.graphs.generic_graph.GenericGraph.minimum_cycle_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">minimum_cycle_basis()</span></code></a></p></td>
<td><p>Return a minimum weight cycle basis of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.cycle_basis" title="sage.graphs.generic_graph.GenericGraph.cycle_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cycle_basis()</span></code></a></p></td>
<td><p>Return a list of cycles which form a basis of the cycle space of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.all_paths" title="sage.graphs.generic_graph.GenericGraph.all_paths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">all_paths()</span></code></a></p></td>
<td><p>Return a list of all paths (also lists) between a pair of vertices in the (di)graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.triangles_count" title="sage.graphs.generic_graph.GenericGraph.triangles_count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">triangles_count()</span></code></a></p></td>
<td><p>Return the number of triangles in the (di)graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.shortest_simple_paths" title="sage.graphs.generic_graph.GenericGraph.shortest_simple_paths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shortest_simple_paths()</span></code></a></p></td>
<td><p>Return an iterator over the simple paths between a pair of vertices.</p></td>
</tr>
</tbody>
</table>
<p><strong>Linear algebra:</strong></p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.spectrum" title="sage.graphs.generic_graph.GenericGraph.spectrum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spectrum()</span></code></a></p></td>
<td><p>Return a list of the eigenvalues of the adjacency matrix.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.eigenvectors" title="sage.graphs.generic_graph.GenericGraph.eigenvectors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eigenvectors()</span></code></a></p></td>
<td><p>Return the <em>right</em> eigenvectors of the adjacency matrix of the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.eigenspaces" title="sage.graphs.generic_graph.GenericGraph.eigenspaces"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eigenspaces()</span></code></a></p></td>
<td><p>Return the <em>right</em> eigenspaces of the adjacency matrix of the graph.</p></td>
</tr>
</tbody>
</table>
<p><strong>Some metrics:</strong></p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.cluster_triangles" title="sage.graphs.generic_graph.GenericGraph.cluster_triangles"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cluster_triangles()</span></code></a></p></td>
<td><p>Return the number of triangles for the set nbunch of vertices as a dictionary keyed by vertex.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.clustering_average" title="sage.graphs.generic_graph.GenericGraph.clustering_average"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clustering_average()</span></code></a></p></td>
<td><p>Return the average clustering coefficient.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.clustering_coeff" title="sage.graphs.generic_graph.GenericGraph.clustering_coeff"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clustering_coeff()</span></code></a></p></td>
<td><p>Return the clustering coefficient for each vertex in nbunch</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.cluster_transitivity" title="sage.graphs.generic_graph.GenericGraph.cluster_transitivity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cluster_transitivity()</span></code></a></p></td>
<td><p>Return the transitivity (fraction of transitive triangles) of the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.szeged_index" title="sage.graphs.generic_graph.GenericGraph.szeged_index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">szeged_index()</span></code></a></p></td>
<td><p>Return the Szeged index of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.katz_centrality" title="sage.graphs.generic_graph.GenericGraph.katz_centrality"><code class="xref py py-meth docutils literal notranslate"><span class="pre">katz_centrality()</span></code></a></p></td>
<td><p>Return the katz centrality of the vertex u of the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.katz_matrix" title="sage.graphs.generic_graph.GenericGraph.katz_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">katz_matrix()</span></code></a></p></td>
<td><p>Return the katz matrix of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.pagerank" title="sage.graphs.generic_graph.GenericGraph.pagerank"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pagerank()</span></code></a></p></td>
<td><p>Return the PageRank of the vertices of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></td>
</tr>
</tbody>
</table>
<p><strong>Automorphism group:</strong></p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.coarsest_equitable_refinement" title="sage.graphs.generic_graph.GenericGraph.coarsest_equitable_refinement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coarsest_equitable_refinement()</span></code></a></p></td>
<td><p>Return the coarsest partition which is finer than the input partition, and equitable with respect to self.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.automorphism_group" title="sage.graphs.generic_graph.GenericGraph.automorphism_group"><code class="xref py py-meth docutils literal notranslate"><span class="pre">automorphism_group()</span></code></a></p></td>
<td><p>Return the largest subgroup of the automorphism group of the (di)graph whose orbit partition is finer than the partition given.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_vertex_transitive" title="sage.graphs.generic_graph.GenericGraph.is_vertex_transitive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_vertex_transitive()</span></code></a></p></td>
<td><p>Return whether the automorphism group of self is transitive within the partition provided</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_isomorphic" title="sage.graphs.generic_graph.GenericGraph.is_isomorphic"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_isomorphic()</span></code></a></p></td>
<td><p>Test for isomorphism between self and other.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.canonical_label" title="sage.graphs.generic_graph.GenericGraph.canonical_label"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_label()</span></code></a></p></td>
<td><p>Return the canonical graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_cayley" title="sage.graphs.generic_graph.GenericGraph.is_cayley"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_cayley()</span></code></a></p></td>
<td><p>Check whether the graph is a Cayley graph.</p></td>
</tr>
</tbody>
</table>
<p><strong>Graph properties:</strong></p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_eulerian" title="sage.graphs.generic_graph.GenericGraph.is_eulerian"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_eulerian()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the graph has a (closed) tour that visits each edge exactly once.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_planar" title="sage.graphs.generic_graph.GenericGraph.is_planar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_planar()</span></code></a></p></td>
<td><p>Check whether the graph is planar.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_circular_planar" title="sage.graphs.generic_graph.GenericGraph.is_circular_planar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_circular_planar()</span></code></a></p></td>
<td><p>Check whether the graph is circular planar (outerplanar)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_regular" title="sage.graphs.generic_graph.GenericGraph.is_regular"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_regular()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if this graph is (<span class="math notranslate nohighlight">\(k\)</span>-)regular.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_chordal" title="sage.graphs.generic_graph.GenericGraph.is_chordal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_chordal()</span></code></a></p></td>
<td><p>Check whether the given graph is chordal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_bipartite" title="sage.graphs.generic_graph.GenericGraph.is_bipartite"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_bipartite()</span></code></a></p></td>
<td><p>Test whether the given graph is bipartite.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_circulant" title="sage.graphs.generic_graph.GenericGraph.is_circulant"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_circulant()</span></code></a></p></td>
<td><p>Check whether the graph is a circulant graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_interval" title="sage.graphs.generic_graph.GenericGraph.is_interval"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_interval()</span></code></a></p></td>
<td><p>Check whether the graph is an interval graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_gallai_tree" title="sage.graphs.generic_graph.GenericGraph.is_gallai_tree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_gallai_tree()</span></code></a></p></td>
<td><p>Return whether the current graph is a Gallai tree.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_clique" title="sage.graphs.generic_graph.GenericGraph.is_clique"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_clique()</span></code></a></p></td>
<td><p>Check whether a set of vertices is a clique</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_cycle" title="sage.graphs.generic_graph.GenericGraph.is_cycle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_cycle()</span></code></a></p></td>
<td><p>Check whether <code class="docutils literal notranslate"><span class="pre">self</span></code> is a (directed) cycle graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_independent_set" title="sage.graphs.generic_graph.GenericGraph.is_independent_set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_independent_set()</span></code></a></p></td>
<td><p>Check whether <code class="docutils literal notranslate"><span class="pre">vertices</span></code> is an independent set of <code class="docutils literal notranslate"><span class="pre">self</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_transitively_reduced" title="sage.graphs.generic_graph.GenericGraph.is_transitively_reduced"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_transitively_reduced()</span></code></a></p></td>
<td><p>Test whether the digraph is transitively reduced.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_equitable" title="sage.graphs.generic_graph.GenericGraph.is_equitable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_equitable()</span></code></a></p></td>
<td><p>Check whether the given partition is equitable with respect to self.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_self_complementary" title="sage.graphs.generic_graph.GenericGraph.is_self_complementary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_self_complementary()</span></code></a></p></td>
<td><p>Check whether the graph is self-complementary.</p></td>
</tr>
</tbody>
</table>
<p><strong>Traversals:</strong></p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.breadth_first_search" title="sage.graphs.generic_graph.GenericGraph.breadth_first_search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">breadth_first_search()</span></code></a></p></td>
<td><p>Return an iterator over the vertices in a breadth-first ordering.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.depth_first_search" title="sage.graphs.generic_graph.GenericGraph.depth_first_search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">depth_first_search()</span></code></a></p></td>
<td><p>Return an iterator over the vertices in a depth-first ordering.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.lex_BFS" title="sage.graphs.generic_graph.GenericGraph.lex_BFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_BFS()</span></code></a></p></td>
<td><p>Perform a lexicographic breadth first search (LexBFS) on the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.lex_UP" title="sage.graphs.generic_graph.GenericGraph.lex_UP"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_UP()</span></code></a></p></td>
<td><p>Perform a lexicographic UP search (LexUP) on the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.lex_DFS" title="sage.graphs.generic_graph.GenericGraph.lex_DFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DFS()</span></code></a></p></td>
<td><p>Perform a lexicographic depth first search (LexDFS) on the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.lex_DOWN" title="sage.graphs.generic_graph.GenericGraph.lex_DOWN"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DOWN()</span></code></a></p></td>
<td><p>Perform a lexicographic DOWN search (LexDOWN) on the graph.</p></td>
</tr>
</tbody>
</table>
<p><strong>Distances:</strong></p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.centrality_betweenness" title="sage.graphs.generic_graph.GenericGraph.centrality_betweenness"><code class="xref py py-meth docutils literal notranslate"><span class="pre">centrality_betweenness()</span></code></a></p></td>
<td><p>Return the betweenness centrality</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.centrality_closeness" title="sage.graphs.generic_graph.GenericGraph.centrality_closeness"><code class="xref py py-meth docutils literal notranslate"><span class="pre">centrality_closeness()</span></code></a></p></td>
<td><p>Returns the closeness centrality (1/average distance to all vertices)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.distance" title="sage.graphs.generic_graph.GenericGraph.distance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">distance()</span></code></a></p></td>
<td><p>Return the (directed) distance from u to v in the (di)graph</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.distance_all_pairs" title="sage.graphs.generic_graph.GenericGraph.distance_all_pairs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">distance_all_pairs()</span></code></a></p></td>
<td><p>Return the distances between all pairs of vertices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.distances_distribution" title="sage.graphs.generic_graph.GenericGraph.distances_distribution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">distances_distribution()</span></code></a></p></td>
<td><p>Return the distances distribution of the (di)graph in a dictionary.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.distance_graph" title="sage.graphs.generic_graph.GenericGraph.distance_graph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">distance_graph()</span></code></a></p></td>
<td><p>Return the graph on the same vertex set as the original graph but vertices are adjacent in the returned graph if and only if they are at specified distances in the original graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.girth" title="sage.graphs.generic_graph.GenericGraph.girth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">girth()</span></code></a></p></td>
<td><p>Return the girth of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.odd_girth" title="sage.graphs.generic_graph.GenericGraph.odd_girth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">odd_girth()</span></code></a></p></td>
<td><p>Return the odd girth of the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.shortest_path" title="sage.graphs.generic_graph.GenericGraph.shortest_path"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shortest_path()</span></code></a></p></td>
<td><p>Return a list of vertices representing some shortest path from <span class="math notranslate nohighlight">\(u\)</span> to <span class="math notranslate nohighlight">\(v\)</span></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.shortest_path_length" title="sage.graphs.generic_graph.GenericGraph.shortest_path_length"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shortest_path_length()</span></code></a></p></td>
<td><p>Return the minimal length of paths from u to v</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.shortest_paths" title="sage.graphs.generic_graph.GenericGraph.shortest_paths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shortest_paths()</span></code></a></p></td>
<td><p>Return a dictionary associating to each vertex v a shortest path from u to v, if it exists.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.shortest_path_lengths" title="sage.graphs.generic_graph.GenericGraph.shortest_path_lengths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shortest_path_lengths()</span></code></a></p></td>
<td><p>Return a dictionary of shortest path lengths keyed by targets that are connected by a path from u.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.shortest_path_all_pairs" title="sage.graphs.generic_graph.GenericGraph.shortest_path_all_pairs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shortest_path_all_pairs()</span></code></a></p></td>
<td><p>Compute a shortest path between each pair of vertices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.wiener_index" title="sage.graphs.generic_graph.GenericGraph.wiener_index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wiener_index()</span></code></a></p></td>
<td><p>Return the Wiener index of the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.average_distance" title="sage.graphs.generic_graph.GenericGraph.average_distance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">average_distance()</span></code></a></p></td>
<td><p>Return the average distance between vertices of the graph.</p></td>
</tr>
</tbody>
</table>
<p><strong>Flows, connectivity, trees:</strong></p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_connected" title="sage.graphs.generic_graph.GenericGraph.is_connected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_connected()</span></code></a></p></td>
<td><p>Test whether the (di)graph is connected.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.connected_components" title="sage.graphs.generic_graph.GenericGraph.connected_components"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connected_components()</span></code></a></p></td>
<td><p>Return the list of connected components</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.connected_components_number" title="sage.graphs.generic_graph.GenericGraph.connected_components_number"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connected_components_number()</span></code></a></p></td>
<td><p>Return the number of connected components.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.connected_components_subgraphs" title="sage.graphs.generic_graph.GenericGraph.connected_components_subgraphs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connected_components_subgraphs()</span></code></a></p></td>
<td><p>Return a list of connected components as graph objects.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.connected_component_containing_vertex" title="sage.graphs.generic_graph.GenericGraph.connected_component_containing_vertex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connected_component_containing_vertex()</span></code></a></p></td>
<td><p>Return a list of the vertices connected to vertex.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.connected_components_sizes" title="sage.graphs.generic_graph.GenericGraph.connected_components_sizes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connected_components_sizes()</span></code></a></p></td>
<td><p>Return the sizes of the connected components as a list.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.blocks_and_cut_vertices" title="sage.graphs.generic_graph.GenericGraph.blocks_and_cut_vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">blocks_and_cut_vertices()</span></code></a></p></td>
<td><p>Compute the blocks and cut vertices of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.blocks_and_cuts_tree" title="sage.graphs.generic_graph.GenericGraph.blocks_and_cuts_tree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">blocks_and_cuts_tree()</span></code></a></p></td>
<td><p>Compute the blocks-and-cuts tree of the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_cut_edge" title="sage.graphs.generic_graph.GenericGraph.is_cut_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_cut_edge()</span></code></a></p></td>
<td><p>Return True if the input edge is a cut-edge or a bridge.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_cut_vertex" title="sage.graphs.generic_graph.GenericGraph.is_cut_vertex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_cut_vertex()</span></code></a></p></td>
<td><p>Return True if the input vertex is a cut-vertex.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.edge_cut" title="sage.graphs.generic_graph.GenericGraph.edge_cut"><code class="xref py py-meth docutils literal notranslate"><span class="pre">edge_cut()</span></code></a></p></td>
<td><p>Return a minimum edge cut between vertices <span class="math notranslate nohighlight">\(s\)</span> and <span class="math notranslate nohighlight">\(t\)</span></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.vertex_cut" title="sage.graphs.generic_graph.GenericGraph.vertex_cut"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertex_cut()</span></code></a></p></td>
<td><p>Return a minimum vertex cut between non-adjacent vertices <span class="math notranslate nohighlight">\(s\)</span> and <span class="math notranslate nohighlight">\(t\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.flow" title="sage.graphs.generic_graph.GenericGraph.flow"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flow()</span></code></a></p></td>
<td><p>Return a maximum flow in the graph from <code class="docutils literal notranslate"><span class="pre">x</span></code> to <code class="docutils literal notranslate"><span class="pre">y</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.nowhere_zero_flow" title="sage.graphs.generic_graph.GenericGraph.nowhere_zero_flow"><code class="xref py py-meth docutils literal notranslate"><span class="pre">nowhere_zero_flow()</span></code></a></p></td>
<td><p>Return a <span class="math notranslate nohighlight">\(k\)</span>-nowhere zero flow of the (di)graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.edge_disjoint_paths" title="sage.graphs.generic_graph.GenericGraph.edge_disjoint_paths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">edge_disjoint_paths()</span></code></a></p></td>
<td><p>Return a list of edge-disjoint paths between two vertices</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.vertex_disjoint_paths" title="sage.graphs.generic_graph.GenericGraph.vertex_disjoint_paths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertex_disjoint_paths()</span></code></a></p></td>
<td><p>Return a list of vertex-disjoint paths between two vertices</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.edge_connectivity" title="sage.graphs.generic_graph.GenericGraph.edge_connectivity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">edge_connectivity()</span></code></a></p></td>
<td><p>Return the edge connectivity of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.vertex_connectivity" title="sage.graphs.generic_graph.GenericGraph.vertex_connectivity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertex_connectivity()</span></code></a></p></td>
<td><p>Return the vertex connectivity of the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.transitive_closure" title="sage.graphs.generic_graph.GenericGraph.transitive_closure"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transitive_closure()</span></code></a></p></td>
<td><p>Compute the transitive closure of a graph and returns it.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.transitive_reduction" title="sage.graphs.generic_graph.GenericGraph.transitive_reduction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transitive_reduction()</span></code></a></p></td>
<td><p>Return a transitive reduction of a graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.min_spanning_tree" title="sage.graphs.generic_graph.GenericGraph.min_spanning_tree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">min_spanning_tree()</span></code></a></p></td>
<td><p>Return the edges of a minimum spanning tree.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.spanning_trees_count" title="sage.graphs.generic_graph.GenericGraph.spanning_trees_count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spanning_trees_count()</span></code></a></p></td>
<td><p>Return the number of spanning trees in a graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.dominator_tree" title="sage.graphs.generic_graph.GenericGraph.dominator_tree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dominator_tree()</span></code></a></p></td>
<td><p>Returns a dominator tree of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.connected_subgraph_iterator" title="sage.graphs.generic_graph.GenericGraph.connected_subgraph_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connected_subgraph_iterator()</span></code></a></p></td>
<td><p>Iterator over the induced connected subgraphs of order at most <span class="math notranslate nohighlight">\(k\)</span></p></td>
</tr>
</tbody>
</table>
<p><strong>Plot/embedding-related methods:</strong></p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.set_embedding" title="sage.graphs.generic_graph.GenericGraph.set_embedding"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_embedding()</span></code></a></p></td>
<td><p>Set a combinatorial embedding dictionary to <code class="docutils literal notranslate"><span class="pre">_embedding</span></code> attribute.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.get_embedding" title="sage.graphs.generic_graph.GenericGraph.get_embedding"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_embedding()</span></code></a></p></td>
<td><p>Return the attribute _embedding if it exists.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.faces" title="sage.graphs.generic_graph.GenericGraph.faces"><code class="xref py py-meth docutils literal notranslate"><span class="pre">faces()</span></code></a></p></td>
<td><p>Return the faces of an embedded graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.genus" title="sage.graphs.generic_graph.GenericGraph.genus"><code class="xref py py-meth docutils literal notranslate"><span class="pre">genus()</span></code></a></p></td>
<td><p>Return the number of faces of an embedded graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.planar_dual" title="sage.graphs.generic_graph.GenericGraph.planar_dual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">planar_dual()</span></code></a></p></td>
<td><p>Return the planar dual of an embedded graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.get_pos" title="sage.graphs.generic_graph.GenericGraph.get_pos"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_pos()</span></code></a></p></td>
<td><p>Return the position dictionary</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.set_pos" title="sage.graphs.generic_graph.GenericGraph.set_pos"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_pos()</span></code></a></p></td>
<td><p>Set the position dictionary.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.layout_planar" title="sage.graphs.generic_graph.GenericGraph.layout_planar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">layout_planar()</span></code></a></p></td>
<td><p>Compute a planar layout of the graph using Schnyder’s algorithm.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_drawn_free_of_edge_crossings" title="sage.graphs.generic_graph.GenericGraph.is_drawn_free_of_edge_crossings"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_drawn_free_of_edge_crossings()</span></code></a></p></td>
<td><p>Check whether the position dictionary gives a planar embedding.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.latex_options" title="sage.graphs.generic_graph.GenericGraph.latex_options"><code class="xref py py-meth docutils literal notranslate"><span class="pre">latex_options()</span></code></a></p></td>
<td><p>Return an instance of <a class="reference internal" href="graph_latex.html#sage.graphs.graph_latex.GraphLatex" title="sage.graphs.graph_latex.GraphLatex"><code class="xref py py-class docutils literal notranslate"><span class="pre">GraphLatex</span></code></a> for the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.set_latex_options" title="sage.graphs.generic_graph.GenericGraph.set_latex_options"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_latex_options()</span></code></a></p></td>
<td><p>Set multiple options for rendering a graph with LaTeX.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.layout" title="sage.graphs.generic_graph.GenericGraph.layout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">layout()</span></code></a></p></td>
<td><p>Return a layout for the vertices of this graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.layout_spring" title="sage.graphs.generic_graph.GenericGraph.layout_spring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">layout_spring()</span></code></a></p></td>
<td><p>Return a spring layout for this graph</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.layout_ranked" title="sage.graphs.generic_graph.GenericGraph.layout_ranked"><code class="xref py py-meth docutils literal notranslate"><span class="pre">layout_ranked()</span></code></a></p></td>
<td><p>Return a ranked layout for this graph</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.layout_extend_randomly" title="sage.graphs.generic_graph.GenericGraph.layout_extend_randomly"><code class="xref py py-meth docutils literal notranslate"><span class="pre">layout_extend_randomly()</span></code></a></p></td>
<td><p>Extend randomly a partial layout</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.layout_circular" title="sage.graphs.generic_graph.GenericGraph.layout_circular"><code class="xref py py-meth docutils literal notranslate"><span class="pre">layout_circular()</span></code></a></p></td>
<td><p>Return a circular layout for this graph</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.layout_tree" title="sage.graphs.generic_graph.GenericGraph.layout_tree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">layout_tree()</span></code></a></p></td>
<td><p>Return an ordered tree layout for this graph</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.layout_forest" title="sage.graphs.generic_graph.GenericGraph.layout_forest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">layout_forest()</span></code></a></p></td>
<td><p>Return an ordered forest layout for this graph</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.layout_graphviz" title="sage.graphs.generic_graph.GenericGraph.layout_graphviz"><code class="xref py py-meth docutils literal notranslate"><span class="pre">layout_graphviz()</span></code></a></p></td>
<td><p>Call <code class="docutils literal notranslate"><span class="pre">graphviz</span></code> to compute a layout of the vertices of this graph.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">_circle_embedding()</span></code></p></td>
<td><p>Set some vertices on a circle in the embedding of this graph.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">_line_embedding()</span></code></p></td>
<td><p>Set some vertices on a line in the embedding of this graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.graphplot" title="sage.graphs.generic_graph.GenericGraph.graphplot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graphplot()</span></code></a></p></td>
<td><p>Return a <a class="reference internal" href="graph_plot.html#sage.graphs.graph_plot.GraphPlot" title="sage.graphs.graph_plot.GraphPlot"><code class="xref py py-class docutils literal notranslate"><span class="pre">GraphPlot</span></code></a> object.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.plot" title="sage.graphs.generic_graph.GenericGraph.plot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot()</span></code></a></p></td>
<td><p>Return a <a class="reference external" href="../../../plotting/sage/plot/graphics.html#sage.plot.graphics.Graphics" title="(in Sage 9.5 Reference Manual: 2D Graphics v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graphics</span></code></a> object representing the (di)graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.show" title="sage.graphs.generic_graph.GenericGraph.show"><code class="xref py py-meth docutils literal notranslate"><span class="pre">show()</span></code></a></p></td>
<td><p>Show the (di)graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.plot3d" title="sage.graphs.generic_graph.GenericGraph.plot3d"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot3d()</span></code></a></p></td>
<td><p>Plot the graph in three dimensions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.show3d" title="sage.graphs.generic_graph.GenericGraph.show3d"><code class="xref py py-meth docutils literal notranslate"><span class="pre">show3d()</span></code></a></p></td>
<td><p>Plot the graph using <a class="reference external" href="../../../plot3d/sage/plot/plot3d/tachyon.html#sage.plot.plot3d.tachyon.Tachyon" title="(in Sage 9.5 Reference Manual: 3D Graphics v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tachyon</span></code></a>, and shows the resulting plot.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.graphviz_string" title="sage.graphs.generic_graph.GenericGraph.graphviz_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graphviz_string()</span></code></a></p></td>
<td><p>Return a representation in the <code class="docutils literal notranslate"><span class="pre">dot</span></code> language.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.graphviz_to_file_named" title="sage.graphs.generic_graph.GenericGraph.graphviz_to_file_named"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graphviz_to_file_named()</span></code></a></p></td>
<td><p>Write a representation in the <code class="docutils literal notranslate"><span class="pre">dot</span></code> language in a file.</p></td>
</tr>
</tbody>
</table>
<p><strong>Algorithmically hard stuff:</strong></p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.steiner_tree" title="sage.graphs.generic_graph.GenericGraph.steiner_tree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">steiner_tree()</span></code></a></p></td>
<td><p>Return a tree of minimum weight connecting the given set of vertices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.edge_disjoint_spanning_trees" title="sage.graphs.generic_graph.GenericGraph.edge_disjoint_spanning_trees"><code class="xref py py-meth docutils literal notranslate"><span class="pre">edge_disjoint_spanning_trees()</span></code></a></p></td>
<td><p>Return the desired number of edge-disjoint spanning trees/arborescences.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.feedback_vertex_set" title="sage.graphs.generic_graph.GenericGraph.feedback_vertex_set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">feedback_vertex_set()</span></code></a></p></td>
<td><p>Compute the minimum feedback vertex set of a (di)graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.multiway_cut" title="sage.graphs.generic_graph.GenericGraph.multiway_cut"><code class="xref py py-meth docutils literal notranslate"><span class="pre">multiway_cut()</span></code></a></p></td>
<td><p>Return a minimum edge multiway cut</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.max_cut" title="sage.graphs.generic_graph.GenericGraph.max_cut"><code class="xref py py-meth docutils literal notranslate"><span class="pre">max_cut()</span></code></a></p></td>
<td><p>Return a maximum edge cut of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.longest_path" title="sage.graphs.generic_graph.GenericGraph.longest_path"><code class="xref py py-meth docutils literal notranslate"><span class="pre">longest_path()</span></code></a></p></td>
<td><p>Return a longest path of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.traveling_salesman_problem" title="sage.graphs.generic_graph.GenericGraph.traveling_salesman_problem"><code class="xref py py-meth docutils literal notranslate"><span class="pre">traveling_salesman_problem()</span></code></a></p></td>
<td><p>Solve the traveling salesman problem (TSP)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_hamiltonian" title="sage.graphs.generic_graph.GenericGraph.is_hamiltonian"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_hamiltonian()</span></code></a></p></td>
<td><p>Test whether the current graph is Hamiltonian.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.hamiltonian_cycle" title="sage.graphs.generic_graph.GenericGraph.hamiltonian_cycle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hamiltonian_cycle()</span></code></a></p></td>
<td><p>Return a Hamiltonian cycle/circuit of the current graph/digraph</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.hamiltonian_path" title="sage.graphs.generic_graph.GenericGraph.hamiltonian_path"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hamiltonian_path()</span></code></a></p></td>
<td><p>Return a Hamiltonian path of the current graph/digraph</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.multicommodity_flow" title="sage.graphs.generic_graph.GenericGraph.multicommodity_flow"><code class="xref py py-meth docutils literal notranslate"><span class="pre">multicommodity_flow()</span></code></a></p></td>
<td><p>Solve a multicommodity flow problem.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.disjoint_routed_paths" title="sage.graphs.generic_graph.GenericGraph.disjoint_routed_paths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">disjoint_routed_paths()</span></code></a></p></td>
<td><p>Return a set of disjoint routed paths.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.dominating_set" title="sage.graphs.generic_graph.GenericGraph.dominating_set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dominating_set()</span></code></a></p></td>
<td><p>Return a minimum dominating set of the graph</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.greedy_dominating_set" title="sage.graphs.generic_graph.GenericGraph.greedy_dominating_set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">greedy_dominating_set()</span></code></a></p></td>
<td><p>Return a greedy distance-<span class="math notranslate nohighlight">\(k\)</span> dominating set of of the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.subgraph_search" title="sage.graphs.generic_graph.GenericGraph.subgraph_search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subgraph_search()</span></code></a></p></td>
<td><p>Return a copy of <code class="docutils literal notranslate"><span class="pre">G</span></code> in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.subgraph_search_count" title="sage.graphs.generic_graph.GenericGraph.subgraph_search_count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subgraph_search_count()</span></code></a></p></td>
<td><p>Return the number of labelled occurrences of <code class="docutils literal notranslate"><span class="pre">G</span></code> in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.subgraph_search_iterator" title="sage.graphs.generic_graph.GenericGraph.subgraph_search_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subgraph_search_iterator()</span></code></a></p></td>
<td><p>Return an iterator over the labelled copies of <code class="docutils literal notranslate"><span class="pre">G</span></code> in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.characteristic_polynomial" title="sage.graphs.generic_graph.GenericGraph.characteristic_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">characteristic_polynomial()</span></code></a></p></td>
<td><p>Return the characteristic polynomial of the adjacency matrix of the (di)graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.genus" title="sage.graphs.generic_graph.GenericGraph.genus"><code class="xref py py-meth docutils literal notranslate"><span class="pre">genus()</span></code></a></p></td>
<td><p>Return the minimal genus of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.crossing_number" title="sage.graphs.generic_graph.GenericGraph.crossing_number"><code class="xref py py-meth docutils literal notranslate"><span class="pre">crossing_number()</span></code></a></p></td>
<td><p>Return the crossing number of the graph.</p></td>
</tr>
</tbody>
</table>
<p><strong>Miscellaneous</strong></p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.edge_polytope" title="sage.graphs.generic_graph.GenericGraph.edge_polytope"><code class="xref py py-meth docutils literal notranslate"><span class="pre">edge_polytope()</span></code></a></p></td>
<td><p>Return the edge polytope of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.symmetric_edge_polytope" title="sage.graphs.generic_graph.GenericGraph.symmetric_edge_polytope"><code class="xref py py-meth docutils literal notranslate"><span class="pre">symmetric_edge_polytope()</span></code></a></p></td>
<td><p>Return the symmetric edge polytope of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></td>
</tr>
</tbody>
</table>
<section id="methods">
<h2>Methods<a class="headerlink" href="#methods" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sage.graphs.generic_graph.</span></span><span class="sig-name descname"><span class="pre">GenericGraph</span></span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="generic_graph_pyx.html#sage.graphs.generic_graph_pyx.GenericGraph_pyx" title="sage.graphs.generic_graph_pyx.GenericGraph_pyx"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.graphs.generic_graph_pyx.GenericGraph_pyx</span></code></a></p>
<p>Base class for graphs and digraphs.</p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare self and other for equality.</p>
<p>Do not call this method directly. That is, for <code class="docutils literal notranslate"><span class="pre">G.__eq__(H)</span></code> write
<code class="docutils literal notranslate"><span class="pre">G</span> <span class="pre">==</span> <span class="pre">H</span></code>.</p>
<dl class="simple">
<dt>Two graphs are considered equal if the following hold:</dt><dd><ul class="simple">
<li><p>they are either both directed, or both undirected;</p></li>
<li><p>they have the same settings for loops, multiedges, and weightedness;</p></li>
<li><p>they have the same set of vertices;</p></li>
<li><p>they have the same (multi)set of arrows/edges, where labels of
arrows/edges are taken into account if <em>and only if</em> the graphs are
considered weighted. See <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.weighted" title="sage.graphs.generic_graph.GenericGraph.weighted"><code class="xref py py-meth docutils literal notranslate"><span class="pre">weighted()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<p>Note that this is <em>not</em> an isomorphism test.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">EmptyGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">==</span> <span class="n">H</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span> <span class="o">==</span> <span class="n">H</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mf">.9999</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">==</span> <span class="n">H</span>  <span class="c1"># random - most often true</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">7</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">==</span> <span class="n">H</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_loops</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">==</span> <span class="n">H</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mf">.3</span><span class="p">)</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mf">.3</span><span class="p">)</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">==</span> <span class="n">H</span> <span class="c1"># most often false</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">==</span> <span class="n">H</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note that graphs must be considered weighted, or Sage will not pay
attention to edge label data in equality testing:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">foo</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">foo</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">bar</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bar</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">foo</span> <span class="o">==</span> <span class="n">bar</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">foo</span><span class="o">.</span><span class="n">weighted</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">foo</span> <span class="o">==</span> <span class="n">bar</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">bar</span><span class="o">.</span><span class="n">weighted</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">foo</span> <span class="o">==</span> <span class="n">bar</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.add_clique">
<span class="sig-name descname"><span class="pre">add_clique</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.add_clique" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a clique to the graph with the given vertices.</p>
<p>If the vertices are already present, only the edges are added.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – an iterable container of vertices for the clique to be
added, e.g. a list, set, graph, etc.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">loops</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to add edges from
every given vertex to itself. This is allowed only if the (di)graph
allows loops.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_clique</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">add_clique</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">digraphs</span><span class="o">.</span><span class="n">Complete</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">add_clique</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">digraphs</span><span class="o">.</span><span class="n">Complete</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">loops</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">add_clique</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: cannot add edge from 0 to 0 in graph without loops</span>
</pre></div>
</div>
<p>If the list of vertices contains repeated elements, a loop will be added
at that vertex, even if <code class="docutils literal notranslate"><span class="pre">loops=False</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_clique</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(1, 1, None)]</span>
</pre></div>
</div>
<p>This is equivalent to:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_clique</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(1, 1, None)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.add_cycle">
<span class="sig-name descname"><span class="pre">add_cycle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.add_cycle" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a cycle to the graph with the given vertices.</p>
<p>If the vertices are already present, only the edges are added.</p>
<p>For digraphs, adds the directed cycle, whose orientation is determined
by the list. Adds edges <code class="docutils literal notranslate"><span class="pre">(vertices[u],</span> <span class="pre">vertices[u+1])</span></code> and
<code class="docutils literal notranslate"><span class="pre">(vertices[-1],</span> <span class="pre">vertices[0])</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – an ordered list of the vertices of the cycle to be
added</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_vertices</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span> <span class="n">G</span>
<span class="go">Graph on 10 vertices</span>
<span class="gp">sage: </span><span class="n">show</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_cycle</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">show</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_cycle</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">show</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">add_cycle</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None), (1, 2, None), (2, 3, None), (3, 0, None)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.add_edge">
<span class="sig-name descname"><span class="pre">add_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.add_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an edge from <code class="docutils literal notranslate"><span class="pre">u</span></code> to <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<p>INPUT: The following forms are all accepted:</p>
<ul class="simple">
<li><p>G.add_edge( 1, 2 )</p></li>
<li><p>G.add_edge( (1, 2) )</p></li>
<li><p>G.add_edges( [ (1, 2) ])</p></li>
<li><p>G.add_edge( 1, 2, ‘label’ )</p></li>
<li><p>G.add_edge( (1, 2, ‘label’) )</p></li>
<li><p>G.add_edges( [ (1, 2, ‘label’) ] )</p></li>
</ul>
<p>WARNING: The following intuitive input results in nonintuitive output:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="s1">&#39;label&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(&#39;label&#39;, (1, 2), None)]</span>
</pre></div>
</div>
<p>You must either use the <code class="docutils literal notranslate"><span class="pre">label</span></code> keyword:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;label&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(1, 2, &#39;label&#39;)]</span>
</pre></div>
</div>
<p>Or use one of these:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(1, 2, &#39;label&#39;)]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(1, 2, &#39;label&#39;)]</span>
</pre></div>
</div>
<p>Vertex name cannot be <code class="docutils literal notranslate"><span class="pre">None</span></code>, so:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.add_edges">
<span class="sig-name descname"><span class="pre">add_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edges</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.add_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Add edges from an iterable container.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">edges</span></code> – an iterable of edges, given either as <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v)</span></code>
or <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">label)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">loops</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">False</span></code>, remove all
loops <code class="docutils literal notranslate"><span class="pre">(v,</span> <span class="pre">v)</span></code> from the input iterator. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, remove loops
unless the graph allows loops.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">());</span> <span class="n">H</span>
<span class="go">Graph on 20 vertices</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">()</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">());</span> <span class="n">H</span>
<span class="go">Digraph on 20 vertices</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="nb">iter</span><span class="p">([]))</span>

<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;label&quot;</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None), (0, 2, &#39;label&#39;)]</span>
</pre></div>
</div>
<p>We demonstrate the <code class="docutils literal notranslate"><span class="pre">loops</span></code> argument:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">loops</span><span class="o">=</span><span class="kc">False</span><span class="p">);</span> <span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">loops</span><span class="o">=</span><span class="kc">None</span><span class="p">);</span> <span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]);</span> <span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: cannot add edge from 0 to 0 in graph without loops</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">loops</span><span class="o">=</span><span class="kc">False</span><span class="p">);</span> <span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">loops</span><span class="o">=</span><span class="kc">None</span><span class="p">);</span> <span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 0, None)]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]);</span> <span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 0, None)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.add_path">
<span class="sig-name descname"><span class="pre">add_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.add_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a path to the graph with the given vertices.</p>
<p>If the vertices are already present, only the edges are added.</p>
<p>For digraphs, adds the directed path <code class="docutils literal notranslate"><span class="pre">vertices[0],</span> <span class="pre">...,</span> <span class="pre">vertices[-1]</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – an ordered list of the vertices of the path to be
added</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_vertices</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span> <span class="n">G</span>
<span class="go">Graph on 10 vertices</span>
<span class="gp">sage: </span><span class="n">show</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">show</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">show</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None), (1, 2, None), (2, 3, None)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.add_vertex">
<span class="sig-name descname"><span class="pre">add_vertex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.add_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an isolated vertex.</p>
<p>If the vertex already exists, then nothing is done.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code> – an immutable object (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); when no name is
specified (default), then the new vertex will be represented by the least
integer not already representing a vertex. <code class="docutils literal notranslate"><span class="pre">name</span></code> must be an immutable
object (e.g., an integer, a tuple, etc.).</p></li>
</ul>
<p>As it is implemented now, if a graph <span class="math notranslate nohighlight">\(G\)</span> has a large number of vertices
with numeric labels, then <code class="docutils literal notranslate"><span class="pre">G.add_vertex()</span></code> could potentially be slow,
if <code class="docutils literal notranslate"><span class="pre">name=None</span></code>.</p>
<p>OUTPUT:</p>
<p>If <code class="docutils literal notranslate"><span class="pre">name=None</span></code>, the new vertex name is returned. <code class="docutils literal notranslate"><span class="pre">None</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">();</span> <span class="n">G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">();</span> <span class="n">G</span>
<span class="go">0</span>
<span class="go">Graph on 1 vertex</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">();</span> <span class="n">D</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">();</span> <span class="n">D</span>
<span class="go">0</span>
<span class="go">Digraph on 1 vertex</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.add_vertices">
<span class="sig-name descname"><span class="pre">add_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.add_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Add vertices to the (di)graph from an iterable container of vertices.</p>
<p>Vertices that already exist in the graph will not be added again.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – iterator container of vertex labels. A new label is
created, used and returned in the output list for all <code class="docutils literal notranslate"><span class="pre">None</span></code> values
in <code class="docutils literal notranslate"><span class="pre">vertices</span></code>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>Generated names of new vertices if there is at least one <code class="docutils literal notranslate"><span class="pre">None</span></code> value
present in <code class="docutils literal notranslate"><span class="pre">vertices</span></code>. <code class="docutils literal notranslate"><span class="pre">None</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">9</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span> <span class="mi">7</span><span class="p">:</span> <span class="p">[</span><span class="mi">9</span><span class="p">]}</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_vertices</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_vertices</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span><span class="o">.</span><span class="n">vertex_iterator</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_vertices</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_vertices</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="go">[0, 6]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.adjacency_matrix">
<span class="sig-name descname"><span class="pre">adjacency_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.adjacency_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the adjacency matrix of the (di)graph.</p>
<p>The matrix returned is over the integers. If a different ring is
desired, use either the <a class="reference external" href="../../../matrices/sage/matrix/matrix0.html#sage.matrix.matrix0.Matrix.change_ring" title="(in Sage 9.5 Reference Manual: Matrices and Spaces of Matrices v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.matrix.matrix0.Matrix.change_ring()</span></code></a>
method or the <a class="reference external" href="../../../matrices/sage/matrix/constructor.html#sage.matrix.constructor.matrix" title="(in Sage 9.5 Reference Manual: Matrices and Spaces of Matrices v9.5)"><code class="xref py py-func docutils literal notranslate"><span class="pre">matrix()</span></code></a> function.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sparse</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); whether to represent with a
sparse matrix</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – list (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the ordering of the vertices
defining how they should appear in the matrix. By default, the
ordering given by <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.vertices" title="sage.graphs.generic_graph.GenericGraph.vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GenericGraph.vertices()</span></code></a> is used.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span>
<span class="go">[0 1 1 0 1 0 0 0 1 0 0 0 0 0 0 0]</span>
<span class="go">[1 0 0 1 0 1 0 0 0 1 0 0 0 0 0 0]</span>
<span class="go">[1 0 0 1 0 0 1 0 0 0 1 0 0 0 0 0]</span>
<span class="go">[0 1 1 0 0 0 0 1 0 0 0 1 0 0 0 0]</span>
<span class="go">[1 0 0 0 0 1 1 0 0 0 0 0 1 0 0 0]</span>
<span class="go">[0 1 0 0 1 0 0 1 0 0 0 0 0 1 0 0]</span>
<span class="go">[0 0 1 0 1 0 0 1 0 0 0 0 0 0 1 0]</span>
<span class="go">[0 0 0 1 0 1 1 0 0 0 0 0 0 0 0 1]</span>
<span class="go">[1 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0]</span>
<span class="go">[0 1 0 0 0 0 0 0 1 0 0 1 0 1 0 0]</span>
<span class="go">[0 0 1 0 0 0 0 0 1 0 0 1 0 0 1 0]</span>
<span class="go">[0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 1]</span>
<span class="go">[0 0 0 0 1 0 0 0 1 0 0 0 0 1 1 0]</span>
<span class="go">[0 0 0 0 0 1 0 0 0 1 0 0 1 0 0 1]</span>
<span class="go">[0 0 0 0 0 0 1 0 0 0 1 0 1 0 0 1]</span>
<span class="go">[0 0 0 0 0 0 0 1 0 0 0 1 0 1 1 0]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">matrix</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">G</span><span class="p">)</span> <span class="c1"># matrix over GF(2)</span>
<span class="go">[0 1 1 0 1 0 0 0 1 0 0 0 0 0 0 0]</span>
<span class="go">[1 0 0 1 0 1 0 0 0 1 0 0 0 0 0 0]</span>
<span class="go">[1 0 0 1 0 0 1 0 0 0 1 0 0 0 0 0]</span>
<span class="go">[0 1 1 0 0 0 0 1 0 0 0 1 0 0 0 0]</span>
<span class="go">[1 0 0 0 0 1 1 0 0 0 0 0 1 0 0 0]</span>
<span class="go">[0 1 0 0 1 0 0 1 0 0 0 0 0 1 0 0]</span>
<span class="go">[0 0 1 0 1 0 0 1 0 0 0 0 0 0 1 0]</span>
<span class="go">[0 0 0 1 0 1 1 0 0 0 0 0 0 0 0 1]</span>
<span class="go">[1 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0]</span>
<span class="go">[0 1 0 0 0 0 0 0 1 0 0 1 0 1 0 0]</span>
<span class="go">[0 0 1 0 0 0 0 0 1 0 0 1 0 0 1 0]</span>
<span class="go">[0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 1]</span>
<span class="go">[0 0 0 0 1 0 0 0 1 0 0 0 0 1 1 0]</span>
<span class="go">[0 0 0 0 0 1 0 0 0 1 0 0 1 0 0 1]</span>
<span class="go">[0 0 0 0 0 0 1 0 0 0 1 0 1 0 0 1]</span>
<span class="go">[0 0 0 0 0 0 0 1 0 0 0 1 0 1 1 0]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span>
<span class="go">[0 1 1 1 0 0]</span>
<span class="go">[1 0 1 0 0 0]</span>
<span class="go">[0 0 0 1 0 0]</span>
<span class="go">[0 0 0 0 1 0]</span>
<span class="go">[1 0 0 0 0 1]</span>
<span class="go">[0 1 0 0 0 0]</span>
</pre></div>
</div>
<p>A different ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">[0 0 1 1 0]</span>
<span class="go">[0 0 0 1 0]</span>
<span class="go">[1 0 0 0 1]</span>
<span class="go">[1 1 0 0 0]</span>
<span class="go">[0 0 1 0 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.all_paths">
<span class="sig-name descname"><span class="pre">all_paths</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_multiedges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">report_edges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.all_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of all paths between a pair of vertices.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">start</span></code> is the same vertex as <code class="docutils literal notranslate"><span class="pre">end</span></code>, then <code class="docutils literal notranslate"><span class="pre">[[start]]</span></code> is returned
– a list containing the 1-vertex, 0-edge path “<code class="docutils literal notranslate"><span class="pre">start</span></code>”.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">G</span></code> has multiple edges, a path will be returned as many times as the
product of the multiplicity of the edges along that path depending on the
value of the flag <code class="docutils literal notranslate"><span class="pre">use_multiedges</span></code>.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">start</span></code> – a vertex of a graph, where to start</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">end</span></code> – a vertex of a graph, where to end</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">use_multiedges</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); this parameter is
used only if the graph has multiple edges.</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">False</span></code>, the graph is considered as simple and an edge label
is arbitrarily selected for each edge as in
<a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.to_simple" title="sage.graphs.generic_graph.GenericGraph.to_simple"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.graphs.generic_graph.GenericGraph.to_simple()</span></code></a> if
<code class="docutils literal notranslate"><span class="pre">report_edges</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code></p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, a path will be reported as many times as the edges
multiplicities along that path (when <code class="docutils literal notranslate"><span class="pre">report_edges</span> <span class="pre">=</span> <span class="pre">False</span></code> or
<code class="docutils literal notranslate"><span class="pre">labels</span> <span class="pre">=</span> <span class="pre">False</span></code>), or with all possible combinations of edge
labels (when <code class="docutils literal notranslate"><span class="pre">report_edges</span> <span class="pre">=</span> <span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">labels</span> <span class="pre">=</span> <span class="pre">True</span></code>)</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">report_edges</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to report
paths as list of vertices (default) or list of edges, if <code class="docutils literal notranslate"><span class="pre">False</span></code>
then <code class="docutils literal notranslate"><span class="pre">labels</span></code> parameter is ignored</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">False</span></code>, each edge
is simply a pair <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v)</span></code> of vertices. Otherwise a list of edges
along with its edge labels are used to represent the path.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">eg1</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">eg1</span><span class="o">.</span><span class="n">all_paths</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">[[0, 1, 4, 5, 6], [0, 2, 4, 5, 6]]</span>
<span class="gp">sage: </span><span class="n">eg2</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">eg2</span><span class="o">.</span><span class="n">all_paths</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="go">[[1, 0, 4],</span>
<span class="go"> [1, 0, 5, 7, 2, 3, 4],</span>
<span class="go"> [1, 0, 5, 7, 2, 3, 8, 6, 9, 4],</span>
<span class="go"> [1, 0, 5, 7, 9, 4],</span>
<span class="go"> [1, 0, 5, 7, 9, 6, 8, 3, 4],</span>
<span class="go"> [1, 0, 5, 8, 3, 2, 7, 9, 4],</span>
<span class="go"> [1, 0, 5, 8, 3, 4],</span>
<span class="go"> [1, 0, 5, 8, 6, 9, 4],</span>
<span class="go"> [1, 0, 5, 8, 6, 9, 7, 2, 3, 4],</span>
<span class="go"> [1, 2, 3, 4],</span>
<span class="go"> [1, 2, 3, 8, 5, 0, 4],</span>
<span class="go"> [1, 2, 3, 8, 5, 7, 9, 4],</span>
<span class="go"> [1, 2, 3, 8, 6, 9, 4],</span>
<span class="go"> [1, 2, 3, 8, 6, 9, 7, 5, 0, 4],</span>
<span class="go"> [1, 2, 7, 5, 0, 4],</span>
<span class="go"> [1, 2, 7, 5, 8, 3, 4],</span>
<span class="go"> [1, 2, 7, 5, 8, 6, 9, 4],</span>
<span class="go"> [1, 2, 7, 9, 4],</span>
<span class="go"> [1, 2, 7, 9, 6, 8, 3, 4],</span>
<span class="go"> [1, 2, 7, 9, 6, 8, 5, 0, 4],</span>
<span class="go"> [1, 6, 8, 3, 2, 7, 5, 0, 4],</span>
<span class="go"> [1, 6, 8, 3, 2, 7, 9, 4],</span>
<span class="go"> [1, 6, 8, 3, 4],</span>
<span class="go"> [1, 6, 8, 5, 0, 4],</span>
<span class="go"> [1, 6, 8, 5, 7, 2, 3, 4],</span>
<span class="go"> [1, 6, 8, 5, 7, 9, 4],</span>
<span class="go"> [1, 6, 9, 4],</span>
<span class="go"> [1, 6, 9, 7, 2, 3, 4],</span>
<span class="go"> [1, 6, 9, 7, 2, 3, 8, 5, 0, 4],</span>
<span class="go"> [1, 6, 9, 7, 5, 0, 4],</span>
<span class="go"> [1, 6, 9, 7, 5, 8, 3, 4]]</span>
<span class="gp">sage: </span><span class="n">dg</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">dg</span><span class="o">.</span><span class="n">all_paths</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">[[0, 1, 3], [0, 3]]</span>
<span class="gp">sage: </span><span class="n">ug</span> <span class="o">=</span> <span class="n">dg</span><span class="o">.</span><span class="n">to_undirected</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">ug</span><span class="o">.</span><span class="n">all_paths</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">[[0, 1, 3], [0, 2, 3], [0, 3]]</span>

<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">all_paths</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">use_multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[[0, 1, 2], [0, 1, 2], [0, 1, 2], [0, 1, 2]]</span>

<span class="gp">sage: </span><span class="n">dg</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]},</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">dg</span><span class="o">.</span><span class="n">all_paths</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">use_multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[[3, 0, 1], [3, 0, 1], [3, 0, 1], [3, 0, 1]]</span>

<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)],</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">all_paths</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">use_multiedges</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[0, 1, 2]]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">all_paths</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">use_multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[[0, 1, 2], [0, 1, 2], [0, 1, 2], [0, 1, 2]]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">all_paths</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">use_multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">report_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[[(0, 1), (1, 2)], [(0, 1), (1, 2)], [(0, 1), (1, 2)], [(0, 1), (1, 2)]]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">all_paths</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">use_multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">report_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[((0, 1, &#39;b&#39;), (1, 2, &#39;d&#39;)),</span>
<span class="go"> ((0, 1, &#39;b&#39;), (1, 2, &#39;c&#39;)),</span>
<span class="go"> ((0, 1, &#39;a&#39;), (1, 2, &#39;d&#39;)),</span>
<span class="go"> ((0, 1, &#39;a&#39;), (1, 2, &#39;c&#39;))]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">all_paths</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">use_multiedges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">report_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[((0, 1, &#39;b&#39;), (1, 2, &#39;d&#39;))]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">all_paths</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">use_multiedges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">report_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[[0, 1, 2]]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">all_paths</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">use_multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">report_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[[0, 1, 2], [0, 1, 2], [0, 1, 2], [0, 1, 2]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.allow_loops">
<span class="sig-name descname"><span class="pre">allow_loops</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.allow_loops" title="Permalink to this definition">¶</a></dt>
<dd><p>Change whether loops are permitted in the (di)graph</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">new</span></code> – boolean</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether to remove existing
loops from the (di)graph when the new status is <code class="docutils literal notranslate"><span class="pre">False</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Looped graph on 0 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allows_loops</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">loops</span><span class="p">()</span>
<span class="go">[(0, 0, None)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_loops</span><span class="p">(</span><span class="kc">False</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Graph on 1 vertex</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[]</span>

<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">D</span>
<span class="go">Looped digraph on 0 vertices</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">allows_loops</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">loops</span><span class="p">()</span>
<span class="go">[(0, 0, None)]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">allow_loops</span><span class="p">(</span><span class="kc">False</span><span class="p">);</span> <span class="n">D</span>
<span class="go">Digraph on 1 vertex</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.allow_multiple_edges">
<span class="sig-name descname"><span class="pre">allow_multiple_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'any'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.allow_multiple_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Change whether multiple edges are permitted in the (di)graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">new</span></code> – boolean; if <code class="docutils literal notranslate"><span class="pre">True</span></code>, the new graph will allow multiple
edges</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">new</span></code> is
<code class="docutils literal notranslate"><span class="pre">False</span></code>, we remove all multiple edges from the graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">keep_label</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">'any'</span></code>); used only if <code class="docutils literal notranslate"><span class="pre">new</span></code> is
<code class="docutils literal notranslate"><span class="pre">False</span></code> and <code class="docutils literal notranslate"><span class="pre">check</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>. If there are multiple edges with
different labels, this variable defines which label should be kept:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'any'</span></code> – any label</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'min'</span></code> – the smallest label</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'max'</span></code> – the largest label</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="docutils literal notranslate"><span class="pre">'min'</span></code> and <code class="docutils literal notranslate"><span class="pre">'max'</span></code> only works if the labels can be compared. A
<code class="docutils literal notranslate"><span class="pre">TypeError</span></code> might be raised when working with non-comparable
objects in Python 3.</p>
</div>
<p>EXAMPLES:</p>
<p>The standard behavior with undirected graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Multi-graph on 0 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allows_multiple_edges</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">multiple_edges</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(0, 1, 1), (0, 1, 2), (0, 1, 3)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_multiple_edges</span><span class="p">(</span><span class="kc">False</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Graph on 2 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, 3)]</span>
</pre></div>
</div>
<p>If we ask for the minimum label:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)],</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_multiple_edges</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">keep_label</span><span class="o">=</span><span class="s1">&#39;min&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, 1)]</span>
</pre></div>
</div>
<p>If we ask for the maximum label:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)],</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_multiple_edges</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">keep_label</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, 3)]</span>
</pre></div>
</div>
<p>The standard behavior with digraphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">D</span>
<span class="go">Multi-digraph on 0 vertices</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">allows_multiple_edges</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">multiple_edges</span><span class="p">()</span>
<span class="go">[(0, 1, None), (0, 1, None), (0, 1, None)]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">allow_multiple_edges</span><span class="p">(</span><span class="kc">False</span><span class="p">);</span> <span class="n">D</span>
<span class="go">Digraph on 2 vertices</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.allows_loops">
<span class="sig-name descname"><span class="pre">allows_loops</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.allows_loops" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether loops are permitted in the (di)graph</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Looped graph on 0 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allows_loops</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">loops</span><span class="p">()</span>
<span class="go">[(0, 0, None)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_loops</span><span class="p">(</span><span class="kc">False</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Graph on 1 vertex</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[]</span>

<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">D</span>
<span class="go">Looped digraph on 0 vertices</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">allows_loops</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">loops</span><span class="p">()</span>
<span class="go">[(0, 0, None)]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">allow_loops</span><span class="p">(</span><span class="kc">False</span><span class="p">);</span> <span class="n">D</span>
<span class="go">Digraph on 1 vertex</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.allows_multiple_edges">
<span class="sig-name descname"><span class="pre">allows_multiple_edges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.allows_multiple_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether multiple edges are permitted in the (di)graph.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Multi-graph on 0 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allows_multiple_edges</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">multiple_edges</span><span class="p">()</span>
<span class="go">[(0, 1, None), (0, 1, None), (0, 1, None)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_multiple_edges</span><span class="p">(</span><span class="kc">False</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Graph on 2 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None)]</span>

<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">D</span>
<span class="go">Multi-digraph on 0 vertices</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">allows_multiple_edges</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">multiple_edges</span><span class="p">()</span>
<span class="go">[(0, 1, None), (0, 1, None), (0, 1, None)]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">allow_multiple_edges</span><span class="p">(</span><span class="kc">False</span><span class="p">);</span> <span class="n">D</span>
<span class="go">Digraph on 2 vertices</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.am">
<span class="sig-name descname"><span class="pre">am</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.am" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the adjacency matrix of the (di)graph.</p>
<p>The matrix returned is over the integers. If a different ring is
desired, use either the <a class="reference external" href="../../../matrices/sage/matrix/matrix0.html#sage.matrix.matrix0.Matrix.change_ring" title="(in Sage 9.5 Reference Manual: Matrices and Spaces of Matrices v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.matrix.matrix0.Matrix.change_ring()</span></code></a>
method or the <a class="reference external" href="../../../matrices/sage/matrix/constructor.html#sage.matrix.constructor.matrix" title="(in Sage 9.5 Reference Manual: Matrices and Spaces of Matrices v9.5)"><code class="xref py py-func docutils literal notranslate"><span class="pre">matrix()</span></code></a> function.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sparse</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); whether to represent with a
sparse matrix</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – list (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the ordering of the vertices
defining how they should appear in the matrix. By default, the
ordering given by <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.vertices" title="sage.graphs.generic_graph.GenericGraph.vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GenericGraph.vertices()</span></code></a> is used.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span>
<span class="go">[0 1 1 0 1 0 0 0 1 0 0 0 0 0 0 0]</span>
<span class="go">[1 0 0 1 0 1 0 0 0 1 0 0 0 0 0 0]</span>
<span class="go">[1 0 0 1 0 0 1 0 0 0 1 0 0 0 0 0]</span>
<span class="go">[0 1 1 0 0 0 0 1 0 0 0 1 0 0 0 0]</span>
<span class="go">[1 0 0 0 0 1 1 0 0 0 0 0 1 0 0 0]</span>
<span class="go">[0 1 0 0 1 0 0 1 0 0 0 0 0 1 0 0]</span>
<span class="go">[0 0 1 0 1 0 0 1 0 0 0 0 0 0 1 0]</span>
<span class="go">[0 0 0 1 0 1 1 0 0 0 0 0 0 0 0 1]</span>
<span class="go">[1 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0]</span>
<span class="go">[0 1 0 0 0 0 0 0 1 0 0 1 0 1 0 0]</span>
<span class="go">[0 0 1 0 0 0 0 0 1 0 0 1 0 0 1 0]</span>
<span class="go">[0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 1]</span>
<span class="go">[0 0 0 0 1 0 0 0 1 0 0 0 0 1 1 0]</span>
<span class="go">[0 0 0 0 0 1 0 0 0 1 0 0 1 0 0 1]</span>
<span class="go">[0 0 0 0 0 0 1 0 0 0 1 0 1 0 0 1]</span>
<span class="go">[0 0 0 0 0 0 0 1 0 0 0 1 0 1 1 0]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">matrix</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">G</span><span class="p">)</span> <span class="c1"># matrix over GF(2)</span>
<span class="go">[0 1 1 0 1 0 0 0 1 0 0 0 0 0 0 0]</span>
<span class="go">[1 0 0 1 0 1 0 0 0 1 0 0 0 0 0 0]</span>
<span class="go">[1 0 0 1 0 0 1 0 0 0 1 0 0 0 0 0]</span>
<span class="go">[0 1 1 0 0 0 0 1 0 0 0 1 0 0 0 0]</span>
<span class="go">[1 0 0 0 0 1 1 0 0 0 0 0 1 0 0 0]</span>
<span class="go">[0 1 0 0 1 0 0 1 0 0 0 0 0 1 0 0]</span>
<span class="go">[0 0 1 0 1 0 0 1 0 0 0 0 0 0 1 0]</span>
<span class="go">[0 0 0 1 0 1 1 0 0 0 0 0 0 0 0 1]</span>
<span class="go">[1 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0]</span>
<span class="go">[0 1 0 0 0 0 0 0 1 0 0 1 0 1 0 0]</span>
<span class="go">[0 0 1 0 0 0 0 0 1 0 0 1 0 0 1 0]</span>
<span class="go">[0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 1]</span>
<span class="go">[0 0 0 0 1 0 0 0 1 0 0 0 0 1 1 0]</span>
<span class="go">[0 0 0 0 0 1 0 0 0 1 0 0 1 0 0 1]</span>
<span class="go">[0 0 0 0 0 0 1 0 0 0 1 0 1 0 0 1]</span>
<span class="go">[0 0 0 0 0 0 0 1 0 0 0 1 0 1 1 0]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span>
<span class="go">[0 1 1 1 0 0]</span>
<span class="go">[1 0 1 0 0 0]</span>
<span class="go">[0 0 0 1 0 0]</span>
<span class="go">[0 0 0 0 1 0]</span>
<span class="go">[1 0 0 0 0 1]</span>
<span class="go">[0 1 0 0 0 0]</span>
</pre></div>
</div>
<p>A different ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">[0 0 1 1 0]</span>
<span class="go">[0 0 0 1 0]</span>
<span class="go">[1 0 0 0 1]</span>
<span class="go">[1 1 0 0 0]</span>
<span class="go">[0 0 1 0 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.antisymmetric">
<span class="sig-name descname"><span class="pre">antisymmetric</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.antisymmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the graph is antisymmetric.</p>
<p>A graph represents an antisymmetric relation if the existence of a path
from a vertex <span class="math notranslate nohighlight">\(x\)</span> to a vertex <span class="math notranslate nohighlight">\(y\)</span> implies that there is not a path from
<span class="math notranslate nohighlight">\(y\)</span> to <span class="math notranslate nohighlight">\(x\)</span> unless <span class="math notranslate nohighlight">\(x = y\)</span>.</p>
<p>EXAMPLES:</p>
<p>A directed acyclic graph is antisymmetric:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">RandomDirectedGNR</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">antisymmetric</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Loops are allowed:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_loops</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">antisymmetric</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>An undirected graph is never antisymmetric unless it is just a union of
isolated vertices (with possible loops):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">antisymmetric</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">antisymmetric</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">([(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)],</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">antisymmetric</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">DiGraph</span><span class="p">([(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)],</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">antisymmetric</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.automorphism_group">
<span class="sig-name descname"><span class="pre">automorphism_group</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">partition</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbosity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_group</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.automorphism_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the automorphism group of the graph.</p>
<p>With <code class="docutils literal notranslate"><span class="pre">partition</span></code> this can also return the largest subgroup
of the automorphism group of the (di)graph whose orbit
partition is finer than the partition given.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">partition</span></code> - default is the unit partition,
otherwise computes the subgroup of the full automorphism group
respecting the partition.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edge_labels</span></code> - default False, otherwise allows
only permutations respecting edge labels.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">order</span></code> - (default False) if True, compute the
order of the automorphism group</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">return_group</span></code> - default True</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">orbits</span></code> - returns the orbits of the group acting
on the vertices of the graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> - If <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;bliss&quot;</span></code> the automorphism group is
computed using the optional package bliss
(<a class="reference external" href="http://www.tcs.tkk.fi/Software/bliss/index.html">http://www.tcs.tkk.fi/Software/bliss/index.html</a>).  Setting it to
“sage” uses Sage’s implementation. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), bliss
is used when available.</p></li>
</ul>
<p>OUTPUT: The order of the output is group, order, orbits. However, there
are options to turn each of these on or off.</p>
<p>EXAMPLES:</p>
<p>Graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs_query</span> <span class="o">=</span> <span class="n">GraphQuery</span><span class="p">(</span><span class="n">display_cols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;graph6&#39;</span><span class="p">],</span><span class="n">num_vertices</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">graphs_query</span><span class="o">.</span><span class="n">get_graphs_list</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">graphs_list</span><span class="o">.</span><span class="n">show_graphs</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">L</span><span class="p">:</span>
<span class="gp">....: </span>    <span class="n">G</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">(),</span> <span class="n">G</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="go">(24, [(2,3), (1,2), (0,1)])</span>
<span class="go">(4, [(2,3), (0,1)])</span>
<span class="go">(2, [(1,2)])</span>
<span class="go">(6, [(1,2), (0,1)])</span>
<span class="go">(6, [(2,3), (1,2)])</span>
<span class="go">(8, [(1,2), (0,1)(2,3)])</span>
<span class="go">(2, [(0,1)(2,3)])</span>
<span class="go">(2, [(1,2)])</span>
<span class="go">(8, [(2,3), (0,1), (0,2)(1,3)])</span>
<span class="go">(4, [(2,3), (0,1)])</span>
<span class="go">(24, [(2,3), (1,2), (0,1)])</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">character_table</span><span class="p">()</span> <span class="c1"># random order of rows, thus abs() below</span>
<span class="gp">sage: </span><span class="n">QQ</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">determinant</span><span class="p">())</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>
<span class="go">712483534798848</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">384</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A5</span> <span class="o">=</span> <span class="n">AlternatingGroup</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z2</span> <span class="o">=</span> <span class="n">CyclicPermutationGroup</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">A5</span><span class="o">.</span><span class="n">direct_product</span><span class="p">(</span><span class="n">Z2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#see documentation for direct_product to explain the [0]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Multigraphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">()</span>
<span class="go">Permutation Group with generators [(&#39;a&#39;,&#39;b&#39;)]</span>
</pre></div>
</div>
<p>Digraphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span> <span class="p">{</span> <span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">0</span><span class="p">]</span> <span class="p">}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">()</span>
<span class="go">Permutation Group with generators [(0,1,2,3,4)]</span>
</pre></div>
</div>
<p>Edge labeled graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">)]</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Permutation Group with generators [(1,4)(2,3)]</span>

<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;bliss&quot;</span><span class="p">)</span> <span class="c1"># optional - bliss</span>
<span class="go">Permutation Group with generators [(1,4)(2,3)]</span>

<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;sage&quot;</span><span class="p">)</span>
<span class="go">Permutation Group with generators [(1,4)(2,3)]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span> <span class="p">:</span> <span class="p">{</span><span class="mi">1</span> <span class="p">:</span> <span class="mi">7</span><span class="p">}})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Permutation Group with generators [(0,1)]</span>

<span class="gp">sage: </span><span class="n">foo</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bar</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">foo</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">bar</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">foo</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Permutation Group with generators [()]</span>
<span class="gp">sage: </span><span class="n">foo</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">()</span>
<span class="go">Permutation Group with generators [(0,3)(1,2)]</span>
<span class="gp">sage: </span><span class="n">bar</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Permutation Group with generators [()]</span>
</pre></div>
</div>
<p>You can also ask for just the order of the group:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">(</span><span class="n">return_group</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">120</span>
</pre></div>
</div>
<p>Or, just the orbits (note that each graph here is vertex transitive)</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">(</span><span class="n">return_group</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">orbits</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;sage&#39;</span><span class="p">)</span>
<span class="go">[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]</span>
<span class="gp">sage: </span><span class="n">orb</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">(</span><span class="n">partition</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">],</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">))],</span>
<span class="gp">....: </span>                           <span class="n">return_group</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">orbits</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;sage&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">([</span><span class="nb">sorted</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">orb</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)</span>
<span class="go">[[0], [1, 4, 5], [2, 3, 6, 7, 8, 9]]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">orb</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">(</span><span class="n">orbits</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_group</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;sage&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">orb</span><span class="p">]</span>
<span class="go">[[&#39;000&#39;, &#39;001&#39;, &#39;010&#39;, &#39;011&#39;, &#39;100&#39;, &#39;101&#39;, &#39;110&#39;, &#39;111&#39;]]</span>
</pre></div>
</div>
<p>One can also use the faster algorithm for computing the automorphism
group of the graph - bliss:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">HallJankoGraph</span><span class="p">()</span>                   <span class="c1"># optional - bliss</span>
<span class="gp">sage: </span><span class="n">A1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">()</span>                   <span class="c1"># optional - bliss</span>
<span class="gp">sage: </span><span class="n">A2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;bliss&#39;</span><span class="p">)</span>  <span class="c1"># optional - bliss</span>
<span class="gp">sage: </span><span class="n">A1</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">A2</span><span class="p">)</span>                          <span class="c1"># optional - bliss</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.average_degree">
<span class="sig-name descname"><span class="pre">average_degree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.average_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the average degree of the graph.</p>
<p>The average degree of a graph <span class="math notranslate nohighlight">\(G=(V,E)\)</span> is equal to <span class="math notranslate nohighlight">\(\frac{2|E|}{|V|}\)</span>.</p>
<p>EXAMPLES:</p>
<p>The average degree of a regular graph is equal to the degree of any
vertex:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">average_degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">4</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The average degree of a tree is always strictly less than <span class="math notranslate nohighlight">\(2\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">tree</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomTree</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">tree</span><span class="o">.</span><span class="n">average_degree</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span>
<span class="go">True</span>
</pre></div>
</div>
<p>For any graph, it is equal to <span class="math notranslate nohighlight">\(\frac{2|E|}{|V|}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mf">.4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">average_degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">g</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.average_distance">
<span class="sig-name descname"><span class="pre">average_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">by_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.average_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the average distance between vertices of the graph.</p>
<p>Formally, for a graph <span class="math notranslate nohighlight">\(G\)</span> this value is equal to <span class="math notranslate nohighlight">\(\frac 1 {n(n-1)}
\sum_{u,v\in G} d(u,v)\)</span> where <span class="math notranslate nohighlight">\(d(u,v)\)</span> denotes the distance between
vertices <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> and <span class="math notranslate nohighlight">\(n\)</span> is the number of vertices in <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>For more information on the input variables and more examples, we refer
to <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.wiener_index" title="sage.graphs.generic_graph.GenericGraph.wiener_index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wiener_index()</span></code></a> and
<a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.shortest_path_all_pairs" title="sage.graphs.generic_graph.GenericGraph.shortest_path_all_pairs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shortest_path_all_pairs()</span></code></a>,
which have very similar input variables.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">by_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, the edges
in the graph are weighted, otherwise all edges have weight 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); one of the
algorithms available for method <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.wiener_index" title="sage.graphs.generic_graph.GenericGraph.wiener_index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wiener_index()</span></code></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
takes as input an edge <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></code> and outputs its weight. If not
<code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is automatically set to <code class="docutils literal notranslate"><span class="pre">True</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>
and <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, we use the edge label <code class="docutils literal notranslate"><span class="pre">l</span></code>, if <code class="docutils literal notranslate"><span class="pre">l</span></code>
is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, else <code class="docutils literal notranslate"><span class="pre">1</span></code> as a weight.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, we check
that the weight_function outputs a number for each edge</p></li>
</ul>
<p>EXAMPLES:</p>
<p>From <a class="reference internal" href="../../../references/index.html#gyll1993" id="id1"><span>[GYLL1993]</span></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">6</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">average_distance</span><span class="p">()</span><span class="o">==</span><span class="n">w</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Average distance of a circuit:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">average_distance</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.blocks_and_cut_vertices">
<span class="sig-name descname"><span class="pre">blocks_and_cut_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Tarjan_Boost'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.blocks_and_cut_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the blocks and cut vertices of the graph.</p>
<p>In the case of a digraph, this computation is done on the underlying
graph.</p>
<p>A cut vertex is one whose deletion increases the number of connected
components. A block is a maximal induced subgraph which itself has no
cut vertices. Two distinct blocks cannot overlap in more than a single
cut vertex.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">&quot;Tarjan_Boost&quot;</span></code>); the algorithm to
use among:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Tarjan_Boost&quot;</span></code> (default) – Tarjan’s algorithm (Boost
implementation)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Tarjan_Sage&quot;</span></code> – Tarjan’s algorithm (Sage implementation)</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">sort</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to sort vertices inside
the components and the list of cut vertices
<strong>currently only available for ``”Tarjan_Sage”``</strong></p></li>
</ul>
<p>OUTPUT: <code class="docutils literal notranslate"><span class="pre">(B,</span> <span class="pre">C)</span></code>, where <code class="docutils literal notranslate"><span class="pre">B</span></code> is a list of blocks - each is a list of
vertices and the blocks are the corresponding induced subgraphs - and
<code class="docutils literal notranslate"><span class="pre">C</span></code> is a list of cut vertices.</p>
<p>ALGORITHM:</p>
<blockquote>
<div><p>We implement the algorithm proposed by Tarjan in <a class="reference internal" href="../../../references/index.html#tarjan72" id="id2"><span>[Tarjan72]</span></a>. The
original version is recursive. We emulate the recursion using a stack.</p>
</div></blockquote>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.blocks_and_cuts_tree" title="sage.graphs.generic_graph.GenericGraph.blocks_and_cuts_tree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">blocks_and_cuts_tree()</span></code></a></p></li>
<li><p><a class="reference internal" href="base/boost_graph.html#sage.graphs.base.boost_graph.blocks_and_cut_vertices" title="sage.graphs.base.boost_graph.blocks_and_cut_vertices"><code class="xref py py-func docutils literal notranslate"><span class="pre">sage.graphs.base.boost_graph.blocks_and_cut_vertices()</span></code></a></p></li>
<li><p><a class="reference internal" href="graph.html#sage.graphs.graph.Graph.is_biconnected" title="sage.graphs.graph.Graph.is_biconnected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_biconnected()</span></code></a></p></li>
<li><p><a class="reference internal" href="graph.html#sage.graphs.graph.Graph.bridges" title="sage.graphs.graph.Graph.bridges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bridges()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>We construct a trivial example of a graph with one cut vertex:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.connectivity</span> <span class="kn">import</span> <span class="n">blocks_and_cut_vertices</span>
<span class="gp">sage: </span><span class="n">rings</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">rings</span><span class="o">.</span><span class="n">merge_vertices</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">blocks_and_cut_vertices</span><span class="p">(</span><span class="n">rings</span><span class="p">)</span>
<span class="go">([[0, 1, 4, 2, 3], [0, 6, 9, 7, 8]], [0])</span>
<span class="gp">sage: </span><span class="n">rings</span><span class="o">.</span><span class="n">blocks_and_cut_vertices</span><span class="p">()</span>
<span class="go">([[0, 1, 4, 2, 3], [0, 6, 9, 7, 8]], [0])</span>
<span class="gp">sage: </span><span class="n">B</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">blocks_and_cut_vertices</span><span class="p">(</span><span class="n">rings</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Tarjan_Sage&quot;</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span><span class="p">,</span> <span class="n">C</span>
<span class="go">([[0, 1, 2, 3, 4], [0, 6, 7, 8, 9]], [0])</span>
<span class="gp">sage: </span><span class="n">B2</span><span class="p">,</span> <span class="n">C2</span> <span class="o">=</span> <span class="n">blocks_and_cut_vertices</span><span class="p">(</span><span class="n">rings</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Tarjan_Sage&quot;</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="n">B</span><span class="p">))</span> <span class="o">==</span> <span class="n">Set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="n">B2</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">set</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">C2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Petersen graph is biconnected, hence has no cut vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">blocks_and_cut_vertices</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">())</span>
<span class="go">([[0, 1, 4, 5, 2, 6, 3, 7, 8, 9]], [])</span>
</pre></div>
</div>
<p>Decomposing paths to pairs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">blocks_and_cut_vertices</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">([[2, 3], [1, 2], [0, 1], [7, 8], [6, 7], [5, 6], [4, 5]], [1, 2, 5, 6, 7])</span>
</pre></div>
</div>
<p>A disconnected graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">10</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">16</span><span class="p">},</span> <span class="mi">4</span><span class="p">:</span> <span class="p">{},</span> <span class="mi">5</span><span class="p">:</span> <span class="p">{</span><span class="mi">6</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">:</span> <span class="mi">4</span><span class="p">}})</span>
<span class="gp">sage: </span><span class="n">blocks_and_cut_vertices</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">([[1, 2, 3], [5, 6], [5, 7], [5, 8], [4]], [5])</span>
</pre></div>
</div>
<p>A directed graph with Boost’s algorithm (<a class="reference external" href="https://trac.sagemath.org/25994">trac ticket #25994</a>):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">rings</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">rings</span><span class="o">.</span><span class="n">merge_vertices</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">rings</span> <span class="o">=</span> <span class="n">rings</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">blocks_and_cut_vertices</span><span class="p">(</span><span class="n">rings</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Tarjan_Boost&quot;</span><span class="p">)</span>
<span class="go">([[0, 1, 4, 2, 3], [0, 6, 9, 7, 8]], [0])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.blocks_and_cuts_tree">
<span class="sig-name descname"><span class="pre">blocks_and_cuts_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.blocks_and_cuts_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the blocks-and-cuts tree of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This new graph has two different kinds of vertices, some representing the
blocks (type B) and some other the cut vertices of the graph (type C).</p>
<p>There is an edge between a vertex <span class="math notranslate nohighlight">\(u\)</span> of type B and a vertex <span class="math notranslate nohighlight">\(v\)</span> of type C
if the cut-vertex corresponding to <span class="math notranslate nohighlight">\(v\)</span> is in the block corresponding to <span class="math notranslate nohighlight">\(u\)</span>.</p>
<p>The resulting graph is a tree, with the additional characteristic property
that the distance between two leaves is even. When <code class="docutils literal notranslate"><span class="pre">self</span></code> is not
connected, the resulting graph is a forest.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">self</span></code> is biconnected, the tree is reduced to a single node of
type <span class="math notranslate nohighlight">\(B\)</span>.</p>
<p>We referred to <a class="reference internal" href="../../../references/index.html#harpri" id="id3"><span>[HarPri]</span></a> and <a class="reference internal" href="../../../references/index.html#gallai" id="id4"><span>[Gallai]</span></a> for blocks and cuts tree.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.blocks_and_cut_vertices" title="sage.graphs.generic_graph.GenericGraph.blocks_and_cut_vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">blocks_and_cut_vertices()</span></code></a></p></li>
<li><p><a class="reference internal" href="graph.html#sage.graphs.graph.Graph.is_biconnected" title="sage.graphs.graph.Graph.is_biconnected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_biconnected()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.connectivity</span> <span class="kn">import</span> <span class="n">blocks_and_cuts_tree</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">blocks_and_cuts_tree</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">KrackhardtKiteGraph</span><span class="p">());</span> <span class="n">T</span>
<span class="go">Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.connectivity</span> <span class="kn">import</span> <span class="n">blocks_and_cuts_tree</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">KrackhardtKiteGraph</span><span class="p">()</span><span class="o">.</span><span class="n">blocks_and_cuts_tree</span><span class="p">();</span> <span class="n">T</span>
<span class="go">Graph on 5 vertices</span>
</pre></div>
</div>
<p>The distance between two leaves is even:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">blocks_and_cuts_tree</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">RandomTree</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">is_tree</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">leaves</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">T</span> <span class="k">if</span> <span class="n">T</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">leaves</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The tree of a biconnected graph has a single vertex, of type <span class="math notranslate nohighlight">\(B\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">blocks_and_cuts_tree</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[(&#39;B&#39;, (0, 1, 4, 5, 2, 6, 3, 7, 8, 9))]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.breadth_first_search">
<span class="sig-name descname"><span class="pre">breadth_first_search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">report_distance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.breadth_first_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over the vertices in a breadth-first ordering.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">start</span></code> – vertex or list of vertices from which to start the
traversal</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ignore_direction</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); only applies to
directed graphs. If <code class="docutils literal notranslate"><span class="pre">True</span></code>, searches across edges in either
direction.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">distance</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the maximum distance from
the <code class="docutils literal notranslate"><span class="pre">start</span></code> nodes to traverse. The <code class="docutils literal notranslate"><span class="pre">start</span></code> nodes are at distance
zero from themselves.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">neighbors</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that inputs
a vertex and return a list of vertices. For an undirected graph,
<code class="docutils literal notranslate"><span class="pre">neighbors</span></code> is by default the <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.neighbors" title="sage.graphs.generic_graph.GenericGraph.neighbors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">neighbors()</span></code></a> function. For a
digraph, the <code class="docutils literal notranslate"><span class="pre">neighbors</span></code> function defaults to the
<a class="reference internal" href="digraph.html#sage.graphs.digraph.DiGraph.neighbor_out_iterator" title="sage.graphs.digraph.DiGraph.neighbor_out_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">neighbor_out_iterator()</span></code></a> function of the graph.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">report_distance</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>,
reports pairs <code class="docutils literal notranslate"><span class="pre">(vertex,</span> <span class="pre">distance)</span></code> where <code class="docutils literal notranslate"><span class="pre">distance</span></code> is the
distance from the <code class="docutils literal notranslate"><span class="pre">start</span></code> nodes. If <code class="docutils literal notranslate"><span class="pre">False</span></code> only the vertices are
reported.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edges</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the edges
of the BFS tree in the order of visit or the vertices (default).
Edges are directed in root to leaf orientation of the tree.</p>
<p>Note that parameters <code class="docutils literal notranslate"><span class="pre">edges</span></code> and <code class="docutils literal notranslate"><span class="pre">report_distance</span></code> cannot be
<code class="docutils literal notranslate"><span class="pre">True</span></code> simultaneously.</p>
</li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="base/c_graph.html#sage.graphs.base.c_graph.CGraphBackend.breadth_first_search" title="sage.graphs.base.c_graph.CGraphBackend.breadth_first_search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">breadth_first_search</span></code></a>
– breadth-first search for fast compiled graphs.</p></li>
<li><p><a class="reference internal" href="base/c_graph.html#sage.graphs.base.c_graph.CGraphBackend.depth_first_search" title="sage.graphs.base.c_graph.CGraphBackend.depth_first_search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">depth_first_search</span></code></a>
– depth-first search for fast compiled graphs.</p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.depth_first_search" title="sage.graphs.generic_graph.GenericGraph.depth_first_search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">depth_first_search()</span></code></a> – depth-first search for generic graphs.</p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">breadth_first_search</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[0, 1, 4, 2, 3]</span>
</pre></div>
</div>
<p>By default, the edge direction of a digraph is respected, but this
can be overridden by the <code class="docutils literal notranslate"><span class="pre">ignore_direction</span></code> parameter:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">7</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">breadth_first_search</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">breadth_first_search</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ignore_direction</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[0, 1, 2, 3, 7, 4, 5, 6]</span>
</pre></div>
</div>
<p>You can specify a maximum distance in which to search. A distance of
zero returns the <code class="docutils literal notranslate"><span class="pre">start</span></code> vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">7</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">breadth_first_search</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[0]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">breadth_first_search</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[0, 1, 2, 3]</span>
</pre></div>
</div>
<p>Multiple starting vertices can be specified in a list:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">7</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">breadth_first_search</span><span class="p">([</span><span class="mi">0</span><span class="p">]))</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">breadth_first_search</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">]))</span>
<span class="go">[0, 6, 1, 2, 3, 7, 4, 5]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">breadth_first_search</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">distance</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[0, 6]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">breadth_first_search</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">distance</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[0, 6, 1, 2, 3, 7]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">breadth_first_search</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">ignore_direction</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[6, 3, 7, 0, 5]</span>
</pre></div>
</div>
<p>More generally, you can specify a <code class="docutils literal notranslate"><span class="pre">neighbors</span></code> function. For example,
you can traverse the graph backwards by setting <code class="docutils literal notranslate"><span class="pre">neighbors</span></code> to be the
<a class="reference internal" href="digraph.html#sage.graphs.digraph.DiGraph.neighbors_in" title="sage.graphs.digraph.DiGraph.neighbors_in"><code class="xref py py-meth docutils literal notranslate"><span class="pre">neighbors_in()</span></code></a> function of the graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">7</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">breadth_first_search</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">neighbors</span><span class="o">=</span><span class="n">D</span><span class="o">.</span><span class="n">neighbors_in</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[5, 1, 2, 0]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">breadth_first_search</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">neighbors</span><span class="o">=</span><span class="n">D</span><span class="o">.</span><span class="n">neighbors_out</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[5, 7, 0]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">breadth_first_search</span><span class="p">(</span><span class="mi">5</span> <span class="p">,</span><span class="n">neighbors</span><span class="o">=</span><span class="n">D</span><span class="o">.</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[5, 1, 2, 7, 0, 4, 6]</span>
</pre></div>
</div>
<p>It is possible (<a class="reference external" href="https://trac.sagemath.org/16470">trac ticket #16470</a>) using the keyword <code class="docutils literal notranslate"><span class="pre">report_distance</span></code> to
get pairs <code class="docutils literal notranslate"><span class="pre">(vertex,</span> <span class="pre">distance)</span></code> encoding the distance from the starting
vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">breadth_first_search</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">report_distance</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(0, 0), (1, 1), (4, 1), (5, 1), (2, 2), (6, 2), (3, 2), (9, 2),</span>
<span class="go">(7, 2), (8, 2)]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">breadth_first_search</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">report_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">[0, 1, 4, 5, 2, 6, 3, 9, 7, 8]</span>

<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">breadth_first_search</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">neighbors</span><span class="o">=</span><span class="n">D</span><span class="o">.</span><span class="n">neighbor_in_iterator</span><span class="p">,</span> <span class="n">report_distance</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(4, 0), (3, 1), (0, 2), (2, 2), (1, 3)]</span>

<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">breadth_first_search</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">report_distance</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(0, 0), (1, 0), (3, 1), (2, 1)]</span>
</pre></div>
</div>
<p>You can get edges of the BFS tree instead of the vertices using the
<code class="docutils literal notranslate"><span class="pre">edges</span></code> parameter:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span><span class="mi">4</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span><span class="mi">5</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">breadth_first_search</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(1, 2), (1, 3), (2, 4)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.canonical_label">
<span class="sig-name descname"><span class="pre">canonical_label</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">partition</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_graph</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.canonical_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the canonical graph.</p>
<p>A canonical graph is the representative graph of an isomorphism
class by some canonization function <span class="math notranslate nohighlight">\(c\)</span>. If <span class="math notranslate nohighlight">\(G\)</span> and <span class="math notranslate nohighlight">\(H\)</span> are graphs,
then <span class="math notranslate nohighlight">\(G \cong c(G)\)</span>, and <span class="math notranslate nohighlight">\(c(G) == c(H)\)</span> if and only if <span class="math notranslate nohighlight">\(G \cong H\)</span>.</p>
<p>See the <a class="reference external" href="https://en.wikipedia.org/wiki/Graph_canonization">Wikipedia article Graph_canonization</a> for more information.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">partition</span></code> – if given, the canonical label with respect
to this set partition will be computed. The default is the unit
set partition.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>). When set to
<code class="docutils literal notranslate"><span class="pre">True</span></code>, a dictionary mapping from the vertices of the (di)graph
to its canonical label will also be returned.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edge_labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>). When set to
<code class="docutils literal notranslate"><span class="pre">True</span></code>, allows only permutations respecting edge labels.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – a string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>). The algorithm to use;
currently available:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'bliss'</span></code>: use the optional package bliss
(<a class="reference external" href="http://www.tcs.tkk.fi/Software/bliss/index.html">http://www.tcs.tkk.fi/Software/bliss/index.html</a>);</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'sage'</span></code>: always use Sage’s implementation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> (default): use bliss when available and possible</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Make sure you always compare canonical forms obtained by the
same algorithm.</p>
</div>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">return_graph</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>). When set to
<code class="docutils literal notranslate"><span class="pre">False</span></code>, returns the list of edges of the canonical graph
instead of the canonical graph; only available when <code class="docutils literal notranslate"><span class="pre">'bliss'</span></code>
is explicitly set as algorithm.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>Canonization changes isomorphism to equality:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g1</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">GridGraph</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">g2</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">g1</span> <span class="o">==</span> <span class="n">g2</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">g1</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">g2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g1</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">()</span> <span class="o">==</span> <span class="n">g2</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We can get the relabeling used for canonization:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">g1</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;sage&#39;</span><span class="p">,</span> <span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span>
<span class="go">Grid Graph for [2, 3]: Graph on 6 vertices</span>
<span class="gp">sage: </span><span class="n">c</span>
<span class="go">{(0, 0): 3, (0, 1): 4, (0, 2): 2, (1, 0): 0, (1, 1): 5, (1, 2): 1}</span>
</pre></div>
</div>
<p>Multigraphs and directed graphs work too:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">()</span>
<span class="go">Multi-graph on 2 vertices</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;A?&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">()</span>
<span class="go">Graph on 2 vertices</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">DP</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">DP</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;sage&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span>
<span class="go">[0 0 0 0 0 0 0 1 1 1]</span>
<span class="go">[0 0 0 0 1 0 1 0 0 1]</span>
<span class="go">[0 0 0 1 0 0 1 0 1 0]</span>
<span class="go">[0 0 1 0 0 1 0 0 0 1]</span>
<span class="go">[0 1 0 0 0 1 0 0 1 0]</span>
<span class="go">[0 0 0 1 1 0 0 1 0 0]</span>
<span class="go">[0 1 1 0 0 0 0 1 0 0]</span>
<span class="go">[1 0 0 0 0 1 1 0 0 0]</span>
<span class="go">[1 0 1 0 1 0 0 0 0 0]</span>
<span class="go">[1 1 0 1 0 0 0 0 0 0]</span>
</pre></div>
</div>
<p>Edge labeled graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">)]</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;bliss&quot;</span><span class="p">,</span> <span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># optional - bliss</span>
<span class="go">(Graph on 5 vertices, {0: 4, 1: 3, 2: 1, 3: 0, 4: 2})</span>

<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;sage&quot;</span><span class="p">,</span> <span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(Graph on 5 vertices, {0: 4, 1: 3, 2: 0, 3: 1, 4: 2})</span>
</pre></div>
</div>
<p>Another example where different canonization algorithms give
different graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">g_sage</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;sage&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g_bliss</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;bliss&#39;</span><span class="p">)</span>  <span class="c1"># optional - bliss</span>
<span class="gp">sage: </span><span class="n">g_sage</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(0, 3), (1, 2)]</span>
<span class="gp">sage: </span><span class="n">g_bliss</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># optional - bliss</span>
<span class="go">[(0, 1), (2, 3)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.cartesian_product">
<span class="sig-name descname"><span class="pre">cartesian_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.cartesian_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Cartesian product of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>The Cartesian product of <span class="math notranslate nohighlight">\(G\)</span> and <span class="math notranslate nohighlight">\(H\)</span> is the graph <span class="math notranslate nohighlight">\(L\)</span> with vertex set
<span class="math notranslate nohighlight">\(V(L)\)</span> equal to the Cartesian product of the vertices <span class="math notranslate nohighlight">\(V(G)\)</span> and <span class="math notranslate nohighlight">\(V(H)\)</span>,
and <span class="math notranslate nohighlight">\(((u,v), (w,x))\)</span> is an edge iff either - <span class="math notranslate nohighlight">\((u, w)\)</span> is an edge of self
and <span class="math notranslate nohighlight">\(v = x\)</span>, or - <span class="math notranslate nohighlight">\((v, x)\)</span> is an edge of other and <span class="math notranslate nohighlight">\(u = w\)</span>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="graph_decompositions/graph_products.html#sage.graphs.graph_decompositions.graph_products.is_cartesian_product" title="sage.graphs.graph_decompositions.graph_products.is_cartesian_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_cartesian_product()</span></code></a>
– factorization of graphs according to the Cartesian product</p></li>
<li><p><a class="reference internal" href="graph_decompositions/graph_products.html#module-sage.graphs.graph_decompositions.graph_products" title="sage.graphs.graph_decompositions.graph_products"><code class="xref py py-mod docutils literal notranslate"><span class="pre">graph_products</span></code></a>
– a module on graph products</p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.categorical_product">
<span class="sig-name descname"><span class="pre">categorical_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.categorical_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the tensor product of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>The tensor product of <span class="math notranslate nohighlight">\(G\)</span> and <span class="math notranslate nohighlight">\(H\)</span> is the graph <span class="math notranslate nohighlight">\(L\)</span> with vertex set
<span class="math notranslate nohighlight">\(V(L)\)</span> equal to the Cartesian product of the vertices <span class="math notranslate nohighlight">\(V(G)\)</span> and <span class="math notranslate nohighlight">\(V(H)\)</span>,
and <span class="math notranslate nohighlight">\(((u,v), (w,x))\)</span> is an edge iff - <span class="math notranslate nohighlight">\((u, w)\)</span> is an edge of self, and -
<span class="math notranslate nohighlight">\((v, x)\)</span> is an edge of other.</p>
<p>The tensor product is also known as the categorical product and the
Kronecker product (referring to the Kronecker matrix product). See
the <a class="reference external" href="https://en.wikipedia.org/wiki/Kronecker_product">Wikipedia article Kronecker_product</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">tensor_product</span><span class="p">(</span><span class="n">Z</span><span class="p">);</span> <span class="n">T</span>
<span class="go">Graph on 10 vertices</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">10</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span> <span class="c1"># long time</span>
<span class="go">Graphics object consisting of 21 graphics primitives</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">tensor_product</span><span class="p">(</span><span class="n">P</span><span class="p">);</span> <span class="n">T</span>
<span class="go">Graph on 200 vertices</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">900</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span> <span class="c1"># long time</span>
<span class="go">Graphics object consisting of 1101 graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.centrality_betweenness">
<span class="sig-name descname"><span class="pre">centrality_betweenness</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endpoints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.centrality_betweenness" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the betweenness centrality.</p>
<p>The betweenness centrality of a vertex is the fraction of number of
shortest paths that go through each vertex. The betweenness is
normalized by default to be in range (0,1).</p>
<p>Measures of the centrality of a vertex within a graph determine the
relative importance of that vertex to its graph. Vertices that occur on
more shortest paths between other vertices have higher betweenness than
vertices that occur on less.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">normalized</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if set to <code class="docutils literal notranslate"><span class="pre">False</span></code>,
result is not normalized.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); if set to an integer, use <code class="docutils literal notranslate"><span class="pre">k</span></code>
node samples to estimate betweenness. Higher values give better
approximations. Not available when <code class="docutils literal notranslate"><span class="pre">algorithm=&quot;Sage&quot;</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); if set to a string, use that
attribute of the nodes as weight. <code class="docutils literal notranslate"><span class="pre">weight</span> <span class="pre">=</span> <span class="pre">True</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">weight</span> <span class="pre">=</span> <span class="pre">&quot;weight&quot;</span></code>. Not available when <code class="docutils literal notranslate"><span class="pre">algorithm=&quot;Sage&quot;</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">endpoints</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if set to <code class="docutils literal notranslate"><span class="pre">True</span></code> it
includes the endpoints in the shortest paths count. Not available when
<code class="docutils literal notranslate"><span class="pre">algorithm=&quot;Sage&quot;</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">exact</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to compute over
rationals or on <code class="docutils literal notranslate"><span class="pre">double</span></code> C variables. Not available when
<code class="docutils literal notranslate"><span class="pre">algorithm=&quot;NetworkX&quot;</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); can be either <code class="docutils literal notranslate"><span class="pre">&quot;Sage&quot;</span></code>
(see <a class="reference internal" href="centrality.html#module-sage.graphs.centrality" title="sage.graphs.centrality"><code class="xref py py-mod docutils literal notranslate"><span class="pre">centrality</span></code></a>), <code class="docutils literal notranslate"><span class="pre">&quot;NetworkX&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;None&quot;</span></code>. In
the latter case, Sage’s algorithm will be used whenever possible.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="graph.html#sage.graphs.graph.Graph.centrality_degree" title="sage.graphs.graph.Graph.centrality_degree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">centrality_degree()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.centrality_closeness" title="sage.graphs.generic_graph.GenericGraph.centrality_closeness"><code class="xref py py-meth docutils literal notranslate"><span class="pre">centrality_closeness()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">centrality_betweenness</span><span class="p">()</span> <span class="c1"># abs tol 1e-10</span>
<span class="go">{0: 0.06969696969696969, 1: 0.06969696969696969,</span>
<span class="go"> 2: 0.0606060606060606, 3: 0.0606060606060606,</span>
<span class="go"> 4: 0.06969696969696969, 5: 0.06969696969696969,</span>
<span class="go"> 6: 0.0606060606060606, 7: 0.0606060606060606,</span>
<span class="go"> 8: 0.0606060606060606, 9: 0.0606060606060606,</span>
<span class="go"> 10: 0.0606060606060606, 11: 0.0606060606060606}</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">centrality_betweenness</span><span class="p">(</span><span class="n">normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="c1"># abs tol 1e-10</span>
<span class="go">{0: 3.833333333333333, 1: 3.833333333333333, 2: 3.333333333333333,</span>
<span class="go"> 3: 3.333333333333333, 4: 3.833333333333333, 5: 3.833333333333333,</span>
<span class="go"> 6: 3.333333333333333, 7: 3.333333333333333, 8: 3.333333333333333,</span>
<span class="go"> 9: 3.333333333333333, 10: 3.333333333333333,</span>
<span class="go"> 11: 3.333333333333333}</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">to_undirected</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">centrality_betweenness</span><span class="p">()</span> <span class="c1"># abs tol abs 1e-10</span>
<span class="go">{0: 0.16666666666666666, 1: 0.16666666666666666, 2: 0.0, 3: 0.0}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.centrality_closeness">
<span class="sig-name descname"><span class="pre">centrality_closeness</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vert</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">by_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.centrality_closeness" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the closeness centrality of all vertices in <code class="docutils literal notranslate"><span class="pre">vert</span></code>.</p>
<p>In a (strongly) connected graph, the closeness centrality of a vertex
<span class="math notranslate nohighlight">\(v\)</span> is equal to the inverse of the average distance between <span class="math notranslate nohighlight">\(v\)</span> and
other vertices.  If the graph is disconnected, the closeness centrality
of <span class="math notranslate nohighlight">\(v\)</span> is multiplied by the fraction of reachable vertices in the graph:
this way, central vertices should also reach several other vertices in
the graph <a class="reference internal" href="../../../references/index.html#olj2014" id="id5"><span>[OLJ2014]</span></a>. In formulas,</p>
<div class="math notranslate nohighlight">
\[c(v)=\frac{r(v)-1}{\sum_{w \in R(v)} d(v,w)}\frac{r(v)-1}{n-1}\]</div>
<p>where <span class="math notranslate nohighlight">\(R(v)\)</span> is the set of vertices reachable from <span class="math notranslate nohighlight">\(v\)</span>, and <span class="math notranslate nohighlight">\(r(v)\)</span> is
the cardinality of <span class="math notranslate nohighlight">\(R(v)\)</span>.</p>
<p>‘Closeness centrality may be defined as the total graph-theoretic
distance of a given vertex from all other vertices… Closeness is an
inverse measure of centrality in that a larger value indicates a less
central actor while a smaller value indicates a more central actor,’
<a class="reference internal" href="../../../references/index.html#bor1995" id="id6"><span>[Bor1995]</span></a>.</p>
<p>For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Centrality">Wikipedia article Centrality</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vert</span></code> – the vertex or the list of vertices we want to analyze. If
<code class="docutils literal notranslate"><span class="pre">None</span></code> (default), all vertices are considered.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">by_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, the edges
in the graph are weighted, and otherwise all edges have weight 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); one of the following
algorithms:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'BFS'</span></code>: performs a BFS from each vertex that has to be analyzed.
Does not work with edge weights.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'NetworkX'</span></code>: the NetworkX algorithm (works only with positive
weights).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Dijkstra_Boost'</span></code>: the Dijkstra algorithm, implemented in Boost
(works only with positive weights).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Floyd-Warshall-Cython'</span></code>: the Cython implementation of the
Floyd-Warshall algorithm. Works only if <code class="docutils literal notranslate"><span class="pre">by_weight==False</span></code> and all
centralities are needed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Floyd-Warshall-Python'</span></code>: the Python implementation of the
Floyd-Warshall algorithm. Works only if all centralities are needed,
but it can deal with weighted graphs, even with negative weights
(but no negative cycle is allowed).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Johnson_Boost'</span></code>: the Johnson algorithm, implemented in Boost
(works also with negative weights, if there is no negative cycle).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> (default): Sage chooses the best algorithm: <code class="docutils literal notranslate"><span class="pre">'BFS'</span></code> if
<code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, <code class="docutils literal notranslate"><span class="pre">'Dijkstra_Boost'</span></code> if all weights are
positive, <code class="docutils literal notranslate"><span class="pre">'Johnson_Boost'</span></code> otherwise.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
takes as input an edge <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></code> and outputs its weight. If not
<code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is automatically set to <code class="docutils literal notranslate"><span class="pre">True</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>
and <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, we use the edge label <code class="docutils literal notranslate"><span class="pre">l</span></code> as a
weight, if <code class="docutils literal notranslate"><span class="pre">l</span></code> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, else <code class="docutils literal notranslate"><span class="pre">1</span></code> as a weight.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, we check
that the <code class="docutils literal notranslate"><span class="pre">weight_function</span></code> outputs a number for each edge.</p></li>
</ul>
<p>OUTPUT:</p>
<p>If <code class="docutils literal notranslate"><span class="pre">vert</span></code> is a vertex, the closeness centrality of that vertex.
Otherwise, a dictionary associating to each vertex in <code class="docutils literal notranslate"><span class="pre">vert</span></code> its
closeness centrality. If a vertex has (out)degree 0, its closeness
centrality is not defined, and the vertex is not included in the output.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="centrality.html#sage.graphs.centrality.centrality_closeness_top_k" title="sage.graphs.centrality.centrality_closeness_top_k"><code class="xref py py-func docutils literal notranslate"><span class="pre">centrality_closeness_top_k()</span></code></a></p></li>
<li><p><a class="reference internal" href="graph.html#sage.graphs.graph.Graph.centrality_degree" title="sage.graphs.graph.Graph.centrality_degree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">centrality_degree()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.centrality_betweenness" title="sage.graphs.generic_graph.GenericGraph.centrality_betweenness"><code class="xref py py-meth docutils literal notranslate"><span class="pre">centrality_betweenness()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>Standard examples:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">())</span><span class="o">.</span><span class="n">centrality_closeness</span><span class="p">()</span>
<span class="go">{0: 0.61111111111111..., 1: 0.61111111111111..., 2: 0.61111111111111..., 3: 0.61111111111111..., 4: 0.61111111111111..., 5: 0.61111111111111..., 6: 0.61111111111111..., 7: 0.61111111111111..., 8: 0.61111111111111..., 9: 0.61111111111111..., 10: 0.61111111111111..., 11: 0.61111111111111...}</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">centrality_closeness</span><span class="p">(</span><span class="n">vert</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">{0: 1.0, 1: 0.3333333333333333}</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">to_undirected</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">centrality_closeness</span><span class="p">()</span>
<span class="go">{0: 1.0, 1: 1.0, 2: 0.75, 3: 0.75}</span>
</pre></div>
</div>
<p>In a (strongly) connected (di)graph, the closeness centrality of <span class="math notranslate nohighlight">\(v\)</span>
is inverse of the average distance between <span class="math notranslate nohighlight">\(v\)</span> and all other vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">centrality_closeness</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0.4</span>
<span class="gp">sage: </span><span class="n">dist</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shortest_path_lengths</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
<span class="go">0.4</span>
<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">d</span><span class="o">.</span><span class="n">centrality_closeness</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0.4</span>
<span class="gp">sage: </span><span class="n">dist</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">shortest_path_lengths</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
<span class="go">0.4</span>
</pre></div>
</div>
<p>If a vertex has (out)degree 0, its closeness centrality is not defined:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">centrality_closeness</span><span class="p">()</span>
<span class="go">{}</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">centrality_closeness</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">None</span>
</pre></div>
</div>
<p>Weighted graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">GridGraph</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">weight_function</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">e</span><span class="p">:</span><span class="mi">10</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">centrality_closeness</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>                          <span class="c1"># tol abs 1e-12</span>
<span class="go">{(0, 0): 0.75, (0, 1): 0.75}</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">centrality_closeness</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">weight_function</span><span class="o">=</span><span class="n">weight_function</span><span class="p">)</span> <span class="c1"># tol abs 1e-12</span>
<span class="go">0.075</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.characteristic_polynomial">
<span class="sig-name descname"><span class="pre">characteristic_polynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'x'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">laplacian</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.characteristic_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the characteristic polynomial of the adjacency matrix of the
(di)graph.</p>
<p>Let <span class="math notranslate nohighlight">\(G\)</span> be a (simple) graph with adjacency matrix <span class="math notranslate nohighlight">\(A\)</span>. Let <span class="math notranslate nohighlight">\(I\)</span> be the
identity matrix of dimensions the same as <span class="math notranslate nohighlight">\(A\)</span>. The characteristic
polynomial of <span class="math notranslate nohighlight">\(G\)</span> is defined as the determinant <span class="math notranslate nohighlight">\(\det(xI - A)\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">characteristic_polynomial</span></code> and <code class="docutils literal notranslate"><span class="pre">charpoly</span></code> are aliases and thus
provide exactly the same method.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'x'</span></code>); the variable of the characteristic
polynomial</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">laplacian</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, use the
Laplacian matrix</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.kirchhoff_matrix" title="sage.graphs.generic_graph.GenericGraph.kirchhoff_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kirchhoff_matrix()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.laplacian_matrix" title="sage.graphs.generic_graph.GenericGraph.laplacian_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">laplacian_matrix()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">characteristic_polynomial</span><span class="p">()</span>
<span class="go">x^10 - 15*x^8 + 75*x^6 - 24*x^5 - 165*x^4 + 120*x^3 + 120*x^2 - 160*x + 48</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">charpoly</span><span class="p">()</span>
<span class="go">x^10 - 15*x^8 + 75*x^6 - 24*x^5 - 165*x^4 + 120*x^3 + 120*x^2 - 160*x + 48</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">characteristic_polynomial</span><span class="p">(</span><span class="n">laplacian</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">x^10 - 30*x^9 + 390*x^8 - 2880*x^7 + 13305*x^6 -</span>
<span class="go">39882*x^5 + 77640*x^4 - 94800*x^3 + 66000*x^2 - 20000*x</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.charpoly">
<span class="sig-name descname"><span class="pre">charpoly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'x'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">laplacian</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.charpoly" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the characteristic polynomial of the adjacency matrix of the
(di)graph.</p>
<p>Let <span class="math notranslate nohighlight">\(G\)</span> be a (simple) graph with adjacency matrix <span class="math notranslate nohighlight">\(A\)</span>. Let <span class="math notranslate nohighlight">\(I\)</span> be the
identity matrix of dimensions the same as <span class="math notranslate nohighlight">\(A\)</span>. The characteristic
polynomial of <span class="math notranslate nohighlight">\(G\)</span> is defined as the determinant <span class="math notranslate nohighlight">\(\det(xI - A)\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">characteristic_polynomial</span></code> and <code class="docutils literal notranslate"><span class="pre">charpoly</span></code> are aliases and thus
provide exactly the same method.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'x'</span></code>); the variable of the characteristic
polynomial</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">laplacian</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, use the
Laplacian matrix</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.kirchhoff_matrix" title="sage.graphs.generic_graph.GenericGraph.kirchhoff_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kirchhoff_matrix()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.laplacian_matrix" title="sage.graphs.generic_graph.GenericGraph.laplacian_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">laplacian_matrix()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">characteristic_polynomial</span><span class="p">()</span>
<span class="go">x^10 - 15*x^8 + 75*x^6 - 24*x^5 - 165*x^4 + 120*x^3 + 120*x^2 - 160*x + 48</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">charpoly</span><span class="p">()</span>
<span class="go">x^10 - 15*x^8 + 75*x^6 - 24*x^5 - 165*x^4 + 120*x^3 + 120*x^2 - 160*x + 48</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">characteristic_polynomial</span><span class="p">(</span><span class="n">laplacian</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">x^10 - 30*x^9 + 390*x^8 - 2880*x^7 + 13305*x^6 -</span>
<span class="go">39882*x^5 + 77640*x^4 - 94800*x^3 + 66000*x^2 - 20000*x</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.clear">
<span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Empties the graph of vertices and edges and removes name, associated
objects, and position information.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="n">G</span><span class="o">.</span><span class="n">set_vertices</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span><span class="s1">&#39;vertex0&#39;</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">();</span> <span class="n">G</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">4</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">_pos</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
<span class="go">&#39;Cycle graph&#39;</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">get_vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;vertex0&#39;</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">order</span><span class="p">();</span> <span class="n">H</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">0</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">_pos</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
<span class="go">&#39;&#39;</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">get_vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">order</span><span class="p">();</span> <span class="n">H</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">0</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">_pos</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
<span class="go">&#39;&#39;</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">get_vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.cluster_transitivity">
<span class="sig-name descname"><span class="pre">cluster_transitivity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.cluster_transitivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the transitivity (fraction of transitive triangles) of the graph.</p>
<p>Transitivity is the fraction of all existing triangles over all
connected triples (triads),
<span class="math notranslate nohighlight">\(T = 3\times\frac{\text{triangles}}{\text{triads}}\)</span>.</p>
<p>See also section “Clustering” in chapter “Algorithms” of <a class="reference internal" href="../../../references/index.html#hss" id="id7"><span>[HSS]</span></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">FruchtGraph</span><span class="p">()</span><span class="o">.</span><span class="n">cluster_transitivity</span><span class="p">()</span>
<span class="go">0.25</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.cluster_triangles">
<span class="sig-name descname"><span class="pre">cluster_triangles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nbunch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">implementation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.cluster_triangles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of triangles for the set <span class="math notranslate nohighlight">\(nbunch\)</span> of vertices as a
dictionary keyed by vertex.</p>
<p>See also section “Clustering” in chapter “Algorithms” of <a class="reference internal" href="../../../references/index.html#hss" id="id8"><span>[HSS]</span></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nbunch</span></code> – a list of vertices (default: <code class="docutils literal notranslate"><span class="pre">None);</span> <span class="pre">the</span> <span class="pre">vertices</span> <span class="pre">to</span>
<span class="pre">inspect.</span> <span class="pre">If</span> <span class="pre">``nbunch=None</span></code>, returns data for all vertices in the
graph.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">implementation</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); one of
<code class="docutils literal notranslate"><span class="pre">'sparse_copy'</span></code>, <code class="docutils literal notranslate"><span class="pre">'dense_copy'</span></code>, <code class="docutils literal notranslate"><span class="pre">'networkx'</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code>
(default). In the latter case, the best algorithm available is
used. Note that <code class="docutils literal notranslate"><span class="pre">'networkx'</span></code> does not support directed graphs.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">FruchtGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">cluster_triangles</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
<span class="go">[1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">cluster_triangles</span><span class="p">()</span>
<span class="go">{0: 1, 1: 1, 2: 0, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 0, 9: 1, 10: 1, 11: 0}</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">cluster_triangles</span><span class="p">(</span><span class="n">nbunch</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">{0: 1, 1: 1, 2: 0}</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mf">.3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cluster_triangles</span><span class="p">(</span><span class="n">implementation</span><span class="o">=</span><span class="s2">&quot;networkx&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cluster_triangles</span><span class="p">(</span><span class="n">implementation</span><span class="o">=</span><span class="s2">&quot;dense_copy&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d3</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cluster_triangles</span><span class="p">(</span><span class="n">implementation</span><span class="o">=</span><span class="s2">&quot;sparse_copy&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d1</span> <span class="o">==</span> <span class="n">d2</span> <span class="ow">and</span> <span class="n">d1</span> <span class="o">==</span> <span class="n">d3</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.clustering_average">
<span class="sig-name descname"><span class="pre">clustering_average</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">implementation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.clustering_average" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the average clustering coefficient.</p>
<p>The clustering coefficient of a node <span class="math notranslate nohighlight">\(i\)</span> is the fraction of existing
triangles containing node <span class="math notranslate nohighlight">\(i\)</span> over all possible triangles containing
<span class="math notranslate nohighlight">\(i\)</span>: <span class="math notranslate nohighlight">\(c_i = T(i) / \binom {k_i} 2\)</span> where <span class="math notranslate nohighlight">\(T(i)\)</span> is the number of
existing triangles through <span class="math notranslate nohighlight">\(i\)</span>, and <span class="math notranslate nohighlight">\(k_i\)</span> is the degree of vertex <span class="math notranslate nohighlight">\(i\)</span>.</p>
<p>A coefficient for the whole graph is the average of the <span class="math notranslate nohighlight">\(c_i\)</span>.</p>
<p>See also section “Clustering” in chapter “Algorithms” of <a class="reference internal" href="../../../references/index.html#hss" id="id9"><span>[HSS]</span></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">implementation</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); one of <code class="docutils literal notranslate"><span class="pre">'boost'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'sparse_copy'</span></code>, <code class="docutils literal notranslate"><span class="pre">'dense_copy'</span></code>, <code class="docutils literal notranslate"><span class="pre">'networkx'</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code>
(default). In the latter case, the best algorithm available is
used. Note that only <code class="docutils literal notranslate"><span class="pre">'networkx'</span></code> supports directed graphs.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">FruchtGraph</span><span class="p">())</span><span class="o">.</span><span class="n">clustering_average</span><span class="p">()</span>
<span class="go">1/4</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">FruchtGraph</span><span class="p">())</span><span class="o">.</span><span class="n">clustering_average</span><span class="p">(</span><span class="n">implementation</span><span class="o">=</span><span class="s1">&#39;networkx&#39;</span><span class="p">)</span>
<span class="go">0.25</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.clustering_coeff">
<span class="sig-name descname"><span class="pre">clustering_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">implementation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.clustering_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the clustering coefficient for each vertex in <code class="docutils literal notranslate"><span class="pre">nodes</span></code> as a
dictionary keyed by vertex.</p>
<p>For an unweighted graph, the clustering coefficient of a node <span class="math notranslate nohighlight">\(i\)</span> is the
fraction of existing triangles containing node <span class="math notranslate nohighlight">\(i\)</span> over all possible
triangles containing <span class="math notranslate nohighlight">\(i\)</span>: <span class="math notranslate nohighlight">\(c_i = T(i) / \binom {k_i} 2\)</span> where <span class="math notranslate nohighlight">\(T(i)\)</span> is
the number of existing triangles through <span class="math notranslate nohighlight">\(i\)</span>, and <span class="math notranslate nohighlight">\(k_i\)</span> is the degree of
vertex <span class="math notranslate nohighlight">\(i\)</span>.</p>
<p>For weighted graphs the clustering is defined as the geometric average
of the subgraph edge weights, normalized by the maximum weight in the
network.</p>
<p>The value of <span class="math notranslate nohighlight">\(c_i\)</span> is assigned <span class="math notranslate nohighlight">\(0\)</span> if <span class="math notranslate nohighlight">\(k_i &lt; 2\)</span>.</p>
<p>See also section “Clustering” in chapter “Algorithms” of <a class="reference internal" href="../../../references/index.html#hss" id="id10"><span>[HSS]</span></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nodes</span></code> – an iterable container of vertices (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>);
the vertices to inspect. By default, returns data on all vertices in
graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight</span></code> – string or boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if it is a
string it uses the indicated edge property as weight.  <code class="docutils literal notranslate"><span class="pre">weight</span> <span class="pre">=</span>
<span class="pre">True</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">weight</span> <span class="pre">=</span> <span class="pre">'weight'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">implementation</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); one of <code class="docutils literal notranslate"><span class="pre">'boost'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'sparse_copy'</span></code>, <code class="docutils literal notranslate"><span class="pre">'dense_copy'</span></code>, <code class="docutils literal notranslate"><span class="pre">'networkx'</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code>
(default). In the latter case, the best algorithm available is
used. Note that only <code class="docutils literal notranslate"><span class="pre">'networkx'</span></code> supports directed or weighted
graphs, and that <code class="docutils literal notranslate"><span class="pre">'sparse_copy'</span></code> and <code class="docutils literal notranslate"><span class="pre">'dense_copy'</span></code> do not support
<code class="docutils literal notranslate"><span class="pre">node</span></code> different from <code class="docutils literal notranslate"><span class="pre">None</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">FruchtGraph</span><span class="p">()</span><span class="o">.</span><span class="n">clustering_coeff</span><span class="p">()</span>
<span class="go">{0: 1/3, 1: 1/3, 2: 0, 3: 1/3, 4: 1/3, 5: 1/3,</span>
<span class="go"> 6: 1/3, 7: 1/3, 8: 0, 9: 1/3, 10: 1/3, 11: 0}</span>

<span class="gp">sage: </span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">FruchtGraph</span><span class="p">())</span><span class="o">.</span><span class="n">clustering_coeff</span><span class="p">(</span><span class="n">weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{0: 0.3333333333333333, 1: 0.3333333333333333, 2: 0,</span>
<span class="go">3: 0.3333333333333333, 4: 0.3333333333333333,</span>
<span class="go">5: 0.3333333333333333, 6: 0.3333333333333333,</span>
<span class="go">7: 0.3333333333333333, 8: 0, 9: 0.3333333333333333,</span>
<span class="go">10: 0.3333333333333333, 11: 0}</span>

<span class="gp">sage: </span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">FruchtGraph</span><span class="p">())</span><span class="o">.</span><span class="n">clustering_coeff</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">{0: 0.3333333333333333, 1: 0.3333333333333333, 2: 0.0}</span>

<span class="gp">sage: </span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">FruchtGraph</span><span class="p">())</span><span class="o">.</span><span class="n">clustering_coeff</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
<span class="gp">....: </span>  <span class="n">weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{0: 0.3333333333333333, 1: 0.3333333333333333, 2: 0}</span>

<span class="gp">sage: </span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">GridGraph</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]))</span><span class="o">.</span><span class="n">clustering_coeff</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span>
<span class="go">{(0, 0): 0.0, (0, 1): 0.0, (2, 2): 0.0}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.coarsest_equitable_refinement">
<span class="sig-name descname"><span class="pre">coarsest_equitable_refinement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">partition</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.coarsest_equitable_refinement" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the coarsest partition which is finer than the input
partition, and equitable with respect to self.</p>
<p>A partition is equitable with respect to a graph if for every pair of
cells <span class="math notranslate nohighlight">\(C_1\)</span>, <span class="math notranslate nohighlight">\(C_2\)</span> of the partition, the number of edges from a vertex
of <span class="math notranslate nohighlight">\(C_1\)</span> to <span class="math notranslate nohighlight">\(C_2\)</span> is the same, over all vertices in <span class="math notranslate nohighlight">\(C_1\)</span>.</p>
<p>A partition <span class="math notranslate nohighlight">\(P_1\)</span> is finer than <span class="math notranslate nohighlight">\(P_2\)</span> (<span class="math notranslate nohighlight">\(P_2\)</span> is coarser than <span class="math notranslate nohighlight">\(P_1\)</span>) if
every cell of <span class="math notranslate nohighlight">\(P_1\)</span> is a subset of a cell of <span class="math notranslate nohighlight">\(P_2\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">partition</span></code> – a list of lists</p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sparse</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to use sparse or</dt><dd><p>dense representation - for small graphs, use dense for speed</p>
</dd>
</dl>
</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">coarsest_equitable_refinement</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">))])</span>
<span class="go">[[0], [2, 3, 6, 7, 8, 9], [1, 4, 5]]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">verts</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Pi</span> <span class="o">=</span> <span class="p">[</span><span class="n">verts</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span> <span class="n">verts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
<span class="gp">sage: </span><span class="n">Pi</span>
<span class="go">[[&#39;000&#39;], [&#39;001&#39;, &#39;010&#39;, &#39;011&#39;, &#39;100&#39;, &#39;101&#39;, &#39;110&#39;, &#39;111&#39;]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">coarsest_equitable_refinement</span><span class="p">(</span><span class="n">Pi</span><span class="p">)]</span>
<span class="go">[[&#39;000&#39;], [&#39;011&#39;, &#39;101&#39;, &#39;110&#39;], [&#39;111&#39;], [&#39;001&#39;, &#39;010&#39;, &#39;100&#39;]]</span>
</pre></div>
</div>
<p>Note that given an equitable partition, this function returns that
partition:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">prt</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">coarsest_equitable_refinement</span><span class="p">(</span><span class="n">prt</span><span class="p">)</span>
<span class="go">[[0], [1, 4, 5], [2, 3, 6, 7, 8, 9]]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ss</span> <span class="o">=</span> <span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">WheelGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span><span class="o">.</span><span class="n">line_graph</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">prt</span> <span class="o">=</span> <span class="p">[[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]]</span>
<span class="gp">sage: </span><span class="n">ss</span><span class="o">.</span><span class="n">coarsest_equitable_refinement</span><span class="p">(</span><span class="n">prt</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: partition ([[(0, 1)], [(0, 2), (0, 3), (0, 4), (1, 2), (1, 4)], [(2, 3), (3, 4)]]) is not valid for this graph: vertices are incorrect</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ss</span> <span class="o">=</span> <span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">WheelGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">line_graph</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ss</span><span class="o">.</span><span class="n">coarsest_equitable_refinement</span><span class="p">(</span><span class="n">prt</span><span class="p">)</span>
<span class="go">[[(0, 1)], [(1, 2), (1, 4)], [(0, 3)], [(0, 4), (0, 2)], [(2, 3), (3, 4)]]</span>
</pre></div>
</div>
<p>ALGORITHM: Brendan D. McKay’s Master’s Thesis, University of
Melbourne, 1976.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.complement">
<span class="sig-name descname"><span class="pre">complement</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.complement" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the complement of the (di)graph.</p>
<p>The complement of a graph has the same vertices, but exactly those edges
that are not in the original graph. This is not well defined for graphs
with multiple edges.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span> <span class="c1"># long time</span>
<span class="go">Graphics object consisting of 26 graphics primitives</span>
<span class="gp">sage: </span><span class="n">PC</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">PC</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span> <span class="c1"># long time</span>
<span class="go">Graphics object consisting of 41 graphics primitives</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">TetrahedralGraph</span><span class="p">()</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 2, None), (1, 3, None)]</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
<span class="go">complement(Cycle graph): Graph on 4 vertices</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: This method is not known to work on graphs with</span>
<span class="go">multiedges. Perhaps this method can be updated to handle them, but</span>
<span class="go">in the meantime if you want to use it please disallow multiedges</span>
<span class="go">using allow_multiple_edges().</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.connected_component_containing_vertex">
<span class="sig-name descname"><span class="pre">connected_component_containing_vertex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.connected_component_containing_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the vertices connected to vertex.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – the input graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">v</span></code> – the vertex to search for</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sort</span></code> – boolean (default <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether to sort vertices inside
the component</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.connectivity</span> <span class="kn">import</span> <span class="n">connected_component_containing_vertex</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">connected_component_containing_vertex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">connected_component_containing_vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">connected_component_containing_vertex</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.connected_components">
<span class="sig-name descname"><span class="pre">connected_components</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.connected_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of connected components.</p>
<p>This returns a list of lists of vertices, each list representing a connected
component. The list is ordered from largest to smallest component.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – the input graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sort</span></code> – boolean (default <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether to sort vertices inside
each component</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.connectivity</span> <span class="kn">import</span> <span class="n">connected_components</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">[[0, 1, 2, 3], [4, 5, 6]]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">connected_components</span><span class="p">()</span>
<span class="go">[[0, 1, 2, 3], [4, 5, 6]]</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">connected_components</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="go">[[0, 1, 2, 3], [4, 5, 6]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.connected_components_number">
<span class="sig-name descname"><span class="pre">connected_components_number</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.connected_components_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of connected components.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – the input graph</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.connectivity</span> <span class="kn">import</span> <span class="n">connected_components_number</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">connected_components_number</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">connected_components_number</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">connected_components_number</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.connected_components_sizes">
<span class="sig-name descname"><span class="pre">connected_components_sizes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.connected_components_sizes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sizes of the connected components as a list.</p>
<p>The list is sorted from largest to lower values.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.connectivity</span> <span class="kn">import</span> <span class="n">connected_components_sizes</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">graphs</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="n">connected_components_sizes</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">[1, 1, 1]</span>
<span class="go">[2, 1]</span>
<span class="go">[3]</span>
<span class="go">[3]</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">graphs</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">connected_components_sizes</span><span class="p">())</span>
<span class="go">[1, 1, 1]</span>
<span class="go">[2, 1]</span>
<span class="go">[3]</span>
<span class="go">[3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.connected_components_subgraphs">
<span class="sig-name descname"><span class="pre">connected_components_subgraphs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.connected_components_subgraphs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of connected components as graph objects.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.connectivity</span> <span class="kn">import</span> <span class="n">connected_components_subgraphs</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">connected_components_subgraphs</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">graphs_list</span><span class="o">.</span><span class="n">show_graphs</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">connected_components_subgraphs</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">graphs_list</span><span class="o">.</span><span class="n">show_graphs</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">connected_components_subgraphs</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">graphs_list</span><span class="o">.</span><span class="n">show_graphs</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.connected_subgraph_iterator">
<span class="sig-name descname"><span class="pre">connected_subgraph_iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.connected_subgraph_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator over the induced connected subgraphs of order at most <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>This method implements a iterator over the induced connected subgraphs of
the input (di)graph. An induced subgraph of a graph is another graph, formed
from a subset of the vertices of the graph and all of the edges connecting
pairs of vertices in that subset (<a class="reference external" href="https://en.wikipedia.org/wiki/Induced_subgraph">Wikipedia article Induced_subgraph</a>).</p>
<p>As for method <code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.graphs.generic_graph.connected_components()</span></code>, edge
orientation is ignored. Hence, the directed graph with a single arc <span class="math notranslate nohighlight">\(0 \to
1\)</span> is considered connected.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a <a class="reference internal" href="graph.html#sage.graphs.graph.Graph" title="sage.graphs.graph.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a> or a <a class="reference internal" href="digraph.html#sage.graphs.digraph.DiGraph" title="sage.graphs.digraph.DiGraph"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraph</span></code></a>; loops and multiple edges
are allowed</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> – (optional) integer; maximum order of the connected subgraphs to
report; by default, the method iterates over all connected subgraphs
(equivalent to <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">==</span> <span class="pre">n</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertices_only</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return
(Di)Graph or list of vertices</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">connected_subgraph_iterator</span><span class="p">())</span>
<span class="go">[Subgraph of (): Digraph on 1 vertex,</span>
<span class="go"> Subgraph of (): Digraph on 2 vertices,</span>
<span class="go"> Subgraph of (): Digraph on 3 vertices,</span>
<span class="go"> Subgraph of (): Digraph on 4 vertices,</span>
<span class="go"> Subgraph of (): Digraph on 3 vertices,</span>
<span class="go"> Subgraph of (): Digraph on 1 vertex,</span>
<span class="go"> Subgraph of (): Digraph on 2 vertices,</span>
<span class="go"> Subgraph of (): Digraph on 3 vertices,</span>
<span class="go"> Subgraph of (): Digraph on 2 vertices,</span>
<span class="go"> Subgraph of (): Digraph on 1 vertex,</span>
<span class="go"> Subgraph of (): Digraph on 2 vertices,</span>
<span class="go"> Subgraph of (): Digraph on 1 vertex]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">connected_subgraph_iterator</span><span class="p">(</span><span class="n">vertices_only</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[[1], [1, 2], [1, 2, 3], [1, 2, 3, 4], [1, 2, 4],</span>
<span class="go"> [2], [2, 3], [2, 3, 4], [2, 4], [3], [3, 4], [4]]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">connected_subgraph_iterator</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[Subgraph of (): Digraph on 1 vertex,</span>
<span class="go"> Subgraph of (): Digraph on 2 vertices,</span>
<span class="go"> Subgraph of (): Digraph on 1 vertex,</span>
<span class="go"> Subgraph of (): Digraph on 2 vertices,</span>
<span class="go"> Subgraph of (): Digraph on 2 vertices,</span>
<span class="go"> Subgraph of (): Digraph on 1 vertex,</span>
<span class="go"> Subgraph of (): Digraph on 2 vertices,</span>
<span class="go"> Subgraph of (): Digraph on 1 vertex]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">connected_subgraph_iterator</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">vertices_only</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[[1], [1, 2], [2], [2, 3], [2, 4], [3], [3, 4], [4]]</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">connected_subgraph_iterator</span><span class="p">())</span>
<span class="go">[Subgraph of (): Digraph on 1 vertex,</span>
<span class="go"> Subgraph of (): Digraph on 2 vertices,</span>
<span class="go"> Subgraph of (): Digraph on 1 vertex]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">connected_subgraph_iterator</span><span class="p">(</span><span class="n">vertices_only</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[[1], [1, 2], [2]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.contract_edge">
<span class="sig-name descname"><span class="pre">contract_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.contract_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract an edge from <code class="docutils literal notranslate"><span class="pre">u</span></code> to <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<p>This method returns silently if the edge does not exist.</p>
<p>INPUT: The following forms are all accepted:</p>
<ul class="simple">
<li><p>G.contract_edge( 1, 2 )</p></li>
<li><p>G.contract_edge( (1, 2) )</p></li>
<li><p>G.contract_edge( [ (1, 2) ] )</p></li>
<li><p>G.contract_edge( 1, 2, ‘label’ )</p></li>
<li><p>G.contract_edge( (1, 2, ‘label’) )</p></li>
<li><p>G.contract_edge( [ (1, 2, ‘label’) ] )</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">contract_edge</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 2, None), (0, 3, None), (2, 3, None)]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_loops</span><span class="p">(</span><span class="kc">True</span><span class="p">);</span> <span class="n">G</span><span class="o">.</span><span class="n">allow_multiple_edges</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">contract_edge</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 2, None), (0, 2, None), (0, 3, None), (0, 3, None), (2, 3, None)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">contract_edge</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 0, None), (0, 3, None), (0, 3, None), (0, 3, None)]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_loops</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">contract_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 0, None),</span>
<span class="go"> (0, 2, None),</span>
<span class="go"> (0, 3, None),</span>
<span class="go"> (2, 0, None),</span>
<span class="go"> (2, 3, None),</span>
<span class="go"> (3, 0, None),</span>
<span class="go"> (3, 2, None)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.contract_edges">
<span class="sig-name descname"><span class="pre">contract_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edges</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.contract_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract edges from an iterable container.</p>
<p>If <span class="math notranslate nohighlight">\(e\)</span> is an edge that is not contracted but the vertices of <span class="math notranslate nohighlight">\(e\)</span> are
merged by contraction of other edges, then <span class="math notranslate nohighlight">\(e\)</span> will become a loop.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">edges</span></code> – a list containing 2-tuples or 3-tuples that represent
edges</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_loops</span><span class="p">(</span><span class="kc">True</span><span class="p">);</span> <span class="n">G</span><span class="o">.</span><span class="n">allow_multiple_edges</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">contract_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]);</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 3, None), (0, 3, None), (0, 3, None)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">contract_edges</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]);</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 3, None), (0, 3, None), (0, 3, None)]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_loops</span><span class="p">(</span><span class="kc">True</span><span class="p">);</span> <span class="n">G</span><span class="o">.</span><span class="n">allow_multiple_edges</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">contract_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]);</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 0, None)]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Complete</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">allow_loops</span><span class="p">(</span><span class="kc">True</span><span class="p">);</span> <span class="n">D</span><span class="o">.</span><span class="n">allow_multiple_edges</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">contract_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]);</span> <span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 0, None),</span>
<span class="go"> (0, 0, None),</span>
<span class="go"> (0, 0, None),</span>
<span class="go"> (0, 3, None),</span>
<span class="go"> (0, 3, None),</span>
<span class="go"> (0, 3, None),</span>
<span class="go"> (3, 0, None),</span>
<span class="go"> (3, 0, None),</span>
<span class="go"> (3, 0, None)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_structure</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">immutable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the graph implementation</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">weighted</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); weightedness for the
copy. Might change the equality class if not <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sparse</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); <code class="docutils literal notranslate"><span class="pre">sparse=True</span></code> is an alias
for <code class="docutils literal notranslate"><span class="pre">data_structure=&quot;sparse&quot;</span></code>, and <code class="docutils literal notranslate"><span class="pre">sparse=False</span></code> is an alias for
<code class="docutils literal notranslate"><span class="pre">data_structure=&quot;dense&quot;</span></code>. Only used when <code class="docutils literal notranslate"><span class="pre">data_structure=None</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">data_structure</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); one of <code class="docutils literal notranslate"><span class="pre">&quot;sparse&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;static_sparse&quot;</span></code>, or <code class="docutils literal notranslate"><span class="pre">&quot;dense&quot;</span></code>. See the documentation of
<a class="reference internal" href="graph.html#sage.graphs.graph.Graph" title="sage.graphs.graph.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a> or <a class="reference internal" href="digraph.html#sage.graphs.digraph.DiGraph" title="sage.graphs.digraph.DiGraph"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraph</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">immutable</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); whether to create a
mutable/immutable copy. Only used when <code class="docutils literal notranslate"><span class="pre">data_structure=None</span></code>.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">immutable=None</span></code> (default) means that the graph and its copy will
behave the same way.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">immutable=True</span></code> is a shortcut for
<code class="docutils literal notranslate"><span class="pre">data_structure='static_sparse'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">immutable=False</span></code> means that the created graph is mutable. When
used to copy an immutable graph, the data structure used is
<code class="docutils literal notranslate"><span class="pre">&quot;sparse&quot;</span></code> unless anything else is specified.</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the graph uses
<a class="reference internal" href="base/static_sparse_backend.html#sage.graphs.base.static_sparse_backend.StaticSparseBackend" title="sage.graphs.base.static_sparse_backend.StaticSparseBackend"><code class="xref py py-class docutils literal notranslate"><span class="pre">StaticSparseBackend</span></code></a>
and the <code class="docutils literal notranslate"><span class="pre">_immutable</span></code> flag, then <code class="docutils literal notranslate"><span class="pre">self</span></code> is returned rather than a
copy (unless one of the optional arguments is used).</p>
</div>
<p>OUTPUT:</p>
<p>A Graph object.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Please use this method only if you need to copy but change the
underlying data structure or weightedness. Otherwise simply do
<code class="docutils literal notranslate"><span class="pre">copy(g)</span></code> instead of <code class="docutils literal notranslate"><span class="pre">g.copy()</span></code>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If <code class="docutils literal notranslate"><span class="pre">weighted</span></code> is passed and is not the weightedness of the
original, then the copy will not equal the original.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]},</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">==</span> <span class="n">copy</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]},</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">==</span> <span class="n">copy</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note that vertex associations are also kept:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">(),</span> <span class="mi">1</span><span class="p">:</span> <span class="n">graphs</span><span class="o">.</span><span class="n">FlowerSnark</span><span class="p">(),</span> <span class="mi">2</span><span class="p">:</span> <span class="n">graphs</span><span class="o">.</span><span class="n">MoebiusKantorGraph</span><span class="p">(),</span> <span class="mi">3</span><span class="p">:</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()}</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">TetrahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">set_vertices</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T2</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T2</span><span class="o">.</span><span class="n">get_vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Dodecahedron: Graph on 20 vertices</span>
</pre></div>
</div>
<p>Notice that the copy is at least as deep as the objects:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T2</span><span class="o">.</span><span class="n">get_vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="ow">is</span> <span class="n">T</span><span class="o">.</span><span class="n">get_vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Examples of the keywords in use:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">==</span> <span class="n">G</span><span class="p">;</span> <span class="n">H</span> <span class="ow">is</span> <span class="n">G</span>
<span class="go">True</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G1</span> <span class="o">==</span> <span class="n">G</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G1</span> <span class="ow">is</span> <span class="n">G</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G2</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G2</span> <span class="ow">is</span> <span class="n">G</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Argument <code class="docutils literal notranslate"><span class="pre">weighted</span></code> affects the equality class:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">weighted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">weighted</span><span class="p">(),</span> <span class="n">H1</span><span class="o">.</span><span class="n">weighted</span><span class="p">(),</span> <span class="n">H2</span><span class="o">.</span><span class="n">weighted</span><span class="p">()]</span>
<span class="go">[False, False, True]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">G</span> <span class="o">==</span> <span class="n">H1</span><span class="p">,</span> <span class="n">G</span> <span class="o">==</span> <span class="n">H2</span><span class="p">,</span> <span class="n">H1</span> <span class="o">==</span> <span class="n">H2</span><span class="p">]</span>
<span class="go">[True, False, False]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">weighted</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">G</span> <span class="o">==</span> <span class="n">H1</span><span class="p">,</span> <span class="n">G</span> <span class="o">==</span> <span class="n">H2</span><span class="p">,</span> <span class="n">H1</span> <span class="o">==</span> <span class="n">H2</span><span class="p">]</span>
<span class="go">[False, True, False]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.crossing_number">
<span class="sig-name descname"><span class="pre">crossing_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.crossing_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the crossing number of the graph.</p>
<p>The crossing number of a graph is the minimum number of edge crossings
needed to draw the graph on a plane. It can be seen as a measure of
non-planarity; a planar graph has crossing number zero.</p>
<p>See the <a class="reference external" href="https://en.wikipedia.org/wiki/Crossing_number">Wikipedia article Crossing_number</a> for more information.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">crossing_number</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
<p>ALGORITHM:</p>
<p>This is slow brute force implementation: for every <span class="math notranslate nohighlight">\(k\)</span> pairs of edges
try adding a new vertex for a crossing point for them. If the result is
not planar in any of those, try <span class="math notranslate nohighlight">\(k+1\)</span> pairs.</p>
<p>Computing the crossing number is NP-hard problem.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.cycle_basis">
<span class="sig-name descname"><span class="pre">cycle_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'vertex'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.cycle_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of cycles which form a basis of the cycle space of
<code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>A basis of cycles of a graph is a minimal collection of cycles
(considered as sets of edges) such that the edge set of any cycle in the
graph can be written as a <span class="math notranslate nohighlight">\(Z/2Z\)</span> sum of the cycles in the basis.</p>
<p>See the <a class="reference external" href="https://en.wikipedia.org/wiki/Cycle_basis">Wikipedia article Cycle_basis</a> for more information.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">output</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">'vertex'</span></code>); whether every cycle is
given as a list of vertices (<code class="docutils literal notranslate"><span class="pre">output</span> <span class="pre">==</span> <span class="pre">'vertex'</span></code>) or a list of
edges (<code class="docutils literal notranslate"><span class="pre">output</span> <span class="pre">==</span> <span class="pre">'edge'</span></code>)</p></li>
</ul>
<p>OUTPUT:</p>
<p>A list of lists, each of them representing the vertices (or the edges)
of a cycle in a basis.</p>
<p>ALGORITHM:</p>
<p>Uses the NetworkX library for graphs without multiple edges.</p>
<p>Otherwise, by the standard algorithm using a spanning tree.</p>
<p>EXAMPLES:</p>
<p>A cycle basis in Petersen’s Graph</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">cycle_basis</span><span class="p">()</span>
<span class="go">[[1, 6, 8, 5, 0], [4, 9, 6, 8, 5, 0], [7, 9, 6, 8, 5], [4, 3, 8, 5, 0], [1, 2, 3, 8, 5, 0], [7, 2, 3, 8, 5]]</span>
</pre></div>
</div>
<p>One can also get the result as a list of lists of edges:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">cycle_basis</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)</span>
<span class="go">[[(1, 6, None), (6, 8, None), (8, 5, None), (5, 0, None),</span>
<span class="go">(0, 1, None)], [(4, 9, None), (9, 6, None), (6, 8, None),</span>
<span class="go">(8, 5, None), (5, 0, None), (0, 4, None)], [(7, 9, None),</span>
<span class="go">(9, 6, None), (6, 8, None), (8, 5, None), (5, 7, None)],</span>
<span class="go">[(4, 3, None), (3, 8, None), (8, 5, None), (5, 0, None),</span>
<span class="go">(0, 4, None)], [(1, 2, None), (2, 3, None), (3, 8, None),</span>
<span class="go">(8, 5, None), (5, 0, None), (0, 1, None)], [(7, 2, None),</span>
<span class="go">(2, 3, None), (3, 8, None), (8, 5, None), (5, 7, None)]]</span>
</pre></div>
</div>
<p>Checking the given cycles are algebraically free:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mf">.4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">basis</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">cycle_basis</span><span class="p">()</span>
</pre></div>
</div>
<p>Building the space of (directed) edges over <span class="math notranslate nohighlight">\(Z/2Z\)</span>. On the way, building
a dictionary associating a unique vector to each undirected edge:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">edge_space</span> <span class="o">=</span> <span class="n">VectorSpace</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">edge_vector</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">edge_space</span><span class="o">.</span><span class="n">basis</span><span class="p">()))</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">vec</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">edge_vector</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
<span class="gp">....: </span>   <span class="n">edge_vector</span><span class="p">[(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">)]</span> <span class="o">=</span> <span class="n">vec</span>
</pre></div>
</div>
<p>Defining a lambda function associating a vector to the vertices of a
cycle:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">vertices_to_edges</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">cycle_to_vector</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="n">edge_vector</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">vertices_to_edges</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>Finally checking the cycles are a free set:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">basis_as_vectors</span> <span class="o">=</span> <span class="p">[</span><span class="n">cycle_to_vector</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">edge_space</span><span class="o">.</span><span class="n">span</span><span class="p">(</span><span class="n">basis_as_vectors</span><span class="p">)</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>For undirected graphs with multiple edges:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)],</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cycle_basis</span><span class="p">()</span>
<span class="go">[[0, 2], [2, 1, 0]]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cycle_basis</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)</span>
<span class="go">[[(0, 2, &#39;a&#39;), (2, 0, &#39;b&#39;)], [(2, 1, &#39;d&#39;), (1, 0, &#39;c&#39;), (0, 2, &#39;a&#39;)]]</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">)],</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">cycle_basis</span><span class="p">()</span>
<span class="go">[[1, 4], [2, 3], [4, 3, 2, 1], [6, 5, 4]]</span>
</pre></div>
</div>
<p>Disconnected graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_cycle</span><span class="p">([</span><span class="s2">&quot;Hey&quot;</span><span class="p">,</span> <span class="s2">&quot;Wuuhuu&quot;</span><span class="p">,</span> <span class="s2">&quot;Really ?&quot;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">cycle_basis</span><span class="p">()]</span>
<span class="go">[[&#39;Hey&#39;, &#39;Really ?&#39;, &#39;Wuuhuu&#39;], [0, 2], [0, 1, 2]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">cycle_basis</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)]</span>
<span class="go">[[(&#39;Hey&#39;, &#39;Wuuhuu&#39;, None),</span>
<span class="go">  (&#39;Really ?&#39;, &#39;Hey&#39;, None),</span>
<span class="go">  (&#39;Wuuhuu&#39;, &#39;Really ?&#39;, None)],</span>
<span class="go"> [(0, 2, &#39;a&#39;), (2, 0, &#39;b&#39;)],</span>
<span class="go"> [(0, 2, &#39;b&#39;), (1, 0, &#39;c&#39;), (2, 1, &#39;d&#39;)]]</span>
</pre></div>
</div>
<p>Graph that allows multiple edges but does not contain any:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_multiple_edges</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cycle_basis</span><span class="p">()</span>
<span class="go">[[2, 1, 0]]</span>
</pre></div>
</div>
<p>Not yet implemented for directed graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cycle_basis</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">NotImplementedError: not implemented for directed graphs</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.degree">
<span class="sig-name descname"><span class="pre">degree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the degree (in + out for digraphs) of a vertex or of vertices.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – a vertex or an iterable container of vertices
(default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); if <code class="docutils literal notranslate"><span class="pre">vertices</span></code> is a single vertex, returns the
number of neighbors of that vertex. If <code class="docutils literal notranslate"><span class="pre">vertices</span></code> is an iterable
container of vertices, returns a list of degrees. If <code class="docutils literal notranslate"><span class="pre">vertices</span></code> is
<code class="docutils literal notranslate"><span class="pre">None</span></code>, same as listing all vertices.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); when <code class="docutils literal notranslate"><span class="pre">True</span></code>, return a
dictionary mapping each vertex in <code class="docutils literal notranslate"><span class="pre">vertices</span></code> to its
degree. Otherwise, return the degree of a single vertex or a list of
the degrees of each vertex in <code class="docutils literal notranslate"><span class="pre">vertices</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>When <code class="docutils literal notranslate"><span class="pre">vertices</span></code> is a single vertex and <code class="docutils literal notranslate"><span class="pre">labels</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>,
returns the degree of that vertex as an integer</p></li>
<li><p>When <code class="docutils literal notranslate"><span class="pre">vertices</span></code> is an iterable container of vertices (or <code class="docutils literal notranslate"><span class="pre">None</span></code>)
and <code class="docutils literal notranslate"><span class="pre">labels</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, returns a list of integers. The <span class="math notranslate nohighlight">\(i\)</span>-th
value is the degree of the <span class="math notranslate nohighlight">\(i\)</span>-th vertex in the list
<code class="docutils literal notranslate"><span class="pre">vertices</span></code>. When <code class="docutils literal notranslate"><span class="pre">vertices</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, the <span class="math notranslate nohighlight">\(i\)</span>-th value is the
degree of <span class="math notranslate nohighlight">\(i\)</span>-th vertex in the ordering <code class="docutils literal notranslate"><span class="pre">list(self)</span></code>, which might be
different from the ordering of the vertices given by <code class="docutils literal notranslate"><span class="pre">g.vertices()</span></code>.</p></li>
<li><p>When <code class="docutils literal notranslate"><span class="pre">labels</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, returns a dictionary mapping each vertex
in <code class="docutils literal notranslate"><span class="pre">vertices</span></code> to its degree</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">[8, 8, 8, 8, 8, 8, 8, 8, 8]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{0: 5, 1: 4, 2: 3}</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">[5, 4, 3, 3, 3, 2]</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">vertices=None</span></code> and <code class="docutils literal notranslate"><span class="pre">labels=False</span></code>, the <span class="math notranslate nohighlight">\(i\)</span>-th value of the
returned list is the degree of the <span class="math notranslate nohighlight">\(i\)</span>-th vertex in the list
<code class="docutils literal notranslate"><span class="pre">list(self)</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">DeBruijn</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">delete_vertex</span><span class="p">(</span><span class="s1">&#39;20&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">degree</span><span class="p">())</span>
<span class="go">[7, 7, 6, 7, 8, 8, 7, 8, 8, 7, 8, 8, 8, 7, 8]</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="p">)))</span>
<span class="go">[7, 7, 6, 7, 8, 8, 7, 8, 8, 7, 8, 8, 8, 7, 8]</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">D</span><span class="o">.</span><span class="n">vertices</span><span class="p">()))</span>
<span class="go">[7, 7, 6, 7, 8, 8, 7, 8, 8, 7, 8, 8, 8, 7, 8]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.degree_histogram">
<span class="sig-name descname"><span class="pre">degree_histogram</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.degree_histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list, whose <span class="math notranslate nohighlight">\(i\)</span>-th entry is the frequency of degree <span class="math notranslate nohighlight">\(i\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">degree_histogram</span><span class="p">()</span>
<span class="go">[0, 0, 4, 34, 70]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">degree_histogram</span><span class="p">()</span>
<span class="go">[0, 0, 0, 0, 4, 0, 34, 0, 70]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.degree_iterator">
<span class="sig-name descname"><span class="pre">degree_iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.degree_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over the degrees of the (di)graph.</p>
<p>In the case of a digraph, the degree is defined as the sum of the
in-degree and the out-degree, i.e. the total number of edges incident to
a given vertex.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – a vertex or an iterable container of vertices
(default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); if <code class="docutils literal notranslate"><span class="pre">vertices</span></code> is a single vertex, the iterator
will yield the number of neighbors of that vertex. If <code class="docutils literal notranslate"><span class="pre">vertices</span></code> is
an iterable container of vertices, return an iterator over the degrees
of these vertices. If <code class="docutils literal notranslate"><span class="pre">vertices</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, same as listing all
vertices.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return an
iterator over degrees (<code class="docutils literal notranslate"><span class="pre">labels=False</span></code>), or over tuples <code class="docutils literal notranslate"><span class="pre">(vertex,</span>
<span class="pre">degree)</span></code></p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The returned iterator yields values in order specified by
<code class="docutils literal notranslate"><span class="pre">list(vertices)</span></code>. When <code class="docutils literal notranslate"><span class="pre">vertices</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, it yields values
in the same order as <code class="docutils literal notranslate"><span class="pre">list(self)</span></code>, which might be different from
the ordering of the vertices given by <code class="docutils literal notranslate"><span class="pre">g.vertices()</span></code>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">degree_iterator</span><span class="p">():</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">3</span>
<span class="go">...</span>
<span class="go">3</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">degree_iterator</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">((0, 0), 2)</span>
<span class="go">((0, 1), 3)</span>
<span class="go">((0, 2), 3)</span>
<span class="go">...</span>
<span class="go">((2, 2), 3)</span>
<span class="go">((2, 3), 2)</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">D</span><span class="o">.</span><span class="n">degree_iterator</span><span class="p">():</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">4</span>
<span class="go">6</span>
<span class="go">...</span>
<span class="go">6</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">D</span><span class="o">.</span><span class="n">degree_iterator</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">((0, 0), 4)</span>
<span class="go">((0, 1), 6)</span>
<span class="go">...</span>
<span class="go">((1, 2), 6)</span>
<span class="go">((1, 3), 4)</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">vertices=None</span></code> yields values in the order of <code class="docutils literal notranslate"><span class="pre">list(D)</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">DeBruijn</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">delete_vertex</span><span class="p">(</span><span class="s1">&#39;20&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">degree_iterator</span><span class="p">()))</span>
<span class="go">[7, 7, 6, 7, 8, 8, 7, 8, 8, 7, 8, 8, 8, 7, 8]</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">([</span><span class="n">D</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">D</span><span class="p">])</span>
<span class="go">[7, 7, 6, 7, 8, 8, 7, 8, 8, 7, 8, 8, 8, 7, 8]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.degree_sequence">
<span class="sig-name descname"><span class="pre">degree_sequence</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.degree_sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the degree sequence of this (di)graph.</p>
<p>EXAMPLES:</p>
<p>The degree sequence of an undirected graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">degree_sequence</span><span class="p">()</span>
<span class="go">[4, 3, 3, 2, 2]</span>
</pre></div>
</div>
<p>The degree sequence of a digraph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">degree_sequence</span><span class="p">()</span>
<span class="go">[5, 3, 3, 3, 3, 3]</span>
</pre></div>
</div>
<p>Degree sequences of some common graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">degree_sequence</span><span class="p">()</span>
<span class="go">[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">HouseGraph</span><span class="p">()</span><span class="o">.</span><span class="n">degree_sequence</span><span class="p">()</span>
<span class="go">[3, 3, 2, 2, 2]</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">FlowerSnark</span><span class="p">()</span><span class="o">.</span><span class="n">degree_sequence</span><span class="p">()</span>
<span class="go">[3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.degree_to_cell">
<span class="sig-name descname"><span class="pre">degree_to_cell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.degree_to_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of edges from vertex to an edge in cell. In the
case of a digraph, returns a tuple (in_degree, out_degree).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">cell</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">()[:</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">degree_to_cell</span><span class="p">(</span><span class="s1">&#39;011&#39;</span><span class="p">,</span> <span class="n">cell</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">degree_to_cell</span><span class="p">(</span><span class="s1">&#39;111&#39;</span><span class="p">,</span> <span class="n">cell</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span> <span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">cell</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">degree_to_cell</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">cell</span><span class="p">)</span>
<span class="go">(0, 0)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">degree_to_cell</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">cell</span><span class="p">)</span>
<span class="go">(2, 0)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">degree_to_cell</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cell</span><span class="p">)</span>
<span class="go">(0, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.delete_edge">
<span class="sig-name descname"><span class="pre">delete_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.delete_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the edge from <code class="docutils literal notranslate"><span class="pre">u</span></code> to <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<p>This method returns silently if vertices or edge does not
exist.</p>
<p>INPUT: The following forms are all accepted:</p>
<ul class="simple">
<li><p>G.delete_edge( 1, 2 )</p></li>
<li><p>G.delete_edge( (1, 2) )</p></li>
<li><p>G.delete_edges( [ (1, 2) ] )</p></li>
<li><p>G.delete_edge( 1, 2, ‘label’ )</p></li>
<li><p>G.delete_edge( (1, 2, ‘label’) )</p></li>
<li><p>G.delete_edges( [ (1, 2, ‘label’) ] )</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">36</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">delete_edge</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">delete_edge</span><span class="p">(</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">delete_edges</span><span class="p">(</span> <span class="p">[</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="p">]</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">32</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">delete_edge</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">delete_edge</span><span class="p">(</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">delete_edges</span><span class="p">(</span> <span class="p">[</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">)</span> <span class="p">]</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">32</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="p">)</span> <span class="c1"># correct!</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">)</span> <span class="p">)</span> <span class="c1"># correct!</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Complete</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">72</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">delete_edge</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">delete_edge</span><span class="p">(</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">delete_edges</span><span class="p">(</span> <span class="p">[</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="p">]</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">68</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">delete_edge</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">delete_edge</span><span class="p">(</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">delete_edges</span><span class="p">(</span> <span class="p">[</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">)</span> <span class="p">]</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="c1"># correct!</span>
<span class="go">68</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="p">)</span> <span class="c1"># correct!</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">)</span> <span class="p">)</span> <span class="c1"># correct!</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.delete_edges">
<span class="sig-name descname"><span class="pre">delete_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edges</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.delete_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete edges from an iterable container.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K12</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K4</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K12</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">66</span>
<span class="gp">sage: </span><span class="n">K12</span><span class="o">.</span><span class="n">delete_edges</span><span class="p">(</span><span class="n">K4</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">K12</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">60</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K12</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Complete</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K4</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Complete</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K12</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">132</span>
<span class="gp">sage: </span><span class="n">K12</span><span class="o">.</span><span class="n">delete_edges</span><span class="p">(</span><span class="n">K4</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">K12</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">120</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.delete_multiedge">
<span class="sig-name descname"><span class="pre">delete_multiedge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.delete_multiedge" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete all edges from <code class="docutils literal notranslate"><span class="pre">u</span></code> to <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None), (0, 1, None), (0, 1, None), (1, 2, None), (2, 3, None)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">delete_multiedge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(1, 2, None), (2, 3, None)]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="kc">None</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, 1), (0, 1, 2), (0, 1, 3), (1, 0, None), (1, 2, None), (2, 3, None)]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">delete_multiedge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(1, 0, None), (1, 2, None), (2, 3, None)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.delete_vertex">
<span class="sig-name descname"><span class="pre">delete_vertex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.delete_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete vertex, removing all incident edges.</p>
<p>Deleting a non-existent vertex will raise an exception.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">in_order</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, this
deletes the <span class="math notranslate nohighlight">\(i\)</span>-th vertex in the sorted list of vertices, i.e.
<code class="docutils literal notranslate"><span class="pre">G.vertices()[i]</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">WheelGraph</span><span class="p">(</span><span class="mi">9</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">delete_vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">delete_vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">D</span>
<span class="go">Digraph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 5]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">delete_vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: vertex (0) not in the graph</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">line_graph</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">delete_vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">in_order</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[(0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">set_vertices</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;no delete&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;delete&#39;</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">delete_vertex</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">get_vertices</span><span class="p">()</span>
<span class="go">{0: &#39;no delete&#39;, 2: None, 3: None, 4: None}</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">get_pos</span><span class="p">()</span>
<span class="go">{0: (0, 0), 2: (2, 0), 3: (3, 0), 4: (4, 0)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.delete_vertices">
<span class="sig-name descname"><span class="pre">delete_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.delete_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete vertices from the (di)graph taken from an iterable container of
vertices.</p>
<p>Deleting a non-existent vertex will raise an exception, in which case
none of the vertices in <code class="docutils literal notranslate"><span class="pre">vertices</span></code> is deleted.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">delete_vertices</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]);</span> <span class="n">D</span>
<span class="go">Digraph on 1 vertex</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">delete_vertices</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: vertex (1) not in the graph</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.density">
<span class="sig-name descname"><span class="pre">density</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.density" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the density of the (di)graph.</p>
<p>The density of a (di)graph is defined as the number of edges divided by
number of possible edges.</p>
<p>In the case of a multigraph, raises an error, since there is an infinite
number of possible edges.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">9</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span> <span class="mi">7</span><span class="p">:</span> <span class="p">[</span><span class="mi">9</span><span class="p">]}</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">d</span><span class="p">);</span> <span class="n">G</span><span class="o">.</span><span class="n">density</span><span class="p">()</span>
<span class="go">1/3</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]});</span> <span class="n">G</span><span class="o">.</span><span class="n">density</span><span class="p">()</span>
<span class="go">2/3</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]});</span> <span class="n">G</span><span class="o">.</span><span class="n">density</span><span class="p">()</span>
<span class="go">1/2</span>
</pre></div>
</div>
<p>Note that there are more possible edges on a looped graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_loops</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">density</span><span class="p">()</span>
<span class="go">1/3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.depth_first_search">
<span class="sig-name descname"><span class="pre">depth_first_search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.depth_first_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over the vertices in a depth-first ordering.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">start</span></code> – vertex or list of vertices from which to start the
traversal</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ignore_direction</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); only applies to
directed graphs. If <code class="docutils literal notranslate"><span class="pre">True</span></code>, searches across edges in either
direction.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">neighbors</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that inputs
a vertex and return a list of vertices. For an undirected graph,
<code class="docutils literal notranslate"><span class="pre">neighbors</span></code> is by default the <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.neighbors" title="sage.graphs.generic_graph.GenericGraph.neighbors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">neighbors()</span></code></a> function. For a
digraph, the <code class="docutils literal notranslate"><span class="pre">neighbors</span></code> function defaults to the
<a class="reference internal" href="digraph.html#sage.graphs.digraph.DiGraph.neighbor_out_iterator" title="sage.graphs.digraph.DiGraph.neighbor_out_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">neighbor_out_iterator()</span></code></a> function of the graph.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edges</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the edges
of the DFS tree in the order of visit or the vertices (default).
Edges are directed in root to leaf orientation of the tree.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.breadth_first_search" title="sage.graphs.generic_graph.GenericGraph.breadth_first_search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">breadth_first_search()</span></code></a></p></li>
<li><p><a class="reference internal" href="base/c_graph.html#sage.graphs.base.c_graph.CGraphBackend.breadth_first_search" title="sage.graphs.base.c_graph.CGraphBackend.breadth_first_search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">breadth_first_search</span></code></a>
– breadth-first search for fast compiled graphs.</p></li>
<li><p><a class="reference internal" href="base/c_graph.html#sage.graphs.base.c_graph.CGraphBackend.depth_first_search" title="sage.graphs.base.c_graph.CGraphBackend.depth_first_search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">depth_first_search</span></code></a>
– depth-first search for fast compiled graphs.</p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">depth_first_search</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[0, 4, 3, 2, 1]</span>
</pre></div>
</div>
<p>By default, the edge direction of a digraph is respected, but this can
be overridden by the <code class="docutils literal notranslate"><span class="pre">ignore_direction</span></code> parameter:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">7</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">depth_first_search</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[0, 3, 6, 7, 2, 5, 1, 4]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">depth_first_search</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ignore_direction</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[0, 7, 6, 3, 5, 2, 1, 4]</span>
</pre></div>
</div>
<p>Multiple starting vertices can be specified in a list:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">7</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">depth_first_search</span><span class="p">([</span><span class="mi">0</span><span class="p">]))</span>
<span class="go">[0, 3, 6, 7, 2, 5, 1, 4]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">depth_first_search</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">]))</span>
<span class="go">[0, 3, 6, 7, 2, 5, 1, 4]</span>
</pre></div>
</div>
<p>More generally, you can specify a <code class="docutils literal notranslate"><span class="pre">neighbors</span></code> function.  For example,
you can traverse the graph backwards by setting <code class="docutils literal notranslate"><span class="pre">neighbors</span></code> to be the
<a class="reference internal" href="digraph.html#sage.graphs.digraph.DiGraph.neighbors_in" title="sage.graphs.digraph.DiGraph.neighbors_in"><code class="xref py py-meth docutils literal notranslate"><span class="pre">neighbors_in()</span></code></a> function of the graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">add_path</span><span class="p">([</span><span class="mi">22</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">add_path</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">35</span><span class="p">])</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">depth_first_search</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">neighbors</span><span class="o">=</span><span class="n">D</span><span class="o">.</span><span class="n">neighbors_in</span><span class="p">))</span>
<span class="go">[5, 4, 3, 2, 1, 0, 24, 23, 22]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">breadth_first_search</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">neighbors</span><span class="o">=</span><span class="n">D</span><span class="o">.</span><span class="n">neighbors_in</span><span class="p">))</span>
<span class="go">[5, 24, 4, 23, 3, 22, 2, 1, 0]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">depth_first_search</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">neighbors</span><span class="o">=</span><span class="n">D</span><span class="o">.</span><span class="n">neighbors_out</span><span class="p">))</span>
<span class="go">[5, 6, 7, 8, 9, 33, 34, 35]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">breadth_first_search</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">neighbors</span><span class="o">=</span><span class="n">D</span><span class="o">.</span><span class="n">neighbors_out</span><span class="p">))</span>
<span class="go">[5, 33, 6, 34, 7, 35, 8, 9]</span>
</pre></div>
</div>
<p>You can get edges of the DFS tree instead of the vertices using the
<code class="docutils literal notranslate"><span class="pre">edges</span></code> parameter:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">depth_first_search</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(2, 3), (3, 4)]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">depth_first_search</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ignore_direction</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(2, 3), (3, 4), (2, 1), (1, 0)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.disjoint_routed_paths">
<span class="sig-name descname"><span class="pre">disjoint_routed_paths</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pairs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.disjoint_routed_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a set of disjoint routed paths.</p>
<p>Given a set of pairs <span class="math notranslate nohighlight">\((s_i,t_i)\)</span>, a set of disjoint routed paths is a
set of <span class="math notranslate nohighlight">\(s_i-t_i\)</span> paths which can intersect at their endpoints and are
vertex-disjoint otherwise.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pairs</span></code> – list of pairs of vertices</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>Given a grid, finding two vertex-disjoint paths, the first one from the
top-left corner to the bottom-left corner, and the second from the
top-right corner to the bottom-right corner is easy:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">disjoint_routed_paths</span><span class="p">([((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)),</span> <span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">))])</span>
</pre></div>
</div>
<p>Though there is obviously no solution to the problem in which each
corner is sending information to the opposite one:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">disjoint_routed_paths</span><span class="p">([((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)),</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">))])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">EmptySetError: the disjoint routed paths do not exist</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.disjoint_union">
<span class="sig-name descname"><span class="pre">disjoint_union</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pairs'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">immutable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.disjoint_union" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the disjoint union of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">labels</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">'pairs'</span></code>); if set to <code class="docutils literal notranslate"><span class="pre">'pairs'</span></code>,
each element <code class="docutils literal notranslate"><span class="pre">v</span></code> in the first graph will be named <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">v)</span></code> and
each element <code class="docutils literal notranslate"><span class="pre">u</span></code> in <code class="docutils literal notranslate"><span class="pre">other</span></code> will be named <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">u)</span></code> in the
result. If set to <code class="docutils literal notranslate"><span class="pre">'integers'</span></code>, the elements of the result will be
relabeled with consecutive integers.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">immutable</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); whether to create a
mutable/immutable disjoint union. <code class="docutils literal notranslate"><span class="pre">immutable=None</span></code> (default) means
that the graphs and their disjoint union will behave the same way.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.union" title="sage.graphs.generic_graph.GenericGraph.union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">union()</span></code></a></p></li>
<li><p><a class="reference internal" href="graph.html#sage.graphs.graph.Graph.join" title="sage.graphs.graph.Graph.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">H</span><span class="p">);</span> <span class="n">J</span>
<span class="go">Cycle graph disjoint_union Cycle graph: Graph on 7 vertices</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (1, 3)]</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="s1">&#39;integers&#39;</span><span class="p">);</span> <span class="n">J</span>
<span class="go">Cycle graph disjoint_union Cycle graph: Graph on 7 vertices</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">G</span> <span class="o">+</span> <span class="n">H</span><span class="p">)</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>  <span class="c1"># &#39;+&#39;-operator is a shortcut</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">name</span><span class="p">(</span><span class="s2">&quot;Custom path&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
<span class="go">&#39;Custom path&#39;</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">H</span><span class="p">);</span> <span class="n">J</span>
<span class="go">Custom path disjoint_union Cycle graph: Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[(0, &#39;a&#39;), (0, &#39;b&#39;), (1, 0), (1, 1), (1, 2)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.disjunctive_product">
<span class="sig-name descname"><span class="pre">disjunctive_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.disjunctive_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the disjunctive product of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>The disjunctive product of <span class="math notranslate nohighlight">\(G\)</span> and <span class="math notranslate nohighlight">\(H\)</span> is the graph <span class="math notranslate nohighlight">\(L\)</span> with vertex set
<span class="math notranslate nohighlight">\(V(L)=V(G)\times V(H)\)</span>, and <span class="math notranslate nohighlight">\(((u,v), (w,x))\)</span> is an edge iff either :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\((u, w)\)</span> is an edge of <span class="math notranslate nohighlight">\(G\)</span>, or</p></li>
<li><p><span class="math notranslate nohighlight">\((v, x)\)</span> is an edge of <span class="math notranslate nohighlight">\(H\)</span>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">disjunctive_product</span><span class="p">(</span><span class="n">Z</span><span class="p">);</span> <span class="n">D</span>
<span class="go">Graph on 4 vertices</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span> <span class="c1"># long time</span>
<span class="go">Graphics object consisting of 11 graphics primitives</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">disjunctive_product</span><span class="p">(</span><span class="n">Z</span><span class="p">);</span> <span class="n">D</span>
<span class="go">Graph on 10 vertices</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span> <span class="c1"># long time</span>
<span class="go">Graphics object consisting of 46 graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.distance">
<span class="sig-name descname"><span class="pre">distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">by_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the (directed) distance from <code class="docutils literal notranslate"><span class="pre">u</span></code> to <code class="docutils literal notranslate"><span class="pre">v</span></code> in the (di)graph.</p>
<p>The distance is the length of the shortest path from <code class="docutils literal notranslate"><span class="pre">u</span></code> to <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<p>This method simply calls <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.shortest_path_length" title="sage.graphs.generic_graph.GenericGraph.shortest_path_length"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shortest_path_length()</span></code></a>,
with default arguments. For more information, and for more option, we
refer to that method.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">by_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">False</span></code>, the graph
is considered unweighted, and the distance is the number of edges in a
shortest path. If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the distance is the sum of edge labels
(which are assumed to be numbers).</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[],</span> <span class="mi">1</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">+Infinity</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span> <span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">3</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="mi">4</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="mi">4</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">2</span><span class="p">}},</span> <span class="n">sparse</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span> <span class="c1"># long time</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.distance_all_pairs">
<span class="sig-name descname"><span class="pre">distance_all_pairs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">by_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.distance_all_pairs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the distances between all pairs of vertices.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">by_weight</span></code> boolean (default: <span class="math notranslate nohighlight">\(False\)</span>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, the edges in
the graph are weighted; if <code class="docutils literal notranslate"><span class="pre">False</span></code>, all edges have weight 1.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); one of the following
algorithms:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'BFS'</span></code>: the computation is done through a BFS centered on each
vertex successively. Works only if <code class="docutils literal notranslate"><span class="pre">by_weight==False</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Floyd-Warshall-Cython'</span></code>: the Cython implementation of
the Floyd-Warshall algorithm. Works only if <code class="docutils literal notranslate"><span class="pre">by_weight==False</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Floyd-Warshall-Python'</span></code>: the Python implementation of
the Floyd-Warshall algorithm. Works also with weighted graphs, even
with negative weights (but no negative cycle is allowed).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Dijkstra_NetworkX'</span></code>: the Dijkstra algorithm, implemented in
NetworkX. It works with weighted graphs, but no negative weight is
allowed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Dijkstra_Boost'</span></code>: the Dijkstra algorithm, implemented in Boost
(works only with positive weights).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Johnson_Boost'</span></code>: the Johnson algorithm, implemented in
Boost (works also with negative weights, if there is no negative
cycle).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> (default): Sage chooses the best algorithm: <code class="docutils literal notranslate"><span class="pre">'BFS'</span></code> if
<code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, <code class="docutils literal notranslate"><span class="pre">'Dijkstra_Boost'</span></code> if all weights are
positive, <code class="docutils literal notranslate"><span class="pre">'Floyd-Warshall-Cython'</span></code> otherwise.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
takes as input an edge <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></code> and outputs its weight. If not
<code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is automatically set to <code class="docutils literal notranslate"><span class="pre">True</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>
and <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, we use the edge label <code class="docutils literal notranslate"><span class="pre">l</span></code>, if <code class="docutils literal notranslate"><span class="pre">l</span></code>
is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, else <code class="docutils literal notranslate"><span class="pre">1</span></code> as a weight.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether to check that
the <code class="docutils literal notranslate"><span class="pre">weight_function</span></code> outputs a number for each edge.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A doubly indexed dictionary</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is a Cython version of this method that is usually much faster
for large graphs, as most of the time is actually spent building the
final double dictionary. Everything on the subject is to be found in
the <a class="reference internal" href="distances_all_pairs.html#module-sage.graphs.distances_all_pairs" title="sage.graphs.distances_all_pairs"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distances_all_pairs</span></code></a> module.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This algorithm simply calls
<a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.shortest_path_all_pairs" title="sage.graphs.generic_graph.GenericGraph.shortest_path_all_pairs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GenericGraph.shortest_path_all_pairs()</span></code></a>, and we suggest to look
at that method for more information and examples.</p>
</div>
<p>EXAMPLES:</p>
<p>The Petersen Graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">distance_all_pairs</span><span class="p">())</span>
<span class="go">{0: {0: 0, 1: 1, 2: 2, 3: 2, 4: 1, 5: 1, 6: 2, 7: 2, 8: 2, 9: 2}, 1: {0: 1, 1: 0, 2: 1, 3: 2, 4: 2, 5: 2, 6: 1, 7: 2, 8: 2, 9: 2}, 2: {0: 2, 1: 1, 2: 0, 3: 1, 4: 2, 5: 2, 6: 2, 7: 1, 8: 2, 9: 2}, 3: {0: 2, 1: 2, 2: 1, 3: 0, 4: 1, 5: 2, 6: 2, 7: 2, 8: 1, 9: 2}, 4: {0: 1, 1: 2, 2: 2, 3: 1, 4: 0, 5: 2, 6: 2, 7: 2, 8: 2, 9: 1}, 5: {0: 1, 1: 2, 2: 2, 3: 2, 4: 2, 5: 0, 6: 2, 7: 1, 8: 1, 9: 2}, 6: {0: 2, 1: 1, 2: 2, 3: 2, 4: 2, 5: 2, 6: 0, 7: 2, 8: 1, 9: 1}, 7: {0: 2, 1: 2, 2: 1, 3: 2, 4: 2, 5: 1, 6: 2, 7: 0, 8: 2, 9: 1}, 8: {0: 2, 1: 2, 2: 2, 3: 1, 4: 2, 5: 1, 6: 1, 7: 2, 8: 0, 9: 2}, 9: {0: 2, 1: 2, 2: 2, 3: 2, 4: 1, 5: 2, 6: 1, 7: 1, 8: 2, 9: 0}}</span>
</pre></div>
</div>
<p>Testing on Random Graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mf">.3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">distances</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">distance_all_pairs</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">((</span><span class="n">g</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="n">Infinity</span> <span class="ow">and</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">distances</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span>
<span class="gp">....: </span>    <span class="n">g</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="n">distances</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">g</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.distance_matrix" title="sage.graphs.generic_graph.GenericGraph.distance_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">distance_matrix()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.shortest_path_all_pairs" title="sage.graphs.generic_graph.GenericGraph.shortest_path_all_pairs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shortest_path_all_pairs()</span></code></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.distance_graph">
<span class="sig-name descname"><span class="pre">distance_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dist</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.distance_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the graph on the same vertex set as the original graph but
vertices are adjacent in the returned graph if and only if they are at
specified distances in the original graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dist</span></code> – a nonnegative integer or a list of nonnegative integers;
specified distance(s) for the connecting vertices.  <code class="docutils literal notranslate"><span class="pre">Infinity</span></code> may
be used here to describe vertex pairs in separate components.</p></li>
</ul>
<p>OUTPUT:</p>
<p>The returned value is an undirected graph.  The vertex set is identical
to the calling graph, but edges of the returned graph join vertices
whose distance in the calling graph are present in the input <code class="docutils literal notranslate"><span class="pre">dist</span></code>.
Loops will only be present if distance 0 is included.  If the original
graph has a position dictionary specifying locations of vertices for
plotting, then this information is copied over to the distance graph.
In some instances this layout may not be the best, and might even be
confusing when edges run on top of each other due to symmetries chosen
for the layout.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">distance_graph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">am</span><span class="p">()</span>
<span class="go">[0 0 0 1 0 1]</span>
<span class="go">[0 0 1 0 1 0]</span>
<span class="go">[0 1 0 0 0 1]</span>
<span class="go">[1 0 0 0 1 0]</span>
<span class="go">[0 1 0 1 0 0]</span>
<span class="go">[1 0 1 0 0 0]</span>
</pre></div>
</div>
<p>To obtain the graph where vertices are adjacent if their distance apart
is <code class="docutils literal notranslate"><span class="pre">d</span></code> or less use a <code class="docutils literal notranslate"><span class="pre">range()</span></code> command to create the input, using
<code class="docutils literal notranslate"><span class="pre">d</span> <span class="pre">+</span> <span class="pre">1</span></code> as the input to <code class="docutils literal notranslate"><span class="pre">range</span></code>.  Notice that this will include
distance 0 and hence place a loop at each vertex.  To avoid this, use
<code class="docutils literal notranslate"><span class="pre">range(1,</span> <span class="pre">d</span> <span class="pre">+</span> <span class="pre">1)</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">OddGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">diameter</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">num_verts</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">distance_graph</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">distance_graph</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A complete collection of distance graphs will have adjacency matrices
that sum to the matrix of all ones:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">all_ones</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">P</span><span class="o">.</span><span class="n">distance_graph</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">am</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">all_ones</span> <span class="o">==</span> <span class="n">matrix</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">400</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Four-bit strings differing in one bit is the same as
four-bit strings differing in three bits:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">distance_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The graph of eight-bit strings, adjacent if different in an odd number
of bits:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="c1"># long time</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">distance_graph</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span> <span class="c1"># long time</span>
<span class="gp">sage: </span><span class="n">degrees</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">sum</span><span class="p">([</span><span class="n">binomial</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">]])</span> <span class="c1"># long time</span>
<span class="gp">sage: </span><span class="n">degrees</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">8</span><span class="p">)</span> <span class="c1"># long time</span>
<span class="gp">sage: </span><span class="n">degrees</span> <span class="o">==</span> <span class="n">H</span><span class="o">.</span><span class="n">degree_histogram</span><span class="p">()</span> <span class="c1"># long time</span>
<span class="go">True</span>
</pre></div>
</div>
<p>An example of using <code class="docutils literal notranslate"><span class="pre">Infinity</span></code> as the distance in a graph that is not
connected:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">distance_graph</span><span class="p">(</span><span class="n">Infinity</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">am</span><span class="p">()</span>
<span class="go">[0 0 0 1 1]</span>
<span class="go">[0 0 0 1 1]</span>
<span class="go">[0 0 0 1 1]</span>
<span class="go">[1 1 1 0 0]</span>
<span class="go">[1 1 1 0 0]</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<p>Rob Beezer, 2009-11-25</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.distance_matrix">
<span class="sig-name descname"><span class="pre">distance_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.distance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the distance matrix of (di)graph.</p>
<p>The (di)graph is expected to be (strongly) connected.</p>
<p>The distance matrix of a (strongly) connected (di)graph is a matrix
whose rows and columns are by default (<code class="docutils literal notranslate"><span class="pre">vertices</span> <span class="pre">==</span> <span class="pre">None</span></code>) indexed
with the positions of the vertices of the (di)graph in the ordering
<a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.vertices" title="sage.graphs.generic_graph.GenericGraph.vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertices()</span></code></a>. When <code class="docutils literal notranslate"><span class="pre">vertices</span></code> is set, the position of the vertices
in this ordering is used. The intersection of row <span class="math notranslate nohighlight">\(i\)</span> and column <span class="math notranslate nohighlight">\(j\)</span>
contains the shortest path distance from the vertex at the <span class="math notranslate nohighlight">\(i\)</span>-th
position to the vertex at the <span class="math notranslate nohighlight">\(j\)</span>-th position.</p>
<p>Note that even when the vertices are consecutive integers starting from
one, usually the vertex is not equal to its index.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – list (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the ordering of the vertices
defining how they should appear in the matrix. By default, the
ordering given by <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.vertices" title="sage.graphs.generic_graph.GenericGraph.vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertices()</span></code></a> is used. Because <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.vertices" title="sage.graphs.generic_graph.GenericGraph.vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertices()</span></code></a>
only works if the vertices can be sorted, using <code class="docutils literal notranslate"><span class="pre">vertices</span></code> is useful
when working with possibly non-sortable objects in Python 3.</p></li>
<li><p>All other arguments are forwarded to the subfunction
<a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.distance_all_pairs" title="sage.graphs.generic_graph.GenericGraph.distance_all_pairs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">distance_all_pairs()</span></code></a></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">d</span><span class="o">.</span><span class="n">distance_matrix</span><span class="p">()</span>
<span class="go">[0 1 1 2]</span>
<span class="go">[3 0 1 2]</span>
<span class="go">[2 3 0 1]</span>
<span class="go">[1 2 2 0]</span>
<span class="gp">sage: </span><span class="n">d</span><span class="o">.</span><span class="n">distance_matrix</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">[0 2 2 1]</span>
<span class="go">[1 0 3 2]</span>
<span class="go">[2 1 0 3]</span>
<span class="go">[2 1 1 0]</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">distance_matrix</span><span class="p">()</span>
<span class="go">[0 1 1 2 1 2 2 3]</span>
<span class="go">[1 0 2 1 2 1 3 2]</span>
<span class="go">[1 2 0 1 2 3 1 2]</span>
<span class="go">[2 1 1 0 3 2 2 1]</span>
<span class="go">[1 2 2 3 0 1 1 2]</span>
<span class="go">[2 1 3 2 1 0 2 1]</span>
<span class="go">[2 3 1 2 1 2 0 1]</span>
<span class="go">[3 2 2 1 2 1 1 0]</span>
</pre></div>
</div>
<p>The well known result of Graham and Pollak states that the determinant
of the distance matrix of any tree of order <span class="math notranslate nohighlight">\(n\)</span> is
<span class="math notranslate nohighlight">\((-1)^{n-1}(n-1)2^{n-2}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">distance_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">det</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">^</span><span class="mi">9</span><span class="o">*</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">^</span><span class="mi">8</span> <span class="k">for</span> <span class="n">T</span> <span class="ow">in</span> <span class="n">graphs</span><span class="o">.</span><span class="n">trees</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.distance_all_pairs" title="sage.graphs.generic_graph.GenericGraph.distance_all_pairs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">distance_all_pairs()</span></code></a>
– computes the distance between any two vertices.</p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.distances_distribution">
<span class="sig-name descname"><span class="pre">distances_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.distances_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the distances distribution of the (di)graph in a dictionary.</p>
<p>This method <em>ignores all edge labels</em>, so that the distance considered is
the topological distance.</p>
<p>OUTPUT:</p>
<blockquote>
<div><p>A dictionary <code class="docutils literal notranslate"><span class="pre">d</span></code> such that the number of pairs of vertices at distance
<code class="docutils literal notranslate"><span class="pre">k</span></code> (if any) is equal to <span class="math notranslate nohighlight">\(d[k] \cdot |V(G)| \cdot (|V(G)|-1)\)</span>.</p>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We consider that two vertices that do not belong to the same connected
component are at infinite distance, and we do not take the trivial pairs
of vertices <span class="math notranslate nohighlight">\((v, v)\)</span> at distance <span class="math notranslate nohighlight">\(0\)</span> into account. Empty (di)graphs and
(di)graphs of order 1 have no paths and so we return the empty
dictionary <code class="docutils literal notranslate"><span class="pre">{}</span></code>.</p>
</div>
<p>EXAMPLES:</p>
<p>An empty Graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">distances_distribution</span><span class="p">()</span>
<span class="go">{}</span>
</pre></div>
</div>
<p>A Graph of order 1:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">distances_distribution</span><span class="p">()</span>
<span class="go">{}</span>
</pre></div>
</div>
<p>A Graph of order 2 without edge:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_vertices</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">distances_distribution</span><span class="p">()</span>
<span class="go">{+Infinity: 1}</span>
</pre></div>
</div>
<p>The Petersen Graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">distances_distribution</span><span class="p">()</span>
<span class="go">{1: 1/3, 2: 2/3}</span>
</pre></div>
</div>
<p>A graph with multiple disconnected components:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;good&#39;</span><span class="p">,</span><span class="s1">&#39;wine&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">distances_distribution</span><span class="p">()</span>
<span class="go">{1: 8/33, 2: 5/11, +Infinity: 10/33}</span>
</pre></div>
</div>
<p>The de Bruijn digraph dB(2,3):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">DeBruijn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">distances_distribution</span><span class="p">()</span>
<span class="go">{1: 1/4, 2: 11/28, 3: 5/14}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.dominating_set">
<span class="sig-name descname"><span class="pre">dominating_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">independent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">total</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.dominating_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a minimum distance-<span class="math notranslate nohighlight">\(k\)</span> dominating set of the graph.</p>
<p>A minimum dominating set <span class="math notranslate nohighlight">\(S\)</span> of a graph <span class="math notranslate nohighlight">\(G\)</span> is a set of its vertices of
minimal cardinality such that any vertex of <span class="math notranslate nohighlight">\(G\)</span> is in <span class="math notranslate nohighlight">\(S\)</span> or has one of its
neighbors in <span class="math notranslate nohighlight">\(S\)</span>. See the <a class="reference external" href="https://en.wikipedia.org/wiki/Dominating_set">Wikipedia article Dominating_set</a>.</p>
<p>A minimum distance-<span class="math notranslate nohighlight">\(k\)</span> dominating set is a set <span class="math notranslate nohighlight">\(S\)</span> of vertices of <span class="math notranslate nohighlight">\(G\)</span> of
minimal cardinality such that any vertex of <span class="math notranslate nohighlight">\(G\)</span> is in <span class="math notranslate nohighlight">\(S\)</span> or at distance at
most <span class="math notranslate nohighlight">\(k\)</span> from a vertex in <span class="math notranslate nohighlight">\(S\)</span>. A distance-<span class="math notranslate nohighlight">\(0\)</span> dominating set is the set of
vertices itself, and when <span class="math notranslate nohighlight">\(k\)</span> is the radius of the graph, any vertex
dominates all the other vertices.</p>
<p>As an optimization problem, it can be expressed as follows, where <span class="math notranslate nohighlight">\(N^k(u)\)</span>
denotes the set of vertices at distance at most <span class="math notranslate nohighlight">\(k\)</span> from <span class="math notranslate nohighlight">\(u\)</span> (the set of
neighbors when <span class="math notranslate nohighlight">\(k=1\)</span>):</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mbox{Minimize : }&amp;\sum_{v\in G} b_v\\
\mbox{Such that : }&amp;\forall v \in G, b_v+\sum_{u \in N^k(v)} b_u\geq 1\\
&amp;\forall x\in G, b_x\mbox{ is a binary variable}\end{split}\]</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> – a non-negative integer (default: <code class="docutils literal notranslate"><span class="pre">1</span></code>); the domination distance</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">independent</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); when <code class="docutils literal notranslate"><span class="pre">True</span></code>, computes a
minimum independent dominating set, that is a minimum dominating set that
is also an independent set (see also
<code class="xref py py-meth docutils literal notranslate"><span class="pre">independent_set()</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">total</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); when <code class="docutils literal notranslate"><span class="pre">True</span></code>, computes a total
dominating set (see the See the <a class="reference external" href="https://en.wikipedia.org/wiki/Dominating_set">Wikipedia article Dominating_set</a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value_only</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to only return the
cardinality of the computed dominating set, or to return its list of
vertices (default)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer Linear
Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one
is used. For more information on MILP solvers and which default solver is
used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of verbosity. Set
to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP solvers
over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>A basic illustration on a <code class="docutils literal notranslate"><span class="pre">PappusGraph</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PappusGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">dominating_set</span><span class="p">(</span><span class="n">value_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
<p>If we build a graph from two disjoint stars, then link their centers we will
find a difference between the cardinality of an independent set and a stable
independent set:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">graphs</span><span class="o">.</span><span class="n">StarGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">dominating_set</span><span class="p">())</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">dominating_set</span><span class="p">(</span><span class="n">independent</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">6</span>
</pre></div>
</div>
<p>The total dominating set of the Petersen graph has cardinality 4:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">dominating_set</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">value_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">4</span>
</pre></div>
</div>
<p>The dominating set is calculated for both the directed and undirected graphs
(modification introduced in <a class="reference external" href="https://trac.sagemath.org/17905">trac ticket #17905</a>):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">dominating_set</span><span class="p">(</span><span class="n">value_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">dominating_set</span><span class="p">(</span><span class="n">value_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Cardinality of distance-<span class="math notranslate nohighlight">\(k\)</span> dominating sets:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">dominating_set</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">value_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">radius</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
<span class="go">[10, 3, 1]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">dominating_set</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">value_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">radius</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
<span class="go">[5, 2, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.dominator_tree">
<span class="sig-name descname"><span class="pre">dominator_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.dominator_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Use Boost to compute the dominator tree of <code class="docutils literal notranslate"><span class="pre">g</span></code>, rooted at <code class="docutils literal notranslate"><span class="pre">root</span></code>.</p>
<p>A node <span class="math notranslate nohighlight">\(d\)</span> dominates a node <span class="math notranslate nohighlight">\(n\)</span> if every path from the entry node
<code class="docutils literal notranslate"><span class="pre">root</span></code> to <span class="math notranslate nohighlight">\(n\)</span> must go through <span class="math notranslate nohighlight">\(d\)</span>. The immediate dominator of a node
<span class="math notranslate nohighlight">\(n\)</span> is the unique node that strictly dominates <span class="math notranslate nohighlight">\(n\)</span> but does not dominate
any other node that dominates <span class="math notranslate nohighlight">\(n\)</span>. A dominator tree is a tree where each
node’s children are those nodes it immediately dominates. For more
information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Dominator_(graph_theory)">Wikipedia article Dominator_(graph_theory)</a>.</p>
<p>If the graph is connected and undirected, the parent of a vertex <span class="math notranslate nohighlight">\(v\)</span> is:</p>
<blockquote>
<div><ul class="simple">
<li><p>the root if <span class="math notranslate nohighlight">\(v\)</span> is in the same biconnected component as the root;</p></li>
<li><p>the first cut vertex in a path from <span class="math notranslate nohighlight">\(v\)</span> to the root, otherwise.</p></li>
</ul>
</div></blockquote>
<p>If the graph is not connected, the dominator tree of the whole graph is
equal to the dominator tree of the connected component of the root.</p>
<p>If the graph is directed, computing a dominator tree is more complicated,
and it needs time <span class="math notranslate nohighlight">\(O(m\log m)\)</span>, where <span class="math notranslate nohighlight">\(m\)</span> is the number of edges. The
implementation provided by Boost is the most general one, so it needs time
<span class="math notranslate nohighlight">\(O(m\log m)\)</span> even for undirected graphs.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">g</span></code> – the input Sage (Di)Graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">root</span></code> – the root of the dominator tree</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">return_dict</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, the function
returns a dictionary associating to each vertex its parent in the
dominator tree. If <code class="docutils literal notranslate"><span class="pre">False</span></code> (default), it returns the whole tree, as a
<code class="docutils literal notranslate"><span class="pre">Graph</span></code> or a <code class="docutils literal notranslate"><span class="pre">DiGraph</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reverse</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); when set to <code class="docutils literal notranslate"><span class="pre">True</span></code>,
computes the dominator tree in the reverse graph</p></li>
</ul>
<p>OUTPUT:</p>
<p>The dominator tree, as a graph or as a dictionary, depending on the
value of <code class="docutils literal notranslate"><span class="pre">return_dict</span></code>. If the output is a dictionary, it will contain
<code class="docutils literal notranslate"><span class="pre">None</span></code> in correspondence of <code class="docutils literal notranslate"><span class="pre">root</span></code> and of vertices that are not
reachable from <code class="docutils literal notranslate"><span class="pre">root</span></code>. If the output is a graph, it will not contain
vertices that are not reachable from <code class="docutils literal notranslate"><span class="pre">root</span></code>.</p>
<p>EXAMPLES:</p>
<p>An undirected grid is biconnected, and its dominator tree is a star
(everyone’s parent is the root):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">GridGraph</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">dominator_tree</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">to_dictionary</span><span class="p">()</span>
<span class="go">{(0, 0): [(0, 1), (1, 0), (1, 1)], (0, 1): [(0, 0)], (1, 0): [(0, 0)], (1, 1): [(0, 0)]}</span>
</pre></div>
</div>
<p>If the graph is made by two 3-cycles <span class="math notranslate nohighlight">\(C_1,C_2\)</span> connected by an edge <span class="math notranslate nohighlight">\((v,w)\)</span>,
with <span class="math notranslate nohighlight">\(v \in C_1\)</span>, <span class="math notranslate nohighlight">\(w \in C_2\)</span>, the cut vertices are <span class="math notranslate nohighlight">\(v\)</span> and <span class="math notranslate nohighlight">\(w\)</span>, the
biconnected components are <span class="math notranslate nohighlight">\(C_1\)</span>, <span class="math notranslate nohighlight">\(C_2\)</span>, and the edge <span class="math notranslate nohighlight">\((v,w)\)</span>. If the root
is in <span class="math notranslate nohighlight">\(C_1\)</span>, the parent of each vertex in <span class="math notranslate nohighlight">\(C_1\)</span> is the root, the parent of
<span class="math notranslate nohighlight">\(w\)</span> is <span class="math notranslate nohighlight">\(v\)</span>, and the parent of each vertex in <span class="math notranslate nohighlight">\(C_2\)</span> is <span class="math notranslate nohighlight">\(w\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">dominator_tree</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">return_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{0: 1, 1: None, 2: 1, 3: 0, 4: 3, 5: 3}</span>
</pre></div>
</div>
<p>An example with a directed graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">dominator_tree</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">to_dictionary</span><span class="p">()</span>
<span class="go">{0: [1], 1: [2], 2: [3], 3: [4], 4: [], 5: [6], 6: [7], 7: [8], 8: [9], 9: [0]}</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">dominator_tree</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">to_dictionary</span><span class="p">()</span>
<span class="go">{0: [9], 1: [0], 2: [1], 3: [2], 4: [3], 5: [4], 6: [], 7: [6], 8: [7], 9: [8]}</span>
</pre></div>
</div>
<p>If the output is a dictionary:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">GridGraph</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">dominator_tree</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">return_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{(0, 0): None, (0, 1): (0, 0), (1, 0): (0, 0), (1, 1): (0, 0)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.edge_boundary">
<span class="sig-name descname"><span class="pre">edge_boundary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.edge_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of edges <code class="docutils literal notranslate"><span class="pre">(u,v,l)</span></code> with <code class="docutils literal notranslate"><span class="pre">u</span></code> in <code class="docutils literal notranslate"><span class="pre">vertices1</span></code>
and <code class="docutils literal notranslate"><span class="pre">v</span></code> in <code class="docutils literal notranslate"><span class="pre">vertices2</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">vertices2</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, then it is set to the complement of
<code class="docutils literal notranslate"><span class="pre">vertices1</span></code>.</p>
<p>In a digraph, the external boundary of a vertex <span class="math notranslate nohighlight">\(v\)</span> are those vertices
<span class="math notranslate nohighlight">\(u\)</span> with an arc <span class="math notranslate nohighlight">\((v, u)\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">False</span></code>, each edge is
a tuple <span class="math notranslate nohighlight">\((u,v)\)</span> of vertices</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sort</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to sort the result</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">edge_boundary</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]))</span>
<span class="go">27</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">27</span>
</pre></div>
</div>
<p>Note that the edge boundary preserves direction:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">edge_boundary</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]))</span>
<span class="go">27</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">54</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edge_boundary</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(0, 1, None), (0, 2, None)]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edge_boundary</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(0, 1), (0, 2)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.edge_connectivity">
<span class="sig-name descname"><span class="pre">edge_connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">implementation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_edge_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.edge_connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the edge connectivity of the graph.</p>
<p>For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Connectivity_(graph_theory)">Wikipedia article Connectivity_(graph_theory)</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When the graph is a directed graph, this method actually computes the
<em>strong</em> connectivity, (i.e. a directed graph is strongly <span class="math notranslate nohighlight">\(k\)</span>-connected
if there are <span class="math notranslate nohighlight">\(k\)</span> disjoint paths between any two vertices <span class="math notranslate nohighlight">\(u, v\)</span>). If you
do not want to consider strong connectivity, the best is probably to
convert your <code class="docutils literal notranslate"><span class="pre">DiGraph</span></code> object to a <code class="docutils literal notranslate"><span class="pre">Graph</span></code> object, and compute the
connectivity of this other graph.</p>
</div>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – the input Sage (Di)Graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value_only</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<ul class="simple">
<li><p>When set to <code class="docutils literal notranslate"><span class="pre">True</span></code> (default), only the value is returned.</p></li>
<li><p>When set to <code class="docutils literal notranslate"><span class="pre">False</span></code>, both the value and a minimum vertex cut are
returned.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">implementation</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); selects an
implementation:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> (default) – selects the best implementation available</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;boost&quot;</span></code> – use the Boost graph library (which is much more
efficient). It is not available when <code class="docutils literal notranslate"><span class="pre">edge_labels=True</span></code>, and it is
unreliable for directed graphs (see <a class="reference external" href="https://trac.sagemath.org/18753">trac ticket #18753</a>).</p></li>
</ul>
<dl class="simple">
<dt>-<code class="docutils literal notranslate"><span class="pre">&quot;Sage&quot;</span></code> – use Sage’s implementation based on integer linear</dt><dd><p>programming</p>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">use_edge_labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<ul class="simple">
<li><p>When set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, computes a weighted minimum cut where each edge
has a weight defined by its label. (If an edge has no label, <span class="math notranslate nohighlight">\(1\)</span> is
assumed.). Implies <code class="docutils literal notranslate"><span class="pre">boost</span></code> = <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p>When set to <code class="docutils literal notranslate"><span class="pre">False</span></code>, each edge has weight <span class="math notranslate nohighlight">\(1\)</span>.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<ul class="simple">
<li><p>When set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, also returns the two sets of vertices that are
disconnected by the cut. Implies <code class="docutils literal notranslate"><span class="pre">value_only=False</span></code>.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer Linear
Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one
is used. For more information on MILP solvers and which default solver is
used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of verbosity. Set
to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP solvers
over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>A basic application on the PappusGraph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.connectivity</span> <span class="kn">import</span> <span class="n">edge_connectivity</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PappusGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">edge_connectivity</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">edge_connectivity</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>The edge connectivity of a complete graph is its minimum degree, and one of
the two parts of the bipartition is reduced to only one vertex. The graph of
the cut edges is isomorphic to a Star graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span> <span class="n">value</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="p">[</span> <span class="n">setA</span><span class="p">,</span> <span class="n">setB</span> <span class="p">]]</span> <span class="o">=</span> <span class="n">edge_connectivity</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">value</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">setA</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">setB</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">cut</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">cut</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">cut</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">StarGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Even if obviously in any graph we know that the edge connectivity is less
than the minimum degree of the graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mf">.3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">min</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">degree</span><span class="p">())</span> <span class="o">&gt;=</span> <span class="n">edge_connectivity</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If we build a tree then assign to its edges a random value, the minimum cut
will be the edge with minimum value:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">tree</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomTree</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">....: </span>     <span class="n">tree</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">random</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">minimum</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">edge_labels</span><span class="p">())</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">_</span><span class="p">,</span> <span class="p">[(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">l</span><span class="p">)]]</span> <span class="o">=</span> <span class="n">edge_connectivity</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">value_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">==</span> <span class="n">minimum</span>
<span class="go">True</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">value_only=True</span></code> and <code class="docutils literal notranslate"><span class="pre">implementation=&quot;sage&quot;</span></code>, this function is
optimized for small connectivity values and does not need to build a linear
program.</p>
<p>It is the case for graphs which are not connected</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">edge_connectivity</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="s2">&quot;sage&quot;</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>For directed graphs, the strong connectivity is tested through the dedicated
function:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">ButterflyGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">edge_connectivity</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="s2">&quot;sage&quot;</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>We check that the result with Boost is the same as the result without Boost:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mf">.3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">edge_connectivity</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="s2">&quot;boost&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">edge_connectivity</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="s2">&quot;sage&quot;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Boost interface also works with directed graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">edge_connectivity</span><span class="p">(</span><span class="n">digraphs</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">implementation</span><span class="o">=</span><span class="s2">&quot;boost&quot;</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[1, [(0, 1)], [{0}, {1, 2, 3, 4, 5, 6, 7, 8, 9}]]</span>
</pre></div>
</div>
<p>However, the Boost algorithm is not reliable if the input is directed
(see <a class="reference external" href="https://trac.sagemath.org/18753">trac ticket #18753</a>):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">edge_connectivity</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">sage: </span><span class="n">edge_connectivity</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="s2">&quot;boost&quot;</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">edge_connectivity</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">sage: </span><span class="n">edge_connectivity</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="s2">&quot;boost&quot;</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.edge_cut">
<span class="sig-name descname"><span class="pre">edge_cut</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_only</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_edge_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'FF'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.edge_cut" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a minimum edge cut between vertices <span class="math notranslate nohighlight">\(s\)</span> and <span class="math notranslate nohighlight">\(t\)</span>.</p>
<p>A minimum edge cut between two vertices <span class="math notranslate nohighlight">\(s\)</span> and <span class="math notranslate nohighlight">\(t\)</span> of self is a set <span class="math notranslate nohighlight">\(A\)</span>
of edges of minimum weight such that the graph obtained by removing <span class="math notranslate nohighlight">\(A\)</span>
from the graph is disconnected. For more information, see the
<a class="reference external" href="https://en.wikipedia.org/wiki/Cut_(graph_theory)">Wikipedia article Cut_(graph_theory)</a>.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code> – source vertex</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code> – sink vertex</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value_only</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether to return only
the weight of a minimum cut (<code class="docutils literal notranslate"><span class="pre">True</span></code>) or a list of edges of a minimum
cut (<code class="docutils literal notranslate"><span class="pre">False</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">use_edge_labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to
compute a weighted minimum edge cut where the weight of an edge is
defined by its label (if an edge has no label, <span class="math notranslate nohighlight">\(1\)</span> is assumed), or to
compute a cut of minimum cardinality (i.e., edge weights are set to 1)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether set to <code class="docutils literal notranslate"><span class="pre">True</span></code>,
return a list of edges in the edge cut and the two sets of vertices
that are disconnected by the cut</p>
<p>Note: <code class="docutils literal notranslate"><span class="pre">vertices=True</span></code> implies <code class="docutils literal notranslate"><span class="pre">value_only=False</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">'FF'</span></code>); algorithm to use:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;FF&quot;</span></code>, a Python implementation of the
Ford-Fulkerson algorithm is used</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;LP&quot;</span></code>, the problem is solved using Linear
Programming.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;igraph&quot;</span></code>, the igraph implementation of the
Goldberg-Tarjan algorithm is used (only available when <code class="docutils literal notranslate"><span class="pre">igraph</span></code> is
installed)</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">None</span></code>, the problem is solved using the default
maximum flow algorithm (see <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.flow" title="sage.graphs.generic_graph.GenericGraph.flow"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flow()</span></code></a>)</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The use of Linear Programming for non-integer problems may possibly
mean the presence of a (slight) numerical noise.</p>
</div>
<p>OUTPUT:</p>
<p>Real number or tuple, depending on the given arguments (examples are
given below).</p>
<p>EXAMPLES:</p>
<p>A basic application in the Pappus graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PappusGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">edge_cut</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">value_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Or on Petersen’s graph, with the corresponding bipartition of the vertex
set:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">edge_cut</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[3, [(0, 1, None), (0, 4, None), (0, 5, None)], [[0], [1, 2, 3, 4, 5, 6, 7, 8, 9]]]</span>
</pre></div>
</div>
<p>If the graph is a path with randomly weighted edges:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">....: </span>   <span class="n">g</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">random</span><span class="p">())</span>
</pre></div>
</div>
<p>The edge cut between the two ends is the edge of minimum weight:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">minimum</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">edge_labels</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">minimum</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">edge_cut</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="n">use_edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">value</span><span class="p">,</span> <span class="p">[</span><span class="n">e</span><span class="p">]]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">edge_cut</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="n">use_edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">value_only</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">edge_label</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">minimum</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The two sides of the edge cut are obviously shorter paths:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">value</span><span class="p">,</span><span class="n">edges</span><span class="p">,[</span><span class="n">set1</span><span class="p">,</span><span class="n">set2</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">edge_cut</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="n">use_edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">set1</span><span class="p">)</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">set1</span><span class="p">)))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">set2</span><span class="p">)</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">set2</span><span class="p">)))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">set1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">set2</span><span class="p">)</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.edge_disjoint_paths">
<span class="sig-name descname"><span class="pre">edge_disjoint_paths</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'FF'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.edge_disjoint_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of edge-disjoint paths between two vertices.</p>
<p>The edge version of Menger’s theorem asserts that the size of the
minimum edge cut between two vertices <span class="math notranslate nohighlight">\(s\)</span> and`t` (the minimum number of
edges whose removal disconnects <span class="math notranslate nohighlight">\(s\)</span> and <span class="math notranslate nohighlight">\(t\)</span>) is equal to the maximum
number of pairwise edge-independent paths from <span class="math notranslate nohighlight">\(s\)</span> to <span class="math notranslate nohighlight">\(t\)</span>.</p>
<p>This function returns a list of such paths.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">&quot;FF&quot;</span></code>); the algorithm to use
among:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;FF&quot;</span></code>, a Python implementation of the Ford-Fulkerson algorithm</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;LP&quot;</span></code>, the flow problem is solved using Linear Programming</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p>
<p>Only used when <span class="math notranslate nohighlight">\(àlgorithm\)</span> is <code class="docutils literal notranslate"><span class="pre">&quot;LP&quot;</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p>
<p>Only used when <span class="math notranslate nohighlight">\(àlgorithm\)</span> is <code class="docutils literal notranslate"><span class="pre">&quot;LP&quot;</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p>
<p>Only used when <span class="math notranslate nohighlight">\(àlgorithm\)</span> is <code class="docutils literal notranslate"><span class="pre">&quot;LP&quot;</span></code>.</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is topological: it does not take the eventual weights
of the edges into account.</p>
</div>
<p>EXAMPLES:</p>
<p>In a complete bipartite graph</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">edge_disjoint_paths</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[[0, 2, 1], [0, 3, 1], [0, 4, 1]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.edge_disjoint_spanning_trees">
<span class="sig-name descname"><span class="pre">edge_disjoint_spanning_trees</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.edge_disjoint_spanning_trees" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the desired number of edge-disjoint spanning trees/arborescences.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> – integer; the required number of edge-disjoint spanning
trees/arborescences</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">root</span></code> – vertex (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); root of the disjoint
arborescences when the graph is directed.  If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
first vertex in the graph is picked.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Linear Program
(LP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is
used. For more information on LP solvers and which default solver is
used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
</ul>
<p>ALGORITHM:</p>
<p>Mixed Integer Linear Program. The formulation can be found in
<a class="reference internal" href="../../../references/index.html#coh2019" id="id11"><span>[Coh2019]</span></a>.</p>
<p>There are at least two possible rewritings of this method which do not
use Linear Programming:</p>
<blockquote>
<div><ul class="simple">
<li><p>The algorithm presented in the paper entitled “A short proof of
the tree-packing theorem”, by Thomas Kaiser <a class="reference internal" href="../../../references/index.html#kai2012" id="id12"><span>[Kai2012]</span></a>.</p></li>
<li><p>The implementation of a Matroid class and of the Matroid Union
Theorem (see section 42.3 of <a class="reference internal" href="../../../references/index.html#sch2003" id="id13"><span>[Sch2003]</span></a>), applied to the
cycle Matroid (see chapter 51 of <a class="reference internal" href="../../../references/index.html#sch2003" id="id14"><span>[Sch2003]</span></a>).</p></li>
</ul>
</div></blockquote>
<p>EXAMPLES:</p>
<p>The Petersen Graph does have a spanning tree (it is connected):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">edge_disjoint_spanning_trees</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">is_tree</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Though, it does not have 2 edge-disjoint trees (as it has less than
<span class="math notranslate nohighlight">\(2(|V|-1)\)</span> edges):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">edge_disjoint_spanning_trees</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">EmptySetError: this graph does not contain the required number of trees/arborescences</span>
</pre></div>
</div>
<p>By Edmond’s theorem, a graph which is <span class="math notranslate nohighlight">\(k\)</span>-connected always has <span class="math notranslate nohighlight">\(k\)</span>
edge-disjoint arborescences, regardless of the root we pick:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">RandomDirectedGNP</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mf">.3</span><span class="p">)</span>  <span class="c1"># reduced from 30 to 11, cf. #32169</span>
<span class="gp">sage: </span><span class="n">k</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">edge_connectivity</span><span class="p">())</span>
<span class="gp">sage: </span><span class="k">while</span> <span class="ow">not</span> <span class="n">k</span><span class="p">:</span>
<span class="gp">....: </span>    <span class="n">g</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">RandomDirectedGNP</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mf">.3</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="n">k</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">edge_connectivity</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">arborescences</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">edge_disjoint_spanning_trees</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>  <span class="c1"># long time (up to 15s on sage.math, 2011)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">is_directed_acyclic</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arborescences</span><span class="p">)</span>  <span class="c1"># long time</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arborescences</span><span class="p">)</span>  <span class="c1"># long time</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In the undirected case, we can only ensure half of it:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mf">.3</span><span class="p">)</span>  <span class="c1"># reduced from 30 to 14, see #32169</span>
<span class="gp">sage: </span><span class="k">while</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_biconnected</span><span class="p">():</span>
<span class="gp">....: </span>    <span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mf">.3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">k</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">edge_connectivity</span><span class="p">())</span> <span class="o">//</span> <span class="mi">2</span>
<span class="gp">sage: </span><span class="n">trees</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">edge_disjoint_spanning_trees</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">is_tree</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.edge_iterator">
<span class="sig-name descname"><span class="pre">edge_iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort_vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.edge_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over edges.</p>
<p>The iterator returned is over the edges incident with any vertex given
in the parameter <code class="docutils literal notranslate"><span class="pre">vertices</span></code>. If the graph is directed, iterates over
edges going out only. If <code class="docutils literal notranslate"><span class="pre">vertices</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, then returns an
iterator over all edges. If <code class="docutils literal notranslate"><span class="pre">self</span></code> is directed, returns outgoing edges
only.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – object (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a vertex, a list of
vertices or <code class="docutils literal notranslate"><span class="pre">None</span></code></p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">False</span></code>, each edge is</dt><dd><p>a tuple <span class="math notranslate nohighlight">\((u,v)\)</span> of vertices</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ignore_direction</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); only applies to</dt><dd><p>directed graphs. If <code class="docutils literal notranslate"><span class="pre">True</span></code>, searches across edges in either
direction.</p>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">sort_vertices</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); only applies to
undirected graphs. If <code class="docutils literal notranslate"><span class="pre">True</span></code>, sort the ends of the edges.
Not sorting the ends is faster.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is somewhat safe to modify the graph during iterating.</p>
<p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> must be specified if modifying the vertices.</p>
<p>Without multiedges, you can safely use this graph to relabel
edges or delete some edges. If you add edges, they might later
appear in the iterator or not
(depending on the internal order of vertices).</p>
<p>In case of multiedges, all arcs from one vertex to another are
internally cached. So the iterator will yield them, even if you delete
them all after seeing the first one.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">([</span><span class="mi">0</span><span class="p">]):</span>
<span class="gp">....: </span> <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">(0, 1, None)</span>
<span class="go">(0, 4, None)</span>
<span class="go">(0, 5, None)</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">D</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">([</span><span class="mi">0</span><span class="p">]):</span>
<span class="gp">....: </span> <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">(0, 1, None)</span>
<span class="go">(0, 2, None)</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">TetrahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">[(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">TetrahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">[(1, 0), (2, 0), (3, 0), (2, 1), (3, 1), (3, 2)]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ignore_direction</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(1, 0, None), (2, 0, None)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.edge_label">
<span class="sig-name descname"><span class="pre">edge_label</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.edge_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the label of an edge.</p>
<p>If the graph allows multiple edges, then the list of labels on the edges
is returned.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.set_edge_label" title="sage.graphs.generic_graph.GenericGraph.set_edge_label"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_edge_label()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;edgelabel&#39;</span><span class="p">}})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edge_label</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;edgelabel&#39;</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;up&#39;</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;down&#39;</span><span class="p">}})</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edge_label</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;down&#39;</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)]</span>
<span class="go">[None, None, None, None, None]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edge_label</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">[1, 2, 3, 4, 5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.edge_labels">
<span class="sig-name descname"><span class="pre">edge_labels</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.edge_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the labels of all edges in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The output list is not sorted.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s1">&#39;a&#39;</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">5</span><span class="p">:</span> <span class="s1">&#39;out&#39;</span><span class="p">}},</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edge_labels</span><span class="p">()</span>
<span class="go">[&#39;x&#39;, &#39;z&#39;, &#39;a&#39;, &#39;out&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s1">&#39;a&#39;</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">5</span><span class="p">:</span> <span class="s1">&#39;out&#39;</span><span class="p">}},</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edge_labels</span><span class="p">()</span>
<span class="go">[&#39;x&#39;, &#39;z&#39;, &#39;a&#39;, &#39;out&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.edge_polytope">
<span class="sig-name descname"><span class="pre">edge_polytope</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.edge_polytope" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the edge polytope of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The edge polytope (EP) of a Graph on <span class="math notranslate nohighlight">\(n\)</span> vertices
is the polytope in <span class="math notranslate nohighlight">\(\ZZ^{n}\)</span> defined as the convex hull of
<span class="math notranslate nohighlight">\(e_i + e_j\)</span> for each edge <span class="math notranslate nohighlight">\((i, j)\)</span>.
Here <span class="math notranslate nohighlight">\(e_1, \dots, e_n\)</span> denotes the standard basis.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">backend</span></code> – string or <code class="docutils literal notranslate"><span class="pre">None</span></code> (default); the backend to use;
see <code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.geometry.polyhedron.constructor.Polyhedron()</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<p>The EP of a <span class="math notranslate nohighlight">\(4\)</span>-cycle is a square:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">edge_polytope</span><span class="p">();</span> <span class="n">P</span>
<span class="go">A 2-dimensional polyhedron in ZZ^4 defined as the convex hull of 4 vertices</span>
</pre></div>
</div>
<p>The EP of a complete graph on <span class="math notranslate nohighlight">\(4\)</span> vertices is cross polytope:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">edge_polytope</span><span class="p">();</span> <span class="n">P</span>
<span class="go">A 3-dimensional polyhedron in ZZ^4 defined as the convex hull of 6 vertices</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_combinatorially_isomorphic</span><span class="p">(</span><span class="n">polytopes</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The EP of a graph is isomorphic to the subdirect sum of
its connected components EPs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G1</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G2</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">G1</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">G2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">edge_polytope</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">G1</span><span class="o">.</span><span class="n">edge_polytope</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">G2</span><span class="o">.</span><span class="n">edge_polytope</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_combinatorially_isomorphic</span><span class="p">(</span><span class="n">P1</span><span class="o">.</span><span class="n">subdirect_sum</span><span class="p">(</span><span class="n">P2</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>All trees on <span class="math notranslate nohighlight">\(n\)</span> vertices have isomorphic EPs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G1</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomTree</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G2</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomTree</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">G1</span><span class="o">.</span><span class="n">edge_polytope</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">G2</span><span class="o">.</span><span class="n">edge_polytope</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P1</span><span class="o">.</span><span class="n">is_combinatorially_isomorphic</span><span class="p">(</span><span class="n">P2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>However, there are still many different EPs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">graphs</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span>
<span class="go">34</span>
<span class="gp">sage: </span><span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">G</span> <span class="ow">in</span> <span class="n">graphs</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">P</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">edge_polytope</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">P1</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="n">P</span><span class="o">.</span><span class="n">is_combinatorially_isomorphic</span><span class="p">(</span><span class="n">P1</span><span class="p">):</span>
<span class="gp">....: </span>            <span class="k">break</span>
<span class="gp">....: </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="gp">....:</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span>
<span class="go">19</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.edges">
<span class="sig-name descname"><span class="pre">edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort_vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <a class="reference internal" href="views.html#sage.graphs.views.EdgesView" title="sage.graphs.views.EdgesView"><code class="xref py py-class docutils literal notranslate"><span class="pre">EdgesView</span></code></a> of edges.</p>
<p>Each edge is a triple <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></code> where <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span></code> are vertices
and <code class="docutils literal notranslate"><span class="pre">l</span></code> is a label. If the parameter <code class="docutils literal notranslate"><span class="pre">labels</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> then a
list of couple <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v)</span></code> is returned where <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span></code> are
vertices.</p>
<p>The returned <a class="reference internal" href="views.html#sage.graphs.views.EdgesView" title="sage.graphs.views.EdgesView"><code class="xref py py-class docutils literal notranslate"><span class="pre">EdgesView</span></code></a> is over the edges incident with any
vertex given in the parameter <code class="docutils literal notranslate"><span class="pre">vertices</span></code> (all edges if <code class="docutils literal notranslate"><span class="pre">None</span></code>). If
<code class="docutils literal notranslate"><span class="pre">self</span></code> is directed, iterates over outgoing edges only, unless
parameter <code class="docutils literal notranslate"><span class="pre">ignore_direction</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> in which case it searches
across edges in either direction.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – object (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a vertex, a list of
vertices or <code class="docutils literal notranslate"><span class="pre">None</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">False</span></code>, each edge is
simply a pair <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v)</span></code> of vertices</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sort</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, edges are sorted
according to the default ordering</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">key</span></code> – a function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that takes an
edge (a pair or a triple, according to the <code class="docutils literal notranslate"><span class="pre">labels</span></code> keyword) as its
one argument and returns a value that can be used for comparisons in
the sorting algorithm</p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ignore_direction</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); only applies to</dt><dd><p>directed graphs. If <code class="docutils literal notranslate"><span class="pre">True</span></code>, searches across edges in either
direction.</p>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">sort_vertices</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); only applies to
undirected graphs. If <code class="docutils literal notranslate"><span class="pre">True</span></code>, sort the ends of the edges.
Not sorting the ends is faster.</p></li>
</ul>
<p>OUTPUT: A <a class="reference internal" href="views.html#sage.graphs.views.EdgesView" title="sage.graphs.views.EdgesView"><code class="xref py py-class docutils literal notranslate"><span class="pre">EdgesView</span></code></a>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Since any object may be a vertex, there is no guarantee that any two
vertices will be comparable, and thus no guarantee how two edges may
compare.  With default objects for vertices (all integers), or when
all the vertices are of the same simple type, then there should not
be a problem with how the vertices will be sorted.  However, if you
need to guarantee a total order for the sorting of the edges, use
the <code class="docutils literal notranslate"><span class="pre">key</span></code> argument, as illustrated in the examples below.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None), (0, 10, None), (0, 19, None), (1, 2, None), (1, 8, None), (2, 3, None), (2, 6, None), (3, 4, None), (3, 19, None), (4, 5, None), (4, 17, None), (5, 6, None), (5, 15, None), (6, 7, None), (7, 8, None), (7, 14, None), (8, 9, None), (9, 10, None), (9, 13, None), (10, 11, None), (11, 12, None), (11, 18, None), (12, 13, None), (12, 16, None), (13, 14, None), (14, 15, None), (15, 16, None), (16, 17, None), (17, 18, None), (18, 19, None)]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(0, 1), (0, 10), (0, 19), (1, 2), (1, 8), (2, 3), (2, 6), (3, 4), (3, 19), (4, 5), (4, 17), (5, 6), (5, 15), (6, 7), (7, 8), (7, 14), (8, 9), (9, 10), (9, 13), (10, 11), (11, 12), (11, 18), (12, 13), (12, 16), (13, 14), (14, 15), (15, 16), (16, 17), (17, 18), (18, 19)]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">()</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None), (0, 10, None), (0, 19, None), (1, 0, None), (1, 2, None), (1, 8, None), (2, 1, None), (2, 3, None), (2, 6, None), (3, 2, None), (3, 4, None), (3, 19, None), (4, 3, None), (4, 5, None), (4, 17, None), (5, 4, None), (5, 6, None), (5, 15, None), (6, 2, None), (6, 5, None), (6, 7, None), (7, 6, None), (7, 8, None), (7, 14, None), (8, 1, None), (8, 7, None), (8, 9, None), (9, 8, None), (9, 10, None), (9, 13, None), (10, 0, None), (10, 9, None), (10, 11, None), (11, 10, None), (11, 12, None), (11, 18, None), (12, 11, None), (12, 13, None), (12, 16, None), (13, 9, None), (13, 12, None), (13, 14, None), (14, 7, None), (14, 13, None), (14, 15, None), (15, 5, None), (15, 14, None), (15, 16, None), (16, 12, None), (16, 15, None), (16, 17, None), (17, 4, None), (17, 16, None), (17, 18, None), (18, 11, None), (18, 17, None), (18, 19, None), (19, 0, None), (19, 3, None), (19, 18, None)]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(0, 1), (0, 10), (0, 19), (1, 0), (1, 2), (1, 8), (2, 1), (2, 3), (2, 6), (3, 2), (3, 4), (3, 19), (4, 3), (4, 5), (4, 17), (5, 4), (5, 6), (5, 15), (6, 2), (6, 5), (6, 7), (7, 6), (7, 8), (7, 14), (8, 1), (8, 7), (8, 9), (9, 8), (9, 10), (9, 13), (10, 0), (10, 9), (10, 11), (11, 10), (11, 12), (11, 18), (12, 11), (12, 13), (12, 16), (13, 9), (13, 12), (13, 14), (14, 7), (14, 13), (14, 15), (15, 5), (15, 14), (15, 16), (16, 12), (16, 15), (16, 17), (17, 4), (17, 16), (17, 18), (18, 11), (18, 17), (18, 19), (19, 0), (19, 3), (19, 18)]</span>
</pre></div>
</div>
<p>The default is to sort the returned list in the default fashion, as in
the above examples. This can be overridden by specifying a key
function. This first example just ignores the labels in the third
component of the triple:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="go">[(0, 1, None), (1, 2, None), (2, 3, None), (3, 4, None), (0, 4, None)]</span>
</pre></div>
</div>
<p>We set the labels to characters and then perform a default sort followed
by a sort according to the labels:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="gp">....: </span>  <span class="n">G</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(0, 1, &#39;F&#39;), (0, 4, &#39;U&#39;), (1, 2, &#39;L&#39;), (2, 3, &#39;R&#39;), (3, 4, &#39;X&#39;)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">[(0, 1, &#39;F&#39;), (1, 2, &#39;L&#39;), (2, 3, &#39;R&#39;), (0, 4, &#39;U&#39;), (3, 4, &#39;X&#39;)]</span>
</pre></div>
</div>
<p>We can restrict considered edges to those incident to a given set:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">(0, 1, None)</span>
<span class="go">(0, 4, None)</span>
<span class="go">(0, 5, None)</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">(0, 1, None)</span>
<span class="go">(0, 2, None)</span>
</pre></div>
</div>
<p>Ignoring the direction of edges:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ignore_direction</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(1, 0, None), (2, 0, None)]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ignore_direction</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(1, 0, None), (2, 0, None)]</span>
</pre></div>
</div>
<p>Not sorting the ends of the edges:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">(</span><span class="n">sort_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">[(3, 0, None), (2, 1, None), (3, 2, None)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.edges_incident">
<span class="sig-name descname"><span class="pre">edges_incident</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.edges_incident" title="Permalink to this definition">¶</a></dt>
<dd><p>Return incident edges to some vertices.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">vertices</span></code> is a vertex, then it returns the list of edges
incident to that vertex. If <code class="docutils literal notranslate"><span class="pre">vertices</span></code> is a list of vertices
then it returns the list of all edges adjacent to those
vertices. If <code class="docutils literal notranslate"><span class="pre">vertices</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, it returns a list of all edges
in graph. For digraphs, only lists outward edges.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – object (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a vertex, a list of
vertices or <code class="docutils literal notranslate"><span class="pre">None</span></code></p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">False</span></code>, each edge is</dt><dd><p>a tuple <span class="math notranslate nohighlight">\((u,v)\)</span> of vertices</p>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">sort</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code> the returned
list is sorted</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">edges_incident</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(0, 1), (0, 4), (0, 5), (4, 9), (6, 9), (7, 9)]</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges_incident</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[(0, 1, None)]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges_incident</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.eigenspaces">
<span class="sig-name descname"><span class="pre">eigenspaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">laplacian</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.eigenspaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <em>right</em> eigenspaces of the adjacency matrix of the graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">laplacian</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, use the</dt><dd><p>Laplacian matrix (see <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.kirchhoff_matrix" title="sage.graphs.generic_graph.GenericGraph.kirchhoff_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kirchhoff_matrix()</span></code></a>)</p>
</dd>
</dl>
</li>
</ul>
<p>OUTPUT:</p>
<p>A list of pairs.  Each pair is an eigenvalue of the adjacency matrix of
the graph, followed by the vector space that is the eigenspace for that
eigenvalue, when the eigenvectors are placed on the right of the matrix.</p>
<p>For some graphs, some of the eigenspaces are described exactly by vector
spaces over a <a class="reference external" href="../../../number_fields/sage/rings/number_field/number_field.html#sage.rings.number_field.number_field.NumberField" title="(in Sage 9.5 Reference Manual: Algebraic Numbers and Number Fields v9.5)"><code class="xref py py-func docutils literal notranslate"><span class="pre">NumberField()</span></code></a>.
For numerical eigenvectors use <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.eigenvectors" title="sage.graphs.generic_graph.GenericGraph.eigenvectors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eigenvectors()</span></code></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">eigenspaces</span><span class="p">()</span>
<span class="go">[</span>
<span class="go">(3, Vector space of degree 10 and dimension 1 over Rational Field</span>
<span class="go">User basis matrix:</span>
<span class="go">[1 1 1 1 1 1 1 1 1 1]),</span>
<span class="go">(-2, Vector space of degree 10 and dimension 4 over Rational Field</span>
<span class="go">User basis matrix:</span>
<span class="go">[ 1  0  0  0 -1 -1 -1  0  1  1]</span>
<span class="go">[ 0  1  0  0 -1  0 -2 -1  1  2]</span>
<span class="go">[ 0  0  1  0 -1  1 -1 -2  0  2]</span>
<span class="go">[ 0  0  0  1 -1  1  0 -1 -1  1]),</span>
<span class="go">(1, Vector space of degree 10 and dimension 5 over Rational Field</span>
<span class="go">User basis matrix:</span>
<span class="go">[ 1  0  0  0  0  1 -1  0  0 -1]</span>
<span class="go">[ 0  1  0  0  0 -1  1 -1  0  0]</span>
<span class="go">[ 0  0  1  0  0  0 -1  1 -1  0]</span>
<span class="go">[ 0  0  0  1  0  0  0 -1  1 -1]</span>
<span class="go">[ 0  0  0  0  1 -1  0  0 -1  1])</span>
<span class="go">]</span>
</pre></div>
</div>
<p>Eigenspaces for the Laplacian should be identical since the Petersen
graph is regular.  However, since the output also contains the
eigenvalues, the two outputs are slightly different:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">eigenspaces</span><span class="p">(</span><span class="n">laplacian</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[</span>
<span class="go">(0, Vector space of degree 10 and dimension 1 over Rational Field</span>
<span class="go">User basis matrix:</span>
<span class="go">[1 1 1 1 1 1 1 1 1 1]),</span>
<span class="go">(5, Vector space of degree 10 and dimension 4 over Rational Field</span>
<span class="go">User basis matrix:</span>
<span class="go">[ 1  0  0  0 -1 -1 -1  0  1  1]</span>
<span class="go">[ 0  1  0  0 -1  0 -2 -1  1  2]</span>
<span class="go">[ 0  0  1  0 -1  1 -1 -2  0  2]</span>
<span class="go">[ 0  0  0  1 -1  1  0 -1 -1  1]),</span>
<span class="go">(2, Vector space of degree 10 and dimension 5 over Rational Field</span>
<span class="go">User basis matrix:</span>
<span class="go">[ 1  0  0  0  0  1 -1  0  0 -1]</span>
<span class="go">[ 0  1  0  0  0 -1  1 -1  0  0]</span>
<span class="go">[ 0  0  1  0  0  0 -1  1 -1  0]</span>
<span class="go">[ 0  0  0  1  0  0  0 -1  1 -1]</span>
<span class="go">[ 0  0  0  0  1 -1  0  0 -1  1])</span>
<span class="go">]</span>
</pre></div>
</div>
<p>Notice how one eigenspace below is described with a square root of 2.
For the two possible values (positive and negative) there is a
corresponding eigenspace:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">eigenspaces</span><span class="p">()</span>
<span class="go">[</span>
<span class="go">(2, Vector space of degree 8 and dimension 1 over Rational Field</span>
<span class="go">User basis matrix:</span>
<span class="go">[1 1 1 1 1 1 1 1]),</span>
<span class="go">(-2, Vector space of degree 8 and dimension 1 over Rational Field</span>
<span class="go">User basis matrix:</span>
<span class="go">[ 1 -1  1 -1  1 -1  1 -1]),</span>
<span class="go">(0, Vector space of degree 8 and dimension 2 over Rational Field</span>
<span class="go">User basis matrix:</span>
<span class="go">[ 1  0 -1  0  1  0 -1  0]</span>
<span class="go">[ 0  1  0 -1  0  1  0 -1]),</span>
<span class="go">(a3, Vector space of degree 8 and dimension 2 over Number Field in a3 with defining polynomial x^2 - 2</span>
<span class="go">User basis matrix:</span>
<span class="go">[  1   0  -1 -a3  -1   0   1  a3]</span>
<span class="go">[  0   1  a3   1   0  -1 -a3  -1])</span>
<span class="go">]</span>
</pre></div>
</div>
<p>A digraph may have complex eigenvalues and eigenvectors. For a 3-cycle,
we have:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">eigenspaces</span><span class="p">()</span>
<span class="go">[</span>
<span class="go">(1, Vector space of degree 3 and dimension 1 over Rational Field</span>
<span class="go">User basis matrix:</span>
<span class="go">[1 1 1]),</span>
<span class="go">(a1, Vector space of degree 3 and dimension 1 over Number Field in a1 with defining polynomial x^2 + x + 1</span>
<span class="go">User basis matrix:</span>
<span class="go">[      1      a1 -a1 - 1])</span>
<span class="go">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.eigenvectors">
<span class="sig-name descname"><span class="pre">eigenvectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">laplacian</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.eigenvectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <em>right</em> eigenvectors of the adjacency matrix of the graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">laplacian</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, use the
Laplacian matrix (see <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.kirchhoff_matrix" title="sage.graphs.generic_graph.GenericGraph.kirchhoff_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kirchhoff_matrix()</span></code></a>)</p></li>
</ul>
<p>OUTPUT:</p>
<p>A list of triples.  Each triple begins with an eigenvalue of the
adjacency matrix of the graph.  This is followed by a list of
eigenvectors for the eigenvalue, when the eigenvectors are placed on the
right side of the matrix.  Together, the eigenvectors form a basis for
the eigenspace.  The triple concludes with the algebraic multiplicity of
the eigenvalue.</p>
<p>For some graphs, the exact eigenspaces provided by <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.eigenspaces" title="sage.graphs.generic_graph.GenericGraph.eigenspaces"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eigenspaces()</span></code></a>
provide additional insight into the structure of the eigenspaces.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">()</span>
<span class="go">[(3, [</span>
<span class="go">(1, 1, 1, 1, 1, 1, 1, 1, 1, 1)</span>
<span class="go">], 1), (-2, [</span>
<span class="go">(1, 0, 0, 0, -1, -1, -1, 0, 1, 1),</span>
<span class="go">(0, 1, 0, 0, -1, 0, -2, -1, 1, 2),</span>
<span class="go">(0, 0, 1, 0, -1, 1, -1, -2, 0, 2),</span>
<span class="go">(0, 0, 0, 1, -1, 1, 0, -1, -1, 1)</span>
<span class="go">], 4), (1, [</span>
<span class="go">(1, 0, 0, 0, 0, 1, -1, 0, 0, -1),</span>
<span class="go">(0, 1, 0, 0, 0, -1, 1, -1, 0, 0),</span>
<span class="go">(0, 0, 1, 0, 0, 0, -1, 1, -1, 0),</span>
<span class="go">(0, 0, 0, 1, 0, 0, 0, -1, 1, -1),</span>
<span class="go">(0, 0, 0, 0, 1, -1, 0, 0, -1, 1)</span>
<span class="go">], 5)]</span>
</pre></div>
</div>
<p>Eigenspaces for the Laplacian should be identical since the Petersen
graph is regular.  However, since the output also contains the
eigenvalues, the two outputs are slightly different:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">(</span><span class="n">laplacian</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(0, [</span>
<span class="go">(1, 1, 1, 1, 1, 1, 1, 1, 1, 1)</span>
<span class="go">], 1), (5, [</span>
<span class="go">(1, 0, 0, 0, -1, -1, -1, 0, 1, 1),</span>
<span class="go">(0, 1, 0, 0, -1, 0, -2, -1, 1, 2),</span>
<span class="go">(0, 0, 1, 0, -1, 1, -1, -2, 0, 2),</span>
<span class="go">(0, 0, 0, 1, -1, 1, 0, -1, -1, 1)</span>
<span class="go">], 4), (2, [</span>
<span class="go">(1, 0, 0, 0, 0, 1, -1, 0, 0, -1),</span>
<span class="go">(0, 1, 0, 0, 0, -1, 1, -1, 0, 0),</span>
<span class="go">(0, 0, 1, 0, 0, 0, -1, 1, -1, 0),</span>
<span class="go">(0, 0, 0, 1, 0, 0, 0, -1, 1, -1),</span>
<span class="go">(0, 0, 0, 0, 1, -1, 0, 0, -1, 1)</span>
<span class="go">], 5)]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">()</span>
<span class="go">[(2, [</span>
<span class="go">(1, 1, 1, 1, 1, 1, 1, 1)</span>
<span class="go">], 1), (-2, [</span>
<span class="go">(1, -1, 1, -1, 1, -1, 1, -1)</span>
<span class="go">], 1), (0, [</span>
<span class="go">(1, 0, -1, 0, 1, 0, -1, 0),</span>
<span class="go">(0, 1, 0, -1, 0, 1, 0, -1)</span>
<span class="go">], 2), (-1.4142135623..., [(1, 0, -1, 1.4142135623..., -1, 0, 1, -1.4142135623...), (0, 1, -1.4142135623..., 1, 0, -1, 1.4142135623..., -1)], 2), (1.4142135623..., [(1, 0, -1, -1.4142135623..., -1, 0, 1, 1.4142135623...), (0, 1, 1.4142135623..., 1, 0, -1, -1.4142135623..., -1)], 2)]</span>
</pre></div>
</div>
<p>A digraph may have complex eigenvalues. Previously, the complex parts of
graph eigenvalues were being dropped. For a 3-cycle, we have:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">0</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">()</span>
<span class="go">[(1, [</span>
<span class="go">(1, 1, 1)</span>
<span class="go">], 1), (-0.5000000000... - 0.8660254037...*I, [(1, -0.5000000000... - 0.8660254037...*I, -0.5000000000... + 0.8660254037...*I)], 1), (-0.5000000000... + 0.8660254037...*I, [(1, -0.5000000000... + 0.8660254037...*I, -0.5000000000... - 0.8660254037...*I)], 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.eulerian_circuit">
<span class="sig-name descname"><span class="pre">eulerian_circuit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.eulerian_circuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of edges forming an Eulerian circuit if one exists.</p>
<p>If no Eulerian circuit is found, the method returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>This is implemented using Hierholzer’s algorithm.</p>
<p>INPUT:</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">return_vertices</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); optionally</dt><dd><p>provide a list of vertices for the path</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether to return edges</dt><dd><p>with labels (3-tuples)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">path</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); find an Eulerian path</dt><dd><p>instead</p>
</dd>
</dl>
</li>
</ul>
<p>OUTPUT:</p>
<p>either ([edges], [vertices]) or [edges] of an Eulerian circuit (or path)</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">eulerian_circuit</span><span class="p">()</span>
<span class="go">[(0, 4, None), (4, 3, None), (3, 2, None), (2, 1, None), (1, 0, None)]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">eulerian_circuit</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(0, 4), (4, 3), (3, 2), (2, 1), (1, 0)]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">edges</span><span class="p">,</span> <span class="n">vertices</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">eulerian_circuit</span><span class="p">(</span><span class="n">return_vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">vertices</span>
<span class="go">[0, 6, 5, 4, 6, 3, 5, 2, 4, 3, 2, 6, 1, 5, 0, 4, 1, 3, 0, 2, 1, 0]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">eulerian_circuit</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A disconnected graph can be Eulerian:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[]})</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">eulerian_circuit</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(1, 3), (3, 2), (2, 1)]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">eulerian_circuit</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(0, 1), (1, 2), (2, 3), (3, 1), (1, 4)]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(0, 1)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">eulerian_circuit</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(1, 3), (3, 4), (4, 2), (2, 3), (3, 0), (0, 2), (2, 1), (1, 0)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.eulerian_orientation">
<span class="sig-name descname"><span class="pre">eulerian_orientation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.eulerian_orientation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a DiGraph which is an Eulerian orientation of the current graph.</p>
<p>An Eulerian graph being a graph such that any vertex has an even degree,
an Eulerian orientation of a graph is an orientation of its edges such
that each vertex <span class="math notranslate nohighlight">\(v\)</span> verifies <span class="math notranslate nohighlight">\(d^+(v)=d^-(v)=d(v)/2\)</span>, where <span class="math notranslate nohighlight">\(d^+\)</span> and
<span class="math notranslate nohighlight">\(d^-\)</span> respectively represent the out-degree and the in-degree of a
vertex.</p>
<p>If the graph is not Eulerian, the orientation verifies for any vertex
<span class="math notranslate nohighlight">\(v\)</span> that <span class="math notranslate nohighlight">\(| d^+(v)-d^-(v) | \leq 1\)</span>.</p>
<p>ALGORITHM:</p>
<p>This algorithm is a random walk through the edges of the graph, which
orients the edges according to the walk. When a vertex is reached which
has no non-oriented edge (this vertex must have odd degree), the walk
resumes at another vertex of odd degree, if any.</p>
<p>This algorithm has complexity <span class="math notranslate nohighlight">\(O(m)\)</span>, where <span class="math notranslate nohighlight">\(m\)</span> is the number of edges
in the graph.</p>
<p>EXAMPLES:</p>
<p>The CubeGraph with parameter 4, which is regular of even degree, has an
Eulerian orientation such that <span class="math notranslate nohighlight">\(d^+ = d^-\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]</span>
<span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">eulerian_orientation</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">in_degree</span><span class="p">()</span>
<span class="go">[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">out_degree</span><span class="p">()</span>
<span class="go">[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]</span>
</pre></div>
</div>
<p>Secondly, the Petersen Graph, which is 3 regular has an orientation such
that the difference between <span class="math notranslate nohighlight">\(d^+\)</span> and <span class="math notranslate nohighlight">\(d^-\)</span> is at most 1:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">eulerian_orientation</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">in_degree</span><span class="p">()</span>
<span class="go">[2, 2, 2, 2, 2, 1, 1, 1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">out_degree</span><span class="p">()</span>
<span class="go">[1, 1, 1, 1, 1, 2, 2, 2, 2, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.export_to_file">
<span class="sig-name descname"><span class="pre">export_to_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.export_to_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Export the graph to a file.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">filename</span></code> – string; a file name</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">format</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); select the output format
explicitly. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), the format is set to be the
file extension of <code class="docutils literal notranslate"><span class="pre">filename</span></code>. Admissible formats are: <code class="docutils literal notranslate"><span class="pre">adjlist</span></code>,
<code class="docutils literal notranslate"><span class="pre">dot</span></code>, <code class="docutils literal notranslate"><span class="pre">edgelist</span></code>, <code class="docutils literal notranslate"><span class="pre">gexf</span></code>, <code class="docutils literal notranslate"><span class="pre">gml</span></code>, <code class="docutils literal notranslate"><span class="pre">graphml</span></code>,
<code class="docutils literal notranslate"><span class="pre">multiline_adjlist</span></code>, <code class="docutils literal notranslate"><span class="pre">pajek</span></code>, <code class="docutils literal notranslate"><span class="pre">yaml</span></code>.</p></li>
<li><p>All other arguments are forwarded to the subfunction. For more
information, see their respective documentation:</p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">adjlist</span></code></p></td>
<td><p><a class="reference external" href="http://networkx.lanl.gov/reference/generated/networkx.readwrite.adjlist.write_adjlist.html">http://networkx.lanl.gov/reference/generated/networkx.readwrite.adjlist.write_adjlist.html</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">dot</span></code></p></td>
<td><p><a class="reference external" href="https://networkx.github.io/documentation/latest/reference/generated/networkx.drawing.nx_pydot.write_dot.html">https://networkx.github.io/documentation/latest/reference/generated/networkx.drawing.nx_pydot.write_dot.html</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">edgelist</span></code></p></td>
<td><p><a class="reference external" href="http://networkx.lanl.gov/reference/generated/networkx.readwrite.edgelist.write_edgelist.html">http://networkx.lanl.gov/reference/generated/networkx.readwrite.edgelist.write_edgelist.html</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">gexf</span></code></p></td>
<td><p><a class="reference external" href="http://networkx.lanl.gov/reference/generated/networkx.readwrite.gexf.write_gexf.html">http://networkx.lanl.gov/reference/generated/networkx.readwrite.gexf.write_gexf.html</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">gml</span></code></p></td>
<td><p><a class="reference external" href="http://networkx.lanl.gov/reference/generated/networkx.readwrite.gml.write_gml.html">http://networkx.lanl.gov/reference/generated/networkx.readwrite.gml.write_gml.html</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">graphml</span></code></p></td>
<td><p><a class="reference external" href="http://networkx.lanl.gov/reference/generated/networkx.readwrite.graphml.write_graphml.html">http://networkx.lanl.gov/reference/generated/networkx.readwrite.graphml.write_graphml.html</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">multiline_adjlist</span></code></p></td>
<td><p><a class="reference external" href="http://networkx.lanl.gov/reference/generated/networkx.readwrite.multiline_adjlist.write_multiline_adjlist.html">http://networkx.lanl.gov/reference/generated/networkx.readwrite.multiline_adjlist.write_multiline_adjlist.html</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">pajek</span></code></p></td>
<td><p><a class="reference external" href="http://networkx.lanl.gov/reference/generated/networkx.readwrite.pajek.write_pajek.html">http://networkx.lanl.gov/reference/generated/networkx.readwrite.pajek.write_pajek.html</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">yaml</span></code></p></td>
<td><p><a class="reference external" href="http://networkx.lanl.gov/reference/generated/networkx.readwrite.nx_yaml.write_yaml.html">http://networkx.lanl.gov/reference/generated/networkx.readwrite.nx_yaml.write_yaml.html</a></p></td>
</tr>
</tbody>
</table>
</li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference external" href="../../../structure/sage/structure/sage_object.html#sage.structure.sage_object.SageObject.save" title="(in Sage 9.5 Reference Manual: Parents and Elements v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> – save a Sage
object to a ‘sobj’ file (preserves all its attributes)</p></li>
</ul>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This functions uses the <code class="docutils literal notranslate"><span class="pre">write_*</span></code> functions defined in NetworkX
(see <a class="reference external" href="http://networkx.lanl.gov/reference/readwrite.html">http://networkx.lanl.gov/reference/readwrite.html</a>).</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">filename</span> <span class="o">=</span> <span class="n">tmp_filename</span><span class="p">(</span><span class="n">ext</span><span class="o">=</span><span class="s2">&quot;.pajek&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">export_to_file</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">networkx</span>
<span class="gp">sage: </span><span class="n">G_networkx</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">read_pajek</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">G_networkx</span><span class="p">)</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">filename</span> <span class="o">=</span> <span class="n">tmp_filename</span><span class="p">(</span><span class="n">ext</span><span class="o">=</span><span class="s2">&quot;.edgelist&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">export_to_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">networkx</span><span class="o">.</span><span class="n">read_edgelist</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.faces">
<span class="sig-name descname"><span class="pre">faces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">embedding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the faces of an embedded graph.</p>
<p>A combinatorial embedding of a graph is a clockwise ordering of the
neighbors of each vertex. From this information one can define the faces
of the embedding, which is what this method returns.</p>
<p>If no embedding is provided or stored as <code class="docutils literal notranslate"><span class="pre">self._embedding</span></code>, this
method will compute the set of faces from the embedding returned by
<a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_planar" title="sage.graphs.generic_graph.GenericGraph.is_planar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_planar()</span></code></a> (if the graph is, of course, planar).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This method is not well defined when the graph is not connected.
Indeed, the result may contain several faces corresponding to the
external face.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">embedding</span></code> – dictionary (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a combinatorial
embedding dictionary. Format: <code class="docutils literal notranslate"><span class="pre">{v1:</span> <span class="pre">[v2,v3],</span> <span class="pre">v2:</span> <span class="pre">[v1],</span> <span class="pre">v3:</span> <span class="pre">[v1]}</span></code>
(clockwise ordering of neighbors at each vertex). If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>
(default) the method will use the embedding stored as
<code class="docutils literal notranslate"><span class="pre">self._embedding</span></code>. If none is stored, the method will compute the
set of faces from the embedding returned by <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_planar" title="sage.graphs.generic_graph.GenericGraph.is_planar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_planar()</span></code></a> (if the
graph is, of course, planar).</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">embedding</span></code> is an ordered list based on the hash order of the
vertices of graph. To avoid confusion, it might be best to set the
rot_sys based on a ‘nice_copy’ of the graph.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.set_embedding" title="sage.graphs.generic_graph.GenericGraph.set_embedding"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_embedding()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.get_embedding" title="sage.graphs.generic_graph.GenericGraph.get_embedding"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_embedding()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_planar" title="sage.graphs.generic_graph.GenericGraph.is_planar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_planar()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.planar_dual" title="sage.graphs.generic_graph.GenericGraph.planar_dual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">planar_dual()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>Providing an embedding:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">TetrahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">faces</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
<span class="go">[[(0, 1), (1, 2), (2, 0)],</span>
<span class="go"> [(0, 2), (2, 3), (3, 0)],</span>
<span class="go"> [(0, 3), (3, 1), (1, 0)],</span>
<span class="go"> [(1, 3), (3, 2), (2, 1)]]</span>
</pre></div>
</div>
<p>With no embedding provided:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">TetrahedralGraph</span><span class="p">()</span><span class="o">.</span><span class="n">faces</span><span class="p">()</span>
<span class="go">[[(0, 1), (1, 2), (2, 0)],</span>
<span class="go"> [(0, 2), (2, 3), (3, 0)],</span>
<span class="go"> [(0, 3), (3, 1), (1, 0)],</span>
<span class="go"> [(1, 3), (3, 2), (2, 1)]]</span>
</pre></div>
</div>
<p>With no embedding provided (non-planar graph):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">faces</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: no embedding is provided and the graph is not planar</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.feedback_vertex_set">
<span class="sig-name descname"><span class="pre">feedback_vertex_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value_only</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraint_generation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.feedback_vertex_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum feedback vertex set of a (di)graph.</p>
<p>The minimum feedback vertex set of a (di)graph is a set of vertices that
intersect all of its cycles.  Equivalently, a minimum feedback vertex
set of a (di)graph is a set <span class="math notranslate nohighlight">\(S\)</span> of vertices such that the digraph <span class="math notranslate nohighlight">\(G-S\)</span>
is acyclic. For more information, see the
<a class="reference external" href="https://en.wikipedia.org/wiki/Feedback_vertex_set">Wikipedia article Feedback_vertex_set</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">value_only</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return only
the minimum cardinal of a minimum vertex set, or the <code class="docutils literal notranslate"><span class="pre">Set</span></code> of
vertices of a minimal feedback vertex set</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">constraint_generation</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether to
use constraint generation when solving the Mixed Integer Linear
Program</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>ALGORITHMS:</p>
<p>(Constraints generation)</p>
<p>When the parameter <code class="docutils literal notranslate"><span class="pre">constraint_generation</span></code> is enabled (default) the
following MILP formulation is used to solve the problem:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mbox{Minimize : }&amp;\sum_{v\in G} b_{v}\\
\mbox{Such that : }&amp;\\
&amp;\forall C\text{ circuits }\subseteq G, \sum_{v\in C}b_{v}\geq 1\\\end{split}\]</div>
<p>As the number of circuits contained in a graph is exponential, this LP
is solved through constraint generation. This means that the solver is
sequentially asked to solve the problem, knowing only a portion of the
circuits contained in <span class="math notranslate nohighlight">\(G\)</span>, each time adding to the list of its
constraints the circuit which its last answer had left intact.</p>
<p>(Another formulation based on an ordering of the vertices)</p>
<p>When the graph is directed, a second (and very slow) formulation is
available, which should only be used to check the result of the first
implementation in case of doubt.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mbox{Minimize : }&amp;\sum_{v\in G} b_v\\
\mbox{Such that : }&amp;\\
&amp;\forall (u,v)\in G, d_u-d_v+nb_u+nb_v\geq 0\\
&amp;\forall u\in G, 0\leq d_u\leq |G|\\\end{split}\]</div>
<p>A brief explanation:</p>
<p>An acyclic digraph can be seen as a poset, and every poset has a linear
extension. This means that in any acyclic digraph the vertices can be
ordered with a total order <span class="math notranslate nohighlight">\(&lt;\)</span> in such a way that if <span class="math notranslate nohighlight">\((u,v)\in G\)</span>, then
<span class="math notranslate nohighlight">\(u&lt;v\)</span>.  Thus, this linear program is built in order to assign to each
vertex <span class="math notranslate nohighlight">\(v\)</span> a number <span class="math notranslate nohighlight">\(d_v\in [0,\dots,n-1]\)</span> such that if there exists an
edge <span class="math notranslate nohighlight">\((u,v)\in G\)</span> then either <span class="math notranslate nohighlight">\(d_v&lt;d_u\)</span> or one of <span class="math notranslate nohighlight">\(u\)</span> or <span class="math notranslate nohighlight">\(v\)</span> is removed.
The number of vertices removed is then minimized, which is the
objective.</p>
<p>EXAMPLES:</p>
<p>The necessary example:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">fvs</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">feedback_vertex_set</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">fvs</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">delete_vertices</span><span class="p">(</span><span class="n">fvs</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_forest</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In a digraph built from a graph, any edge is replaced by arcs going in
the two opposite directions, thus creating a cycle of length two.
Hence, to remove all the cycles from the graph, each edge must see one
of its neighbors removed: a feedback vertex set is in this situation a
vertex cover:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cycle</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">dcycle</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">cycle</span><span class="o">.</span><span class="n">vertex_cover</span><span class="p">(</span><span class="n">value_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">feedback</span> <span class="o">=</span> <span class="n">dcycle</span><span class="o">.</span><span class="n">feedback_vertex_set</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">feedback</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">cycle</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">u</span> <span class="ow">in</span> <span class="n">feedback</span> <span class="ow">or</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">feedback</span>
<span class="go">True</span>
</pre></div>
</div>
<p>For a circuit, the minimum feedback arc set is clearly <span class="math notranslate nohighlight">\(1\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">circuit</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">circuit</span><span class="o">.</span><span class="n">feedback_vertex_set</span><span class="p">(</span><span class="n">value_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.flow">
<span class="sig-name descname"><span class="pre">flow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_only</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_edge_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.flow" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a maximum flow in the graph from <code class="docutils literal notranslate"><span class="pre">x</span></code> to <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
<p>The returned flow is represented by an optimal valuation of the edges.
For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Max_flow">Wikipedia article Max_flow</a>.</p>
<p>As an optimization problem, is can be expressed this way :</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mbox{Maximize : }&amp;\sum_{e\in G.edges()} w_e b_e\\
\mbox{Such that : }&amp;\forall v \in G, \sum_{(u,v)\in G.edges()} b_{(u,v)}\leq 1\\
&amp;\forall x\in G, b_x\mbox{ is a binary variable}\end{split}\]</div>
<p>Observe that the integrality of the flow variables is automatic for all
available solvers when all capacities are integers.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – source vertex</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">y</span></code> – sink vertex</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value_only</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether to return only
the value of a maximal flow, or to also return a flow graph (a copy of
the current graph, such that each edge has the flow using it as a
label, the edges without flow being omitted)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integer</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether to compute an
optimal solution under the constraint that the flow going through an
edge has to be an integer, or without this constraint</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">use_edge_labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to
compute a maximum flow where each edge has a capacity defined by its
label (if an edge has no label, capacity <span class="math notranslate nohighlight">\(1\)</span> is assumed), or to use
default edge capacity of <span class="math notranslate nohighlight">\(1\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertex_bound</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); when set to
<code class="docutils literal notranslate"><span class="pre">True</span></code>, sets the maximum flow leaving a vertex different from <span class="math notranslate nohighlight">\(x\)</span> to
<span class="math notranslate nohighlight">\(1\)</span> (useful for vertex connectivity parameters)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the algorithm to use
among:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;FF&quot;</span></code>, a Python implementation of the Ford-Fulkerson algorithm
(only available when <code class="docutils literal notranslate"><span class="pre">vertex_bound</span> <span class="pre">=</span> <span class="pre">False</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;LP&quot;</span></code>, the flow problem is solved using Linear Programming</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;igraph&quot;</span></code>, the <code class="docutils literal notranslate"><span class="pre">igraph</span></code> implementation of the Goldberg-Tarjan
algorithm is used (only available when <code class="docutils literal notranslate"><span class="pre">igraph</span></code> is installed and
<code class="docutils literal notranslate"><span class="pre">vertex_bound</span> <span class="pre">=</span> <span class="pre">False</span></code>)</p></li>
</ul>
<p>When <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">None</span></code> (default), we use <code class="docutils literal notranslate"><span class="pre">LP</span></code> if <code class="docutils literal notranslate"><span class="pre">vertex_bound</span> <span class="pre">=</span>
<span class="pre">True</span></code>, otherwise, we use <code class="docutils literal notranslate"><span class="pre">igraph</span></code> if it is available, <code class="docutils literal notranslate"><span class="pre">FF</span></code> if it
is not available.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p>
<p>Only useful when algorithm <code class="docutils literal notranslate"><span class="pre">&quot;LP&quot;</span></code> is used to solve the flow problem.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p>
<p>Only useful when algorithm <code class="docutils literal notranslate"><span class="pre">&quot;LP&quot;</span></code> is used to solve the flow problem.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p>
<p>Only useful when <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">==</span> <span class="pre">&quot;LP&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">integer</span> <span class="pre">==</span> <span class="pre">True</span></code>.</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Even though the three different implementations are meant to return
the same Flow values, they cannot be expected to return the same
Flow graphs.</p>
<p>Besides, the use of Linear Programming may possibly mean a (slight)
numerical noise.</p>
</div>
<p>EXAMPLES:</p>
<p>Two basic applications of the flow method for the <code class="docutils literal notranslate"><span class="pre">PappusGraph</span></code> and the
<code class="docutils literal notranslate"><span class="pre">ButterflyGraph</span></code> with parameter <span class="math notranslate nohighlight">\(2\)</span></p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">PappusGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">int</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">flow</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="go">3</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">b</span><span class="o">=</span><span class="n">digraphs</span><span class="o">.</span><span class="n">ButterflyGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">flow</span><span class="p">((</span><span class="s1">&#39;00&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;00&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
<span class="go">1</span>
</pre></div>
</div>
<p>The flow method can be used to compute a matching in a bipartite graph
by linking a source <span class="math notranslate nohighlight">\(s\)</span> to all the vertices of the first set and linking
a sink <span class="math notranslate nohighlight">\(t\)</span> to all the vertices of the second set, then computing
a maximum <span class="math notranslate nohighlight">\(s-t\)</span> flow</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">((</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">((</span><span class="mi">4</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">cardinal</span><span class="p">,</span> <span class="n">flow_graph</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">flow</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">value_only</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">flow_graph</span><span class="o">.</span><span class="n">delete_vertices</span><span class="p">([</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">flow_graph</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
<p>The undirected case:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">((</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">((</span><span class="mi">4</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">cardinal</span><span class="p">,</span> <span class="n">flow_graph</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">flow</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">value_only</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">flow_graph</span><span class="o">.</span><span class="n">delete_vertices</span><span class="p">([</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">flow_graph</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.genus">
<span class="sig-name descname"><span class="pre">genus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">set_embedding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">on_embedding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minimal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">circular</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ordered</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.genus" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimal genus of the graph.</p>
<p>The genus of a compact surface is the number of handles it has. The
genus of a graph is the minimal genus of the surface it can be embedded
into. It can be seen as a measure of non-planarity; a planar graph has
genus zero.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function uses Euler’s formula and thus it is necessary to
consider only connected graphs.</p>
</div>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">set_embedding</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether or not to
store an embedding attribute of the computed (minimal) genus of the
graph</p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">on_embedding</span></code> – two kinds of input are allowed (default:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">None</span></code>):</p>
</dd>
</dl>
<ul class="simple">
<li><p>a dictionary representing a combinatorial embedding on which the
genus should be computed. Note that this must be a valid embedding
for the graph. The dictionary structure is given by: <code class="docutils literal notranslate"><span class="pre">vertex1:</span>
<span class="pre">[neighbor1,</span> <span class="pre">neighbor2,</span> <span class="pre">neighbor3],</span> <span class="pre">vertex2:</span> <span class="pre">[neighbor]</span></code> where there
is a key for each vertex in the graph and a (clockwise) ordered list
of each vertex’s neighbors as values. The value of <code class="docutils literal notranslate"><span class="pre">on_embedding</span></code>
takes precedence over a stored <code class="docutils literal notranslate"><span class="pre">_embedding</span></code> attribute if
<code class="docutils literal notranslate"><span class="pre">minimal</span></code> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p>The value <code class="docutils literal notranslate"><span class="pre">True</span></code>, in order to indicate that the embedding stored
as <code class="docutils literal notranslate"><span class="pre">_embedding</span></code> should be used (see examples).</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">minimal</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether or not to compute
the minimal genus of the graph (i.e., testing all embeddings). If
minimal is <code class="docutils literal notranslate"><span class="pre">False</span></code>, then either <code class="docutils literal notranslate"><span class="pre">maximal</span></code> must be <code class="docutils literal notranslate"><span class="pre">True</span></code> or
<code class="docutils literal notranslate"><span class="pre">on_embedding</span></code> must not be <code class="docutils literal notranslate"><span class="pre">None</span></code>. If <code class="docutils literal notranslate"><span class="pre">on_embedding</span></code> is not
<code class="docutils literal notranslate"><span class="pre">None</span></code>, it will take priority over <code class="docutils literal notranslate"><span class="pre">minimal</span></code>. Similarly, if
<code class="docutils literal notranslate"><span class="pre">maximal</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, it will take priority over <code class="docutils literal notranslate"><span class="pre">minimal</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">maximal</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether or not to compute
the maximal genus of the graph (i.e., testing all embeddings). If
<code class="docutils literal notranslate"><span class="pre">maximal</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, then either <code class="docutils literal notranslate"><span class="pre">minimal</span></code> must be <code class="docutils literal notranslate"><span class="pre">True</span></code> or
<code class="docutils literal notranslate"><span class="pre">on_embedding</span></code> must not be <code class="docutils literal notranslate"><span class="pre">None</span></code>. If <code class="docutils literal notranslate"><span class="pre">on_embedding</span></code> is not
<code class="docutils literal notranslate"><span class="pre">None</span></code>, it will take priority over <code class="docutils literal notranslate"><span class="pre">maximal</span></code>. However, <code class="docutils literal notranslate"><span class="pre">maximal</span></code>
takes priority over the default <code class="docutils literal notranslate"><span class="pre">minimal</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">circular</span></code> – list (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); if <code class="docutils literal notranslate"><span class="pre">circular</span></code> is a list of
vertices, the method computes the genus preserving a planar embedding
of the this list. If <code class="docutils literal notranslate"><span class="pre">circular</span></code> is defined, <code class="docutils literal notranslate"><span class="pre">on_embedding</span></code> is not
a valid option.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ordered</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">circular</span></code> is
<code class="docutils literal notranslate"><span class="pre">True</span></code>, then whether or not the boundary order may be permuted
(default is <code class="docutils literal notranslate"><span class="pre">True</span></code>, which means the boundary order is preserved)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span> <span class="c1"># tests for minimal genus by default</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">genus</span><span class="p">(</span><span class="n">on_embedding</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">maximal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># on_embedding overrides minimal and maximal arguments</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">genus</span><span class="p">(</span><span class="n">maximal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># setting maximal to True overrides default minimal=True</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">genus</span><span class="p">(</span><span class="n">on_embedding</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">get_embedding</span><span class="p">())</span> <span class="c1"># can also send a valid combinatorial embedding dict</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">K23</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K23</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">K33</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K33</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Using the circular argument, we can compute the minimal genus preserving
a planar, ordered boundary:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cube</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">cube</span><span class="o">.</span><span class="n">genus</span><span class="p">(</span><span class="n">circular</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;01&#39;</span><span class="p">,</span><span class="s1">&#39;10&#39;</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">cube</span><span class="o">.</span><span class="n">is_circular_planar</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">cube</span><span class="o">.</span><span class="n">genus</span><span class="p">(</span><span class="n">circular</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;01&#39;</span><span class="p">,</span><span class="s1">&#39;10&#39;</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">cube</span><span class="o">.</span><span class="n">genus</span><span class="p">(</span><span class="n">circular</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;01&#39;</span><span class="p">,</span><span class="s1">&#39;10&#39;</span><span class="p">],</span> <span class="n">on_embedding</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: on_embedding is not a valid option when circular is defined</span>
<span class="gp">sage: </span><span class="n">cube</span><span class="o">.</span><span class="n">genus</span><span class="p">(</span><span class="n">circular</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;01&#39;</span><span class="p">,</span><span class="s1">&#39;10&#39;</span><span class="p">],</span> <span class="n">maximal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">NotImplementedError: cannot compute the maximal genus of a genus respecting a boundary</span>
</pre></div>
</div>
<p>Note: not everything works for multigraphs, looped graphs or digraphs.
But the minimal genus is ultimately computable for every connected graph
– but the embedding we obtain for the simple graph can’t be easily
converted to an embedding of a non-simple graph.  Also, the maximal
genus of a multigraph does not trivially correspond to that of its
simple graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">NotImplementedError: cannot work with embeddings of non-simple graphs</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">to_simple</span><span class="p">()</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">genus</span><span class="p">(</span><span class="n">set_embedding</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">genus</span><span class="p">(</span><span class="n">maximal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">set_embedding</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">NotImplementedError: cannot compute the maximal genus of a graph with loops or multiple edges</span>
</pre></div>
</div>
<p>We break graphs with cut vertices into their blocks, which greatly
speeds up computation of minimal genus. This is not implemented for
maximal genus:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomBlockGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span>
<span class="go">10</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.get_embedding">
<span class="sig-name descname"><span class="pre">get_embedding</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.get_embedding" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the attribute <code class="docutils literal notranslate"><span class="pre">_embedding</span></code> if it exists.</p>
<p><code class="docutils literal notranslate"><span class="pre">_embedding</span></code> is a dictionary organized with vertex labels as keys and
a list of each vertex’s neighbors in clockwise order.</p>
<p>Error-checked to insure valid embedding is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">get_embedding</span><span class="p">()</span>
<span class="go">{0: [1, 4, 5], 1: [0, 2, 6], 2: [1, 3, 7], 3: [2, 4, 8], 4: [0, 3, 9], 5: [0, 7, 8], 6: [1, 9, 8], 7: [2, 5, 9], 8: [3, 6, 5], 9: [4, 6, 7]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.get_pos">
<span class="sig-name descname"><span class="pre">get_pos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.get_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the position dictionary.</p>
<p>The position dictionary specifies the coordinates of each vertex.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dim</span></code> – integer (default: 2); whether to return the position
dictionary in the plane (<code class="docutils literal notranslate"><span class="pre">dim</span> <span class="pre">==</span> <span class="pre">2</span></code>) or in the 3-dimensional space</p></li>
</ul>
<p>EXAMPLES:</p>
<p>By default, the position of a graph is None:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">get_pos</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">get_pos</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">save_pos</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">get_pos</span><span class="p">()</span>
<span class="go">{}</span>
</pre></div>
</div>
<p>Some of the named graphs come with a pre-specified positioning:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">get_pos</span><span class="p">()</span>
<span class="go">{0: (0.0, 1.0),</span>
<span class="go"> ...</span>
<span class="go"> 9: (0.475..., 0.154...)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.get_vertex">
<span class="sig-name descname"><span class="pre">get_vertex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertex</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.get_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the object associated with a given vertex.</p>
<p>If no associated object is found, <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertex</span></code> – the given vertex</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">(),</span> <span class="mi">1</span><span class="p">:</span> <span class="n">graphs</span><span class="o">.</span><span class="n">FlowerSnark</span><span class="p">(),</span> <span class="mi">2</span><span class="p">:</span> <span class="n">graphs</span><span class="o">.</span><span class="n">MoebiusKantorGraph</span><span class="p">(),</span> <span class="mi">3</span><span class="p">:</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()}</span>
<span class="gp">sage: </span><span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">Moebius-Kantor Graph: Graph on 16 vertices</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">TetrahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">set_vertices</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">get_vertex</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Flower Snark: Graph on 20 vertices</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.get_vertices">
<span class="sig-name descname"><span class="pre">get_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.get_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary of the objects associated to each vertex.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">verts</span></code> – iterable container of vertices</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">(),</span> <span class="mi">1</span><span class="p">:</span> <span class="n">graphs</span><span class="o">.</span><span class="n">FlowerSnark</span><span class="p">(),</span> <span class="mi">2</span><span class="p">:</span> <span class="n">graphs</span><span class="o">.</span><span class="n">MoebiusKantorGraph</span><span class="p">(),</span> <span class="mi">3</span><span class="p">:</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()}</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">TetrahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">set_vertices</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">get_vertices</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">{1: Flower Snark: Graph on 20 vertices,</span>
<span class="go"> 2: Moebius-Kantor Graph: Graph on 16 vertices}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.girth">
<span class="sig-name descname"><span class="pre">girth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.girth" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the girth of the graph.</p>
<p>The girth is the length of the shortest cycle in the graph
(directed cycle if the graph is directed). Graphs without
(directed) cycles have infinite girth.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return
<code class="docutils literal notranslate"><span class="pre">(g,</span> <span class="pre">c)</span></code>, where <code class="docutils literal notranslate"><span class="pre">g</span></code> is the girth and <code class="docutils literal notranslate"><span class="pre">c</span></code> is a list
of vertices of a (directed) cycle of length <code class="docutils literal notranslate"><span class="pre">g</span></code> in the graph,
thus providing a certificate that the girth is at most <code class="docutils literal notranslate"><span class="pre">g</span></code>,
or <code class="docutils literal notranslate"><span class="pre">None</span></code> if <code class="docutils literal notranslate"><span class="pre">g</span></code>  infinite</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">TetrahedralGraph</span><span class="p">()</span><span class="o">.</span><span class="n">girth</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">girth</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">girth</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># random</span>
<span class="go">(5, [4, 3, 2, 1, 0])</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">HeawoodGraph</span><span class="p">()</span><span class="o">.</span><span class="n">girth</span><span class="p">()</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">trees</span><span class="p">(</span><span class="mi">9</span><span class="p">))</span><span class="o">.</span><span class="n">girth</span><span class="p">()</span>
<span class="go">+Infinity</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.odd_girth" title="sage.graphs.generic_graph.GenericGraph.odd_girth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">odd_girth()</span></code></a> – return the odd girth
of the graph.</p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.graphplot">
<span class="sig-name descname"><span class="pre">graphplot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.graphplot" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <a class="reference internal" href="graph_plot.html#sage.graphs.graph_plot.GraphPlot" title="sage.graphs.graph_plot.GraphPlot"><code class="xref py py-class docutils literal notranslate"><span class="pre">GraphPlot</span></code></a> object.</p>
<p>See <a class="reference internal" href="graph_plot.html#sage.graphs.graph_plot.GraphPlot" title="sage.graphs.graph_plot.GraphPlot"><code class="xref py py-class docutils literal notranslate"><span class="pre">GraphPlot</span></code></a> for more details.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">**options</span></code> – parameters for the
<a class="reference internal" href="graph_plot.html#sage.graphs.graph_plot.GraphPlot" title="sage.graphs.graph_plot.GraphPlot"><code class="xref py py-class docutils literal notranslate"><span class="pre">GraphPlot</span></code></a> constructor</p></li>
</ul>
<p>EXAMPLES:</p>
<p>Creating a <a class="reference internal" href="graph_plot.html#sage.graphs.graph_plot.GraphPlot" title="sage.graphs.graph_plot.GraphPlot"><code class="xref py py-class docutils literal notranslate"><span class="pre">GraphPlot</span></code></a> object uses the
same options as <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.plot" title="sage.graphs.generic_graph.GenericGraph.plot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot()</span></code></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({},</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">),</span>
<span class="gp">....: </span>    <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;e&#39;</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;f&#39;</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;f&#39;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;g&#39;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;h&#39;</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">GP</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">graphplot</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">color_by_label</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">edge_style</span><span class="o">=</span><span class="s1">&#39;dashed&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">GP</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="go">Graphics object consisting of 22 graphics primitives</span>
</pre></div>
</div>
<p>We can modify the <a class="reference internal" href="graph_plot.html#sage.graphs.graph_plot.GraphPlot" title="sage.graphs.graph_plot.GraphPlot"><code class="xref py py-class docutils literal notranslate"><span class="pre">GraphPlot</span></code></a> object.
Notice that the changes are cumulative:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">GP</span><span class="o">.</span><span class="n">set_edges</span><span class="p">(</span><span class="n">edge_style</span><span class="o">=</span><span class="s1">&#39;solid&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">GP</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="go">Graphics object consisting of 22 graphics primitives</span>
<span class="gp">sage: </span><span class="n">GP</span><span class="o">.</span><span class="n">set_vertices</span><span class="p">(</span><span class="n">talk</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">GP</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="go">Graphics object consisting of 22 graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.graphviz_string">
<span class="sig-name descname"><span class="pre">graphviz_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'string'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_by_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rankdir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'down'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subgraph_clusters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.graphviz_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a representation in the <code class="docutils literal notranslate"><span class="pre">dot</span></code> language.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">dot</span></code> language is a text based format for graphs. It is used by
the software suite <code class="docutils literal notranslate"><span class="pre">graphviz</span></code>. The specifications of the language are
available on the web (see the reference <a class="reference internal" href="../../../references/index.html#dotspec" id="id15"><span>[dotspec]</span></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">labels</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">&quot;string&quot;</span></code>); either <code class="docutils literal notranslate"><span class="pre">&quot;string&quot;</span></code> or
<code class="docutils literal notranslate"><span class="pre">&quot;latex&quot;</span></code>. If labels is <code class="docutils literal notranslate"><span class="pre">&quot;string&quot;</span></code>, latex commands are not
interpreted. This option stands for both vertex labels and edge
labels.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertex_labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether to add the
labels on vertices</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edge_labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to add the
labels on edges</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edge_color</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a default color for the
edges. The color could be one of</p>
<ul>
<li><p>a name given as a string such as <code class="docutils literal notranslate"><span class="pre">&quot;blue&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;orchid&quot;</span></code></p></li>
<li><p>a HSV sequence in a string such as <code class="docutils literal notranslate"><span class="pre">&quot;.52,.386,.22&quot;</span></code></p></li>
<li><p>an hexadecimal code such as <code class="docutils literal notranslate"><span class="pre">&quot;#DA3305&quot;</span></code></p></li>
<li><p>a 3-tuple of floating point (to be interpreted as RGB tuple). In
this case the 3-tuple is converted in hexadecimal code.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">edge_colors</span></code> – dictionary (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a dictionary whose
keys are colors and values are list of edges. The list of edges need
not to be complete in which case the default color is used. See the
option <code class="docutils literal notranslate"><span class="pre">edge_color</span></code> for a description of valid color formats.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">color_by_label</span></code> – a boolean or dictionary or function (default:
<code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to color each edge with a different color
according to its label; the colors are chosen along a rainbow, unless
they are specified by a function or dictionary mapping labels to
colors; this option is incompatible with <code class="docutils literal notranslate"><span class="pre">edge_color</span></code> and
<code class="docutils literal notranslate"><span class="pre">edge_colors</span></code>.  See the option <code class="docutils literal notranslate"><span class="pre">edge_color</span></code> for a description of
valid color formats.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edge_options</span></code> – a function (or tuple thereof) mapping edges to a
dictionary of options for this edge</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rankdir</span></code> – <code class="docutils literal notranslate"><span class="pre">'left'</span></code>, <code class="docutils literal notranslate"><span class="pre">'right'</span></code>, <code class="docutils literal notranslate"><span class="pre">'up'</span></code>, or <code class="docutils literal notranslate"><span class="pre">'down'</span></code>
(default: <code class="docutils literal notranslate"><span class="pre">'down'</span></code>, for consistency with <code class="docutils literal notranslate"><span class="pre">graphviz</span></code>): the
preferred ranking direction for acyclic layouts; see the <code class="docutils literal notranslate"><span class="pre">rankdir</span></code>
option of <code class="docutils literal notranslate"><span class="pre">graphviz</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">subgraph_clusters</span></code> – a list of lists of vertices (default:
<code class="docutils literal notranslate"><span class="pre">[]</span></code>); From <a class="reference internal" href="../../../references/index.html#dotspec" id="id16"><span>[dotspec]</span></a>: “If supported, the layout engine will do the
layout so that the nodes belonging to the cluster are drawn together,
with the entire drawing of the cluster contained within a bounding
rectangle. Note that, for good and bad, cluster subgraphs are not part
of the <code class="docutils literal notranslate"><span class="pre">dot</span></code> language, but solely a syntactic convention adhered to
by certain of the layout engines.”</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span> <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">},</span> <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">}},</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">graphviz_string</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">graph {</span>
<span class="go">  node_0  [label=&quot;0&quot;];</span>
<span class="go">  node_1  [label=&quot;1&quot;];</span>
<span class="go">  node_2  [label=&quot;2&quot;];</span>
<span class="go">  node_3  [label=&quot;3&quot;];</span>

<span class="go">  node_0 -- node_1;</span>
<span class="go">  node_0 -- node_2;</span>
<span class="go">  node_1 -- node_2;</span>
<span class="go">  node_2 -- node_3 [label=&quot;foo&quot;];</span>
<span class="go">}</span>
</pre></div>
</div>
<p>A variant, with the labels in latex, for post-processing with
<code class="docutils literal notranslate"><span class="pre">dot2tex</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">graphviz_string</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="s2">&quot;latex&quot;</span><span class="p">))</span>
<span class="go">graph {</span>
<span class="go">  node [shape=&quot;plaintext&quot;];</span>
<span class="go">  node_0  [label=&quot; &quot;, texlbl=&quot;$0$&quot;];</span>
<span class="go">  node_1  [label=&quot; &quot;, texlbl=&quot;$1$&quot;];</span>
<span class="go">  node_2  [label=&quot; &quot;, texlbl=&quot;$2$&quot;];</span>
<span class="go">  node_3  [label=&quot; &quot;, texlbl=&quot;$3$&quot;];</span>

<span class="go">  node_0 -- node_1;</span>
<span class="go">  node_0 -- node_2;</span>
<span class="go">  node_1 -- node_2;</span>
<span class="go">  node_2 -- node_3 [label=&quot; &quot;, texlbl=&quot;$\text{\texttt{foo}}$&quot;];</span>
<span class="go">}</span>
</pre></div>
</div>
<p>Same, with a digraph and a color for edges:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span> <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">3</span><span class="p">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">},</span> <span class="mi">3</span><span class="p">:</span> <span class="p">{}},</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">graphviz_string</span><span class="p">(</span><span class="n">edge_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">))</span>
<span class="go">digraph {</span>
<span class="go">  node_0  [label=&quot;0&quot;];</span>
<span class="go">  node_1  [label=&quot;1&quot;];</span>
<span class="go">  node_2  [label=&quot;2&quot;];</span>
<span class="go">  node_3  [label=&quot;3&quot;];</span>

<span class="go">edge [color=&quot;red&quot;];</span>
<span class="go">  node_0 -&gt; node_1;</span>
<span class="go">  node_0 -&gt; node_2;</span>
<span class="go">  node_1 -&gt; node_2;</span>
<span class="go">  node_2 -&gt; node_3;</span>
<span class="go">}</span>
</pre></div>
</div>
<p>A digraph using latex labels for vertices and edges:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="n">x</span>                                                             <span class="c1"># optional - sage.symbolic</span>
<span class="gp">sage: </span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>                                                        <span class="c1"># optional - sage.symbolic</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">()</span>                                                             <span class="c1"># optional - sage.symbolic</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">))</span>                       <span class="c1"># optional - sage.symbolic</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">g</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">))</span>                       <span class="c1"># optional - sage.symbolic</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">graphviz_string</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="s2">&quot;latex&quot;</span><span class="p">,</span> <span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>  <span class="c1"># random      # optional - sage.symbolic</span>
<span class="go">digraph {</span>
<span class="go">  node [shape=&quot;plaintext&quot;];</span>
<span class="go">  node_10  [label=&quot; &quot;, texlbl=&quot;$1$&quot;];</span>
<span class="go">  node_11  [label=&quot; &quot;, texlbl=&quot;$2$&quot;];</span>
<span class="go">  node_3  [label=&quot; &quot;, texlbl=&quot;$-\frac{1}{2}$&quot;];</span>
<span class="go">  node_6  [label=&quot; &quot;, texlbl=&quot;$\frac{1}{2}$&quot;];</span>
<span class="go">  node_7  [label=&quot; &quot;, texlbl=&quot;$\frac{1}{2}$&quot;];</span>
<span class="go">  node_5  [label=&quot; &quot;, texlbl=&quot;$\frac{1}{3}$&quot;];</span>
<span class="go">  node_8  [label=&quot; &quot;, texlbl=&quot;$\frac{2}{3}$&quot;];</span>
<span class="go">  node_4  [label=&quot; &quot;, texlbl=&quot;$\frac{1}{4}$&quot;];</span>
<span class="go">  node_1  [label=&quot; &quot;, texlbl=&quot;$-2$&quot;];</span>
<span class="go">  node_9  [label=&quot; &quot;, texlbl=&quot;$\frac{4}{5}$&quot;];</span>
<span class="go">  node_0  [label=&quot; &quot;, texlbl=&quot;$-4$&quot;];</span>
<span class="go">  node_2  [label=&quot; &quot;, texlbl=&quot;$-1$&quot;];</span>

<span class="go">  node_10 -&gt; node_2 [label=&quot; &quot;, texlbl=&quot;$x \ {\mapsto}\ -\frac{1}{x}$&quot;];</span>
<span class="go">  node_10 -&gt; node_6 [label=&quot; &quot;, texlbl=&quot;$x \ {\mapsto}\ \frac{1}{x + 1}$&quot;];</span>
<span class="go">  node_11 -&gt; node_3 [label=&quot; &quot;, texlbl=&quot;$x \ {\mapsto}\ -\frac{1}{x}$&quot;];</span>
<span class="go">  node_11 -&gt; node_5 [label=&quot; &quot;, texlbl=&quot;$x \ {\mapsto}\ \frac{1}{x + 1}$&quot;];</span>
<span class="go">  node_7 -&gt; node_1 [label=&quot; &quot;, texlbl=&quot;$x \ {\mapsto}\ -\frac{1}{x}$&quot;];</span>
<span class="go">  node_7 -&gt; node_8 [label=&quot; &quot;, texlbl=&quot;$x \ {\mapsto}\ \frac{1}{x + 1}$&quot;];</span>
<span class="go">  node_4 -&gt; node_0 [label=&quot; &quot;, texlbl=&quot;$x \ {\mapsto}\ -\frac{1}{x}$&quot;];</span>
<span class="go">  node_4 -&gt; node_9 [label=&quot; &quot;, texlbl=&quot;$x \ {\mapsto}\ \frac{1}{x + 1}$&quot;];</span>
<span class="go">}</span>

<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">graphviz_string</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="s2">&quot;latex&quot;</span><span class="p">,</span> <span class="n">color_by_label</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>  <span class="c1"># random   # optional - sage.symbolic</span>
<span class="go">digraph {</span>
<span class="go">  node [shape=&quot;plaintext&quot;];</span>
<span class="go">  node_10  [label=&quot; &quot;, texlbl=&quot;$1$&quot;];</span>
<span class="go">  node_11  [label=&quot; &quot;, texlbl=&quot;$2$&quot;];</span>
<span class="go">  node_3  [label=&quot; &quot;, texlbl=&quot;$-\frac{1}{2}$&quot;];</span>
<span class="go">  node_6  [label=&quot; &quot;, texlbl=&quot;$\frac{1}{2}$&quot;];</span>
<span class="go">  node_7  [label=&quot; &quot;, texlbl=&quot;$\frac{1}{2}$&quot;];</span>
<span class="go">  node_5  [label=&quot; &quot;, texlbl=&quot;$\frac{1}{3}$&quot;];</span>
<span class="go">  node_8  [label=&quot; &quot;, texlbl=&quot;$\frac{2}{3}$&quot;];</span>
<span class="go">  node_4  [label=&quot; &quot;, texlbl=&quot;$\frac{1}{4}$&quot;];</span>
<span class="go">  node_1  [label=&quot; &quot;, texlbl=&quot;$-2$&quot;];</span>
<span class="go">  node_9  [label=&quot; &quot;, texlbl=&quot;$\frac{4}{5}$&quot;];</span>
<span class="go">  node_0  [label=&quot; &quot;, texlbl=&quot;$-4$&quot;];</span>
<span class="go">  node_2  [label=&quot; &quot;, texlbl=&quot;$-1$&quot;];</span>

<span class="go">  node_10 -&gt; node_2 [color = &quot;#ff0000&quot;];</span>
<span class="go">  node_10 -&gt; node_6 [color = &quot;#00ffff&quot;];</span>
<span class="go">  node_11 -&gt; node_3 [color = &quot;#ff0000&quot;];</span>
<span class="go">  node_11 -&gt; node_5 [color = &quot;#00ffff&quot;];</span>
<span class="go">  node_7 -&gt; node_1 [color = &quot;#ff0000&quot;];</span>
<span class="go">  node_7 -&gt; node_8 [color = &quot;#00ffff&quot;];</span>
<span class="go">  node_4 -&gt; node_0 [color = &quot;#ff0000&quot;];</span>
<span class="go">  node_4 -&gt; node_9 [color = &quot;#00ffff&quot;];</span>
<span class="go">}</span>

<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">graphviz_string</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="s2">&quot;latex&quot;</span><span class="p">,</span> <span class="n">color_by_label</span><span class="o">=</span><span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span> <span class="s2">&quot;blue&quot;</span><span class="p">}))</span>  <span class="c1"># random  # optional - sage.symbolic</span>
<span class="go">digraph {</span>
<span class="go">  node [shape=&quot;plaintext&quot;];</span>
<span class="go">  node_10  [label=&quot; &quot;, texlbl=&quot;$1$&quot;];</span>
<span class="go">  node_11  [label=&quot; &quot;, texlbl=&quot;$2$&quot;];</span>
<span class="go">  node_3  [label=&quot; &quot;, texlbl=&quot;$-\frac{1}{2}$&quot;];</span>
<span class="go">  node_6  [label=&quot; &quot;, texlbl=&quot;$\frac{1}{2}$&quot;];</span>
<span class="go">  node_7  [label=&quot; &quot;, texlbl=&quot;$\frac{1}{2}$&quot;];</span>
<span class="go">  node_5  [label=&quot; &quot;, texlbl=&quot;$\frac{1}{3}$&quot;];</span>
<span class="go">  node_8  [label=&quot; &quot;, texlbl=&quot;$\frac{2}{3}$&quot;];</span>
<span class="go">  node_4  [label=&quot; &quot;, texlbl=&quot;$\frac{1}{4}$&quot;];</span>
<span class="go">  node_1  [label=&quot; &quot;, texlbl=&quot;$-2$&quot;];</span>
<span class="go">  node_9  [label=&quot; &quot;, texlbl=&quot;$\frac{4}{5}$&quot;];</span>
<span class="go">  node_0  [label=&quot; &quot;, texlbl=&quot;$-4$&quot;];</span>
<span class="go">  node_2  [label=&quot; &quot;, texlbl=&quot;$-1$&quot;];</span>

<span class="go">  node_10 -&gt; node_2 [color = &quot;red&quot;];</span>
<span class="go">  node_10 -&gt; node_6 [color = &quot;blue&quot;];</span>
<span class="go">  node_11 -&gt; node_3 [color = &quot;red&quot;];</span>
<span class="go">  node_11 -&gt; node_5 [color = &quot;blue&quot;];</span>
<span class="go">  node_7 -&gt; node_1 [color = &quot;red&quot;];</span>
<span class="go">  node_7 -&gt; node_8 [color = &quot;blue&quot;];</span>
<span class="go">  node_4 -&gt; node_0 [color = &quot;red&quot;];</span>
<span class="go">  node_4 -&gt; node_9 [color = &quot;blue&quot;];</span>
<span class="go">}</span>
</pre></div>
</div>
<p>By default <code class="docutils literal notranslate"><span class="pre">graphviz</span></code> renders digraphs using a hierarchical layout,
ranking the vertices down from top to bottom. Here we specify
alternative ranking directions for this layout:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">graphviz_string</span><span class="p">(</span><span class="n">rankdir</span><span class="o">=</span><span class="s2">&quot;up&quot;</span><span class="p">))</span>
<span class="go">digraph {</span>
<span class="go">  rankdir=BT</span>
<span class="go">  node_0  [label=&quot;1&quot;];</span>
<span class="go">  node_1  [label=&quot;2&quot;];</span>

<span class="go">  node_0 -&gt; node_1;</span>
<span class="go">}</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">graphviz_string</span><span class="p">(</span><span class="n">rankdir</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">))</span>
<span class="go">digraph {</span>
<span class="go">  node_0  [label=&quot;1&quot;];</span>
<span class="go">  node_1  [label=&quot;2&quot;];</span>

<span class="go">  node_0 -&gt; node_1;</span>
<span class="go">}</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">graphviz_string</span><span class="p">(</span><span class="n">rankdir</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">))</span>
<span class="go">digraph {</span>
<span class="go">  rankdir=RL</span>
<span class="go">  node_0  [label=&quot;1&quot;];</span>
<span class="go">  node_1  [label=&quot;2&quot;];</span>

<span class="go">  node_0 -&gt; node_1;</span>
<span class="go">}</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">graphviz_string</span><span class="p">(</span><span class="n">rankdir</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">))</span>
<span class="go">digraph {</span>
<span class="go">  rankdir=LR</span>
<span class="go">  node_0  [label=&quot;1&quot;];</span>
<span class="go">  node_1  [label=&quot;2&quot;];</span>

<span class="go">  node_0 -&gt; node_1;</span>
<span class="go">}</span>
</pre></div>
</div>
<p>Edge-specific options can also be specified by providing a function (or
tuple thereof) which maps each edge to a dictionary of options. Valid
options are</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;color&quot;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;dot&quot;</span></code> (a string containing a sequence of options in <code class="docutils literal notranslate"><span class="pre">dot</span></code> format)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;label&quot;</span></code> (a string)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;label_style&quot;</span></code> (<code class="docutils literal notranslate"><span class="pre">&quot;string&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;latex&quot;</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;edge_string&quot;</span></code> (<code class="docutils literal notranslate"><span class="pre">&quot;--&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;-&gt;&quot;</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;dir&quot;</span></code> (<code class="docutils literal notranslate"><span class="pre">&quot;forward&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;back&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;both&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;none&quot;</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;backward&quot;</span></code> (boolean), instead of defining the edge in the
graphviz string as <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">-&gt;</span> <span class="pre">v</span></code> it draws it as <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">-&gt;</span> <span class="pre">u</span>
<span class="pre">[dir=back]</span></code> and instead of <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">-&gt;</span> <span class="pre">v</span> <span class="pre">[dir=back]</span></code> it draws it as
<code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">-&gt;</span> <span class="pre">u</span></code>, this changes the way it is drawn by Graphviz’s dot
program: vertex <code class="docutils literal notranslate"><span class="pre">v</span></code> will be <em>above</em> vertex <code class="docutils literal notranslate"><span class="pre">u</span></code> instead of
below.</p></li>
</ul>
<p>Here we state that the graph should be laid out so that edges
starting from <code class="docutils literal notranslate"><span class="pre">1</span></code> are going backward (e.g. going up instead of
down):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">edge_options</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">data</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;dir&quot;</span><span class="p">:</span><span class="s2">&quot;back&quot;</span><span class="p">}</span> <span class="k">if</span> <span class="n">u</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">{}</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">graphviz_string</span><span class="p">(</span><span class="n">edge_options</span><span class="o">=</span><span class="n">edge_options</span><span class="p">))</span>  <span class="c1"># random             # optional - sage.symbolic</span>
<span class="go">digraph {</span>
<span class="go">  node_0  [label=&quot;-1&quot;];</span>
<span class="go">  node_1  [label=&quot;-1/2&quot;];</span>
<span class="go">  node_2  [label=&quot;1/2&quot;];</span>
<span class="go">  node_3  [label=&quot;-2&quot;];</span>
<span class="go">  node_4  [label=&quot;1/4&quot;];</span>
<span class="go">  node_5  [label=&quot;-4&quot;];</span>
<span class="go">  node_6  [label=&quot;1/3&quot;];</span>
<span class="go">  node_7  [label=&quot;2/3&quot;];</span>
<span class="go">  node_8  [label=&quot;4/5&quot;];</span>
<span class="go">  node_9  [label=&quot;1&quot;];</span>
<span class="go">  node_10  [label=&quot;2&quot;];</span>

<span class="go">  node_2 -&gt; node_3;</span>
<span class="go">  node_2 -&gt; node_7;</span>
<span class="go">  node_4 -&gt; node_5;</span>
<span class="go">  node_4 -&gt; node_8;</span>
<span class="go">  node_9 -&gt; node_0 [dir=back];</span>
<span class="go">  node_9 -&gt; node_2 [dir=back];</span>
<span class="go">  node_10 -&gt; node_1;</span>
<span class="go">  node_10 -&gt; node_6;</span>
<span class="go">}</span>
</pre></div>
</div>
<p>We now test all options:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">edge_options</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">data</span>
<span class="gp">....: </span>    <span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span> <span class="s2">&quot;blue&quot;</span><span class="p">}[</span><span class="n">label</span><span class="p">]}</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">):</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span>       <span class="o">=</span> <span class="s2">&quot;coucou&quot;</span><span class="p">;</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;label_style&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;string&quot;</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">):</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;dot&quot;</span><span class="p">]</span>         <span class="o">=</span> <span class="s2">&quot;x=1,y=2&quot;</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;label_style&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;latex&quot;</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">):</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;dir&quot;</span><span class="p">]</span>         <span class="o">=</span> <span class="s2">&quot;back&quot;</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">options</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">graphviz_string</span><span class="p">(</span><span class="n">edge_options</span><span class="o">=</span><span class="n">edge_options</span><span class="p">))</span>  <span class="c1"># random             # optional - sage.symbolic</span>
<span class="go">digraph {</span>
<span class="go">  node_0  [label=&quot;-1&quot;];</span>
<span class="go">  node_1  [label=&quot;-1/2&quot;];</span>
<span class="go">  node_2  [label=&quot;1/2&quot;];</span>
<span class="go">  node_3  [label=&quot;-2&quot;];</span>
<span class="go">  node_4  [label=&quot;1/4&quot;];</span>
<span class="go">  node_5  [label=&quot;-4&quot;];</span>
<span class="go">  node_6  [label=&quot;1/3&quot;];</span>
<span class="go">  node_7  [label=&quot;2/3&quot;];</span>
<span class="go">  node_8  [label=&quot;4/5&quot;];</span>
<span class="go">  node_9  [label=&quot;1&quot;];</span>
<span class="go">  node_10  [label=&quot;2&quot;];</span>

<span class="go">  node_2 -&gt; node_3 [label=&quot;coucou&quot;, color = &quot;red&quot;];</span>
<span class="go">  node_2 -&gt; node_7 [x=1,y=2, color = &quot;blue&quot;];</span>
<span class="go">  node_4 -&gt; node_5 [color = &quot;red&quot;];</span>
<span class="go">  node_4 -&gt; node_8 [color = &quot;blue&quot;];</span>
<span class="go">  node_9 -&gt; node_0 [label=&quot; &quot;, texlbl=&quot;$x \ {\mapsto}\ -\frac{1}{x}$&quot;, color = &quot;red&quot;];</span>
<span class="go">  node_9 -&gt; node_2 [color = &quot;blue&quot;, dir=back];</span>
<span class="go">  node_10 -&gt; node_1 [color = &quot;red&quot;];</span>
<span class="go">  node_10 -&gt; node_6 [color = &quot;blue&quot;];</span>
<span class="go">}</span>
</pre></div>
</div>
<p>We test the possible values of the <code class="docutils literal notranslate"><span class="pre">'dir'</span></code> edge option:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">edges</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">edge_options</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">label</span> <span class="o">=</span> <span class="n">data</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;dir&#39;</span><span class="p">:</span><span class="s1">&#39;forward&#39;</span><span class="p">}</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;dir&#39;</span><span class="p">:</span><span class="s1">&#39;back&#39;</span><span class="p">}</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;dir&#39;</span><span class="p">:</span><span class="s1">&#39;none&#39;</span><span class="p">}</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;dir&#39;</span><span class="p">:</span><span class="s1">&#39;both&#39;</span><span class="p">}</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">graphviz_string</span><span class="p">(</span><span class="n">edge_options</span><span class="o">=</span><span class="n">edge_options</span><span class="p">))</span>
<span class="go">digraph {</span>
<span class="go">  node_0  [label=&quot;0&quot;];</span>
<span class="go">  node_1  [label=&quot;1&quot;];</span>
<span class="go">  node_2  [label=&quot;2&quot;];</span>
<span class="go">  node_3  [label=&quot;3&quot;];</span>
<span class="go">  node_4  [label=&quot;4&quot;];</span>

<span class="go">  node_0 -&gt; node_1;</span>
<span class="go">  node_1 -&gt; node_2 [dir=back];</span>
<span class="go">  node_2 -&gt; node_3 [dir=none];</span>
<span class="go">  node_3 -&gt; node_4 [dir=both];</span>
<span class="go">}</span>
</pre></div>
</div>
<p>We test the same graph and <code class="docutils literal notranslate"><span class="pre">'dir'</span></code> edge options but with
<code class="docutils literal notranslate"><span class="pre">backward=True</span></code>, which reverses the natural direction
each edge wants to be pointing for the layout:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">edge_options</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">label</span> <span class="o">=</span> <span class="n">data</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;dir&#39;</span><span class="p">:</span><span class="s1">&#39;forward&#39;</span><span class="p">,</span> <span class="s1">&#39;backward&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">}</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;dir&#39;</span><span class="p">:</span><span class="s1">&#39;back&#39;</span><span class="p">,</span> <span class="s1">&#39;backward&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">}</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;dir&#39;</span><span class="p">:</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="s1">&#39;backward&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">}</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;dir&#39;</span><span class="p">:</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;backward&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">}</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">graphviz_string</span><span class="p">(</span><span class="n">edge_options</span><span class="o">=</span><span class="n">edge_options</span><span class="p">))</span>
<span class="go">digraph {</span>
<span class="go">  node_0  [label=&quot;0&quot;];</span>
<span class="go">  node_1  [label=&quot;1&quot;];</span>
<span class="go">  node_2  [label=&quot;2&quot;];</span>
<span class="go">  node_3  [label=&quot;3&quot;];</span>
<span class="go">  node_4  [label=&quot;4&quot;];</span>

<span class="go">  node_1 -&gt; node_0 [dir=back];</span>
<span class="go">  node_2 -&gt; node_1;</span>
<span class="go">  node_3 -&gt; node_2 [dir=none];</span>
<span class="go">  node_4 -&gt; node_3 [dir=both];</span>
<span class="go">}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.graphviz_to_file_named">
<span class="sig-name descname"><span class="pre">graphviz_to_file_named</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.graphviz_to_file_named" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a representation in the <code class="docutils literal notranslate"><span class="pre">dot</span></code> language in a file.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">dot</span></code> language is a plaintext format for graph structures. See the
documentation of <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.graphviz_string" title="sage.graphs.generic_graph.GenericGraph.graphviz_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graphviz_string()</span></code></a> for available options.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">filename</span></code> – the name of the file to write in</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">**options</span></code> – options for the graphviz string</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span> <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">},</span> <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">}},</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">tempfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">SAGE_TMP</span><span class="p">,</span> <span class="s1">&#39;temp_graphviz&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">graphviz_to_file_named</span><span class="p">(</span><span class="n">tempfile</span><span class="p">,</span> <span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tempfile</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
<span class="go">graph {</span>
<span class="go">  node_0  [label=&quot;0&quot;];</span>
<span class="go">  node_1  [label=&quot;1&quot;];</span>
<span class="go">  node_2  [label=&quot;2&quot;];</span>
<span class="go">  node_3  [label=&quot;3&quot;];</span>

<span class="go">  node_0 -- node_1;</span>
<span class="go">  node_0 -- node_2;</span>
<span class="go">  node_1 -- node_2;</span>
<span class="go">  node_2 -- node_3 [label=&quot;foo&quot;];</span>
<span class="go">}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.greedy_dominating_set">
<span class="sig-name descname"><span class="pre">greedy_dominating_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ordering</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_sets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">closest</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.greedy_dominating_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a greedy distance-<span class="math notranslate nohighlight">\(k\)</span> dominating set of the graph.</p>
<p>A distance-<span class="math notranslate nohighlight">\(k\)</span> dominating set <span class="math notranslate nohighlight">\(S\)</span> of a graph <span class="math notranslate nohighlight">\(G\)</span> is a set of its vertices of
minimal cardinality such that any vertex of <span class="math notranslate nohighlight">\(G\)</span> is in <span class="math notranslate nohighlight">\(S\)</span> or is at distance
at most <span class="math notranslate nohighlight">\(k\)</span> from a vertex in <span class="math notranslate nohighlight">\(S\)</span>. See the <a class="reference external" href="https://en.wikipedia.org/wiki/Dominating_set">Wikipedia article Dominating_set</a>.</p>
<p>When <span class="math notranslate nohighlight">\(G\)</span> is directed, vertex <span class="math notranslate nohighlight">\(u\)</span> can be a dominator of vertex <span class="math notranslate nohighlight">\(v\)</span> if there
is a directed path of length at most <span class="math notranslate nohighlight">\(k\)</span> from <span class="math notranslate nohighlight">\(u\)</span> to <span class="math notranslate nohighlight">\(v\)</span>.</p>
<p>This method implements a greedy heuristic to find a minimal dominatic set.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a Graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">1</span></code>); the domination distance to consider</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – iterable container of vertices (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); when
specified, return a dominating set of the specified vertices only</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ordering</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify the order in which to
consider the vertices</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> – if <code class="docutils literal notranslate"><span class="pre">vertices</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, then consider the vertices in
the order given by <code class="docutils literal notranslate"><span class="pre">list(G)</span></code>. Otherwise, consider the vertices in the
order of iteration of <code class="docutils literal notranslate"><span class="pre">vertices</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;degree_min&quot;</span></code> – consider the vertices by increasing degree</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;degree_max&quot;</span></code> – consider the vertices by decreasing degree</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">return_sets</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
vertices of the dominating set only (default), or a dictionary mapping
each vertex of the dominating set to the set of vertices it dominates.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">closest</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to attach a vertex to
its closest dominator or not. This parameter is use only when
<code class="docutils literal notranslate"><span class="pre">return_sets</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>Dominating sets of a path:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.domination</span> <span class="kn">import</span> <span class="n">greedy_dominating_set</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">greedy_dominating_set</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">ordering</span><span class="o">=</span><span class="kc">None</span><span class="p">))</span>
<span class="go">[0, 2, 4]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">greedy_dominating_set</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">ordering</span><span class="o">=</span><span class="s2">&quot;degree_min&quot;</span><span class="p">))</span>
<span class="go">[0, 2, 4]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">greedy_dominating_set</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">ordering</span><span class="o">=</span><span class="s2">&quot;degree_max&quot;</span><span class="p">))</span>
<span class="go">[1, 3]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">greedy_dominating_set</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ordering</span><span class="o">=</span><span class="kc">None</span><span class="p">))</span>
<span class="go">[0, 3]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">greedy_dominating_set</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ordering</span><span class="o">=</span><span class="s2">&quot;degree_min&quot;</span><span class="p">))</span>
<span class="go">[0, 4]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">greedy_dominating_set</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ordering</span><span class="o">=</span><span class="s2">&quot;degree_max&quot;</span><span class="p">))</span>
<span class="go">[1, 4]</span>
<span class="gp">sage: </span><span class="n">greedy_dominating_set</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">ordering</span><span class="o">=</span><span class="s2">&quot;degree_min&quot;</span><span class="p">,</span> <span class="n">return_sets</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">closest</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">{0: {0, 1, 2, 3}, 4: {4}}</span>
<span class="gp">sage: </span><span class="n">greedy_dominating_set</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">ordering</span><span class="o">=</span><span class="s2">&quot;degree_min&quot;</span><span class="p">,</span> <span class="n">return_sets</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">closest</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{0: {0, 2, 3}, 4: {1, 4}}</span>
</pre></div>
</div>
<p>Asking for a dominating set of a subset of vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.domination</span> <span class="kn">import</span> <span class="n">greedy_dominating_set</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.domination</span> <span class="kn">import</span> <span class="n">is_dominating</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">vertices</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
<span class="gp">sage: </span><span class="n">dom</span> <span class="o">=</span> <span class="n">greedy_dominating_set</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="n">vertices</span><span class="p">,</span> <span class="n">return_sets</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">dom</span><span class="p">)</span>
<span class="go">[0, 2]</span>
<span class="gp">sage: </span><span class="n">is_dominating</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">dom</span><span class="p">,</span> <span class="n">focus</span><span class="o">=</span><span class="n">vertices</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">is_dominating</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">dom</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">dominated</span> <span class="o">=</span> <span class="p">[</span><span class="n">u</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dom</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">dom</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">dominated</span><span class="p">)</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Influence of the ordering of the vertices on the result:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.domination</span> <span class="kn">import</span> <span class="n">greedy_dominating_set</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">StarGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">greedy_dominating_set</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">[0]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">greedy_dominating_set</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
<span class="go">[1, 2, 3, 4]</span>
</pre></div>
</div>
<p>Dominating set of a directed graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.domination</span> <span class="kn">import</span> <span class="n">greedy_dominating_set</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">greedy_dominating_set</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[0, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.hamiltonian_cycle">
<span class="sig-name descname"><span class="pre">hamiltonian_cycle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'tsp'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraint_generation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.hamiltonian_cycle" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Hamiltonian cycle/circuit of the current graph/digraph.</p>
<p>A graph (resp. digraph) is said to be Hamiltonian if it contains as a
subgraph a cycle (resp. a circuit) going through all the vertices.</p>
<p>Computing a Hamiltonian cycle/circuit being NP-Complete, this algorithm
could run for some time depending on the instance.</p>
<p>ALGORITHM:</p>
<p>See <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.traveling_salesman_problem" title="sage.graphs.generic_graph.GenericGraph.traveling_salesman_problem"><code class="xref py py-meth docutils literal notranslate"><span class="pre">traveling_salesman_problem()</span></code></a> for ‘tsp’
algorithm and
<a class="reference internal" href="generic_graph_pyx.html#sage.graphs.generic_graph_pyx.find_hamiltonian" title="sage.graphs.generic_graph_pyx.find_hamiltonian"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_hamiltonian()</span></code></a> from
<a class="reference internal" href="generic_graph_pyx.html#module-sage.graphs.generic_graph_pyx" title="sage.graphs.generic_graph_pyx"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.graphs.generic_graph_pyx</span></code></a> for ‘backtrack’ algorithm.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">'tsp'</span></code>); one of ‘tsp’ or
‘backtrack’</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">constraint_generation</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); whether to
use constraint generation when solving the Mixed Integer Linear
Program.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">constraint_generation</span> <span class="pre">=</span> <span class="pre">None</span></code>, constraint generation is used
whenever the graph has a density larger than 70%.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose_constraints</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to
display which constraints are being generated</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>If using the <code class="docutils literal notranslate"><span class="pre">'tsp'</span></code> algorithm, returns a Hamiltonian cycle/circuit if
it exists; otherwise, raises a <code class="docutils literal notranslate"><span class="pre">EmptySetError</span></code> exception. If using the
<code class="docutils literal notranslate"><span class="pre">'backtrack'</span></code> algorithm, returns a pair <code class="docutils literal notranslate"><span class="pre">(B,</span> <span class="pre">P)</span></code>. If <code class="docutils literal notranslate"><span class="pre">B</span></code> is
<code class="docutils literal notranslate"><span class="pre">True</span></code> then <code class="docutils literal notranslate"><span class="pre">P</span></code> is a Hamiltonian cycle and if <code class="docutils literal notranslate"><span class="pre">B</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>,
<code class="docutils literal notranslate"><span class="pre">P</span></code> is a longest path found by the algorithm. Observe that if <code class="docutils literal notranslate"><span class="pre">B</span></code> is
<code class="docutils literal notranslate"><span class="pre">False</span></code>, the graph may still be Hamiltonian.  The <code class="docutils literal notranslate"><span class="pre">'backtrack'</span></code>
algorithm is only implemented for undirected graphs.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The <code class="docutils literal notranslate"><span class="pre">'backtrack'</span></code> algorithm may loop endlessly on graphs with
vertices of degree 1.</p>
</div>
<p>NOTE:</p>
<p>This function, as <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_hamiltonian" title="sage.graphs.generic_graph.GenericGraph.is_hamiltonian"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_hamiltonian()</span></code></a>, computes a Hamiltonian cycle
if it exists: the user should <em>NOT</em> test for Hamiltonicity using
<a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_hamiltonian" title="sage.graphs.generic_graph.GenericGraph.is_hamiltonian"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_hamiltonian()</span></code></a> before calling this function, as it would result
in computing it twice.</p>
<p>The backtrack algorithm is only implemented for undirected graphs.</p>
<p>EXAMPLES:</p>
<p>The Heawood Graph is known to be Hamiltonian</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">HeawoodGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">hamiltonian_cycle</span><span class="p">()</span>
<span class="go">TSP from Heawood graph: Graph on 14 vertices</span>
</pre></div>
</div>
<p>The Petersen Graph, though, is not</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">hamiltonian_cycle</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">EmptySetError: the given graph is not Hamiltonian</span>
</pre></div>
</div>
<p>Now, using the backtrack algorithm in the Heawood graph</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">HeawoodGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">hamiltonian_cycle</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;backtrack&#39;</span><span class="p">)</span>
<span class="go">(True, [...])</span>
</pre></div>
</div>
<p>And now in the Petersen graph</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">B</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">hamiltonian_cycle</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;backtrack&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">10</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Finally, we test the algorithm in a cube graph, which is Hamiltonian</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">hamiltonian_cycle</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;backtrack&#39;</span><span class="p">)</span>
<span class="go">(True, [...])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.hamiltonian_path">
<span class="sig-name descname"><span class="pre">hamiltonian_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_edge_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'MILP'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.hamiltonian_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Hamiltonian path of the current graph/digraph.</p>
<p>A path is Hamiltonian if it goes through all the vertices exactly
once. Computing a Hamiltonian path being NP-Complete, this
algorithm could run for some time depending on the instance.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">use_edge_labels</span> <span class="pre">==</span> <span class="pre">True</span></code>, this method returns either a minimum
weight hamiltonian path or a maximum weight Hamiltonian path (if
<code class="docutils literal notranslate"><span class="pre">maximize</span> <span class="pre">==</span> <span class="pre">True</span></code>).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.longest_path" title="sage.graphs.generic_graph.GenericGraph.longest_path"><code class="xref py py-meth docutils literal notranslate"><span class="pre">longest_path()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.hamiltonian_cycle" title="sage.graphs.generic_graph.GenericGraph.hamiltonian_cycle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hamiltonian_cycle()</span></code></a></p></li>
</ul>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code> – vertex (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); if specified, then forces the
source of the path (the method then returns a Hamiltonian path
starting at <code class="docutils literal notranslate"><span class="pre">s</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code> – vertex (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); if specified, then forces the
destination of the path (the method then returns a Hamiltonian path
ending at <code class="docutils literal notranslate"><span class="pre">t</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">use_edge_labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to
compute a weighted hamiltonian path where the weight of an edge is
defined by its label (a label set to <code class="docutils literal notranslate"><span class="pre">None</span></code> or <code class="docutils literal notranslate"><span class="pre">{}</span></code> being
considered as a weight of <span class="math notranslate nohighlight">\(1\)</span>), or a non-weighted hamiltonian path</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">maximize</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to compute a
minimum (default) or a maximum (when <code class="docutils literal notranslate"><span class="pre">maximize</span> <span class="pre">==</span> <span class="pre">True</span></code>) weight
hamiltonian path. This parameter is considered only if
<code class="docutils literal notranslate"><span class="pre">use_edge_labels</span> <span class="pre">==</span> <span class="pre">True</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">&quot;MILP&quot;</span></code>); the algorithm the use
among <code class="docutils literal notranslate"><span class="pre">&quot;MILP&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;backtrack&quot;</span></code>; two remarks on this respect:</p>
<ul>
<li><p>While the MILP formulation returns an exact answer, the backtrack
algorithm is a randomized heuristic.</p></li>
<li><p>The backtrack algorithm does not support edge weighting, so setting
<code class="docutils literal notranslate"><span class="pre">use_edge_labels=True</span></code> will force the use of the MILP algorithm.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A subgraph of <code class="docutils literal notranslate"><span class="pre">self</span></code> corresponding to a (directed if <code class="docutils literal notranslate"><span class="pre">self</span></code> is
directed) hamiltonian path. If no hamiltonian path is found, return
<code class="docutils literal notranslate"><span class="pre">None</span></code>. If <code class="docutils literal notranslate"><span class="pre">use_edge_labels</span> <span class="pre">==</span> <span class="pre">True</span></code>, a pair <code class="docutils literal notranslate"><span class="pre">weight,</span> <span class="pre">path</span></code> is
returned.</p>
<p>EXAMPLES:</p>
<p>The <span class="math notranslate nohighlight">\(3 \times 3\)</span>-grid has an Hamiltonian path, an hamiltonian path
starting from vertex <span class="math notranslate nohighlight">\((0, 0)\)</span> and ending at vertex <span class="math notranslate nohighlight">\((2, 2)\)</span>, but no
Hamiltonian path starting from <span class="math notranslate nohighlight">\((0, 0)\)</span> and ending at <span class="math notranslate nohighlight">\((0, 1)\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">hamiltonian_path</span><span class="p">()</span>
<span class="go">Hamiltonian path from 2D Grid Graph for [3, 3]: Graph on 9 vertices</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">hamiltonian_path</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">t</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">Hamiltonian path from 2D Grid Graph for [3, 3]: Graph on 9 vertices</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">hamiltonian_path</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">t</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">use_edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(8, Hamiltonian path from 2D Grid Graph for [3, 3]: Graph on 9 vertices)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">hamiltonian_path</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">t</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">hamiltonian_path</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">t</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">use_edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(0, None)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.has_edge">
<span class="sig-name descname"><span class="pre">has_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.has_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v)</span></code> is an edge of the (di)graph.</p>
<p>INPUT: The following forms are accepted:</p>
<ul class="simple">
<li><p>G.has_edge( 1, 2 )</p></li>
<li><p>G.has_edge( (1, 2) )</p></li>
<li><p>G.has_edge( 1, 2, ‘label’ )</p></li>
<li><p>G.has_edge( (1, 2, ‘label’) )</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">EmptyGraph</span><span class="p">()</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">DiGraph</span><span class="p">()</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;label&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;different label&quot;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;label&quot;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.has_loops">
<span class="sig-name descname"><span class="pre">has_loops</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.has_loops" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether there are loops in the (di)graph</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Looped graph on 0 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allows_loops</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">loops</span><span class="p">()</span>
<span class="go">[(0, 0, None)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_loops</span><span class="p">(</span><span class="kc">False</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Graph on 1 vertex</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[]</span>

<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">D</span>
<span class="go">Looped digraph on 0 vertices</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">allows_loops</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">loops</span><span class="p">()</span>
<span class="go">[(0, 0, None)]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">allow_loops</span><span class="p">(</span><span class="kc">False</span><span class="p">);</span> <span class="n">D</span>
<span class="go">Digraph on 1 vertex</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.has_multiple_edges">
<span class="sig-name descname"><span class="pre">has_multiple_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">to_undirected</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.has_multiple_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether there are multiple edges in the (di)graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">to_undirected</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False)</span></code>; if <code class="docutils literal notranslate"><span class="pre">True</span></code>, runs the test
on the undirected version of a DiGraph. Otherwise, treats DiGraph
edges <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v)</span></code> and <code class="docutils literal notranslate"><span class="pre">(v,</span> <span class="pre">u)</span></code> as unique individual edges.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Multi-graph on 0 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allows_multiple_edges</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">multiple_edges</span><span class="p">()</span>
<span class="go">[(0, 1, None), (0, 1, None), (0, 1, None)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_multiple_edges</span><span class="p">(</span><span class="kc">False</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Graph on 2 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None)]</span>

<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">D</span>
<span class="go">Multi-digraph on 0 vertices</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">allows_multiple_edges</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">multiple_edges</span><span class="p">()</span>
<span class="go">[(0, 1, None), (0, 1, None), (0, 1, None)]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">allow_multiple_edges</span><span class="p">(</span><span class="kc">False</span><span class="p">);</span> <span class="n">D</span>
<span class="go">Digraph on 2 vertices</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None)]</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;h&#39;</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;g&#39;</span><span class="p">}},</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">(</span><span class="n">to_undirected</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">multiple_edges</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">multiple_edges</span><span class="p">(</span><span class="n">to_undirected</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(1, 2, &#39;h&#39;), (2, 1, &#39;g&#39;)]</span>
</pre></div>
</div>
<p>A loop is not a multiedge:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.has_vertex">
<span class="sig-name descname"><span class="pre">has_vertex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertex</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.has_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if <code class="docutils literal notranslate"><span class="pre">vertex</span></code> is one of the vertices of this graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertex</span></code> – the name of a vertex (see <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.add_vertex" title="sage.graphs.generic_graph.GenericGraph.add_vertex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_vertex()</span></code></a>)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">]});</span> <span class="n">g</span>
<span class="go">Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="mi">2</span> <span class="ow">in</span> <span class="n">g</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="mi">10</span> <span class="ow">in</span> <span class="n">g</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">has_vertex</span><span class="p">(</span><span class="mi">99</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.igraph_graph">
<span class="sig-name descname"><span class="pre">igraph_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertex_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_attrs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_attrs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.igraph_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an <code class="docutils literal notranslate"><span class="pre">igraph</span></code> graph from the Sage graph.</p>
<p>Optionally, it is possible to add vertex attributes and edge attributes
to the output graph.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This routine needs the optional package igraph to be installed:
to do so, it is enough to run <code class="docutils literal notranslate"><span class="pre">sage</span> <span class="pre">-i</span> <span class="pre">python_igraph</span></code>. For more
information on the Python version of igraph, see
<a class="reference external" href="http://igraph.org/python/">http://igraph.org/python/</a>.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertex_list</span></code> – list (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); defines a mapping from
the vertices of the graph to consecutive integers in <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">\ldots,</span>
<span class="pre">n-1)`.</span> <span class="pre">Otherwise,</span> <span class="pre">the</span> <span class="pre">result</span> <span class="pre">of</span> <span class="pre">:meth:`vertices`</span> <span class="pre">will</span> <span class="pre">be</span> <span class="pre">used</span>
<span class="pre">instead.</span> <span class="pre">Because</span> <span class="pre">:meth:`vertices`</span> <span class="pre">only</span> <span class="pre">works</span> <span class="pre">if</span> <span class="pre">the</span> <span class="pre">vertices</span> <span class="pre">can</span> <span class="pre">be</span>
<span class="pre">sorted,</span> <span class="pre">using</span> <span class="pre">``vertex_list</span></code> is useful when working with possibly
non-sortable objects in Python 3.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertex_attrs</span></code> – dictionary (default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>); a dictionary where
the key is a string (the attribute name), and the value is an iterable
containing in position <span class="math notranslate nohighlight">\(i\)</span> the label of the <span class="math notranslate nohighlight">\(i\)</span>-th vertex in the list
<code class="docutils literal notranslate"><span class="pre">vertex_list</span></code> if it is given or in <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.vertices" title="sage.graphs.generic_graph.GenericGraph.vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertices()</span></code></a> when
<code class="docutils literal notranslate"><span class="pre">vertex_list</span> <span class="pre">==</span> <span class="pre">None</span></code> (see
<a class="reference external" href="http://igraph.org/python/doc/igraph.Graph-class.html#__init__">http://igraph.org/python/doc/igraph.Graph-class.html#__init__</a> for more
information)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edge_attrs</span></code> – dictionary (default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>); a dictionary where the
key is a string (the attribute name), and the value is an iterable
containing in position <span class="math notranslate nohighlight">\(i\)</span> the label of the <span class="math notranslate nohighlight">\(i\)</span>-th edge in the list
outputted by <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.edge_iterator" title="sage.graphs.generic_graph.GenericGraph.edge_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">edge_iterator()</span></code></a> (see
<a class="reference external" href="http://igraph.org/python/doc/igraph.Graph-class.html#__init__">http://igraph.org/python/doc/igraph.Graph-class.html#__init__</a> for more
information)</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In <code class="docutils literal notranslate"><span class="pre">igraph</span></code>, a graph is weighted if the edge labels have attribute
<code class="docutils literal notranslate"><span class="pre">weight</span></code>. Hence, to create a weighted graph, it is enough to add
this attribute.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Often, Sage uses its own defined types for integer/floats. These
types may not be igraph-compatible (see example below).</p>
</div>
<p>EXAMPLES:</p>
<p>Standard conversion:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">TetrahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">igraph_graph</span><span class="p">()</span>          <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>                   <span class="c1"># optional - python_igraph</span>
<span class="go">&#39;IGRAPH U--- 4 6 -- &#39;</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">igraph_graph</span><span class="p">()</span>          <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>                   <span class="c1"># optional - python_igraph</span>
<span class="go">&#39;IGRAPH D--- 3 2 -- &#39;</span>
</pre></div>
</div>
<p>Adding edge attributes:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">igraph_graph</span><span class="p">(</span><span class="n">edge_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">E</span><span class="p">]})</span> <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span>                                               <span class="c1"># optional - python_igraph</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;]</span>
</pre></div>
</div>
<p>If edges have an attribute <code class="docutils literal notranslate"><span class="pre">weight</span></code>, the igraph graph is considered
weighted:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})])</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">igraph_graph</span><span class="p">(</span><span class="n">edge_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">E</span><span class="p">]})</span> <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">is_weighted</span><span class="p">()</span>                                                        <span class="c1"># optional - python_igraph</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span>                                                         <span class="c1"># optional - python_igraph</span>
<span class="go">[1, 2]</span>
</pre></div>
</div>
<p>Adding vertex attributes:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">GridGraph</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">igraph_graph</span><span class="p">(</span><span class="n">vertex_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">()})</span> <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">vs</span><span class="p">()[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>                                          <span class="c1"># optional - python_igraph</span>
<span class="go">[(0, 0), (0, 1), (1, 0), (1, 1)]</span>
</pre></div>
</div>
<p>Providing a mapping from vertices to consecutive integers:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">GridGraph</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">igraph_graph</span><span class="p">(</span><span class="n">vertex_list</span><span class="o">=</span><span class="n">V</span><span class="p">,</span> <span class="n">vertex_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">V</span><span class="p">})</span> <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">vs</span><span class="p">()[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">V</span>                                         <span class="c1"># optional - python_igraph</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Sometimes, Sage integer/floats are not compatible with igraph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">igraph_graph</span><span class="p">(</span><span class="n">edge_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;capacity&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">E</span><span class="p">]})</span> <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">maxflow_value</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;capacity&#39;</span><span class="p">)</span>                              <span class="c1"># optional - python_igraph</span>
<span class="go">1.0</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">igraph_graph</span><span class="p">(</span><span class="n">edge_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;capacity&#39;</span><span class="p">:</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">E</span><span class="p">]})</span> <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">maxflow_value</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;capacity&#39;</span><span class="p">)</span>                                     <span class="c1"># optional - python_igraph</span>
<span class="go">2.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.incidence_matrix">
<span class="sig-name descname"><span class="pre">incidence_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oriented</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.incidence_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the incidence matrix of the (di)graph.</p>
<p>Each row is a vertex, and each column is an edge. The vertices are
ordered as obtained by the method <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.vertices" title="sage.graphs.generic_graph.GenericGraph.vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertices()</span></code></a>, except when
parameter <code class="docutils literal notranslate"><span class="pre">vertices</span></code> is given (see below), and the edges as obtained
by the method <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.edge_iterator" title="sage.graphs.generic_graph.GenericGraph.edge_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">edge_iterator()</span></code></a>.</p>
<p>If the graph is not directed, then return a matrix with entries in
<span class="math notranslate nohighlight">\(\{0,1,2\}\)</span>. Each column will either contain two <span class="math notranslate nohighlight">\(1\)</span> (at the position of
the endpoint of the edge), or one <span class="math notranslate nohighlight">\(2\)</span> (if the corresponding edge is a
loop).</p>
<p>If the graph is directed return a matrix in <span class="math notranslate nohighlight">\(\{-1,0,1\}\)</span> where <span class="math notranslate nohighlight">\(-1\)</span> and
<span class="math notranslate nohighlight">\(+1\)</span> correspond respectively to the source and the target of the edge. A
loop will correspond to a zero column. In particular, it is not possible
to recover the loops of an oriented graph from its incidence matrix.</p>
<p>See the <a class="reference external" href="https://en.wikipedia.org/wiki/Incidence_matrix">Wikipedia article Incidence_matrix</a> for more information.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">oriented</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); when set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the
matrix will be oriented (i.e. with entries in <span class="math notranslate nohighlight">\(-1\)</span>, <span class="math notranslate nohighlight">\(0\)</span>, <span class="math notranslate nohighlight">\(1\)</span>) and if
set to <code class="docutils literal notranslate"><span class="pre">False</span></code> the matrix will be not oriented (i.e. with entries in
<span class="math notranslate nohighlight">\(0\)</span>, <span class="math notranslate nohighlight">\(1\)</span>, <span class="math notranslate nohighlight">\(2\)</span>). By default, this argument is inferred from the graph
type.  Note that in the case the graph is not directed and with the
option <code class="docutils literal notranslate"><span class="pre">directed=True</span></code>, a somewhat random direction is chosen for
each edge.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sparse</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether to use a sparse or
a dense matrix</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – list (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); when specified, the <span class="math notranslate nohighlight">\(i\)</span>-th
row of the matrix corresponds to the <span class="math notranslate nohighlight">\(i\)</span>-th vertex in the ordering of
<code class="docutils literal notranslate"><span class="pre">vertices</span></code>, otherwise, the <span class="math notranslate nohighlight">\(i\)</span>-th row of the matrix corresponds to
the <span class="math notranslate nohighlight">\(i\)</span>-th vertex in the ordering given by method <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.vertices" title="sage.graphs.generic_graph.GenericGraph.vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertices()</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edges</span></code> – list (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); when specified, the <span class="math notranslate nohighlight">\(i\)</span>-th
column of the matrix corresponds to the <span class="math notranslate nohighlight">\(i\)</span>-th edge in the ordering of
<code class="docutils literal notranslate"><span class="pre">edges</span></code>, otherwise, the <span class="math notranslate nohighlight">\(i\)</span>-th column of the matrix corresponds to
the <span class="math notranslate nohighlight">\(i\)</span>-th edge in the ordering given by method <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.edge_iterator" title="sage.graphs.generic_graph.GenericGraph.edge_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">edge_iterator()</span></code></a>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">()</span>
<span class="go">[1 1 1 0 0 0 0 0 0 0 0 0 0 0 0]</span>
<span class="go">[1 0 0 1 1 0 0 0 0 0 0 0 0 0 0]</span>
<span class="go">[0 0 0 1 0 1 1 0 0 0 0 0 0 0 0]</span>
<span class="go">[0 0 0 0 0 1 0 1 1 0 0 0 0 0 0]</span>
<span class="go">[0 1 0 0 0 0 0 1 0 1 0 0 0 0 0]</span>
<span class="go">[0 0 1 0 0 0 0 0 0 0 1 1 0 0 0]</span>
<span class="go">[0 0 0 0 1 0 0 0 0 0 0 0 1 1 0]</span>
<span class="go">[0 0 0 0 0 0 1 0 0 0 1 0 0 0 1]</span>
<span class="go">[0 0 0 0 0 0 0 0 1 0 0 1 1 0 0]</span>
<span class="go">[0 0 0 0 0 0 0 0 0 1 0 0 0 1 1]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">(</span><span class="n">oriented</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[-1 -1 -1  0  0  0  0  0  0  0  0  0  0  0  0]</span>
<span class="go">[ 1  0  0 -1 -1  0  0  0  0  0  0  0  0  0  0]</span>
<span class="go">[ 0  0  0  1  0 -1 -1  0  0  0  0  0  0  0  0]</span>
<span class="go">[ 0  0  0  0  0  1  0 -1 -1  0  0  0  0  0  0]</span>
<span class="go">[ 0  1  0  0  0  0  0  1  0 -1  0  0  0  0  0]</span>
<span class="go">[ 0  0  1  0  0  0  0  0  0  0 -1 -1  0  0  0]</span>
<span class="go">[ 0  0  0  0  1  0  0  0  0  0  0  0 -1 -1  0]</span>
<span class="go">[ 0  0  0  0  0  0  1  0  0  0  1  0  0  0 -1]</span>
<span class="go">[ 0  0  0  0  0  0  0  0  1  0  0  1  1  0  0]</span>
<span class="go">[ 0  0  0  0  0  0  0  0  0  1  0  0  0  1  1]</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Circulant</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">()</span>
<span class="go">[-1 -1  1  0  0  0  1  0]</span>
<span class="go">[ 1  0 -1 -1  1  0  0  0]</span>
<span class="go">[ 0  0  0  1 -1 -1  0  1]</span>
<span class="go">[ 0  1  0  0  0  1 -1 -1]</span>

<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">()</span>
<span class="go">[1 1 0]</span>
<span class="go">[1 0 1]</span>
<span class="go">[0 1 1]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">(</span><span class="n">oriented</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[2 1 1]</span>
<span class="go">[0 1 1]</span>
</pre></div>
</div>
<p>A well known result states that the product of the (oriented) incidence
matrix with its transpose of a (non-oriented graph) is in fact the
Kirchhoff matrix:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">(</span><span class="n">oriented</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">*</span> <span class="n">m</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">==</span> <span class="n">G</span><span class="o">.</span><span class="n">kirchhoff_matrix</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">(</span><span class="n">oriented</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">*</span> <span class="n">m</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">==</span> <span class="n">K</span><span class="o">.</span><span class="n">kirchhoff_matrix</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">(</span><span class="n">oriented</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">*</span> <span class="n">m</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">==</span> <span class="n">H</span><span class="o">.</span><span class="n">kirchhoff_matrix</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A different ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P5</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P5</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">()</span>
<span class="go">[1 0 0 0]</span>
<span class="go">[1 1 0 0]</span>
<span class="go">[0 1 1 0]</span>
<span class="go">[0 0 1 1]</span>
<span class="go">[0 0 0 1]</span>
<span class="gp">sage: </span><span class="n">P5</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">[0 1 1 0]</span>
<span class="go">[0 0 0 1]</span>
<span class="go">[1 1 0 0]</span>
<span class="go">[0 0 1 1]</span>
<span class="go">[1 0 0 0]</span>
</pre></div>
</div>
<p>A different ordering of the edges:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">P5</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">P5</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">E</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[0 0 0 1]</span>
<span class="go">[0 0 1 1]</span>
<span class="go">[0 1 1 0]</span>
<span class="go">[1 1 0 0]</span>
<span class="go">[1 0 0 0]</span>
<span class="gp">sage: </span><span class="n">P5</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">edges</span><span class="o">=</span><span class="n">E</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[0 1 1 0]</span>
<span class="go">[1 0 0 0]</span>
<span class="go">[0 0 1 1]</span>
<span class="go">[1 1 0 0]</span>
<span class="go">[0 0 0 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.is_bipartite">
<span class="sig-name descname"><span class="pre">is_bipartite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.is_bipartite" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the graph is bipartite.</p>
<p>Traverse the graph <span class="math notranslate nohighlight">\(G\)</span> with breadth-first-search and color nodes.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return a
certificate. If set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the certificate returned is a proper
2-coloring when <span class="math notranslate nohighlight">\(G\)</span> is bipartite, and an odd cycle otherwise.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">is_bipartite</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">is_bipartite</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">RandomBipartite</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">)</span><span class="o">.</span><span class="n">is_bipartite</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A random graph is very rarely bipartite:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_bipartite</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">false</span><span class="p">,</span> <span class="n">oddcycle</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_bipartite</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">oddcycle</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span>
<span class="go">1</span>
</pre></div>
</div>
<p>The method works identically with oriented graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_bipartite</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">false</span><span class="p">,</span> <span class="n">oddcycle</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_bipartite</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">oddcycle</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span>
<span class="go">1</span>

<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">random_orientation</span><span class="p">()</span><span class="o">.</span><span class="n">is_bipartite</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">random_orientation</span><span class="p">()</span><span class="o">.</span><span class="n">is_bipartite</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.is_cayley">
<span class="sig-name descname"><span class="pre">is_cayley</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_group</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mapping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generators</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_disconnected</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.is_cayley" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the graph is a Cayley graph.</p>
<p>If none of the parameters are <code class="docutils literal notranslate"><span class="pre">True</span></code>, return a boolean indicating
whether the graph is a Cayley graph. Otherwise, return a tuple
containing said boolean and the requested data. If the graph is not
a Cayley graph, each of the data will be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>The empty graph is defined to be not a Cayley graph.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For this routine to work on all graphs, the optional package
<code class="docutils literal notranslate"><span class="pre">gap_packages</span></code> needs to be installed: to do
so, it is enough to run <code class="docutils literal notranslate"><span class="pre">sage</span> <span class="pre">-i</span> <span class="pre">gap_packages</span></code>.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">return_group</span></code> (boolean; <code class="docutils literal notranslate"><span class="pre">False</span></code>) – If True, return a group for
which the graph is a Cayley graph.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mapping</span></code> (boolean; <code class="docutils literal notranslate"><span class="pre">False</span></code>) – If True, return a mapping from
vertices to group elements.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">generators</span></code> (boolean; <code class="docutils literal notranslate"><span class="pre">False</span></code>) – If True, return the generating
set of the Cayley graph.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">allow_disconnected</span></code> (boolean; <code class="docutils literal notranslate"><span class="pre">False</span></code>) – If True, disconnected
graphs are considered Cayley if they can be obtained from the Cayley
construction with a generating set that does not generate the group.</p></li>
</ul>
<p>ALGORITHM:</p>
<p>For connected graphs, find a regular subgroup of the automorphism
group. For disconnected graphs, check that the graph is
vertex-transitive and perform the check on one of its connected
components. If a simple graph has density over 1/2, perform the check
on its complement as its disconnectedness may increase performance.</p>
<p>EXAMPLES:</p>
<p>A Petersen Graph is not a Cayley graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_cayley</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A Cayley digraph is a Cayley graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C7</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">permutation</span><span class="o">.</span><span class="n">Cyclic</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">C7</span><span class="o">.</span><span class="n">cayley_graph</span><span class="p">(</span><span class="n">generators</span><span class="o">=</span><span class="n">S</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d</span><span class="o">.</span><span class="n">is_cayley</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Graphs with loops and multiedges will have identity and repeated
elements, respectively, among the generators:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PaleyGraph</span><span class="p">(</span><span class="mi">9</span><span class="p">),</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">g</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">g</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">S</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_cayley</span><span class="p">(</span><span class="n">generators</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="c1"># random</span>
<span class="go">[(),</span>
<span class="go"> (0,2,1)(a,a + 2,a + 1)(2*a,2*a + 2,2*a + 1),</span>
<span class="go"> (0,2,1)(a,a + 2,a + 1)(2*a,2*a + 2,2*a + 1),</span>
<span class="go"> (0,1,2)(a,a + 1,a + 2)(2*a,2*a + 1,2*a + 2),</span>
<span class="go"> (0,1,2)(a,a + 1,a + 2)(2*a,2*a + 1,2*a + 2),</span>
<span class="go"> (0,2*a + 2,a + 1)(1,2*a,a + 2)(2,2*a + 1,a),</span>
<span class="go"> (0,a + 1,2*a + 2)(1,a + 2,2*a)(2,a,2*a + 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.is_chordal">
<span class="sig-name descname"><span class="pre">is_chordal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'B'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.is_chordal" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the given graph is chordal.</p>
<p>A Graph <span class="math notranslate nohighlight">\(G\)</span> is said to be chordal if it contains no induced hole (a
cycle of length at least 4).</p>
<p>Alternatively, chordality can be defined using a Perfect Elimination
Order :</p>
<p>A Perfect Elimination Order of a graph <span class="math notranslate nohighlight">\(G\)</span> is an ordering <span class="math notranslate nohighlight">\(v_1,...,v_n\)</span>
of its vertex set such that for all <span class="math notranslate nohighlight">\(i\)</span>, the neighbors of <span class="math notranslate nohighlight">\(v_i\)</span> whose
index is greater that <span class="math notranslate nohighlight">\(i\)</span> induce a complete subgraph in <span class="math notranslate nohighlight">\(G\)</span>. Hence, the
graph <span class="math notranslate nohighlight">\(G\)</span> can be totally erased by successively removing vertices whose
neighborhood is a clique (also called <em>simplicial</em> vertices)
<a class="reference internal" href="../../../references/index.html#fg1965" id="id17"><span>[FG1965]</span></a>.</p>
<p>(It can be seen that if <span class="math notranslate nohighlight">\(G\)</span> contains an induced hole, then it cannot
have a perfect elimination order. Indeed, if we write <span class="math notranslate nohighlight">\(h_1,...,h_k\)</span> the
<span class="math notranslate nohighlight">\(k\)</span> vertices of such a hole, then the first of those vertices to be
removed would have two non-adjacent neighbors in the graph.)</p>
<p>A Graph is then chordal if and only if it has a Perfect Elimination
Order.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return a
certificate.</p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">False</span></code> (default), returns <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>
accordingly.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></code>, returns :</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">peo)</span></code> when the graph is chordal, where <code class="docutils literal notranslate"><span class="pre">peo</span></code> is a
perfect elimination order of its vertices.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">Hole)</span></code> when the graph is not chordal, where <code class="docutils literal notranslate"><span class="pre">Hole</span></code> (a
<code class="docutils literal notranslate"><span class="pre">Graph</span></code> object) is an induced subgraph of <code class="docutils literal notranslate"><span class="pre">self</span></code> isomorphic to
a hole.</p></li>
</ul>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">&quot;B&quot;</span></code>); the algorithm to choose
among <code class="docutils literal notranslate"><span class="pre">&quot;A&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;B&quot;</span></code> (see next section). While they will agree on
whether the given graph is chordal, they cannot be expected to return
the same certificates.</p></li>
</ul>
<p>ALGORITHM:</p>
<p>This algorithm works through computing a Lex BFS on the graph, then
checking whether the order is a Perfect Elimination Order by computing
for each vertex <span class="math notranslate nohighlight">\(v\)</span> the subgraph induces by its non-deleted neighbors,
then testing whether this graph is complete.</p>
<p>This problem can be solved in <span class="math notranslate nohighlight">\(O(m)\)</span> <a class="reference internal" href="../../../references/index.html#rt1975" id="id18"><span>[RT1975]</span></a> ( where <span class="math notranslate nohighlight">\(m\)</span> is the number
of edges in the graph ) but this implementation is not linear because of
the complexity of Lex BFS.</p>
<p>EXAMPLES:</p>
<p>The lexicographic product of a Path and a Complete Graph
is chordal</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">lexicographic_product</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_chordal</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The same goes with the product of a random lobster (which is a tree)
and a Complete Graph</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomLobster</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">)</span><span class="o">.</span><span class="n">lexicographic_product</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_chordal</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The disjoint union of chordal graphs is still chordal:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">is_chordal</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Let us check the certificate given by Sage is indeed a perfect
elimination order:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">peo</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_chordal</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">peo</span><span class="p">:</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">.</span><span class="n">is_clique</span><span class="p">():</span>
<span class="gp">....: </span>         <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;this should never happen&quot;</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="n">g</span><span class="o">.</span><span class="n">delete_vertex</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<p>Of course, the Petersen Graph is not chordal as it has girth 5:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">girth</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_chordal</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We can even obtain such a cycle as a certificate:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">hole</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_chordal</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">hole</span>
<span class="go">Subgraph of (Petersen graph): Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">hole</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.is_circulant">
<span class="sig-name descname"><span class="pre">is_circulant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.is_circulant" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the graph is circulant.</p>
<p>For more information, see <a class="reference external" href="https://en.wikipedia.org/wiki/Circulant_graph">Wikipedia article Circulant_graph</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return a
certificate for yes-answers (see OUTPUT section)</p></li>
</ul>
<p>OUTPUT:</p>
<p>When <code class="docutils literal notranslate"><span class="pre">certificate</span></code> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code> (default) this method only
returns <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code> answers. When <code class="docutils literal notranslate"><span class="pre">certificate</span></code> is set to
<code class="docutils literal notranslate"><span class="pre">True</span></code>, the method either returns <code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">None)</span></code> or <code class="docutils literal notranslate"><span class="pre">(True,</span>
<span class="pre">lists_of_parameters)</span></code> each element of <code class="docutils literal notranslate"><span class="pre">lists_of_parameters</span></code> can be
used to define the graph as a circulant graph.</p>
<p>See the documentation of
<a class="reference internal" href="graph_generators.html#sage.graphs.graph_generators.GraphGenerators.CirculantGraph" title="sage.graphs.graph_generators.GraphGenerators.CirculantGraph"><code class="xref py py-func docutils literal notranslate"><span class="pre">CirculantGraph()</span></code></a> and
<a class="reference internal" href="digraph_generators.html#sage.graphs.digraph_generators.DiGraphGenerators.Circulant" title="sage.graphs.digraph_generators.DiGraphGenerators.Circulant"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Circulant()</span></code></a> for
more information, and the examples below.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="graph_generators.html#sage.graphs.graph_generators.GraphGenerators.CirculantGraph" title="sage.graphs.graph_generators.GraphGenerators.CirculantGraph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CirculantGraph()</span></code></a>
– a constructor for circulant graphs.</p>
</div>
<p>EXAMPLES:</p>
<p>The Petersen graph is not a circulant graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_circulant</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A cycle is obviously a circulant graph, but several sets of parameters
can be used to define it:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_circulant</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(True, [(5, [1, 4]), (5, [2, 3])])</span>
</pre></div>
</div>
<p>The same goes for directed graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_circulant</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(True, [(5, [1]), (5, [3]), (5, [2]), (5, [4])])</span>
</pre></div>
</div>
<p>With this information, it is very easy to create (and plot) all possible
drawings of a circulant graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CirculantGraph</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">is_circulant</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]:</span>
<span class="gp">....: </span>   <span class="n">graphs</span><span class="o">.</span><span class="n">CirculantGraph</span><span class="p">(</span><span class="o">*</span><span class="n">param</span><span class="p">)</span>
<span class="go">Circulant graph ([2, 3, 10, 11]): Graph on 13 vertices</span>
<span class="go">Circulant graph ([1, 5, 8, 12]): Graph on 13 vertices</span>
<span class="go">Circulant graph ([4, 6, 7, 9]): Graph on 13 vertices</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.is_circular_planar">
<span class="sig-name descname"><span class="pre">is_circular_planar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">on_embedding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kuratowski</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_embedding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ordered</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.is_circular_planar" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the graph is circular planar (outerplanar)</p>
<p>A graph is circular planar if it has a planar embedding in which all
vertices can be drawn in order on a circle. This method can also be used
to check the existence of a planar embedding in which the vertices of a
specific set (the <em>boundary</em>) can be drawn on a circle, all other
vertices being drawn inside of the circle. An order can be defined on
the vertices of the boundary in order to define how they are to appear
on the circle.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">on_embedding</span></code> – dictionary (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the embedding
dictionary to test planarity on (i.e.: will return <code class="docutils literal notranslate"><span class="pre">True</span></code> or
<code class="docutils literal notranslate"><span class="pre">False</span></code> only for the given embedding)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">kuratowski</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return a
tuple with boolean first entry and the Kuratowski subgraph (i.e. an
edge subdivision of <span class="math notranslate nohighlight">\(K_5\)</span> or <span class="math notranslate nohighlight">\(K_{3,3}\)</span>) as the second entry (see
OUTPUT below)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">set_embedding</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether or not to
set the instance field variable that contains a combinatorial
embedding (clockwise ordering of neighbors at each vertex). This value
will only be set if a circular planar embedding is found. It is stored
as a Python dict: <code class="docutils literal notranslate"><span class="pre">v1:</span> <span class="pre">[n1,n2,n3]</span></code> where <code class="docutils literal notranslate"><span class="pre">v1</span></code> is a vertex and
<code class="docutils literal notranslate"><span class="pre">n1,n2,n3</span></code> are its neighbors.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">boundary</span></code> – list (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); an ordered list of vertices
that are required to be drawn on the circle, all others being drawn
inside of it. It is set to <code class="docutils literal notranslate"><span class="pre">None</span></code> by default, meaning that <em>all</em>
vertices should be drawn on the boundary.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ordered</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether or not to
consider the order of the boundary. It required <code class="docutils literal notranslate"><span class="pre">boundary</span></code> to be
defined.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">set_pos</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether or not to set the
position dictionary (for plotting) to reflect the combinatorial
embedding. Note that this value will default to <code class="docutils literal notranslate"><span class="pre">False</span></code> if
<code class="docutils literal notranslate"><span class="pre">set_embedding</span></code> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code>. Also, the position dictionary
will only be updated if a circular planar embedding is found.</p></li>
</ul>
<p>OUTPUT:</p>
<p>The method returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the graph is circular planar, and
<code class="docutils literal notranslate"><span class="pre">False</span></code> if it is not.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">kuratowski</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, then this function will return a
tuple, whose first entry is a boolean and whose second entry is the
Kuratowski subgraph (i.e. an edge subdivision of <span class="math notranslate nohighlight">\(K_5\)</span> or <span class="math notranslate nohighlight">\(K_{3,3}\)</span>)
isolated by the Boyer-Myrvold algorithm. Note that this graph might
contain a vertex or edges that were not in the initial graph.  These
would be elements referred to below as parts of the wheel and the star,
which were added to the graph to require that the boundary can be drawn
on the boundary of a disc, with all other vertices drawn inside (and no
edge crossings).</p>
<p>ALGORITHM:</p>
<p>This is a linear time algorithm to test for circular planarity. It
relies on the edge-addition planarity algorithm due to Boyer-Myrvold. We
accomplish linear time for circular planarity by modifying the graph
before running the general planarity algorithm.</p>
<p>REFERENCE:</p>
<p><a class="reference internal" href="../../../references/index.html#bm2004" id="id19"><span>[BM2004]</span></a></p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g439</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">g439</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g439</span><span class="o">.</span><span class="n">is_circular_planar</span><span class="p">(</span><span class="n">boundary</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">g439</span><span class="o">.</span><span class="n">is_circular_planar</span><span class="p">(</span><span class="n">kuratowski</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">(False, Graph on 8 vertices)</span>
<span class="gp">sage: </span><span class="n">g439</span><span class="o">.</span><span class="n">is_circular_planar</span><span class="p">(</span><span class="n">kuratowski</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">(True, None)</span>
<span class="gp">sage: </span><span class="n">g439</span><span class="o">.</span><span class="n">get_embedding</span><span class="p">()</span>
<span class="go">{1: [7, 5],</span>
<span class="go">2: [5, 6],</span>
<span class="go">3: [6, 7],</span>
<span class="go">4: [7, 6, 5],</span>
<span class="go">5: [1, 4, 2],</span>
<span class="go">6: [2, 4, 3],</span>
<span class="go">7: [3, 4, 1]}</span>
</pre></div>
</div>
<p>Order matters:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K23</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K23</span><span class="o">.</span><span class="n">is_circular_planar</span><span class="p">(</span><span class="n">boundary</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">K23</span><span class="o">.</span><span class="n">is_circular_planar</span><span class="p">(</span><span class="n">ordered</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
<p>With a different order:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K23</span><span class="o">.</span><span class="n">is_circular_planar</span><span class="p">(</span><span class="n">set_embedding</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.is_clique">
<span class="sig-name descname"><span class="pre">is_clique</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directed_clique</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">induced</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.is_clique" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether a set of vertices is a clique</p>
<p>A clique is a set of vertices such that there is exactly one edge
between any two vertices.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – a single vertex or an iterable container of vertices
(default: <code class="docutils literal notranslate"><span class="pre">None);</span> <span class="pre">when</span> <span class="pre">set,</span> <span class="pre">check</span> <span class="pre">whether</span> <span class="pre">the</span> <span class="pre">set</span> <span class="pre">of</span> <span class="pre">vertices</span> <span class="pre">is</span> <span class="pre">a</span>
<span class="pre">clique,</span> <span class="pre">otherwise</span> <span class="pre">check</span> <span class="pre">whether</span> <span class="pre">``self</span></code> is a clique</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">directed_clique</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if set to
<code class="docutils literal notranslate"><span class="pre">False</span></code>, only consider the underlying undirected graph. If set to
<code class="docutils literal notranslate"><span class="pre">True</span></code> and the graph is directed, only return <code class="docutils literal notranslate"><span class="pre">True</span></code> if all
possible edges in _both_ directions exist.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">induced</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, check
that the graph has exactly one edge between any two vertices. If set
to <code class="docutils literal notranslate"><span class="pre">False</span></code>, check that the graph has at least one edge between any
two vertices.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">loops</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, check
that each vertex of the graph has a loop, and exactly one if
furthermore <code class="docutils literal notranslate"><span class="pre">induced</span> <span class="pre">==</span> <span class="pre">True</span></code>. If set to <code class="docutils literal notranslate"><span class="pre">False</span></code>, check that the
graph has no loop when <code class="docutils literal notranslate"><span class="pre">induced</span> <span class="pre">==</span> <span class="pre">True</span></code>, and ignore loops
otherwise.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_clique</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_clique</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">is_clique</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">is_clique</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">is_clique</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">i</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Complete</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">i</span><span class="o">.</span><span class="n">delete_edge</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">i</span><span class="o">.</span><span class="n">is_clique</span><span class="p">(</span><span class="n">directed_clique</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">induced</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">i</span><span class="o">.</span><span class="n">is_clique</span><span class="p">(</span><span class="n">directed_clique</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">induced</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">i</span><span class="o">.</span><span class="n">is_clique</span><span class="p">(</span><span class="n">directed_clique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.is_connected">
<span class="sig-name descname"><span class="pre">is_connected</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.is_connected" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the (di)graph is connected.</p>
<p>Note that in a graph, path connected is equivalent to connected.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – the input graph</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="graph.html#sage.graphs.graph.Graph.is_biconnected" title="sage.graphs.graph.Graph.is_biconnected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_biconnected()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.connectivity</span> <span class="kn">import</span> <span class="n">is_connected</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">is_connected</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">is_connected</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">is_connected</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">is_connected</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">is_connected</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.is_cut_edge">
<span class="sig-name descname"><span class="pre">is_cut_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.is_cut_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the input edge is a cut-edge or a bridge.</p>
<p>A cut edge (or bridge) is an edge that when removed increases
the number of connected components.  This function works with
simple graphs as well as graphs with loops and multiedges.  In
a digraph, a cut edge is an edge that when removed increases
the number of (weakly) connected components.</p>
<p>INPUT: The following forms are accepted</p>
<ul class="simple">
<li><p>is_cut_edge(G, 1, 2 )</p></li>
<li><p>is_cut_edge(G, (1, 2) )</p></li>
<li><p>is_cut_edge(G, 1, 2, ‘label’ )</p></li>
<li><p>is_cut_edge(G, (1, 2, ‘label’) )</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>Returns True if (u,v) is a cut edge, False otherwise</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.connectivity</span> <span class="kn">import</span> <span class="n">is_cut_edge</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">is_cut_edge</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_cut_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="s1">&#39;silly&#39;</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">is_cut_edge</span><span class="p">(</span><span class="n">G</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="s1">&#39;silly&#39;</span><span class="p">))</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">is_cut_edge</span><span class="p">(</span><span class="n">G</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">loops</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">is_cut_edge</span><span class="p">(</span><span class="n">G</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">is_cut_edge</span><span class="p">(</span><span class="n">G</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">is_cut_edge</span><span class="p">(</span><span class="n">G</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="mi">7</span><span class="p">))</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: edge not in graph</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.is_cut_vertex">
<span class="sig-name descname"><span class="pre">is_cut_vertex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weak</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.is_cut_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the input vertex is a cut-vertex.</p>
<p>A vertex is a cut-vertex if its removal from the (di)graph increases the
number of (strongly) connected components. Isolated vertices or leafs are
not cut-vertices. This function works with simple graphs as well as graphs
with loops and multiple edges.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a Sage (Di)Graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">u</span></code> – a vertex</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">weak</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether the connectivity of
directed graphs is to be taken in the weak sense, that is ignoring edges
orientations</p></li>
</ul>
<p>OUTPUT:</p>
<p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">u</span></code> is a cut-vertex, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<p>Giving a LollipopGraph(4,2), that is a complete graph with 4 vertices with a
pending edge:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.connectivity</span> <span class="kn">import</span> <span class="n">is_cut_vertex</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">LollipopGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">is_cut_vertex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">is_cut_vertex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_cut_vertex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Comparing the weak and strong connectivity of a digraph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.connectivity</span> <span class="kn">import</span> <span class="n">is_strongly_connected</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">is_strongly_connected</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">is_cut_vertex</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">is_cut_vertex</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">weak</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Giving a vertex that is not in the graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">is_cut_vertex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: vertex (7) is not a vertex of the graph</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.is_cycle">
<span class="sig-name descname"><span class="pre">is_cycle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">directed_cycle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.is_cycle" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether <code class="docutils literal notranslate"><span class="pre">self</span></code> is a (directed) cycle graph.</p>
<p>We follow the definition provided in <a class="reference internal" href="../../../references/index.html#bm2008" id="id20"><span>[BM2008]</span></a> for undirected graphs. A
cycle on three or more vertices is a simple graph whose vertices can be
arranged in a cyclic order so that two vertices are adjacent if they are
consecutive in the order, and not adjacent otherwise. A cycle on a
vertex consists of a single vertex provided with a loop and a cycle with
two vertices consists of two vertices connected by a pair of parallel
edges. In other words, an undirected graph is a cycle if it is 2-regular
and connected. The empty graph is not a cycle.</p>
<p>For directed graphs, a directed cycle, or circuit, on two or more
vertices is a strongly connected directed graph without loops nor
multiple edges with has many arcs as vertices. A circuit on a vertex
consists of a single vertex provided with a loop.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">directed_cycle</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if set to <code class="docutils literal notranslate"><span class="pre">True</span></code>
and the graph is directed, only return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">self</span></code> is a
directed cycle graph (i.e., a circuit). If set to <code class="docutils literal notranslate"><span class="pre">False</span></code>, we ignore
the direction of edges and so opposite arcs become multiple (parallel)
edges. This parameter is ignored for undirected graphs.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_cycle</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">is_cycle</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span> <span class="p">)])</span><span class="o">.</span><span class="n">is_cycle</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">is_cycle</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">is_cycle</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">is_cycle</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_cycle</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">digraphs</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">is_cycle</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">digraphs</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">is_cycle</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">digraphs</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">is_cycle</span><span class="p">(</span><span class="n">directed_cycle</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">is_cycle</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">is_cycle</span><span class="p">(</span><span class="n">directed_cycle</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.is_drawn_free_of_edge_crossings">
<span class="sig-name descname"><span class="pre">is_drawn_free_of_edge_crossings</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.is_drawn_free_of_edge_crossings" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the position dictionary for this graph is set and that
position dictionary gives a planar embedding.</p>
<p>This simply checks all pairs of edges that don’t share a vertex to
make sure that they don’t intersect.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function require that <code class="docutils literal notranslate"><span class="pre">_pos</span></code> attribute is set (Returns False
otherwise)</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pos</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">layout</span><span class="p">(</span><span class="n">layout</span><span class="o">=</span><span class="s1">&#39;planar&#39;</span><span class="p">,</span> <span class="n">save_pos</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">is_drawn_free_of_edge_crossings</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.is_equitable">
<span class="sig-name descname"><span class="pre">is_equitable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">partition</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quotient_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.is_equitable" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether the given partition is equitable with respect to
self.</p>
<p>A partition is equitable with respect to a graph if for every pair
of cells C1, C2 of the partition, the number of edges from a vertex
of C1 to C2 is the same, over all vertices in C1.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">partition</span></code> - a list of lists</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">quotient_matrix</span></code> - (default False) if True, and
the partition is equitable, returns a matrix over the integers
whose rows and columns represent cells of the partition, and whose
i,j entry is the number of vertices in cell j adjacent to each
vertex in cell i (since the partition is equitable, this is well
defined)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_equitable</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">],[</span><span class="mi">7</span><span class="p">]])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_equitable</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">7</span><span class="p">]])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_equitable</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">7</span><span class="p">]],</span> <span class="n">quotient_matrix</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[1 2 0]</span>
<span class="go">[1 0 2]</span>
<span class="go">[0 2 1]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ss</span> <span class="o">=</span> <span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">WheelGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span><span class="o">.</span><span class="n">line_graph</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">prt</span> <span class="o">=</span> <span class="p">[[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ss</span><span class="o">.</span><span class="n">is_equitable</span><span class="p">(</span><span class="n">prt</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: Partition ([[(0, 1)], [(0, 2), (0, 3), (0, 4), (1, 2), (1, 4)], [(2, 3), (3, 4)]]) is not valid for this graph: vertices are incorrect.</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ss</span> <span class="o">=</span> <span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">WheelGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">line_graph</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ss</span><span class="o">.</span><span class="n">is_equitable</span><span class="p">(</span><span class="n">prt</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.is_eulerian">
<span class="sig-name descname"><span class="pre">is_eulerian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.is_eulerian" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the graph is Eulerian.</p>
<p>A graph is Eulerian if it has a (closed) tour that visits each edge
exactly once.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">path</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); by default this function
finds if the graph contains a closed tour visiting each edge once,
i.e. an Eulerian cycle. If you want to test the existence of an
Eulerian path, set this argument to <code class="docutils literal notranslate"><span class="pre">True</span></code>. Graphs with this
property are sometimes called semi-Eulerian.</p></li>
</ul>
<p>OUTPUT:</p>
<p><code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code> for the closed tour case. For an open tour search
(<code class="docutils literal notranslate"><span class="pre">path``=``True</span></code>) the function returns <code class="docutils literal notranslate"><span class="pre">False</span></code> if the graph is not
semi-Eulerian, or a tuple (u, v) in the other case. This tuple defines
the edge that would make the graph Eulerian, i.e. close an existing open
tour.  This edge may or may not be already present in the graph.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">]});</span> <span class="n">g</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">2</span><span class="p">]});</span> <span class="n">g</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[]});</span> <span class="n">g</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">)]);</span> <span class="n">g</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]});</span> <span class="n">g</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(1, 0)</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">]});</span> <span class="n">g</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">]},</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">e</span>
<span class="go">(0, 1)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.is_gallai_tree">
<span class="sig-name descname"><span class="pre">is_gallai_tree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.is_gallai_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the current graph is a Gallai tree.</p>
<p>A graph is a Gallai tree if and only if it is connected and its
<span class="math notranslate nohighlight">\(2\)</span>-connected components are all isomorphic to complete graphs or odd
cycles.</p>
<p>A connected graph is not degree-choosable if and only if it is a Gallai
tree <a class="reference internal" href="../../../references/index.html#ert1979" id="id21"><span>[ERT1979]</span></a>.</p>
<p>EXAMPLES:</p>
<p>A complete graph is, or course, a Gallai Tree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_gallai_tree</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Petersen Graph is not:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_gallai_tree</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A Graph built from vertex-disjoint complete graphs linked by one edge to
a special vertex <span class="math notranslate nohighlight">\(-1\)</span> is a ‘’star-shaped’’ Gallai tree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">connected_components</span><span class="p">()])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_gallai_tree</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.is_hamiltonian">
<span class="sig-name descname"><span class="pre">is_hamiltonian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solver</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraint_generation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.is_hamiltonian" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the current graph is Hamiltonian.</p>
<p>A graph (resp. digraph) is said to be Hamiltonian if it contains as a
subgraph a cycle (resp. a circuit) going through all the vertices.</p>
<p>Testing for Hamiltonicity being NP-Complete, this algorithm could run
for some time depending on the instance.</p>
<p>ALGORITHM:</p>
<p>See <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.traveling_salesman_problem" title="sage.graphs.generic_graph.GenericGraph.traveling_salesman_problem"><code class="xref py py-meth docutils literal notranslate"><span class="pre">traveling_salesman_problem()</span></code></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">constraint_generation</span></code> (boolean) – whether to use constraint
generation when solving the Mixed Integer Linear Program.  When
<code class="docutils literal notranslate"><span class="pre">constraint_generation</span> <span class="pre">=</span> <span class="pre">None</span></code>, constraint generation is used
whenever the graph has a density larger than 70%.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose_constraints</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to
display which constraints are being generated</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if a Hamiltonian cycle/circuit exists, and <code class="docutils literal notranslate"><span class="pre">False</span></code>
otherwise.</p>
<p>NOTE:</p>
<p>This function, as <code class="docutils literal notranslate"><span class="pre">hamiltonian_cycle</span></code> and
<code class="docutils literal notranslate"><span class="pre">traveling_salesman_problem</span></code>, computes a Hamiltonian cycle if it
exists: the user should <em>NOT</em> test for Hamiltonicity using
<code class="docutils literal notranslate"><span class="pre">is_hamiltonian</span></code> before calling <code class="docutils literal notranslate"><span class="pre">hamiltonian_cycle</span></code> or
<code class="docutils literal notranslate"><span class="pre">traveling_salesman_problem</span></code> as it would result in computing it twice.</p>
<p>EXAMPLES:</p>
<p>The Heawood Graph is known to be Hamiltonian</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">HeawoodGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_hamiltonian</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Petergraph, though, is not</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_hamiltonian</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.is_immutable">
<span class="sig-name descname"><span class="pre">is_immutable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.is_immutable" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the graph is immutable.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_immutable</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">immutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">is_immutable</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.is_independent_set">
<span class="sig-name descname"><span class="pre">is_independent_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.is_independent_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether <code class="docutils literal notranslate"><span class="pre">vertices</span></code> is an independent set of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>An independent set is a set of vertices such that there is no edge
between any two vertices.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – a single vertex or an iterable container of vertices
(default: <code class="docutils literal notranslate"><span class="pre">None);</span> <span class="pre">when</span> <span class="pre">set,</span> <span class="pre">check</span> <span class="pre">whether</span> <span class="pre">the</span> <span class="pre">given</span> <span class="pre">set</span> <span class="pre">of</span> <span class="pre">vertices</span>
<span class="pre">is</span> <span class="pre">an</span> <span class="pre">independent</span> <span class="pre">set,</span> <span class="pre">otherwise,</span> <span class="pre">check</span> <span class="pre">whether</span> <span class="pre">the</span> <span class="pre">set</span> <span class="pre">of</span> <span class="pre">vertices</span> <span class="pre">of</span>
<span class="pre">``self</span></code> is an independent set</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">is_independent_set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">is_independent_set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.is_interval">
<span class="sig-name descname"><span class="pre">is_interval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.is_interval" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the graph is an interval graph.</p>
<p>An <em>interval graph</em> is one where every vertex can be seen as
an interval on the real line so that there is an edge in the graph
iff the corresponding intervals intersects.</p>
<p>See the <a class="reference external" href="https://en.wikipedia.org/wiki/Interval_graph">Wikipedia article Interval_graph</a> for more information.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>);</p>
<ul>
<li><p>When <code class="docutils literal notranslate"><span class="pre">certificate=False</span></code>, returns <code class="docutils literal notranslate"><span class="pre">True</span></code> is the graph is an
interval graph and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise</p></li>
<li><p>When <code class="docutils literal notranslate"><span class="pre">certificate=True</span></code>, returns either <code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">None)</span></code> or
<code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">d)</span></code> where <code class="docutils literal notranslate"><span class="pre">d</span></code> is a dictionary whose keys are the
vertices and values are pairs of integers.  They correspond to an
embedding of the interval graph, each vertex being represented by an
interval going from the first of the two values to the second.</p></li>
</ul>
</li>
</ul>
<p>ALGORITHM:</p>
<p>Through the use of PQ-Trees.</p>
<p>AUTHOR:</p>
<p>Nathann Cohen (implementation)</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_interval</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_interval</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(True, {1: (0, 5), 2: (4, 6), 3: (1, 3), 4: (2, 7)})</span>
</pre></div>
</div>
<p>The Petersen Graph is not chordal, so it cannot be an interval graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_interval</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A chordal but still not an interval graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_interval</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="pq_trees.html#module-sage.graphs.pq_trees" title="sage.graphs.pq_trees"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Interval</span> <span class="pre">Graph</span> <span class="pre">Recognition</span></code></a>.</p></li>
<li><p><a class="reference internal" href="pq_trees.html#sage.graphs.pq_trees.PQ" title="sage.graphs.pq_trees.PQ"><code class="xref py py-meth docutils literal notranslate"><span class="pre">PQ</span></code></a> – implementation of PQ-Trees</p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_chordal" title="sage.graphs.generic_graph.GenericGraph.is_chordal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_chordal()</span></code></a></p></li>
<li><p><a class="reference internal" href="graph_generators.html#sage.graphs.graph_generators.GraphGenerators.IntervalGraph" title="sage.graphs.graph_generators.GraphGenerators.IntervalGraph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">IntervalGraph()</span></code></a></p></li>
<li><p><a class="reference internal" href="graph_generators.html#sage.graphs.graph_generators.GraphGenerators.RandomIntervalGraph" title="sage.graphs.graph_generators.GraphGenerators.RandomIntervalGraph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">RandomIntervalGraph()</span></code></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.is_isomorphic">
<span class="sig-name descname"><span class="pre">is_isomorphic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbosity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.is_isomorphic" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests for isomorphism between self and other.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – if True, then output is <span class="math notranslate nohighlight">\((a, b)\)</span>, where <span class="math notranslate nohighlight">\(a\)</span>
is a boolean and <span class="math notranslate nohighlight">\(b\)</span> is either a map or <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edge_labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code> allows
only permutations respecting edge labels.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>either a boolean or, if <code class="docutils literal notranslate"><span class="pre">certificate</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, a tuple consisting
of a boolean and a map or <code class="docutils literal notranslate"><span class="pre">None</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<p>Graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.groups.perm_gps.permgroup_named</span> <span class="kn">import</span> <span class="n">SymmetricGroup</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">gamma</span> <span class="o">=</span> <span class="n">SymmetricGroup</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SymmetricGroup</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">gamma</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">a</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.generic_graph_pyx</span> <span class="kn">import</span> <span class="n">spring_layout_fast</span>
<span class="gp">sage: </span><span class="n">position_D</span> <span class="o">=</span> <span class="n">spring_layout_fast</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">position_E</span> <span class="o">=</span> <span class="p">{}</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">vert</span> <span class="ow">in</span> <span class="n">position_D</span><span class="p">:</span>
<span class="gp">....: </span> <span class="n">position_E</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">vert</span><span class="p">]]</span> <span class="o">=</span> <span class="n">position_D</span><span class="p">[</span><span class="n">vert</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">graphics_array</span><span class="p">([</span><span class="n">D</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="n">position_D</span><span class="p">),</span> <span class="n">E</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="n">position_E</span><span class="p">)])</span><span class="o">.</span><span class="n">show</span><span class="p">()</span> <span class="c1"># long time</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">HeawoodGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Multigraphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Digraphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(True, {0: 1, 1: 0, 2: 2})</span>
</pre></div>
</div>
<p>Edge labeled graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">)]</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">relabel</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Edge labeled digraphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">)]</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">relabel</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(True, {0: 1, 1: 2, 2: 3, 3: 4, 4: 0})</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.is_planar">
<span class="sig-name descname"><span class="pre">is_planar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">on_embedding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kuratowski</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_embedding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.is_planar" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the graph is planar.</p>
<p>This wraps the reference implementation provided by John Boyer of the
linear time planarity algorithm by edge addition due to Boyer
Myrvold. (See reference code in <a class="reference internal" href="planarity.html#module-sage.graphs.planarity" title="sage.graphs.planarity"><code class="xref py py-mod docutils literal notranslate"><span class="pre">planarity</span></code></a>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The argument on_embedding takes precedence over
<code class="docutils literal notranslate"><span class="pre">set_embedding</span></code>. This means that only the <code class="docutils literal notranslate"><span class="pre">on_embedding</span></code>
combinatorial embedding will be tested for planarity and no
<code class="docutils literal notranslate"><span class="pre">_embedding</span></code> attribute will be set as a result of this function
call, unless <code class="docutils literal notranslate"><span class="pre">on_embedding</span></code> is None.</p>
</div>
<p>REFERENCE:</p>
<p><a class="reference internal" href="../../../references/index.html#bm2004" id="id22"><span>[BM2004]</span></a></p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p>“Almost planar graph”: <a class="reference internal" href="graph.html#sage.graphs.graph.Graph.is_apex" title="sage.graphs.graph.Graph.is_apex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_apex()</span></code></a></p></li>
<li><p>“Measuring non-planarity”: <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.genus" title="sage.graphs.generic_graph.GenericGraph.genus"><code class="xref py py-meth docutils literal notranslate"><span class="pre">genus()</span></code></a>, <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.crossing_number" title="sage.graphs.generic_graph.GenericGraph.crossing_number"><code class="xref py py-meth docutils literal notranslate"><span class="pre">crossing_number()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.planar_dual" title="sage.graphs.generic_graph.GenericGraph.planar_dual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">planar_dual()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.faces" title="sage.graphs.generic_graph.GenericGraph.faces"><code class="xref py py-meth docutils literal notranslate"><span class="pre">faces()</span></code></a></p></li>
<li><p><a class="reference internal" href="graph.html#sage.graphs.graph.Graph.is_polyhedral" title="sage.graphs.graph.Graph.is_polyhedral"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_polyhedral()</span></code></a></p></li>
</ul>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">on_embedding</span></code> – dictionary (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the embedding
dictionary to test planarity on (i.e.: will return <code class="docutils literal notranslate"><span class="pre">True</span></code> or
<code class="docutils literal notranslate"><span class="pre">False</span></code> only for the given embedding)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">kuratowski</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return a
tuple with boolean as first entry. If the graph is nonplanar, will
return the Kuratowski subgraph (i.e. an edge subdivision of <span class="math notranslate nohighlight">\(K_5\)</span> or
<span class="math notranslate nohighlight">\(K_{3,3}\)</span>) as the second tuple entry.  If the graph is planar, returns
<code class="docutils literal notranslate"><span class="pre">None</span></code> as the second entry. When set to <code class="docutils literal notranslate"><span class="pre">False</span></code>, only a boolean
answer is returned.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">set_embedding</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to set the
instance field variable that contains a combinatorial embedding
(clockwise ordering of neighbors at each vertex). This value will only
be set if a planar embedding is found. It is stored as a Python dict:
<code class="docutils literal notranslate"><span class="pre">v1:</span> <span class="pre">[n1,n2,n3]</span></code> where <code class="docutils literal notranslate"><span class="pre">v1</span></code> is a vertex and <code class="docutils literal notranslate"><span class="pre">n1,n2,n3</span></code> are its
neighbors.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">set_pos</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to set the
position dictionary (for plotting) to reflect the combinatorial
embedding.  Note that this value will default to False if set_emb is
set to False. Also, the position dictionary will only be updated if a
planar embedding is found.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_planar</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CircularLadderGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_planar</span><span class="p">(</span><span class="n">set_embedding</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">get_embedding</span><span class="p">()</span>
<span class="go">{0: [1, 4, 3],</span>
<span class="go"> 1: [2, 5, 0],</span>
<span class="go"> 2: [3, 6, 1],</span>
<span class="go"> 3: [0, 7, 2],</span>
<span class="go"> 4: [0, 5, 7],</span>
<span class="go"> 5: [1, 6, 4],</span>
<span class="go"> 6: [2, 7, 5],</span>
<span class="go"> 7: [4, 6, 3]}</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">is_planar</span><span class="p">(</span><span class="n">kuratowski</span><span class="o">=</span><span class="kc">True</span><span class="p">))[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span>
<span class="go">[0 1 0 0 0 1 0 0 0]</span>
<span class="go">[1 0 1 0 0 0 1 0 0]</span>
<span class="go">[0 1 0 1 0 0 0 1 0]</span>
<span class="go">[0 0 1 0 0 0 0 0 1]</span>
<span class="go">[0 0 0 0 0 0 1 1 0]</span>
<span class="go">[1 0 0 0 0 0 0 1 1]</span>
<span class="go">[0 1 0 0 1 0 0 0 1]</span>
<span class="go">[0 0 1 0 1 1 0 0 0]</span>
<span class="go">[0 0 0 1 0 1 1 0 0]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">k43</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result</span> <span class="o">=</span> <span class="n">k43</span><span class="o">.</span><span class="n">is_planar</span><span class="p">(</span><span class="n">kuratowski</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">result</span>
<span class="go">(False, Graph on 6 vertices)</span>
<span class="gp">sage: </span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Multi-edged and looped graphs are partially supported:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]},</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_planar</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_planar</span><span class="p">(</span><span class="n">on_embedding</span><span class="o">=</span><span class="p">{})</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">NotImplementedError: cannot compute with embeddings of multiple-edged or looped graphs</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_planar</span><span class="p">(</span><span class="n">set_pos</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">NotImplementedError: cannot compute with embeddings of multiple-edged or looped graphs</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_planar</span><span class="p">(</span><span class="n">set_embedding</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">NotImplementedError: cannot compute with embeddings of multiple-edged or looped graphs</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_planar</span><span class="p">(</span><span class="n">kuratowski</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(True, None)</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_planar</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">b</span><span class="p">,</span><span class="n">k</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">is_planar</span><span class="p">(</span><span class="n">kuratowski</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">k</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.is_regular">
<span class="sig-name descname"><span class="pre">is_regular</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.is_regular" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether this graph is (<span class="math notranslate nohighlight">\(k\)</span>-)regular.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the degree of regularity to
check for</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">HoffmanSingletonGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_regular</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_regular</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>So the Hoffman-Singleton graph is regular, but not 9-regular. In fact,
we can now find the degree easily as follows:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">degree_iterator</span><span class="p">())</span>
<span class="go">7</span>
</pre></div>
</div>
<p>The house graph is not regular:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">HouseGraph</span><span class="p">()</span><span class="o">.</span><span class="n">is_regular</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A graph without vertices is <span class="math notranslate nohighlight">\(k\)</span>-regular for every <span class="math notranslate nohighlight">\(k\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">is_regular</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.is_self_complementary">
<span class="sig-name descname"><span class="pre">is_self_complementary</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.is_self_complementary" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the graph is self-complementary.</p>
<p>A (di)graph is self-complementary if it is isomorphic to its (di)graph
complement. For instance, the path graph <span class="math notranslate nohighlight">\(P_4\)</span> and the cycle graph <span class="math notranslate nohighlight">\(C_5\)</span>
are self-complementary.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Self-complementary_graph">Wikipedia article Self-complementary_graph</a></p></li>
<li><p><a class="reference external" href="https://oeis.org/A000171">OEIS sequence A000171</a> for the numbers of self-complementary graphs of order <span class="math notranslate nohighlight">\(n\)</span></p></li>
<li><p><a class="reference external" href="https://oeis.org/A003086">OEIS sequence A003086</a> for the numbers of self-complementary digraphs of order <span class="math notranslate nohighlight">\(n\)</span>.</p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>The only self-complementary path graph is <span class="math notranslate nohighlight">\(P_4\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">is_self_complementary</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">is_self_complementary</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The only self-complementary directed path is <span class="math notranslate nohighlight">\(P_2\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">digraphs</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">is_self_complementary</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">digraphs</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">is_self_complementary</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Every Paley graph is self-complementary:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PaleyGraph</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_self_complementary</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.is_subgraph">
<span class="sig-name descname"><span class="pre">is_subgraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">induced</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.is_subgraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether <code class="docutils literal notranslate"><span class="pre">self</span></code> is a subgraph of <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Please note that this method does not check whether <code class="docutils literal notranslate"><span class="pre">self</span></code>
contains a subgraph <em>isomorphic</em> to <code class="docutils literal notranslate"><span class="pre">other</span></code>, but only if it
directly contains it as a subgraph !</p>
<p>By default <code class="docutils literal notranslate"><span class="pre">induced</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> for backwards compatibility.</p>
</div>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">other</span></code> – a Sage (Di)Graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">induced</span></code> - boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if set to <code class="docutils literal notranslate"><span class="pre">True</span></code> check
whether the graph is an <em>induced</em> subgraph of <code class="docutils literal notranslate"><span class="pre">other</span></code> that is if the
vertices of the graph are also vertices of <code class="docutils literal notranslate"><span class="pre">other</span></code>, and the edges of
the graph are equal to the edges of <code class="docutils literal notranslate"><span class="pre">other</span></code> between the vertices
contained in the graph.</p>
<p>If set to <code class="docutils literal notranslate"><span class="pre">False</span></code> tests whether the graph is a subgraph of <code class="docutils literal notranslate"><span class="pre">other</span></code>
that is if all vertices of the graph are also in <code class="docutils literal notranslate"><span class="pre">other</span></code> and all
edges of the graph are also in <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
</li>
</ul>
<p>OUTPUT:</p>
<p>boolean – <code class="docutils literal notranslate"><span class="pre">True</span></code> iff the graph is a (possibly induced) subgraph of
<code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>If you are interested in the (possibly induced) subgraphs isomorphic
to the graph in <code class="docutils literal notranslate"><span class="pre">other</span></code>, you are looking for the following
methods:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.subgraph_search" title="sage.graphs.generic_graph.GenericGraph.subgraph_search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subgraph_search()</span></code></a> – find a subgraph
isomorphic to <code class="docutils literal notranslate"><span class="pre">other</span></code> inside of the graph</p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.subgraph_search_count" title="sage.graphs.generic_graph.GenericGraph.subgraph_search_count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subgraph_search_count()</span></code></a> – count the number
of such copies</p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.subgraph_search_iterator" title="sage.graphs.generic_graph.GenericGraph.subgraph_search_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subgraph_search_iterator()</span></code></a> –
iterator over all the copies of <code class="docutils literal notranslate"><span class="pre">other</span></code> contained in the graph</p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_subgraph</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_subgraph</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_subgraph</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">induced</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">is_subgraph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">induced</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.is_transitively_reduced">
<span class="sig-name descname"><span class="pre">is_transitively_reduced</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.is_transitively_reduced" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the digraph is transitively reduced.</p>
<p>A digraph is transitively reduced if it is equal to its transitive
reduction. A graph is transitively reduced if it is a forest.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">d</span><span class="o">.</span><span class="n">is_transitively_reduced</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">d</span><span class="o">.</span><span class="n">is_transitively_reduced</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[]})</span>
<span class="gp">sage: </span><span class="n">d</span><span class="o">.</span><span class="n">is_transitively_reduced</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.is_vertex_transitive">
<span class="sig-name descname"><span class="pre">is_vertex_transitive</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">partition</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbosity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_group</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.is_vertex_transitive" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the automorphism group of self is transitive within
the partition provided, by default the unit partition of the
vertices of self (thus by default tests for vertex transitivity in
the usual sense).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_vertex_transitive</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_vertex_transitive</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">is_vertex_transitive</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="mf">.01</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">is_vertex_transitive</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.katz_centrality">
<span class="sig-name descname"><span class="pre">katz_centrality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.katz_centrality" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Katz centrality of vertex <span class="math notranslate nohighlight">\(u\)</span>.</p>
<p>Katz centrality of a node is a measure of centrality in a graph
network. Katz centrality computes the relative influence of a node
within a network. Connections made with distant neighbors are, however
penalized by an attenuation factor <span class="math notranslate nohighlight">\(\alpha\)</span>.</p>
<p>See the <a class="reference external" href="https://en.wikipedia.org/wiki/Katz_centrality">Wikipedia article Katz_centrality</a> for more information.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">alpha</span></code> – a nonnegative real number, must be less than the
reciprocal of the spectral radius of the graph (the maximum absolute
eigenvalue of the adjacency matrix).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">u</span></code> – the vertex whose Katz centrality needs to be measured
(default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
</ul>
<p>OUTPUT: a list containing the Katz centrality of each vertex if u=None
otherwise Katz centrality of the vertex u.</p>
<p>EXAMPLES:</p>
<p>We compute the Katz centrality of a 4-cycle (note that by symmetry,
all 4 vertices have the same centrality)</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">katz_centrality</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">20</span><span class="p">)</span>
<span class="go">{0: 1/9, 1: 1/9, 2: 1/9, 3: 1/9}</span>
</pre></div>
</div>
<p>Note that in the below example the nodes having indegree <span class="math notranslate nohighlight">\(0\)</span> also have
the Katz centrality value as <span class="math notranslate nohighlight">\(0\)</span>, as these nodes are not influenced by
other nodes.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">6</span><span class="p">:[</span><span class="mi">11</span><span class="p">],</span> <span class="mi">7</span><span class="p">:[</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">],</span> <span class="mi">8</span><span class="p">:[</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">],</span> <span class="mi">9</span><span class="p">:[</span><span class="mi">10</span><span class="p">],</span> <span class="mi">10</span><span class="p">:[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="mi">11</span><span class="p">:[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">katz_centrality</span><span class="p">(</span><span class="mf">.85</span><span class="p">)</span>
<span class="go">{1: 0.000000000000000,</span>
<span class="go"> 2: 0.000000000000000,</span>
<span class="go"> 3: 0.000000000000000,</span>
<span class="go"> 4: 16.7319819819820,</span>
<span class="go"> 5: 18.6846846846847,</span>
<span class="go"> 6: 173.212076941807,</span>
<span class="go"> 7: 0.000000000000000,</span>
<span class="go"> 8: 18.6846846846847,</span>
<span class="go"> 9: 0.000000000000000,</span>
<span class="go"> 10: 20.9819819819820,</span>
<span class="go"> 11: 202.778914049184}</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.katz_matrix" title="sage.graphs.generic_graph.GenericGraph.katz_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">katz_matrix()</span></code></a></p></li>
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Katz_centrality">Wikipedia article Katz_centrality</a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.katz_matrix">
<span class="sig-name descname"><span class="pre">katz_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nonedgesonly</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.katz_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Katz matrix of the graph.</p>
<p>Katz centrality of a node is a measure of centrality in a graph
network. Katz centrality computes the relative influence of a node
within a network. Connections made with distant neighbors are, however
penalized by an attenuation factor <span class="math notranslate nohighlight">\(\alpha\)</span>.</p>
<p>Adding the values in the Katz matrix of all columns in a particular row
gives the Katz centrality measure of the vertex represented by that
particular row.  Katz centrality measures influence by taking into
account the total number of walks between a pair of nodes.</p>
<p>See the <a class="reference external" href="https://en.wikipedia.org/wiki/Katz_centrality">Wikipedia article Katz_centrality</a> for more information.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">alpha</span></code> – a nonnegative real number, must be less than the
reciprocal of the spectral radius of the graph (the maximum
absolute eigenvalue of the adjacency matrix)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nonedgesonly</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, value
for each edge present in the graph is set to zero.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – list (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the ordering of the
vertices defining how they should appear in the matrix. By default,
the ordering given by <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.vertices" title="sage.graphs.generic_graph.GenericGraph.vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GenericGraph.vertices()</span></code></a> is used.</p></li>
</ul>
<p>OUTPUT: the Katz matrix of the graph with parameter alpha</p>
<p>EXAMPLES:</p>
<p>We find the Katz matrix of an undirected 4-cycle.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">katz_matrix</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">20</span><span class="p">)</span>
<span class="go">[1/198  5/99 1/198  5/99]</span>
<span class="go">[ 5/99 1/198  5/99 1/198]</span>
<span class="go">[1/198  5/99 1/198  5/99]</span>
<span class="go">[ 5/99 1/198  5/99 1/198]</span>
</pre></div>
</div>
<p>We find the Katz matrix of an undirected 4-cycle with all entries
other than those which correspond to non-edges zeroed out.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">katz_matrix</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">20</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">[    0     0 1/198     0]</span>
<span class="go">[    0     0     0 1/198]</span>
<span class="go">[1/198     0     0     0]</span>
<span class="go">[    0     1/198 0     0]</span>
</pre></div>
</div>
<p>This will give an error if alpha&lt;=0 or alpha&gt;=1/spectral_radius = 1/max
(A.eigenvalues()).</p>
<p>We find the Katz matrix in a fan on 6 vertices.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">katz_matrix</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
<span class="go">[   169/2256    545/4512      25/188    605/4512      25/188    545/4512    485/4512]</span>
<span class="go">[   545/4512 7081/297792  4355/37224    229/9024   595/37224 4073/297792    109/9024]</span>
<span class="go">[     25/188  4355/37224    172/4653      45/376    125/4653   595/37224       5/376]</span>
<span class="go">[   605/4512    229/9024      45/376    337/9024      45/376    229/9024    121/9024]</span>
<span class="go">[     25/188   595/37224    125/4653      45/376    172/4653  4355/37224       5/376]</span>
<span class="go">[   545/4512 4073/297792   595/37224    229/9024  4355/37224 7081/297792    109/9024]</span>
<span class="go">[   485/4512    109/9024       5/376    121/9024       5/376    109/9024     97/9024]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.katz_centrality" title="sage.graphs.generic_graph.GenericGraph.katz_centrality"><code class="xref py py-meth docutils literal notranslate"><span class="pre">katz_centrality()</span></code></a></p></li>
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Katz_centrality">Wikipedia article Katz_centrality</a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.kirchhoff_matrix">
<span class="sig-name descname"><span class="pre">kirchhoff_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indegree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signless</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.kirchhoff_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Kirchhoff matrix (a.k.a. the Laplacian) of the graph.</p>
<p>The Kirchhoff matrix is defined to be <span class="math notranslate nohighlight">\(D + M\)</span> if signless and <span class="math notranslate nohighlight">\(D - M\)</span>
otherwise, where <span class="math notranslate nohighlight">\(D\)</span> is the diagonal degree matrix (each diagonal entry
is the degree of the corresponding vertex), and <span class="math notranslate nohighlight">\(M\)</span> is the adjacency
matrix.  If <code class="docutils literal notranslate"><span class="pre">normalized</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the returned matrix is
<span class="math notranslate nohighlight">\(D^{-1/2}(D+M)D^{-1/2}\)</span> if signless and <span class="math notranslate nohighlight">\(D^{-1/2}(D-M)D^{-1/2}\)</span>
otherwise.</p>
<p>(In the special case of DiGraphs, <span class="math notranslate nohighlight">\(D\)</span> is defined as the diagonal
in-degree matrix or diagonal out-degree matrix according to the value of
<code class="docutils literal notranslate"><span class="pre">indegree</span></code>)</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">weighted</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>);</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the weighted adjacency matrix is used for <span class="math notranslate nohighlight">\(M\)</span>, and the
diagonal matrix <span class="math notranslate nohighlight">\(D\)</span> takes into account the weight of edges (replace
in the definition “degree” by “sum of the incident edges”)</p></li>
<li><p>Else, each edge is assumed to have weight 1</p></li>
</ul>
<p>Default is to take weights into consideration if and only if the graph
is weighted.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">indegree</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); this parameter is
considered only for digraphs.</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, each diagonal entry of <span class="math notranslate nohighlight">\(D\)</span> is equal to the in-degree of
the corresponding vertex</p></li>
<li><p>Else, each diagonal entry of <span class="math notranslate nohighlight">\(D\)</span> is equal to the out-degree of the
corresponding vertex</p></li>
</ul>
<p>By default, <code class="docutils literal notranslate"><span class="pre">indegree</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">normalized</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>);</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the returned matrix is <span class="math notranslate nohighlight">\(D^{-1/2}(D+M)D^{-1/2}\)</span> for
signless and <span class="math notranslate nohighlight">\(D^{-1/2}(D-M)D^{-1/2}\)</span> otherwise, a normalized
version of the Laplacian matrix. More accurately, the normalizing
matrix used is equal to <span class="math notranslate nohighlight">\(D^{-1/2}\)</span> only for non-isolated vertices.
If vertex <span class="math notranslate nohighlight">\(i\)</span> is isolated, then diagonal entry <span class="math notranslate nohighlight">\(i\)</span> in the matrix is
1, rather than a division by zero</p></li>
<li><p>Else, the matrix <span class="math notranslate nohighlight">\(D+M\)</span> for signless and <span class="math notranslate nohighlight">\(D-M\)</span> otherwise is returned</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">signless</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>);</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, <span class="math notranslate nohighlight">\(D+M\)</span> is used in calculation of Kirchhoff matrix</p></li>
<li><p>Else, <span class="math notranslate nohighlight">\(D-M\)</span> is used in calculation of Kirchhoff matrix</p></li>
</ul>
</li>
</ul>
<p>Note that any additional keywords will be passed on to either the
<code class="docutils literal notranslate"><span class="pre">adjacency_matrix</span></code> or <code class="docutils literal notranslate"><span class="pre">weighted_adjacency_matrix</span></code> method.</p>
<p>AUTHORS:</p>
<ul class="simple">
<li><p>Tom Boothby</p></li>
<li><p>Jason Grout</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">kirchhoff_matrix</span><span class="p">(</span><span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">M</span>
<span class="go">[ 8 -1 -3 -4]</span>
<span class="go">[-1  3 -2  0]</span>
<span class="go">[-3 -2  5  0]</span>
<span class="go">[-4  0  0  4]</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">kirchhoff_matrix</span><span class="p">();</span> <span class="n">M</span>
<span class="go">[ 3 -1 -1 -1]</span>
<span class="go">[-1  2 -1  0]</span>
<span class="go">[-1 -1  2  0]</span>
<span class="go">[-1  0  0  1]</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">laplacian_matrix</span><span class="p">(</span><span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">M</span>                                            <span class="c1"># optional - sage.symbolic</span>
<span class="go">[                   1 -1/6*sqrt(3)*sqrt(2) -1/6*sqrt(3)*sqrt(2)         -1/3*sqrt(3)]</span>
<span class="go">[-1/6*sqrt(3)*sqrt(2)                    1                 -1/2                    0]</span>
<span class="go">[-1/6*sqrt(3)*sqrt(2)                 -1/2                    1                    0]</span>
<span class="go">[        -1/3*sqrt(3)                    0                    0                    1]</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">kirchhoff_matrix</span><span class="p">(</span><span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">signless</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">M</span>
<span class="go">[8 1 3 4]</span>
<span class="go">[1 3 2 0]</span>
<span class="go">[3 2 5 0]</span>
<span class="go">[4 0 0 4]</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">laplacian_matrix</span><span class="p">(</span><span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[ 0  0  0]</span>
<span class="go">[ 0  1 -1]</span>
<span class="go">[ 0 -1  1]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">laplacian_matrix</span><span class="p">(</span><span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">signless</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[0 0 0]</span>
<span class="go">[0 1 1]</span>
<span class="go">[0 1 1]</span>
</pre></div>
</div>
<p>A weighted directed graph with loops, changing the variable <code class="docutils literal notranslate"><span class="pre">indegree</span></code></p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">4</span><span class="p">}},</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">laplacian_matrix</span><span class="p">()</span>
<span class="go">[ 4 -3]</span>
<span class="go">[-4  3]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">4</span><span class="p">}},</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">laplacian_matrix</span><span class="p">(</span><span class="n">indegree</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[ 3 -3]</span>
<span class="go">[-4  4]</span>
</pre></div>
</div>
<p>A different ordering of the vertices (see <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.adjacency_matrix" title="sage.graphs.generic_graph.GenericGraph.adjacency_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">adjacency_matrix()</span></code></a> and
<a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.weighted_adjacency_matrix" title="sage.graphs.generic_graph.GenericGraph.weighted_adjacency_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">weighted_adjacency_matrix()</span></code></a>):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">kirchhoff_matrix</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span> <span class="n">M</span>
<span class="go">[ 1  0  0 -1]</span>
<span class="go">[ 0  2 -1 -1]</span>
<span class="go">[ 0 -1  2 -1]</span>
<span class="go">[-1 -1 -1  3]</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">kirchhoff_matrix</span><span class="p">(</span><span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span> <span class="n">M</span>
<span class="go">[ 4  0  0 -4]</span>
<span class="go">[ 0  5 -2 -3]</span>
<span class="go">[ 0 -2  3 -1]</span>
<span class="go">[-4 -3 -1  8]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.kronecker_product">
<span class="sig-name descname"><span class="pre">kronecker_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.kronecker_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the tensor product of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>The tensor product of <span class="math notranslate nohighlight">\(G\)</span> and <span class="math notranslate nohighlight">\(H\)</span> is the graph <span class="math notranslate nohighlight">\(L\)</span> with vertex set
<span class="math notranslate nohighlight">\(V(L)\)</span> equal to the Cartesian product of the vertices <span class="math notranslate nohighlight">\(V(G)\)</span> and <span class="math notranslate nohighlight">\(V(H)\)</span>,
and <span class="math notranslate nohighlight">\(((u,v), (w,x))\)</span> is an edge iff - <span class="math notranslate nohighlight">\((u, w)\)</span> is an edge of self, and -
<span class="math notranslate nohighlight">\((v, x)\)</span> is an edge of other.</p>
<p>The tensor product is also known as the categorical product and the
Kronecker product (referring to the Kronecker matrix product). See
the <a class="reference external" href="https://en.wikipedia.org/wiki/Kronecker_product">Wikipedia article Kronecker_product</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">tensor_product</span><span class="p">(</span><span class="n">Z</span><span class="p">);</span> <span class="n">T</span>
<span class="go">Graph on 10 vertices</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">10</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span> <span class="c1"># long time</span>
<span class="go">Graphics object consisting of 21 graphics primitives</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">tensor_product</span><span class="p">(</span><span class="n">P</span><span class="p">);</span> <span class="n">T</span>
<span class="go">Graph on 200 vertices</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">900</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span> <span class="c1"># long time</span>
<span class="go">Graphics object consisting of 1101 graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.laplacian_matrix">
<span class="sig-name descname"><span class="pre">laplacian_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indegree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signless</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.laplacian_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Kirchhoff matrix (a.k.a. the Laplacian) of the graph.</p>
<p>The Kirchhoff matrix is defined to be <span class="math notranslate nohighlight">\(D + M\)</span> if signless and <span class="math notranslate nohighlight">\(D - M\)</span>
otherwise, where <span class="math notranslate nohighlight">\(D\)</span> is the diagonal degree matrix (each diagonal entry
is the degree of the corresponding vertex), and <span class="math notranslate nohighlight">\(M\)</span> is the adjacency
matrix.  If <code class="docutils literal notranslate"><span class="pre">normalized</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the returned matrix is
<span class="math notranslate nohighlight">\(D^{-1/2}(D+M)D^{-1/2}\)</span> if signless and <span class="math notranslate nohighlight">\(D^{-1/2}(D-M)D^{-1/2}\)</span>
otherwise.</p>
<p>(In the special case of DiGraphs, <span class="math notranslate nohighlight">\(D\)</span> is defined as the diagonal
in-degree matrix or diagonal out-degree matrix according to the value of
<code class="docutils literal notranslate"><span class="pre">indegree</span></code>)</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">weighted</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>);</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the weighted adjacency matrix is used for <span class="math notranslate nohighlight">\(M\)</span>, and the
diagonal matrix <span class="math notranslate nohighlight">\(D\)</span> takes into account the weight of edges (replace
in the definition “degree” by “sum of the incident edges”)</p></li>
<li><p>Else, each edge is assumed to have weight 1</p></li>
</ul>
<p>Default is to take weights into consideration if and only if the graph
is weighted.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">indegree</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); this parameter is
considered only for digraphs.</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, each diagonal entry of <span class="math notranslate nohighlight">\(D\)</span> is equal to the in-degree of
the corresponding vertex</p></li>
<li><p>Else, each diagonal entry of <span class="math notranslate nohighlight">\(D\)</span> is equal to the out-degree of the
corresponding vertex</p></li>
</ul>
<p>By default, <code class="docutils literal notranslate"><span class="pre">indegree</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">normalized</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>);</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the returned matrix is <span class="math notranslate nohighlight">\(D^{-1/2}(D+M)D^{-1/2}\)</span> for
signless and <span class="math notranslate nohighlight">\(D^{-1/2}(D-M)D^{-1/2}\)</span> otherwise, a normalized
version of the Laplacian matrix. More accurately, the normalizing
matrix used is equal to <span class="math notranslate nohighlight">\(D^{-1/2}\)</span> only for non-isolated vertices.
If vertex <span class="math notranslate nohighlight">\(i\)</span> is isolated, then diagonal entry <span class="math notranslate nohighlight">\(i\)</span> in the matrix is
1, rather than a division by zero</p></li>
<li><p>Else, the matrix <span class="math notranslate nohighlight">\(D+M\)</span> for signless and <span class="math notranslate nohighlight">\(D-M\)</span> otherwise is returned</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">signless</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>);</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, <span class="math notranslate nohighlight">\(D+M\)</span> is used in calculation of Kirchhoff matrix</p></li>
<li><p>Else, <span class="math notranslate nohighlight">\(D-M\)</span> is used in calculation of Kirchhoff matrix</p></li>
</ul>
</li>
</ul>
<p>Note that any additional keywords will be passed on to either the
<code class="docutils literal notranslate"><span class="pre">adjacency_matrix</span></code> or <code class="docutils literal notranslate"><span class="pre">weighted_adjacency_matrix</span></code> method.</p>
<p>AUTHORS:</p>
<ul class="simple">
<li><p>Tom Boothby</p></li>
<li><p>Jason Grout</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">kirchhoff_matrix</span><span class="p">(</span><span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">M</span>
<span class="go">[ 8 -1 -3 -4]</span>
<span class="go">[-1  3 -2  0]</span>
<span class="go">[-3 -2  5  0]</span>
<span class="go">[-4  0  0  4]</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">kirchhoff_matrix</span><span class="p">();</span> <span class="n">M</span>
<span class="go">[ 3 -1 -1 -1]</span>
<span class="go">[-1  2 -1  0]</span>
<span class="go">[-1 -1  2  0]</span>
<span class="go">[-1  0  0  1]</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">laplacian_matrix</span><span class="p">(</span><span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">M</span>                                            <span class="c1"># optional - sage.symbolic</span>
<span class="go">[                   1 -1/6*sqrt(3)*sqrt(2) -1/6*sqrt(3)*sqrt(2)         -1/3*sqrt(3)]</span>
<span class="go">[-1/6*sqrt(3)*sqrt(2)                    1                 -1/2                    0]</span>
<span class="go">[-1/6*sqrt(3)*sqrt(2)                 -1/2                    1                    0]</span>
<span class="go">[        -1/3*sqrt(3)                    0                    0                    1]</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">kirchhoff_matrix</span><span class="p">(</span><span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">signless</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">M</span>
<span class="go">[8 1 3 4]</span>
<span class="go">[1 3 2 0]</span>
<span class="go">[3 2 5 0]</span>
<span class="go">[4 0 0 4]</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">laplacian_matrix</span><span class="p">(</span><span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[ 0  0  0]</span>
<span class="go">[ 0  1 -1]</span>
<span class="go">[ 0 -1  1]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">laplacian_matrix</span><span class="p">(</span><span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">signless</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[0 0 0]</span>
<span class="go">[0 1 1]</span>
<span class="go">[0 1 1]</span>
</pre></div>
</div>
<p>A weighted directed graph with loops, changing the variable <code class="docutils literal notranslate"><span class="pre">indegree</span></code></p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">4</span><span class="p">}},</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">laplacian_matrix</span><span class="p">()</span>
<span class="go">[ 4 -3]</span>
<span class="go">[-4  3]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">4</span><span class="p">}},</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">laplacian_matrix</span><span class="p">(</span><span class="n">indegree</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[ 3 -3]</span>
<span class="go">[-4  4]</span>
</pre></div>
</div>
<p>A different ordering of the vertices (see <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.adjacency_matrix" title="sage.graphs.generic_graph.GenericGraph.adjacency_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">adjacency_matrix()</span></code></a> and
<a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.weighted_adjacency_matrix" title="sage.graphs.generic_graph.GenericGraph.weighted_adjacency_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">weighted_adjacency_matrix()</span></code></a>):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">kirchhoff_matrix</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span> <span class="n">M</span>
<span class="go">[ 1  0  0 -1]</span>
<span class="go">[ 0  2 -1 -1]</span>
<span class="go">[ 0 -1  2 -1]</span>
<span class="go">[-1 -1 -1  3]</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">kirchhoff_matrix</span><span class="p">(</span><span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span> <span class="n">M</span>
<span class="go">[ 4  0  0 -4]</span>
<span class="go">[ 0  5 -2 -3]</span>
<span class="go">[ 0 -2  3 -1]</span>
<span class="go">[-4 -3 -1  8]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.latex_options">
<span class="sig-name descname"><span class="pre">latex_options</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.latex_options" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an instance of <a class="reference internal" href="graph_latex.html#sage.graphs.graph_latex.GraphLatex" title="sage.graphs.graph_latex.GraphLatex"><code class="xref py py-class docutils literal notranslate"><span class="pre">GraphLatex</span></code></a> for
the graph.</p>
<p>Changes to this object will affect the LaTeX version of the graph.  For
a full explanation of how to use LaTeX to render graphs, see the
introduction to the <a class="reference internal" href="graph_latex.html#module-sage.graphs.graph_latex" title="sage.graphs.graph_latex"><code class="xref py py-mod docutils literal notranslate"><span class="pre">graph_latex</span></code></a> module.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">opts</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">latex_options</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">opts</span>
<span class="go">LaTeX options for Petersen graph: {}</span>
<span class="gp">sage: </span><span class="n">opts</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s1">&#39;tkz_style&#39;</span><span class="p">,</span> <span class="s1">&#39;Classic&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">opts</span>
<span class="go">LaTeX options for Petersen graph: {&#39;tkz_style&#39;: &#39;Classic&#39;}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.layout">
<span class="sig-name descname"><span class="pre">layout</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.layout" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a layout for the vertices of this graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">layout</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specifies a layout algorithm
among <code class="docutils literal notranslate"><span class="pre">&quot;acyclic&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;acyclic_dummy&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;circular&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;ranked&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;graphviz&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;planar&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;spring&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;forest&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;tree&quot;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pos</span></code> – dictionary (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a dictionary of positions</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dim</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">2</span></code>); the number of dimensions of the
layout, 2 or 3</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">save_pos</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to save the
positions</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">**options</span></code> – layout options (see below)</p></li>
</ul>
<p>If <code class="docutils literal notranslate"><span class="pre">layout</span></code> is set, the specified algorithm is used to compute the
positions.</p>
<p>Otherwise, if <code class="docutils literal notranslate"><span class="pre">pos</span></code> is specified, use the given positions.</p>
<p>Otherwise, try to fetch previously computed and saved positions.</p>
<p>Otherwise use the default layout (usually the spring layout).</p>
<p>If <code class="docutils literal notranslate"><span class="pre">save_pos</span> <span class="pre">=</span> <span class="pre">True</span></code>, the layout is saved for later use.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">ButterflyGraph</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">layout</span><span class="p">();</span> <span class="n">D2</span>  <span class="c1"># random</span>
<span class="go">{(&#39;0&#39;, 0): [2.69..., 0.43...],</span>
<span class="go"> (&#39;0&#39;, 1): [1.35..., 0.86...],</span>
<span class="go"> (&#39;1&#39;, 0): [0.89..., -0.42...],</span>
<span class="go"> (&#39;1&#39;, 1): [2.26..., -0.87...]}</span>

<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">layout</span><span class="p">(</span><span class="n">layout</span><span class="o">=</span><span class="s2">&quot;acyclic_dummy&quot;</span><span class="p">,</span> <span class="n">save_pos</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{(&#39;0&#39;, 0): [0.3..., 0],</span>
<span class="go"> (&#39;0&#39;, 1): [0.3..., 1],</span>
<span class="go"> (&#39;1&#39;, 0): [0.6..., 0],</span>
<span class="go"> (&#39;1&#39;, 1): [0.6..., 1]}</span>

<span class="gp">sage: </span><span class="n">D3</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">layout</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">);</span> <span class="n">D3</span>  <span class="c1"># random</span>
<span class="go">{(&#39;0&#39;, 0): [0.68..., 0.50..., -0.24...],</span>
<span class="go"> (&#39;0&#39;, 1): [1.02..., -0.02..., 0.93...],</span>
<span class="go"> (&#39;1&#39;, 0): [2.06..., -0.49..., 0.23...],</span>
<span class="go"> (&#39;1&#39;, 1): [1.74..., 0.01..., -0.92...]}</span>
</pre></div>
</div>
<p>Some safety tests:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">D2</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">D3</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">D2</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">D3</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">c</span> <span class="ow">in</span> <span class="n">RDF</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">D2</span><span class="p">[(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]]</span>
<span class="go">[True, True]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">c</span> <span class="ow">in</span> <span class="n">RDF</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">D3</span><span class="p">[(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]]</span>
<span class="go">[True, True, True]</span>
</pre></div>
</div>
<p>Here is the list of all the available layout options (<code class="docutils literal notranslate"><span class="pre">**options</span></code>):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_plot</span> <span class="kn">import</span> <span class="n">layout_options</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">layout_options</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;option </span><span class="si">{}</span><span class="s2"> : </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
<span class="go">option by_component : Whether to do the spring layout by connected component -- a boolean.</span>
<span class="go">option dim : The dimension of the layout -- 2 or 3.</span>
<span class="go">option forest_roots : An iterable specifying which vertices to use as roots for the ``layout=&#39;forest&#39;`` option. If no root is specified for a tree, then one is chosen close to the center of the tree. Ignored unless ``layout=&#39;forest&#39;``.</span>
<span class="go">option heights : A dictionary mapping heights to the list of vertices at this height.</span>
<span class="go">option iterations : The number of times to execute the spring layout algorithm.</span>
<span class="go">option layout : A layout algorithm -- one of : &quot;acyclic&quot;, &quot;circular&quot; (plots the graph with vertices evenly distributed on a circle), &quot;ranked&quot;, &quot;graphviz&quot;, &quot;planar&quot;, &quot;spring&quot; (traditional spring layout, using the graph&#39;s current positions as initial positions), or &quot;tree&quot; (the tree will be plotted in levels, depending on minimum distance for the root).</span>
<span class="go">option prog : Which graphviz layout program to use -- one of &quot;circo&quot;, &quot;dot&quot;, &quot;fdp&quot;, &quot;neato&quot;, or &quot;twopi&quot;.</span>
<span class="go">option save_pos : Whether or not to save the computed position for the graph.</span>
<span class="go">option spring : Use spring layout to finalize the current layout.</span>
<span class="go">option tree_orientation : The direction of tree branches -- &#39;up&#39;, &#39;down&#39;, &#39;left&#39; or &#39;right&#39;.</span>
<span class="go">option tree_root : A vertex designation for drawing trees. A vertex of the tree to be used as the root for the ``layout=&#39;tree&#39;`` option. If no root is specified, then one is chosen close to the center of the tree. Ignored unless ``layout=&#39;tree&#39;``.</span>
</pre></div>
</div>
<p>Some of them only apply to certain layout algorithms. For details, see
<a class="reference internal" href="digraph.html#sage.graphs.digraph.DiGraph.layout_acyclic" title="sage.graphs.digraph.DiGraph.layout_acyclic"><code class="xref py py-meth docutils literal notranslate"><span class="pre">layout_acyclic()</span></code></a>, <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.layout_planar" title="sage.graphs.generic_graph.GenericGraph.layout_planar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">layout_planar()</span></code></a>,
<a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.layout_circular" title="sage.graphs.generic_graph.GenericGraph.layout_circular"><code class="xref py py-meth docutils literal notranslate"><span class="pre">layout_circular()</span></code></a>, <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.layout_spring" title="sage.graphs.generic_graph.GenericGraph.layout_spring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">layout_spring()</span></code></a>, …</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>unknown optional arguments are silently ignored</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="docutils literal notranslate"><span class="pre">graphviz</span></code> and <code class="docutils literal notranslate"><span class="pre">dot2tex</span></code> are currently required to obtain a nice
<code class="docutils literal notranslate"><span class="pre">'acyclic'</span></code> layout. See <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.layout_graphviz" title="sage.graphs.generic_graph.GenericGraph.layout_graphviz"><code class="xref py py-meth docutils literal notranslate"><span class="pre">layout_graphviz()</span></code></a> for installation
instructions.</p>
</div>
<p>A subclass may implement another layout algorithm <code class="docutils literal notranslate"><span class="pre">&quot;blah&quot;</span></code>, by
implementing a method <code class="docutils literal notranslate"><span class="pre">.layout_blah</span></code>. It may override the default
layout by overriding <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.layout_default" title="sage.graphs.generic_graph.GenericGraph.layout_default"><code class="xref py py-meth docutils literal notranslate"><span class="pre">layout_default()</span></code></a>, and similarly override the
predefined layouts.</p>
<div class="admonition-todo admonition" id="id23">
<p class="admonition-title">Todo</p>
<p>use this feature for all the predefined graphs classes (like for the
Petersen graph, …), rather than systematically building the layout
at construction time.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.layout_circular">
<span class="sig-name descname"><span class="pre">layout_circular</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.layout_circular" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a circular layout for this graph</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dim</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">2</span></code>); the number of dimensions of the
layout, 2 or 3</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">center</span></code> – tuple (default: <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0)</span></code>); position of the center of
the circle</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">radius</span></code> – (default: 1); the radius of the circle</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">shift</span></code> – (default: 0); rotation of the circle. A value of
<code class="docutils literal notranslate"><span class="pre">shift=1</span></code> will replace in the drawing the <span class="math notranslate nohighlight">\(i\)</span>-th element of the list
by the <span class="math notranslate nohighlight">\((i-1)\)</span>-th. Non-integer values are admissible, and a value of
<span class="math notranslate nohighlight">\(\alpha\)</span> corresponds to a rotation of the circle by an angle of
<span class="math notranslate nohighlight">\(\alpha 2\pi/n\)</span> (where <span class="math notranslate nohighlight">\(n\)</span> is the number of vertices set on the
circle).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">angle</span></code> – (default: 0); rotate the embedding of all vertices. For
instance, when <code class="docutils literal notranslate"><span class="pre">angle</span> <span class="pre">==</span> <span class="pre">0</span></code>, the first vertex get position
<code class="docutils literal notranslate"><span class="pre">(center[0]</span> <span class="pre">+</span> <span class="pre">radius,</span> <span class="pre">center[1])</span></code>. With a value of <span class="math notranslate nohighlight">\(\pi/2\)</span>, the
first vertex get position <code class="docutils literal notranslate"><span class="pre">(center[0],</span> <span class="pre">center[1]</span> <span class="pre">+</span> <span class="pre">radius)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">**options</span></code> – other parameters not used here</p></li>
</ul>
<p>OUTPUT: a dictionary mapping vertices to positions</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CirculantGraph</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">layout_circular</span><span class="p">()</span>
<span class="go">{0: (0.0, 1.0),</span>
<span class="go"> 1: (-0.78...,  0.62...),</span>
<span class="go"> 2: (-0.97..., -0.22...),</span>
<span class="go"> 3: (-0.43..., -0.90...),</span>
<span class="go"> 4: (0.43...,  -0.90...),</span>
<span class="go"> 5: (0.97...,  -0.22...),</span>
<span class="go"> 6: (0.78...,   0.62...)}</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">layout</span><span class="o">=</span><span class="s2">&quot;circular&quot;</span><span class="p">)</span>
<span class="go">Graphics object consisting of 22 graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.layout_default">
<span class="sig-name descname"><span class="pre">layout_default</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">by_component</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.layout_default" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a spring layout for this graph.</p>
<p>INPUT:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">by_components</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>);</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">**options</span></code> – options for method
<a class="reference internal" href="generic_graph_pyx.html#sage.graphs.generic_graph_pyx.spring_layout_fast" title="sage.graphs.generic_graph_pyx.spring_layout_fast"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spring_layout_fast()</span></code></a></p></li>
</ul>
</div></blockquote>
<p>OUTPUT: a dictionary mapping vertices to positions</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">LadderGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">#TODO!!!!</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">layout_spring</span><span class="p">()</span>  <span class="c1"># random</span>
<span class="go">{0: [1.0, -0.29...],</span>
<span class="go">1: [1.64..., 0.30...],</span>
<span class="go">2: [2.34..., 0.89...],</span>
<span class="go">3: [1.49..., -0.83...],</span>
<span class="go">4: [2.14..., -0.30...],</span>
<span class="go">5: [2.80..., 0.22...]}</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">LadderGraph</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">layout</span><span class="o">=</span><span class="s2">&quot;spring&quot;</span><span class="p">)</span>
<span class="go">Graphics object consisting of 34 graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.layout_extend_randomly">
<span class="sig-name descname"><span class="pre">layout_extend_randomly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.layout_extend_randomly" title="Permalink to this definition">¶</a></dt>
<dd><p>Extend randomly a partial layout</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pos</span></code> – a dictionary mapping vertices to positions</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dim</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">2</span></code>); the number of dimensions of the
layout, 2 or 3</p></li>
</ul>
<p>OUTPUT: a dictionary mapping vertices to positions</p>
<p>The vertices not referenced in <code class="docutils literal notranslate"><span class="pre">pos</span></code> are assigned random positions
within the box delimited by the other vertices.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">ButterflyGraph</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pos</span> <span class="o">=</span> <span class="p">{(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)}</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">layout_extend_randomly</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>  <span class="c1"># random</span>
<span class="go">{(&#39;0&#39;, 0): (0, 0),</span>
<span class="go"> (&#39;0&#39;, 1): [0.0446..., 0.332...],</span>
<span class="go"> (&#39;1&#39;, 0): [0.1114..., 0.514...],</span>
<span class="go"> (&#39;1&#39;, 1): (1, 1)}</span>
<span class="gp">sage: </span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">_layout_bounding_box</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.layout_forest">
<span class="sig-name descname"><span class="pre">layout_forest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tree_orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'down'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forest_roots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.layout_forest" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an ordered forest layout for this graph.</p>
<p>The function relies on <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.layout_tree" title="sage.graphs.generic_graph.GenericGraph.layout_tree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">layout_tree()</span></code></a> to deal with
each connected component.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">forest_roots</span></code> – an iterable of vertices (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>);
the root vertices of the trees in the forest; a vertex is chosen
close to the center of each component for which no root is specified
in <code class="docutils literal notranslate"><span class="pre">forest_roots</span></code> or if <code class="docutils literal notranslate"><span class="pre">forest_roots</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tree_orientation</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">'down'</span></code>); the direction in
which the tree is growing, can be <code class="docutils literal notranslate"><span class="pre">'up'</span></code>, <code class="docutils literal notranslate"><span class="pre">'down'</span></code>, <code class="docutils literal notranslate"><span class="pre">'left'</span></code> or
<code class="docutils literal notranslate"><span class="pre">'right'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">**options</span></code> – other parameters ignored here</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomTree</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomTree</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomTree</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">layout_forest</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="n">p</span><span class="p">)</span> <span class="c1"># random</span>
<span class="go">Graphics object consisting of 28 graphics primitives</span>

<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">graphs</span><span class="o">.</span><span class="n">BalancedTree</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">layout_forest</span><span class="p">(</span><span class="n">forest_roots</span><span class="o">=</span><span class="p">[</span><span class="mi">14</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
<span class="go">Graphics object consisting of 32 graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.layout_graphviz">
<span class="sig-name descname"><span class="pre">layout_graphviz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prog</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dot'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.layout_graphviz" title="Permalink to this definition">¶</a></dt>
<dd><p>Call <code class="docutils literal notranslate"><span class="pre">graphviz</span></code> to compute a layout of the vertices of this graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dim</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">2</span></code>); the number of dimensions of the
layout, 2 or 3</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">prog</span></code> – one of “dot”, “neato”, “twopi”, “circo”, or “fdp”</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">**options</span></code> – other parameters used by method
<a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.graphviz_string" title="sage.graphs.generic_graph.GenericGraph.graphviz_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graphviz_string()</span></code></a></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">ButterflyGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">layout_graphviz</span><span class="p">()</span>  <span class="c1"># optional - dot2tex graphviz</span>
<span class="go">{(&#39;...&#39;, ...): [...,...],</span>
<span class="go"> (&#39;...&#39;, ...): [...,...],</span>
<span class="go"> (&#39;...&#39;, ...): [...,...],</span>
<span class="go"> (&#39;...&#39;, ...): [...,...],</span>
<span class="go"> (&#39;...&#39;, ...): [...,...],</span>
<span class="go"> (&#39;...&#39;, ...): [...,...],</span>
<span class="go"> (&#39;...&#39;, ...): [...,...],</span>
<span class="go"> (&#39;...&#39;, ...): [...,...],</span>
<span class="go"> (&#39;...&#39;, ...): [...,...],</span>
<span class="go"> (&#39;...&#39;, ...): [...,...],</span>
<span class="go"> (&#39;...&#39;, ...): [...,...],</span>
<span class="go"> (&#39;...&#39;, ...): [...,...]}</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">layout</span><span class="o">=</span><span class="s2">&quot;graphviz&quot;</span><span class="p">)</span>  <span class="c1"># optional - dot2tex graphviz</span>
<span class="go">Graphics object consisting of 29 graphics primitives</span>
</pre></div>
</div>
<p>Note: the actual coordinates are not deterministic</p>
<p>By default, an acyclic layout is computed using <code class="docutils literal notranslate"><span class="pre">graphviz</span></code>’s <code class="docutils literal notranslate"><span class="pre">dot</span></code>
layout program. One may specify an alternative layout program:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">layout</span> <span class="o">=</span> <span class="s2">&quot;graphviz&quot;</span><span class="p">,</span> <span class="n">prog</span> <span class="o">=</span> <span class="s2">&quot;dot&quot;</span><span class="p">)</span>   <span class="c1"># optional - dot2tex graphviz</span>
<span class="go">Graphics object consisting of 29 graphics primitives</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">layout</span> <span class="o">=</span> <span class="s2">&quot;graphviz&quot;</span><span class="p">,</span> <span class="n">prog</span> <span class="o">=</span> <span class="s2">&quot;neato&quot;</span><span class="p">)</span> <span class="c1"># optional - dot2tex graphviz</span>
<span class="go">Graphics object consisting of 29 graphics primitives</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">layout</span> <span class="o">=</span> <span class="s2">&quot;graphviz&quot;</span><span class="p">,</span> <span class="n">prog</span> <span class="o">=</span> <span class="s2">&quot;twopi&quot;</span><span class="p">)</span> <span class="c1"># optional - dot2tex graphviz</span>
<span class="go">Graphics object consisting of 29 graphics primitives</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">layout</span> <span class="o">=</span> <span class="s2">&quot;graphviz&quot;</span><span class="p">,</span> <span class="n">prog</span> <span class="o">=</span> <span class="s2">&quot;fdp&quot;</span><span class="p">)</span>   <span class="c1"># optional - dot2tex graphviz</span>
<span class="go">Graphics object consisting of 29 graphics primitives</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">BalancedTree</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">layout</span> <span class="o">=</span> <span class="s2">&quot;graphviz&quot;</span><span class="p">,</span> <span class="n">prog</span> <span class="o">=</span> <span class="s2">&quot;circo&quot;</span><span class="p">)</span>  <span class="c1"># optional - dot2tex graphviz</span>
<span class="go">Graphics object consisting of 62 graphics primitives</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="id24">
<p class="admonition-title">Todo</p>
<p>Put here some cool examples showcasing graphviz features.</p>
</div>
<p>This requires <code class="docutils literal notranslate"><span class="pre">graphviz</span></code> and the <code class="docutils literal notranslate"><span class="pre">dot2tex</span></code> spkg. Here are some
installation tips:</p>
<ul class="simple">
<li><p>Install <code class="docutils literal notranslate"><span class="pre">graphviz</span></code> &gt;= 2.14 so that the programs <code class="docutils literal notranslate"><span class="pre">dot</span></code>, <code class="docutils literal notranslate"><span class="pre">neato</span></code>,
etc.  are in your path. The graphviz suite can be download from
<a class="reference external" href="http://graphviz.org">http://graphviz.org</a>.</p></li>
<li><p>Install <code class="docutils literal notranslate"><span class="pre">dot2tex</span></code> with <code class="docutils literal notranslate"><span class="pre">sage</span> <span class="pre">-i</span> <span class="pre">dot2tex</span></code></p></li>
</ul>
<div class="admonition-todo admonition" id="id25">
<p class="admonition-title">Todo</p>
<p>Use the graphviz functionality of Networkx 1.0 once it
will be merged into Sage.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.layout_planar">
<span class="sig-name descname"><span class="pre">layout_planar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">set_embedding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">on_embedding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external_face</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">circular</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.layout_planar" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a planar layout of the graph using Schnyder’s algorithm.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">set_embedding</span></code> is set, a new combinatorial embedding is computed
for the layout. Otherwise: if <code class="docutils literal notranslate"><span class="pre">on_embedding</span></code> is provided, then that
combinatorial embedding is used for the layout. Otherwise: if a
combinatorial embedding is set to the instance field variable of the
graph (e.g. using
<code class="xref py py-meth docutils literal notranslate"><span class="pre">set_embedding()</span></code>), then
that one is used, and if no combinatorial embedding is set, then one is
computed.</p>
<p>If the graph is not planar, an error is raised.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">set_embedding</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to set the
instance field variable that contains a combinatorial embedding to the
combinatorial embedding used for the planar layout (see
<code class="xref py py-meth docutils literal notranslate"><span class="pre">get_embedding()</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">on_embedding</span></code> – dictionary (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); provide a
combinatorial embedding</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">external_face</span></code> – a pair <span class="math notranslate nohighlight">\((u,v)\)</span> of vertices (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>);
the external face of the drawing is chosen in such a way that <span class="math notranslate nohighlight">\(u\)</span> and
<span class="math notranslate nohighlight">\(v\)</span> are consecutive vertices in the clockwise traversal of the
external face, in particular <span class="math notranslate nohighlight">\(uv\)</span> has to be an edge of the graph. If
<code class="docutils literal notranslate"><span class="pre">external_face</span> <span class="pre">==</span> <span class="pre">None</span></code>, an arbitrary external face is chosen.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">test</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to perform sanity
tests along the way</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">circular</span></code> – ignored</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">layout</span><span class="p">(</span><span class="n">layout</span><span class="o">=</span><span class="s1">&#39;planar&#39;</span><span class="p">,</span> <span class="n">save_pos</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">test</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{0: [0, 8],</span>
<span class="go"> 1: [8, 1],</span>
<span class="go"> 2: [1, 0],</span>
<span class="go"> 3: [7, 1],</span>
<span class="go"> 4: [1, 1],</span>
<span class="go"> 5: [5, 3],</span>
<span class="go"> 6: [2, 3],</span>
<span class="go"> 7: [2, 4],</span>
<span class="go"> 8: [1, 6],</span>
<span class="go"> 9: [2, 5]}</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">BalancedTree</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pos</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">layout</span><span class="p">(</span><span class="n">layout</span><span class="o">=</span><span class="s1">&#39;planar&#39;</span><span class="p">,</span> <span class="n">save_pos</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">test</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[0, 119]</span>
<span class="gp">sage: </span><span class="n">pos</span><span class="p">[</span><span class="mi">120</span><span class="p">]</span>
<span class="go">[21, 37]</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">layout</span><span class="p">(</span><span class="n">layout</span><span class="o">=</span><span class="s1">&#39;planar&#39;</span><span class="p">,</span> <span class="n">save_pos</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">test</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{0: [0, 5], 1: [5, 1], 2: [1, 0], 3: [4, 1], 4: [1, 1], 5: [2, 2], 6: [1, 2]}</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">layout</span><span class="p">(</span><span class="n">layout</span><span class="o">=</span><span class="s1">&#39;planar&#39;</span><span class="p">,</span> <span class="n">save_pos</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">test</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">set_embedding</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: Complete graph is not a planar graph</span>
</pre></div>
</div>
<p>Choose the external face of the drawing:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">layout</span><span class="p">(</span><span class="n">layout</span><span class="o">=</span><span class="s1">&#39;planar&#39;</span><span class="p">,</span> <span class="n">external_face</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">{0: [0, 2], 1: [2, 1], 2: [1, 0], 3: [1, 1]}</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">layout</span><span class="p">(</span><span class="n">layout</span><span class="o">=</span><span class="s1">&#39;planar&#39;</span><span class="p">,</span> <span class="n">external_face</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">{0: [2, 1], 1: [0, 2], 2: [1, 1], 3: [1, 0]}</span>
</pre></div>
</div>
<p>Choose the embedding:</p>
<blockquote>
<div><p>sage: H = graphs.LadderGraph(4)
sage: em = {0:[1,4], 4:[0,5], 1:[5,2,0], 5:[4,6,1], 2:[1,3,6], 6:[7,5,2], 3:[7,2], 7:[3,6]}
sage: p = H.layout_planar(on_embedding=em)
sage: p # random
{2: [8.121320343559642, 1],
3: [2.1213203435596424, 6],
7: [3.1213203435596424, 0],
0: [5.121320343559642, 3],
1: [3.1213203435596424, 5],
4: [4.121320343559642, 3],
5: [4.121320343559642, 2],
6: [3.1213203435596424, 1],
9: [9.698670612749268, 1],
8: [8.698670612749268, 1],
10: [9.698670612749268, 0]}</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.layout_ranked">
<span class="sig-name descname"><span class="pre">layout_ranked</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">heights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spring</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.layout_ranked" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a ranked layout for this graph</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">heights</span></code> – dictionary (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a dictionary mapping
heights to the list of vertices at this height</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dim</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">2</span></code>); the number of dimensions of the
layout, 2 or 3</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">spring</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>);</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">**options</span></code> – options for method
<a class="reference internal" href="generic_graph_pyx.html#sage.graphs.generic_graph_pyx.spring_layout_fast" title="sage.graphs.generic_graph_pyx.spring_layout_fast"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spring_layout_fast()</span></code></a></p></li>
</ul>
<p>OUTPUT: a dictionary mapping vertices to positions</p>
<p>Returns a layout computed by randomly arranging the vertices
along the given heights</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">LadderGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">layout_ranked</span><span class="p">(</span><span class="n">heights</span><span class="o">=</span><span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)})</span>  <span class="c1"># random</span>
<span class="go">{0: [0.668..., 0],</span>
<span class="go"> 1: [0.667..., 1],</span>
<span class="go"> 2: [0.677..., 2],</span>
<span class="go"> 3: [1.34..., 0],</span>
<span class="go"> 4: [1.33..., 1],</span>
<span class="go"> 5: [1.33..., 2]}</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">LadderGraph</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">layout</span><span class="o">=</span><span class="s2">&quot;ranked&quot;</span><span class="p">,</span> <span class="n">heights</span><span class="o">=</span><span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">7</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">)})</span>
<span class="go">Graphics object consisting of 34 graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.layout_spring">
<span class="sig-name descname"><span class="pre">layout_spring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">by_component</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.layout_spring" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a spring layout for this graph.</p>
<p>INPUT:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">by_components</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>);</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">**options</span></code> – options for method
<a class="reference internal" href="generic_graph_pyx.html#sage.graphs.generic_graph_pyx.spring_layout_fast" title="sage.graphs.generic_graph_pyx.spring_layout_fast"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spring_layout_fast()</span></code></a></p></li>
</ul>
</div></blockquote>
<p>OUTPUT: a dictionary mapping vertices to positions</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">LadderGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">#TODO!!!!</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">layout_spring</span><span class="p">()</span>  <span class="c1"># random</span>
<span class="go">{0: [1.0, -0.29...],</span>
<span class="go">1: [1.64..., 0.30...],</span>
<span class="go">2: [2.34..., 0.89...],</span>
<span class="go">3: [1.49..., -0.83...],</span>
<span class="go">4: [2.14..., -0.30...],</span>
<span class="go">5: [2.80..., 0.22...]}</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">LadderGraph</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">layout</span><span class="o">=</span><span class="s2">&quot;spring&quot;</span><span class="p">)</span>
<span class="go">Graphics object consisting of 34 graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.layout_tree">
<span class="sig-name descname"><span class="pre">layout_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tree_orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'down'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree_root</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.layout_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an ordered tree layout for this graph.</p>
<p>The graph must be a tree (no non-oriented cycles). In case of doubt
whether the graph is connected or not, prefer
<a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.layout_forest" title="sage.graphs.generic_graph.GenericGraph.layout_forest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">layout_forest()</span></code></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tree_root</span></code> – a vertex (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the root vertex of the
tree. By default (<code class="docutils literal notranslate"><span class="pre">None</span></code>) a vertex is chosen close to the center of
the tree.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tree_orientation</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">'down'</span></code>); the direction in
which the tree is growing, can be <code class="docutils literal notranslate"><span class="pre">'up'</span></code>, <code class="docutils literal notranslate"><span class="pre">'down'</span></code>, <code class="docutils literal notranslate"><span class="pre">'left'</span></code> or
<code class="docutils literal notranslate"><span class="pre">'right'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dim</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">2</span></code>); the number of dimensions of the
layout, 2 or 3</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">**options</span></code> – other parameters not used here</p></li>
</ul>
<p>If the tree has been given a planar embedding (fixed circular order on
the set of neighbors of every vertex) using <code class="docutils literal notranslate"><span class="pre">set_embedding</span></code>, the
algorithm will create a layout that respects this embedding.</p>
<p>OUTPUT: a dictionary mapping vertices to positions</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomTree</span><span class="p">(</span><span class="mi">80</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">layout</span><span class="o">=</span><span class="s2">&quot;tree&quot;</span><span class="p">,</span> <span class="n">tree_orientation</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>
<span class="go">Graphics object consisting of 160 graphics primitives</span>

<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomLobster</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">layout</span><span class="o">=</span><span class="s1">&#39;tree&#39;</span><span class="p">,</span> <span class="n">tree_orientation</span><span class="o">=</span><span class="s1">&#39;up&#39;</span><span class="p">)</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">HoffmanSingletonGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">(</span><span class="n">starting_vertex</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">layout</span><span class="o">=</span><span class="s1">&#39;tree&#39;</span><span class="p">,</span> <span class="n">tree_root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">BalancedTree</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">layout_tree</span><span class="p">(</span><span class="n">tree_root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">{0: [1.5, 0],</span>
<span class="go"> 1: [2.5, -1],</span>
<span class="go"> 2: [0.5, -1],</span>
<span class="go"> 3: [3.0, -2],</span>
<span class="go"> 4: [2.0, -2],</span>
<span class="go"> 5: [1.0, -2],</span>
<span class="go"> 6: [0.0, -2]}</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">BalancedTree</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">layout</span><span class="o">=</span><span class="s2">&quot;tree&quot;</span><span class="p">,</span> <span class="n">tree_root</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tree_orientation</span><span class="o">=</span><span class="s2">&quot;up&quot;</span><span class="p">)</span>
<span class="go">Graphics object consisting of 62 graphics primitives</span>
</pre></div>
</div>
<p>Using the embedding when it exists:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">set_embedding</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">....: </span>    <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">7</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">8</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">layout_tree</span><span class="p">()</span>
<span class="go">{0: [2.166..., 0],</span>
<span class="go"> 1: [3.5, -1],</span>
<span class="go"> 2: [4.0, -2],</span>
<span class="go"> 3: [1.0, -1],</span>
<span class="go"> 4: [2.0, -2],</span>
<span class="go"> 5: [3.0, -2],</span>
<span class="go"> 6: [2.0, -1],</span>
<span class="go"> 7: [1.0, -2],</span>
<span class="go"> 8: [0.0, -2]}</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">layout</span><span class="o">=</span><span class="s2">&quot;tree&quot;</span><span class="p">,</span> <span class="n">tree_root</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Graphics object consisting of 18 graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.lex_BFS">
<span class="sig-name descname"><span class="pre">lex_BFS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_vertex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'fast'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.lex_BFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a lexicographic breadth first search (LexBFS) on the graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reverse</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
vertices in discovery order, or the reverse</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tree</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
discovery directed tree (each vertex being linked to the one that saw
it for the first time)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to
consider</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">&quot;fast&quot;</span></code>); algorithm to use among:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;slow&quot;</span></code> – This algorithm maintains for each vertex left in the graph
a code corresponding to the vertices already removed. The vertex of
maximal code (according to the lexicographic order) is then removed, and
the codes are updated. See for instance <a class="reference internal" href="../../../references/index.html#ck2008" id="id26"><span>[CK2008]</span></a> for more details.  The
time complexity of this algorithm as described in <a class="reference internal" href="../../../references/index.html#ck2008" id="id27"><span>[CK2008]</span></a> is in
<span class="math notranslate nohighlight">\(O(n + m)\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the number of vertices and <span class="math notranslate nohighlight">\(m\)</span> is the number of
edges, but our implementation is in <span class="math notranslate nohighlight">\(O(n^2)\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;fast&quot;</span></code> – This algorithm uses the notion of <em>slices</em> to refine the
position of the vertices in the ordering. The time complexity of this
algorithm is in <span class="math notranslate nohighlight">\(O(n + m)\)</span>, and our implementation follows that
complexity. See <a class="reference internal" href="../../../references/index.html#hmpv2000" id="id28"><span>[HMPV2000]</span></a> and next section for more details.</p></li>
</ul>
</li>
</ul>
<p>ALGORITHM:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">&quot;fast&quot;</span></code> algorithm is the <span class="math notranslate nohighlight">\(O(n + m)\)</span> time algorithm proposed in
<a class="reference internal" href="../../../references/index.html#hmpv2000" id="id29"><span>[HMPV2000]</span></a>, where <span class="math notranslate nohighlight">\(n\)</span> is the number of vertices and <span class="math notranslate nohighlight">\(m\)</span> is the number of
edges. It uses the notion of <em>slices</em>, i.e., subsets of consecutive vertices
in the ordering, and iteratively refines the slices by subdividing them into
sub-slices to determine the exact position of the vertices in the ordering.</p>
<p>Consider an ordering <span class="math notranslate nohighlight">\(\sigma\)</span> of the vertices. For a vertex <span class="math notranslate nohighlight">\(v\)</span>, we define
<span class="math notranslate nohighlight">\(N_i(v) = \{u | u \in N(v) \text{ and } \sigma(u) &lt; i\}\)</span>, that is the subset
of neighbors of <span class="math notranslate nohighlight">\(v\)</span> appearing before the <span class="math notranslate nohighlight">\(i\)</span>-th vertex in the ordering
<span class="math notranslate nohighlight">\(\sigma\)</span>. Now, a slice of an ordering <span class="math notranslate nohighlight">\(\sigma\)</span> is a set of consecutive
vertices, <span class="math notranslate nohighlight">\(S = \{u | i \leq \sigma(u) \leq j\}\)</span>, such that for any <span class="math notranslate nohighlight">\(u \in
S\)</span>, we have <span class="math notranslate nohighlight">\(N_i(u) = N_i(\sigma^{-1}(i))\)</span> and for any <span class="math notranslate nohighlight">\(v\)</span> such that <span class="math notranslate nohighlight">\(j &lt;
\sigma(v)\)</span>, <span class="math notranslate nohighlight">\(N_i(v) \neq N_i(\sigma^{-1}(i))\)</span>. The <em>head</em> of a slice is the
first position of its vertices.</p>
<p>The algorithm starts with a single slice containing all vertices. Then, when
the position of the <span class="math notranslate nohighlight">\(i\)</span>-th vertex <span class="math notranslate nohighlight">\(v\)</span> is fixed, it explores the neighbors of
<span class="math notranslate nohighlight">\(v\)</span> that have not yet been ordered. Consider a slice <span class="math notranslate nohighlight">\(S\)</span> such that <span class="math notranslate nohighlight">\(N(x)\cap
S \neq \emptyset\)</span>. The algorithm will rearrange the ordering of the vertices
in <span class="math notranslate nohighlight">\(S\)</span> so that the first vertices are the neighbors of <span class="math notranslate nohighlight">\(v\)</span>. The sub-slice
containing the neighbors of <span class="math notranslate nohighlight">\(v\)</span> is assigned a new slice name, and the head
of slice <span class="math notranslate nohighlight">\(S\)</span> is set to the position of the first vertex of <span class="math notranslate nohighlight">\(S \setminus
N(v)\)</span> in the ordering <span class="math notranslate nohighlight">\(\sigma\)</span>.</p>
<p>Observe that each arc of the graph can induce the subdivision of a
slice. Hence, the algorithm can use up to <span class="math notranslate nohighlight">\(m + 1\)</span> different slices.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Lexicographic_breadth-first_search">Wikipedia article Lexicographic_breadth-first_search</a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.lex_DFS" title="sage.graphs.generic_graph.GenericGraph.lex_DFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DFS()</span></code></a> – perform a
lexicographic depth first search (LexDFS) on the graph</p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.lex_UP" title="sage.graphs.generic_graph.GenericGraph.lex_UP"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_UP()</span></code></a> – perform a
lexicographic UP search (LexUP) on the graph</p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.lex_DOWN" title="sage.graphs.generic_graph.GenericGraph.lex_DOWN"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DOWN()</span></code></a> – perform a
lexicographic DOWN search (LexDOWN) on the graph</p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>A Lex BFS is obviously an ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">())</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Lex BFS ordering of the 3-sun graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">()</span>
<span class="go">[1, 2, 3, 5, 4, 6]</span>
</pre></div>
</div>
<p>The method also works for directed graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;slow&quot;</span><span class="p">)</span>
<span class="go">[2, 3, 1]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;fast&quot;</span><span class="p">)</span>
<span class="go">[2, 3, 1]</span>
</pre></div>
</div>
<p>For a Chordal Graph, a reversed Lex BFS is a Perfect Elimination Order:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">lexicographic_product</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(2, 1), (2, 0), (1, 1), (1, 0), (0, 1), (0, 0)]</span>
</pre></div>
</div>
<p>And the vertices at the end of the tree of discovery are, for chordal
graphs, simplicial vertices (their neighborhood is a complete graph):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">ClawGraph</span><span class="p">()</span><span class="o">.</span><span class="n">lexicographic_product</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">peo</span><span class="p">,</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span> <span class="o">=</span> <span class="n">v</span><span class="p">,</span>  <span class="n">tree</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">leaves</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tree</span> <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">in_degree</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">.</span><span class="n">is_clique</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Different orderings for different traversals:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">DeBruijn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;fast&quot;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;011&#39;, &#39;110&#39;, &#39;101&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;slow&quot;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;011&#39;, &#39;110&#39;, &#39;101&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;011&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_UP</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;111&#39;, &#39;011&#39;, &#39;100&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DOWN</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;011&#39;, &#39;010&#39;, &#39;110&#39;, &#39;111&#39;, &#39;101&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.lex_DFS">
<span class="sig-name descname"><span class="pre">lex_DFS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_vertex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.lex_DFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a lexicographic depth first search (LexDFS) on the graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reverse</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
vertices in discovery order, or the reverse</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tree</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
discovery directed tree (each vertex being linked to the one that saw
it for the first time)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to
consider</p></li>
</ul>
<p>ALGORITHM:</p>
<p>This algorithm maintains for each vertex left in the graph a code
corresponding to the vertices already removed. The vertex of maximal
code (according to the lexicographic order) is then removed, and the
codes are updated. Lex DFS differs from Lex BFS only in the way codes are
updated after each iteration.</p>
<p>Time complexity is <span class="math notranslate nohighlight">\(O(n+m)\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the number of vertices and <span class="math notranslate nohighlight">\(m\)</span> is
the number of edges.</p>
<p>See <a class="reference internal" href="../../../references/index.html#ck2008" id="id30"><span>[CK2008]</span></a> for more details on the algorithm.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.lex_BFS" title="sage.graphs.generic_graph.GenericGraph.lex_BFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_BFS()</span></code></a> – perform a
lexicographic breadth first search (LexBFS) on the graph</p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.lex_UP" title="sage.graphs.generic_graph.GenericGraph.lex_UP"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_UP()</span></code></a> – perform a
lexicographic UP search (LexUP) on the graph</p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.lex_DOWN" title="sage.graphs.generic_graph.GenericGraph.lex_DOWN"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DOWN()</span></code></a> – perform a
lexicographic DOWN search (LexDOWN) on the graph</p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>A Lex DFS is obviously an ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">lex_DFS</span><span class="p">())</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Lex DFS ordering of the 3-sun graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">lex_DFS</span><span class="p">()</span>
<span class="go">[1, 2, 3, 5, 6, 4]</span>
</pre></div>
</div>
<p>The method also works for directed graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[2, 3, 1]</span>
</pre></div>
</div>
<p>Different orderings for different traversals:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">DeBruijn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;011&#39;, &#39;110&#39;, &#39;101&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;011&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_UP</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;111&#39;, &#39;011&#39;, &#39;100&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DOWN</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;011&#39;, &#39;010&#39;, &#39;110&#39;, &#39;111&#39;, &#39;101&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.lex_DOWN">
<span class="sig-name descname"><span class="pre">lex_DOWN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_vertex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.lex_DOWN" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a lexicographic DOWN search (LexDOWN) on the graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reverse</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
vertices in discovery order, or the reverse</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tree</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
discovery directed tree (each vertex being linked to the one that saw
it for the first time)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to
consider</p></li>
</ul>
<p>ALGORITHM:</p>
<p>This algorithm maintains for each vertex left in the graph a code
corresponding to the vertices already removed. The vertex of maximal
code (according to the lexicographic order) is then removed, and the
codes are updated. During the <span class="math notranslate nohighlight">\(i\)</span>-th iteration of the algorithm <span class="math notranslate nohighlight">\(n-i\)</span> is
prepended to the codes of all neighbors of the selected vertex that are left
in the graph.</p>
<p>Time complexity is <span class="math notranslate nohighlight">\(O(n+m)\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the number of vertices and <span class="math notranslate nohighlight">\(m\)</span> is
the number of edges.</p>
<p>See <a class="reference internal" href="../../../references/index.html#mil2017" id="id31"><span>[Mil2017]</span></a> for more details on the algorithm.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.lex_BFS" title="sage.graphs.generic_graph.GenericGraph.lex_BFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_BFS()</span></code></a> – perform a
lexicographic breadth first search (LexBFS) on the graph</p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.lex_DFS" title="sage.graphs.generic_graph.GenericGraph.lex_DFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DFS()</span></code></a> – perform a
lexicographic depth first search (LexDFS) on the graph</p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.lex_UP" title="sage.graphs.generic_graph.GenericGraph.lex_UP"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_UP()</span></code></a> – perform a
lexicographic UP search (LexUP) on the graph</p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>A Lex DOWN is obviously an ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">lex_DOWN</span><span class="p">())</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Lex DOWN ordering of the 3-sun graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">lex_DOWN</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 5]</span>
</pre></div>
</div>
<p>The method also works for directed graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DOWN</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[2, 3, 1]</span>
</pre></div>
</div>
<p>Different orderings for different traversals:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">DeBruijn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;011&#39;, &#39;110&#39;, &#39;101&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;011&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_UP</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;111&#39;, &#39;011&#39;, &#39;100&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DOWN</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;011&#39;, &#39;010&#39;, &#39;110&#39;, &#39;111&#39;, &#39;101&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.lex_UP">
<span class="sig-name descname"><span class="pre">lex_UP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_vertex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.lex_UP" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a lexicographic UP search (LexUP) on the graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reverse</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
vertices in discovery order, or the reverse</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tree</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
discovery directed tree (each vertex being linked to the one that saw
it for the first time)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to
consider</p></li>
</ul>
<p>ALGORITHM:</p>
<p>This algorithm maintains for each vertex left in the graph a code
corresponding to the vertices already removed. The vertex of maximal
code (according to the lexicographic order) is then removed, and the
codes are updated. During the <span class="math notranslate nohighlight">\(i\)</span>-th iteration of the algorithm <span class="math notranslate nohighlight">\(i\)</span> is
appended to the codes of all neighbors of the selected vertex that are left
in the graph.</p>
<p>Time complexity is <span class="math notranslate nohighlight">\(O(n+m)\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the number of vertices and <span class="math notranslate nohighlight">\(m\)</span> is
the number of edges.</p>
<p>See <a class="reference internal" href="../../../references/index.html#mil2017" id="id32"><span>[Mil2017]</span></a> for more details on the algorithm.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.lex_BFS" title="sage.graphs.generic_graph.GenericGraph.lex_BFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_BFS()</span></code></a> – perform a
lexicographic breadth first search (LexBFS) on the graph</p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.lex_DFS" title="sage.graphs.generic_graph.GenericGraph.lex_DFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DFS()</span></code></a> – perform a
lexicographic depth first search (LexDFS) on the graph</p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.lex_DOWN" title="sage.graphs.generic_graph.GenericGraph.lex_DOWN"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DOWN()</span></code></a> – perform a
lexicographic DOWN search (LexDOWN) on the graph</p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>A Lex UP is obviously an ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">lex_UP</span><span class="p">())</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Lex UP ordering of the 3-sun graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">lex_UP</span><span class="p">()</span>
<span class="go">[1, 2, 4, 5, 6, 3]</span>
</pre></div>
</div>
<p>The method also works for directed graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_UP</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[2, 3, 1]</span>
</pre></div>
</div>
<p>Different orderings for different traversals:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">DeBruijn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;011&#39;, &#39;110&#39;, &#39;101&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;011&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_UP</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;111&#39;, &#39;011&#39;, &#39;100&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DOWN</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;011&#39;, &#39;010&#39;, &#39;110&#39;, &#39;111&#39;, &#39;101&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.lexicographic_product">
<span class="sig-name descname"><span class="pre">lexicographic_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.lexicographic_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the lexicographic product of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>The lexicographic product of <span class="math notranslate nohighlight">\(G\)</span> and <span class="math notranslate nohighlight">\(H\)</span> is the graph <span class="math notranslate nohighlight">\(L\)</span> with vertex
set <span class="math notranslate nohighlight">\(V(L)=V(G)\times V(H)\)</span>, and <span class="math notranslate nohighlight">\(((u,v), (w,x))\)</span> is an edge iff :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\((u, w)\)</span> is an edge of <span class="math notranslate nohighlight">\(G\)</span>, or</p></li>
<li><p><span class="math notranslate nohighlight">\(u = w\)</span> and <span class="math notranslate nohighlight">\((v, x)\)</span> is an edge of <span class="math notranslate nohighlight">\(H\)</span>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">lexicographic_product</span><span class="p">(</span><span class="n">Z</span><span class="p">);</span> <span class="n">L</span>
<span class="go">Graph on 10 vertices</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span> <span class="c1"># long time</span>
<span class="go">Graphics object consisting of 36 graphics primitives</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">lexicographic_product</span><span class="p">(</span><span class="n">P</span><span class="p">);</span> <span class="n">L</span>
<span class="go">Graph on 200 vertices</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span> <span class="c1"># long time</span>
<span class="go">Graphics object consisting of 3501 graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.line_graph">
<span class="sig-name descname"><span class="pre">line_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.line_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the line graph of the (di)graph <code class="docutils literal notranslate"><span class="pre">g</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether edge labels should be
taken in consideration. If <code class="docutils literal notranslate"><span class="pre">labels=True</span></code>, the vertices of the line graph
will be triples <code class="docutils literal notranslate"><span class="pre">(u,v,label)</span></code>, and pairs of vertices otherwise.</p></li>
</ul>
<p>The line graph of an undirected graph G is an undirected graph H such that
the vertices of H are the edges of G and two vertices e and f of H are
adjacent if e and f share a common vertex in G. In other words, an edge in H
represents a path of length 2 in G.</p>
<p>The line graph of a directed graph G is a directed graph H such that the
vertices of H are the edges of G and two vertices e and f of H are adjacent
if e and f share a common vertex in G and the terminal vertex of e is the
initial vertex of f. In other words, an edge in H represents a (directed)
path of length 2 in G.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As a <a class="reference internal" href="graph.html#sage.graphs.graph.Graph" title="sage.graphs.graph.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a> object only accepts hashable objects as vertices
(and as the vertices of the line graph are the edges of the graph), this
code will fail if edge labels are not hashable. You can also set the
argument <code class="docutils literal notranslate"><span class="pre">labels=False</span></code> to ignore labels.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p>The <a class="reference internal" href="line_graph.html#module-sage.graphs.line_graph" title="sage.graphs.line_graph"><code class="xref py py-mod docutils literal notranslate"><span class="pre">line_graph</span></code></a> module.</p></li>
<li><p><a class="reference internal" href="graph_generators.html#sage.graphs.graph_generators.GraphGenerators.line_graph_forbidden_subgraphs" title="sage.graphs.graph_generators.GraphGenerators.line_graph_forbidden_subgraphs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">line_graph_forbidden_subgraphs()</span></code></a>
– the forbidden subgraphs of a line graph.</p></li>
<li><p><a class="reference internal" href="graph.html#sage.graphs.graph.Graph.is_line_graph" title="sage.graphs.graph.Graph.is_line_graph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_line_graph()</span></code></a> – tests whether a graph is a line graph.</p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">line_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[(0, 1, None),</span>
<span class="go">(0, 2, None),</span>
<span class="go">(0, 3, None),</span>
<span class="go">(1, 2, None),</span>
<span class="go">(1, 3, None),</span>
<span class="go">(2, 3, None)]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">am</span><span class="p">()</span>
<span class="go">[0 1 1 1 1 0]</span>
<span class="go">[1 0 1 1 0 1]</span>
<span class="go">[1 1 0 0 1 1]</span>
<span class="go">[1 1 0 0 1 1]</span>
<span class="go">[1 0 1 1 0 1]</span>
<span class="go">[0 1 1 1 1 0]</span>
<span class="gp">sage: </span><span class="n">h2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">line_graph</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h2</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]</span>
<span class="gp">sage: </span><span class="n">h2</span><span class="o">.</span><span class="n">am</span><span class="p">()</span> <span class="o">==</span> <span class="n">h</span><span class="o">.</span><span class="n">am</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([[</span><span class="mf">1..4</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">:</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">line_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[(1, 2, None),</span>
<span class="go">(1, 3, None),</span>
<span class="go">(1, 4, None),</span>
<span class="go">(2, 3, None),</span>
<span class="go">(2, 4, None),</span>
<span class="go">(3, 4, None)]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[((1, 2, None), (2, 3, None), None),</span>
<span class="go"> ((1, 2, None), (2, 4, None), None),</span>
<span class="go"> ((1, 3, None), (3, 4, None), None),</span>
<span class="go"> ((2, 3, None), (3, 4, None), None)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.longest_path">
<span class="sig-name descname"><span class="pre">longest_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_edge_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'MILP'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.longest_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a longest path of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code> – a vertex (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); forces the source of the path
(the method then returns the longest path starting at <code class="docutils literal notranslate"><span class="pre">s</span></code>). The
argument is set to <code class="docutils literal notranslate"><span class="pre">None</span></code> by default, which means that no constraint
is set upon the first vertex in the path.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code> – a vertex (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); forces the destination of the
path (the method then returns the longest path ending at <code class="docutils literal notranslate"><span class="pre">t</span></code>). The
argument is set to <code class="docutils literal notranslate"><span class="pre">None</span></code> by default, which means that no constraint
is set upon the last vertex in the path.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">use_edge_labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to
compute a path with maximum weight where the weight of an edge is
defined by its label (a label set to <code class="docutils literal notranslate"><span class="pre">None</span></code> or <code class="docutils literal notranslate"><span class="pre">{}</span></code> being
considered as a weight of <span class="math notranslate nohighlight">\(1\)</span>), or to compute a path with the longest
possible number of edges (i.e., edge weights are set to 1)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">&quot;MILP&quot;</span></code>); the algorithm to use
among <code class="docutils literal notranslate"><span class="pre">&quot;MILP&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;backtrack&quot;</span></code>. Two remarks on this respect:</p>
<ul>
<li><p>While the MILP formulation returns an exact answer, the backtrack
algorithm is a randomized heuristic.</p></li>
<li><p>As the backtrack algorithm does not support edge weighting, setting
<code class="docutils literal notranslate"><span class="pre">use_edge_labels=True</span></code> will force the use of the MILP algorithm.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The length of a path is assumed to be the number of its edges, or
the sum of their labels (when <code class="docutils literal notranslate"><span class="pre">use_edge_labels</span> <span class="pre">==</span> <span class="pre">True</span></code>).</p>
</div>
<p>OUTPUT:</p>
<p>A subgraph of <code class="docutils literal notranslate"><span class="pre">self</span></code> corresponding to a (directed if <code class="docutils literal notranslate"><span class="pre">self</span></code> is
directed) longest path. If <code class="docutils literal notranslate"><span class="pre">use_edge_labels</span> <span class="pre">==</span> <span class="pre">True</span></code>, a pair <code class="docutils literal notranslate"><span class="pre">weight,</span>
<span class="pre">path</span></code> is returned.</p>
<p>ALGORITHM:</p>
<p>Mixed Integer Linear Programming (this problem is known to be NP-Hard).</p>
<p>EXAMPLES:</p>
<p>Petersen’s graph being hypohamiltonian, it has a longest path of length
<span class="math notranslate nohighlight">\(n - 2\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">lp</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">longest_path</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">lp</span><span class="o">.</span><span class="n">order</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The heuristic totally agrees:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">longest_path</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;backtrack&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">9</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="../../_images/generic_graph-1.svg" class="plot-directive" src="../../_images/generic_graph-1.svg" /></figure>
<p>Let us compute the longest path on a random graph with random
weights, and ensure the resulting graph is indeed a path:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">g</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">random</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">lp</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">longest_path</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="ow">not</span> <span class="n">lp</span><span class="o">.</span><span class="n">is_forest</span><span class="p">()</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">max</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">degree</span><span class="p">())</span> <span class="o">&lt;=</span> <span class="mi">2</span>
<span class="gp">....: </span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">lp</span><span class="o">.</span><span class="n">is_connected</span><span class="p">())</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.loop_edges">
<span class="sig-name descname"><span class="pre">loop_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.loop_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of all loops in the (di)graph</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether returned edges have
labels (<code class="docutils literal notranslate"><span class="pre">(u,v,l)</span></code>) or not (<code class="docutils literal notranslate"><span class="pre">(u,v)</span></code>)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Looped graph on 0 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allows_loops</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">loop_edges</span><span class="p">()</span>
<span class="go">[(0, 0, None), (1, 1, None), (2, 2, None), (3, 3, None)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">loop_edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(0, 0), (1, 1), (2, 2), (3, 3)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allows_loops</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_loops</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">loop_edges</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(2, 3, None)]</span>

<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">D</span>
<span class="go">Looped digraph on 0 vertices</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">allows_loops</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">loops</span><span class="p">()</span>
<span class="go">[(0, 0, None)]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">allow_loops</span><span class="p">(</span><span class="kc">False</span><span class="p">);</span> <span class="n">D</span>
<span class="go">Digraph on 1 vertex</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[]</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">loops</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">loop_edges</span><span class="p">()</span>
<span class="go">[(0, 0, None), (1, 1, None), (2, 2, None), (3, 3, None)]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">loop_edges</span><span class="p">()</span>
<span class="go">[(0, 0, None), (1, 1, None), (2, 2, None), (3, 3, None)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">loop_edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(0, 0), (0, 0), (1, 1), (1, 1), (2, 2), (3, 3)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.loop_vertices">
<span class="sig-name descname"><span class="pre">loop_vertices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.loop_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of vertices with loops</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">]},</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">loop_vertices</span><span class="p">()</span>
<span class="go">[0, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.loops">
<span class="sig-name descname"><span class="pre">loops</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.loops" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of all loops in the (di)graph</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether returned edges have
labels (<code class="docutils literal notranslate"><span class="pre">(u,v,l)</span></code>) or not (<code class="docutils literal notranslate"><span class="pre">(u,v)</span></code>)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Looped graph on 0 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allows_loops</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">loop_edges</span><span class="p">()</span>
<span class="go">[(0, 0, None), (1, 1, None), (2, 2, None), (3, 3, None)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">loop_edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(0, 0), (1, 1), (2, 2), (3, 3)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allows_loops</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_loops</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">loop_edges</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(2, 3, None)]</span>

<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">D</span>
<span class="go">Looped digraph on 0 vertices</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">allows_loops</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">loops</span><span class="p">()</span>
<span class="go">[(0, 0, None)]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">allow_loops</span><span class="p">(</span><span class="kc">False</span><span class="p">);</span> <span class="n">D</span>
<span class="go">Digraph on 1 vertex</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[]</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">loops</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">loop_edges</span><span class="p">()</span>
<span class="go">[(0, 0, None), (1, 1, None), (2, 2, None), (3, 3, None)]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">loop_edges</span><span class="p">()</span>
<span class="go">[(0, 0, None), (1, 1, None), (2, 2, None), (3, 3, None)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">loop_edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(0, 0), (0, 0), (1, 1), (1, 1), (2, 2), (3, 3)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.max_cut">
<span class="sig-name descname"><span class="pre">max_cut</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value_only</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_edge_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.max_cut" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a maximum edge cut of the graph.</p>
<p>For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Maximum_cut">Wikipedia article Maximum_cut</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">value_only</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return only
the size of the maximum edge cut, or to also return the list of edges
of the maximum edge cut</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">use_edge_labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to
compute a weighted maximum cut where the weight of an edge is defined
by its label (if an edge has no label, <span class="math notranslate nohighlight">\(1\)</span> is assumed), or to compute
a cut of maximum cardinality (i.e., edge weights are set to 1)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
two sets of vertices that are disconnected by the cut. This implies
<code class="docutils literal notranslate"><span class="pre">value_only=False</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>Quite obviously, the max cut of a bipartite graph is the number of
edges, and the two sets of vertices are the two sides:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span> <span class="n">value</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="p">[</span> <span class="n">setA</span><span class="p">,</span> <span class="n">setB</span> <span class="p">]]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">max_cut</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">value</span> <span class="o">==</span> <span class="mi">5</span><span class="o">*</span><span class="mi">6</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">bsetA</span><span class="p">,</span> <span class="n">bsetB</span>  <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="n">g</span><span class="o">.</span><span class="n">bipartite_sets</span><span class="p">())</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">bsetA</span> <span class="o">==</span> <span class="n">setA</span> <span class="ow">and</span> <span class="n">bsetB</span> <span class="o">==</span> <span class="n">setB</span> <span class="p">)</span> <span class="ow">or</span> <span class="p">((</span><span class="n">bsetA</span> <span class="o">==</span> <span class="n">setB</span> <span class="ow">and</span> <span class="n">bsetB</span> <span class="o">==</span> <span class="n">setA</span> <span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The max cut of a Petersen graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">max_cut</span><span class="p">()</span>
<span class="go">12</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.merge_vertices">
<span class="sig-name descname"><span class="pre">merge_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.merge_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge vertices.</p>
<p>This function replaces a set <span class="math notranslate nohighlight">\(S\)</span> of vertices by a single vertex
<span class="math notranslate nohighlight">\(v_{new}\)</span>, such that the edge <span class="math notranslate nohighlight">\(uv_{new}\)</span> exists if and only if
<span class="math notranslate nohighlight">\(\exists v'\in S: (u,v')\in G\)</span>.</p>
<p>The new vertex is named after the first vertex in the list given in
argument. If this first name is <span class="math notranslate nohighlight">\(None\)</span>, a new vertex is created.</p>
<p>In the case of multigraphs, the multiplicity is preserved.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – the list of vertices to be merged</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span></code> are distinct vertices in <code class="docutils literal notranslate"><span class="pre">vertices</span></code>, any edges
between <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span></code> will be lost.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">merge_vertices</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 2, None)]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">merge_vertices</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 8, 9]</span>
</pre></div>
</div>
<p>When the first vertex in <code class="docutils literal notranslate"><span class="pre">vertices</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, a new vertex is
created:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">merge_vertices</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(0, 4), (0, 5), (2, 5), (4, 5)]</span>
</pre></div>
</div>
<p>With a Multigraph</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">allow_multiple_edges</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">merge_vertices</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(0, 2), (0, 2)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.min_spanning_tree">
<span class="sig-name descname"><span class="pre">min_spanning_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Prim_Boost'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">starting_vertex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">by_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.min_spanning_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the edges of a minimum spanning tree.</p>
<p>At the moment, no algorithm for directed graph is implemented: if the
graph is directed, a minimum spanning tree of the corresponding
undirected graph is returned.</p>
<p>We expect all weights of the graph to be convertible to float.
Otherwise, an exception is raised.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
takes as input an edge <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></code> and outputs its weight. If not
<code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is automatically set to <code class="docutils literal notranslate"><span class="pre">True</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>
and <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, we use the edge label <code class="docutils literal notranslate"><span class="pre">l</span></code> , if <code class="docutils literal notranslate"><span class="pre">l</span></code>
is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, else <code class="docutils literal notranslate"><span class="pre">1</span></code> as a weight. The <code class="docutils literal notranslate"><span class="pre">weight_function</span></code> can
be used to transform the label into a weight (note that, if the weight
returned is not convertible to a float, an error is raised)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">by_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, the edges
in the graph are weighted, otherwise all edges have weight 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">&quot;Prim_Boost&quot;</span></code>); the algorithm to
use in computing a minimum spanning tree of <code class="docutils literal notranslate"><span class="pre">G</span></code>. The following
algorithms are supported:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Prim_Boost&quot;</span></code> – Prim’s algorithm (Boost implementation)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Prim_fringe&quot;</span></code> – a variant of Prim’s algorithm that ignores the
labels on the edges</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Prim_edge&quot;</span></code> – a variant of Prim’s algorithm</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Kruskal&quot;</span></code> – Kruskal’s algorithm</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Filter_Kruskal&quot;</span></code> – a variant of Kruskal’s algorithm <a class="reference internal" href="../../../references/index.html#oss2009" id="id33"><span>[OSS2009]</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Kruskal_Boost&quot;</span></code> – Kruskal’s algorithm (Boost implementation)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Boruvka&quot;</span></code> – Boruvka’s algorithm</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NetworkX</span></code> – uses NetworkX’s minimum spanning tree
implementation</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">starting_vertex</span></code> – a vertex (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the vertex from
which to begin the search for a minimum spanning tree (available only
for <code class="docutils literal notranslate"><span class="pre">Prim_fringe</span></code> and <code class="docutils literal notranslate"><span class="pre">Prim_edge</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to first perform
sanity checks on the input graph <code class="docutils literal notranslate"><span class="pre">G</span></code>. If appropriate, <code class="docutils literal notranslate"><span class="pre">check</span></code> is
passed on to any minimum spanning tree functions that are invoked from
the current method. See the documentation of the corresponding
functions for details on what sort of sanity checks will be performed.</p></li>
</ul>
<p>OUTPUT:</p>
<p>The edges of a minimum spanning tree of <code class="docutils literal notranslate"><span class="pre">G</span></code>, if one exists, otherwise
returns the empty list.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="spanning_tree.html#sage.graphs.spanning_tree.kruskal" title="sage.graphs.spanning_tree.kruskal"><code class="xref py py-func docutils literal notranslate"><span class="pre">sage.graphs.spanning_tree.kruskal()</span></code></a></p></li>
<li><p><a class="reference internal" href="spanning_tree.html#sage.graphs.spanning_tree.filter_kruskal" title="sage.graphs.spanning_tree.filter_kruskal"><code class="xref py py-func docutils literal notranslate"><span class="pre">sage.graphs.spanning_tree.filter_kruskal()</span></code></a></p></li>
<li><p><a class="reference internal" href="spanning_tree.html#sage.graphs.spanning_tree.boruvka" title="sage.graphs.spanning_tree.boruvka"><code class="xref py py-func docutils literal notranslate"><span class="pre">sage.graphs.spanning_tree.boruvka()</span></code></a></p></li>
<li><p><a class="reference internal" href="base/boost_graph.html#sage.graphs.base.boost_graph.min_spanning_tree" title="sage.graphs.base.boost_graph.min_spanning_tree"><code class="xref py py-func docutils literal notranslate"><span class="pre">sage.graphs.base.boost_graph.min_spanning_tree()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>Kruskal’s algorithm:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">())</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">weight</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">((</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">(</span><span class="n">weight_function</span><span class="o">=</span><span class="n">weight</span><span class="p">))</span>
<span class="go">[(0, 4, None), (1, 4, None), (2, 4, None), (3, 4, None)]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">(</span><span class="n">weight_function</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Kruskal_Boost&#39;</span><span class="p">))</span>
<span class="go">[(0, 4, None), (1, 4, None), (2, 4, None), (3, 4, None)]</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">allow_multiple_edges</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">())</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">())</span>
<span class="go">[(0, 1, None), (0, 4, None), (0, 5, None), (1, 2, None), (1, 6, None), (3, 8, None), (5, 7, None), (5, 8, None), (6, 9, None)]</span>
</pre></div>
</div>
<p>Boruvka’s algorithm:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Boruvka&#39;</span><span class="p">))</span>
<span class="go">[(0, 1, None), (0, 4, None), (0, 5, None), (1, 2, None),  (1, 6, None), (2, 3, None), (2, 7, None),  (3, 8, None), (4, 9, None)]</span>
</pre></div>
</div>
<p>Prim’s algorithm:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Prim_edge&#39;</span><span class="p">,</span> <span class="n">starting_vertex</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">weight_function</span><span class="o">=</span><span class="n">weight</span><span class="p">))</span>
<span class="go">[(0, 4, None), (1, 4, None), (2, 4, None), (3, 4, None)]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Prim_fringe&#39;</span><span class="p">,</span> <span class="n">starting_vertex</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">weight_function</span><span class="o">=</span><span class="n">weight</span><span class="p">))</span>
<span class="go">[(0, 4, None), (1, 4, None), (2, 4, None), (3, 4, None)]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">(</span><span class="n">weight_function</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Prim_Boost&#39;</span><span class="p">))</span>
<span class="go">[(0, 4, None), (1, 4, None), (2, 4, None), (3, 4, None)]</span>
</pre></div>
</div>
<p>NetworkX algorithm:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;NetworkX&#39;</span><span class="p">))</span>
<span class="go">[(0, 1, None), (0, 2, None), (0, 3, None), (0, 4, None)]</span>
</pre></div>
</div>
<p>More complicated weights:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">}),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">})])</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">(</span><span class="n">weight_function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]))</span>
<span class="go">[(0, 1, {&#39;name&#39;: &#39;a&#39;, &#39;weight&#39;: 1}), (1, 2, {&#39;name&#39;: &#39;b&#39;, &#39;weight&#39;: 1})]</span>
</pre></div>
</div>
<p>If the graph is not weighted, edge labels are not considered, even if
they are numbers:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">())</span>
<span class="go">[(1, 2, 1), (1, 3, 2)]</span>
</pre></div>
</div>
<p>In order to use weights, we need either to set variable <code class="docutils literal notranslate"><span class="pre">weighted</span></code> to
<code class="docutils literal notranslate"><span class="pre">True</span></code>, or to specify a weight function or set by_weight to <code class="docutils literal notranslate"><span class="pre">True</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">weighted</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">())</span>
<span class="go">[(1, 2, 1), (2, 3, 1)]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">weighted</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">())</span>
<span class="go">[(1, 2, 1), (1, 3, 2)]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">(</span><span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(1, 2, 1), (2, 3, 1)]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">(</span><span class="n">weight_function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">[(1, 2, 1), (2, 3, 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.minimum_cycle_basis">
<span class="sig-name descname"><span class="pre">minimum_cycle_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">by_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.minimum_cycle_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a minimum weight cycle basis of the graph.</p>
<p>A cycle basis is a list of cycles (list of vertices forming a cycle) of
<code class="docutils literal notranslate"><span class="pre">self</span></code>. Note that the vertices are not necessarily returned in the
order in which they appear in the cycle.</p>
<p>A minimum weight cycle basis is a cycle basis that minimizes the sum of
the weights (length for unweighted graphs) of its cycles.</p>
<p>Not implemented for directed graphs and multigraphs.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
takes as input an edge <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></code> and outputs its weight. If not
<code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is automatically set to <code class="docutils literal notranslate"><span class="pre">True</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>
and <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, we use the edge label <code class="docutils literal notranslate"><span class="pre">l</span></code>, if <code class="docutils literal notranslate"><span class="pre">l</span></code>
is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, else <code class="docutils literal notranslate"><span class="pre">1</span></code> as a weight.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">by_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, the edges
in the graph are weighted, otherwise all edges have weight 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); algorithm to use:</p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;NetworkX&quot;</span></code>, use networkx implementation</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">None</span></code>, use Sage Cython implementation</p></li>
</ul>
</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">250</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">17</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">20</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">minimum_cycle_basis</span><span class="p">(</span><span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[[1, 2, 3], [1, 2, 3, 4], [5, 6, 7]]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">minimum_cycle_basis</span><span class="p">(</span><span class="n">by_weight</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">[[1, 2, 3], [1, 3, 4], [5, 6, 7]]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">minimum_cycle_basis</span><span class="p">(</span><span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;NetworkX&#39;</span><span class="p">))</span>
<span class="go">[[1, 2, 3], [1, 2, 3, 4], [5, 6, 7]]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">minimum_cycle_basis</span><span class="p">(</span><span class="n">by_weight</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;NetworkX&#39;</span><span class="p">)</span>
<span class="go">[[1, 2, 3], [1, 3, 4], [5, 6, 7]]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">minimum_cycle_basis</span><span class="p">(</span><span class="n">by_weight</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">[[1, 2, 3, 5], [3, 4, 5]]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">minimum_cycle_basis</span><span class="p">(</span><span class="n">by_weight</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;NetworkX&#39;</span><span class="p">))</span>
<span class="go">[[1, 2, 3, 5], [3, 4, 5]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.cycle_basis" title="sage.graphs.generic_graph.GenericGraph.cycle_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cycle_basis()</span></code></a></p></li>
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Cycle_basis">Wikipedia article Cycle_basis</a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.multicommodity_flow">
<span class="sig-name descname"><span class="pre">multicommodity_flow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">terminals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_edge_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.multicommodity_flow" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a multicommodity flow problem.</p>
<p>In the multicommodity flow problem, we are given a set of pairs <span class="math notranslate nohighlight">\((s_i,
t_i)\)</span>, called terminals meaning that <span class="math notranslate nohighlight">\(s_i\)</span> is willing some flow to
<span class="math notranslate nohighlight">\(t_i\)</span>.</p>
<p>Even though it is a natural generalisation of the flow problem this
version of it is NP-Complete to solve when the flows are required to be
integer.</p>
<p>For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Multi-commodity_flow_problem">Wikipedia article Multi-commodity_flow_problem</a>.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">terminals</span></code> – a list of pairs <span class="math notranslate nohighlight">\((s_i, t_i)\)</span> or triples <span class="math notranslate nohighlight">\((s_i, t_i,
w_i)\)</span> representing a flow from <span class="math notranslate nohighlight">\(s_i\)</span> to <span class="math notranslate nohighlight">\(t_i\)</span> of intensity <span class="math notranslate nohighlight">\(w_i\)</span>. When
the pairs are of size <span class="math notranslate nohighlight">\(2\)</span>, an intensity of <span class="math notranslate nohighlight">\(1\)</span> is assumed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integer</span></code> boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether to require an integer
multicommodity flow</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">use_edge_labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to
compute a multicommodity flow where each edge has a capacity defined
by its label (if an edge has no label, capacity <span class="math notranslate nohighlight">\(1\)</span> is assumed), or to
use default edge capacity of <span class="math notranslate nohighlight">\(1\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertex_bound</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to require
that a vertex can stand at most <span class="math notranslate nohighlight">\(1\)</span> commodity of flow through it of
intensity <span class="math notranslate nohighlight">\(1\)</span>. Terminals can obviously still send or receive several
units of flow even though <code class="docutils literal notranslate"><span class="pre">vertex_bound</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, as this
parameter is meant to represent topological properties.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p>
<p>Only useful when parameter <code class="docutils literal notranslate"><span class="pre">ìnteger</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</li>
</ul>
<p>ALGORITHM:</p>
<p>(Mixed Integer) Linear Program, depending on the value of <code class="docutils literal notranslate"><span class="pre">integer</span></code>.</p>
<p>EXAMPLES:</p>
<p>An easy way to obtain a satisfiable multicommodity flow is to compute a
matching in a graph, and to consider the paired vertices as terminals</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">matching</span> <span class="o">=</span> <span class="p">[(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">matching</span><span class="p">()]</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">multicommodity_flow</span><span class="p">(</span><span class="n">matching</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
<p>We could also have considered <code class="docutils literal notranslate"><span class="pre">g</span></code> as symmetric and computed the
multicommodity flow in this version instead. In this case, however edges
can be used in both directions at the same time:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">multicommodity_flow</span><span class="p">(</span><span class="n">matching</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
<p>An exception is raised when the problem has no solution</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">multicommodity_flow</span><span class="p">([(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">matching</span><span class="p">])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">EmptySetError: the multicommodity flow problem has no solution</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.multiple_edges">
<span class="sig-name descname"><span class="pre">multiple_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">to_undirected</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.multiple_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return any multiple edges in the (di)graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">to_undirected</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether to include labels</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sort</span></code> - boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to sort the result</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Multi-graph on 0 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allows_multiple_edges</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">multiple_edges</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(0, 1, None), (0, 1, None), (0, 1, None)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_multiple_edges</span><span class="p">(</span><span class="kc">False</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Graph on 2 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None)]</span>

<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">D</span>
<span class="go">Multi-digraph on 0 vertices</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">allows_multiple_edges</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">multiple_edges</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(0, 1, None), (0, 1, None), (0, 1, None)]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">allow_multiple_edges</span><span class="p">(</span><span class="kc">False</span><span class="p">);</span> <span class="n">D</span>
<span class="go">Digraph on 2 vertices</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None)]</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;h&#39;</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;g&#39;</span><span class="p">}},</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_multiple_edges</span><span class="p">(</span><span class="n">to_undirected</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">multiple_edges</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">multiple_edges</span><span class="p">(</span><span class="n">to_undirected</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(1, 2, &#39;h&#39;), (2, 1, &#39;g&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.multiway_cut">
<span class="sig-name descname"><span class="pre">multiway_cut</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_only</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_edge_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.multiway_cut" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a minimum edge multiway cut.</p>
<p>A multiway cut for a vertex set <span class="math notranslate nohighlight">\(S\)</span> in a graph or a digraph <span class="math notranslate nohighlight">\(G\)</span> is a set
<span class="math notranslate nohighlight">\(C\)</span> of edges such that any two vertices <span class="math notranslate nohighlight">\(u,v\)</span> in <span class="math notranslate nohighlight">\(S\)</span> are disconnected
when removing the edges of <span class="math notranslate nohighlight">\(C\)</span> from <span class="math notranslate nohighlight">\(G\)</span>.
( cf. <a class="reference external" href="http://www.d.kth.se/~viggo/wwwcompendium/node92.html">http://www.d.kth.se/~viggo/wwwcompendium/node92.html</a> )</p>
<p>Such a cut is said to be minimum when its cardinality (or weight) is
minimum.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – iterable; the set of vertices</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value_only</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return only
the size of the minimum multiway cut, or to return the list of edges
of the multiway cut</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">use_edge_labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to
compute a weighted minimum multiway cut where the weight of an edge is
defined by its label (if an edge has no label, <span class="math notranslate nohighlight">\(1\)</span> is assumed), or to
compute a cut of minimum cardinality (i.e., edge weights are set to 1)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>Of course, a multiway cut between two vertices correspond to a minimum
edge cut:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">edge_cut</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">multiway_cut</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">value_only</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>As Petersen’s graph is <span class="math notranslate nohighlight">\(3\)</span>-regular, a minimum multiway cut between three
vertices contains at most <span class="math notranslate nohighlight">\(2\times 3\)</span> edges (which could correspond to
the neighborhood of 2 vertices):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">multiway_cut</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span> <span class="n">value_only</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">*</span><span class="mi">3</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In this case, though, the vertices are an independent set.  If we pick
instead vertices <span class="math notranslate nohighlight">\(0,9,\)</span> and <span class="math notranslate nohighlight">\(7\)</span>, we can save <span class="math notranslate nohighlight">\(4\)</span> edges in the multiway
cut:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">multiway_cut</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span> <span class="n">value_only</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">*</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">1</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This example, though, does not work in the directed case anymore, as it
is not possible in Petersen’s graph to mutualise edges:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">multiway_cut</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span> <span class="n">value_only</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="o">*</span><span class="mi">3</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Of course, a multiway cut between the whole vertex set contains all the
edges of the graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">multiway_cut</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>
<span class="gp">sage: </span><span class="nb">set</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.name">
<span class="sig-name descname"><span class="pre">name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return or set the graph’s name.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">new</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); by default (<code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">==</span> <span class="pre">None</span></code>),
the method returns the name of the graph. When <code class="docutils literal notranslate"><span class="pre">name</span></code> is set, the
string representation of that object becomes the new name of the
(di)graph (<code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">==</span> <span class="pre">''</span></code> removes any name).</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">9</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span> <span class="mi">7</span><span class="p">:</span> <span class="p">[</span><span class="mi">9</span><span class="p">]}</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">d</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Graph on 10 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">name</span><span class="p">(</span><span class="s2">&quot;Petersen Graph&quot;</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Petersen Graph: Graph on 10 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">name</span><span class="p">(</span><span class="n">new</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Graph on 10 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
<span class="go">&#39;&#39;</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">name</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="n">G</span>
<span class="go">42: Graph on 10 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
<span class="go">&#39;42&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.neighbor_iterator">
<span class="sig-name descname"><span class="pre">neighbor_iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">closed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.neighbor_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over neighbors of <code class="docutils literal notranslate"><span class="pre">vertex</span></code>.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">closed</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the returned iterator also
contains <code class="docutils literal notranslate"><span class="pre">vertex</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertex</span></code> – a vertex of <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">closed</span></code> – a boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to
return the closed neighborhood of <code class="docutils literal notranslate"><span class="pre">vertex</span></code>, i.e., including
<code class="docutils literal notranslate"><span class="pre">vertex</span></code>, or the open neighborhood in which <code class="docutils literal notranslate"><span class="pre">vertex</span></code>
is included only if there is a loop on that vertex.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">neighbor_iterator</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">1</span>
<span class="go">4</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">D</span><span class="o">.</span><span class="n">neighbor_iterator</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">1</span>
<span class="go">4</span>
<span class="go">5</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">neighbor_iterator</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[1, 2, 3]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">neighbor_iterator</span><span class="p">(</span><span class="s1">&#39;010&#39;</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[&#39;000&#39;, &#39;010&#39;, &#39;011&#39;, &#39;110&#39;]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">loops</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">neighbor_iterator</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[0, 1]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">neighbor_iterator</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.neighbors">
<span class="sig-name descname"><span class="pre">neighbors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">closed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of neighbors (in and out if directed) of <code class="docutils literal notranslate"><span class="pre">vertex</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">G[vertex]</span></code> also works.
When <code class="docutils literal notranslate"><span class="pre">closed</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the returned iterator also
contains <code class="docutils literal notranslate"><span class="pre">vertex</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertex</span></code> – a vertex of <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">closed</span></code> – a boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to
return the closed neighborhood of <code class="docutils literal notranslate"><span class="pre">vertex</span></code>, i.e., including
<code class="docutils literal notranslate"><span class="pre">vertex</span></code>, or the open neighborhood in which <code class="docutils literal notranslate"><span class="pre">vertex</span></code>
is included only if there is a loop on that vertex.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">[2, 4, 8]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="go">[0, 3, 9]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[2, 3, 4, 8]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.networkx_graph">
<span class="sig-name descname"><span class="pre">networkx_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.networkx_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new <code class="docutils literal notranslate"><span class="pre">NetworkX</span></code> graph from the Sage graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
takes as input an edge <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></code> and outputs its weight.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">TetrahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">networkx_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="go">&lt;class &#39;networkx.classes.graph.Graph&#39;&gt;</span>

<span class="gp">sage: </span><span class="k">def</span> <span class="nf">weight_fn</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">G1</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G1</span><span class="o">.</span><span class="n">networkx_graph</span><span class="p">(</span><span class="n">weight_function</span><span class="o">=</span><span class="n">weight_fn</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">EdgeDataView([(1, 2, {&#39;weight&#39;: 1}), (1, 3, {&#39;weight&#39;: 4}), (2, 3, {&#39;weight&#39;: 3}), (3, 4, {&#39;weight&#39;: 4})])</span>
<span class="gp">sage: </span><span class="n">G2</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)],</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G2</span><span class="o">.</span><span class="n">networkx_graph</span><span class="p">(</span><span class="n">weight_function</span><span class="o">=</span><span class="n">weight_fn</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">OutMultiEdgeDataView([(1, 2, {&#39;weight&#39;: 1}), (1, 3, {&#39;weight&#39;: 4}), (2, 3, {&#39;weight&#39;: 3}), (3, 4, {&#39;weight&#39;: 5}), (3, 4, {&#39;weight&#39;: 4})])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.nowhere_zero_flow">
<span class="sig-name descname"><span class="pre">nowhere_zero_flow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.nowhere_zero_flow" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <code class="docutils literal notranslate"><span class="pre">k</span></code>-nowhere zero flow of the (di)graph.</p>
<p>A flow on a graph <span class="math notranslate nohighlight">\(G = (V, E)\)</span> is a pair <span class="math notranslate nohighlight">\((D, f)\)</span> such that <span class="math notranslate nohighlight">\(D\)</span>
is an orientation of <span class="math notranslate nohighlight">\(G\)</span> and <span class="math notranslate nohighlight">\(f\)</span> is a function on <span class="math notranslate nohighlight">\(E\)</span> satisfying</p>
<div class="math notranslate nohighlight">
\[\sum_{u \in N^-_D(v)} f(uv) = \sum_{w \in N^+_D(v)} f(vw),
\ \forall v \in V.\]</div>
<p>A <code class="docutils literal notranslate"><span class="pre">nowhere</span> <span class="pre">zero</span> <span class="pre">flow</span></code> on a graph <span class="math notranslate nohighlight">\(G = (V, E)\)</span> is a flow <span class="math notranslate nohighlight">\((D, f)\)</span>
such that <span class="math notranslate nohighlight">\(f(e) \neq 0\)</span> for every <span class="math notranslate nohighlight">\(e \in E\)</span>. For a positive
integer <span class="math notranslate nohighlight">\(k\)</span>, a <span class="math notranslate nohighlight">\(k\)</span>-flow on a graph <span class="math notranslate nohighlight">\(G = (V, E)\)</span> is a flow <span class="math notranslate nohighlight">\((D, f)\)</span>
such that <span class="math notranslate nohighlight">\(f: E \to Z\)</span> and <span class="math notranslate nohighlight">\(-(k - 1) \leq f(e) \leq k - 1\)</span> for
every <span class="math notranslate nohighlight">\(e \in E\)</span>. A <span class="math notranslate nohighlight">\(k\)</span>-flow is positive if <span class="math notranslate nohighlight">\(f(e) &gt; 0\)</span> for every
<span class="math notranslate nohighlight">\(e \in E\)</span>. A <span class="math notranslate nohighlight">\(k\)</span>-flow which is nowhere zero is called a
<span class="math notranslate nohighlight">\(k\)</span>-<em>nowhere zero flow</em> (or <span class="math notranslate nohighlight">\(k\)</span>-NZF).</p>
<p>The following are equivalent.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(G\)</span> admits a positive <span class="math notranslate nohighlight">\(k\)</span>-flow.</p></li>
<li><p><span class="math notranslate nohighlight">\(G\)</span> admits a <span class="math notranslate nohighlight">\(k\)</span>-NZF.</p></li>
<li><p>Every orientation of <span class="math notranslate nohighlight">\(G\)</span> admits a <span class="math notranslate nohighlight">\(k\)</span>-NZF.</p></li>
</ul>
<p>Furthermore, a (di)graph admits a <span class="math notranslate nohighlight">\(k\)</span>-NZF if and only if it
is bridgeless and every bridgeless graph admits a <span class="math notranslate nohighlight">\(6\)</span>-NZF <a class="reference internal" href="../../../references/index.html#sey1981" id="id34"><span>[Sey1981]</span></a>.
See the <a class="reference external" href="https://en.wikipedia.org/wiki/Nowhere-zero_flow">Wikipedia article Nowhere-zero_flow</a> for more details.</p>
<p>ALGORITHM:</p>
<p>If <code class="docutils literal notranslate"><span class="pre">self</span></code> is not directed, we search for a <span class="math notranslate nohighlight">\(k\)</span>-NZF on any orientation
of <code class="docutils literal notranslate"><span class="pre">self</span></code> and then build a positive <span class="math notranslate nohighlight">\(k\)</span>-NZF by reverting edges with
negative flow.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">6</span></code>); when set to a positive integer
<span class="math notranslate nohighlight">\(\geq 2\)</span>, search for a <span class="math notranslate nohighlight">\(k\)</span>-nowhere zero flow</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A digraph with flow values stored as edge labels if a <span class="math notranslate nohighlight">\(k\)</span>-nowhere zero
flow is found. If <code class="docutils literal notranslate"><span class="pre">self</span></code> is undirected, the edges of this digraph
indicate the selected orientation. If no feasible solution is found, an
error is raised.</p>
<p>EXAMPLES:</p>
<p>The Petersen graph admits a (positive) 5-nowhere zero flow, but no
4-nowhere zero flow:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">nowhere_zero_flow</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">edge_labels</span><span class="p">()))</span>
<span class="go">[1, 2, 3, 4]</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">nowhere_zero_flow</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">EmptySetError: the problem has no feasible solution</span>
</pre></div>
</div>
<p>The de Bruijn digraph admits a 2-nowhere zero flow:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">DeBruijn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">nowhere_zero_flow</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">edge_labels</span><span class="p">()))</span>
<span class="go">[-1, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.num_edges">
<span class="sig-name descname"><span class="pre">num_edges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.num_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of edges.</p>
<p>Note that <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.num_edges" title="sage.graphs.generic_graph.GenericGraph.num_edges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">num_edges()</span></code></a> also returns the number of edges in <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">15</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.num_faces">
<span class="sig-name descname"><span class="pre">num_faces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">embedding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.num_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of faces of an embedded graph.</p>
<p>If no embedding is provided or stored as <code class="docutils literal notranslate"><span class="pre">self._embedding</span></code>, this
method uses Euler’s formula (see the <a class="reference external" href="https://en.wikipedia.org/wiki/Euler_characteristic">Wikipedia article Euler_characteristic</a>)
to determine the number of faces if the graph is planar. If the graph is
not planar, an error is raised.</p>
<p>If an embedding is provided or stored as <code class="docutils literal notranslate"><span class="pre">self._embedding</span></code>, this
method calls method <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.faces" title="sage.graphs.generic_graph.GenericGraph.faces"><code class="xref py py-meth docutils literal notranslate"><span class="pre">faces()</span></code></a> to get the list of faces induced by
the embedding in each connected component of the graph. Then it returns
the sum of size of these lists minus the number of connected components
plus one to ensure that the external face is counted only once.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">embedding</span></code> – dictionary (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a combinatorial
embedding dictionary. Format: <code class="docutils literal notranslate"><span class="pre">{v1:</span> <span class="pre">[v2,v3],</span> <span class="pre">v2:</span> <span class="pre">[v1],</span> <span class="pre">v3:</span> <span class="pre">[v1]}</span></code>
(clockwise ordering of neighbors at each vertex). If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>
(default) the method will use the embedding stored as
<code class="docutils literal notranslate"><span class="pre">self._embedding</span></code>. If none is stored, the method will compute the
set of faces from the embedding returned by <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_planar" title="sage.graphs.generic_graph.GenericGraph.is_planar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_planar()</span></code></a> (if the
graph is, of course, planar).</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">TetrahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">num_faces</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
<p>The external face of a disconnected graph is counted only once:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">T</span> <span class="o">+</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">num_faces</span><span class="p">()</span>
<span class="go">7</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">T</span> <span class="o">+</span> <span class="n">T</span> <span class="o">+</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">num_faces</span><span class="p">()</span>
<span class="go">10</span>
</pre></div>
</div>
<p>Trees and forests have a single face:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomTree</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">num_faces</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">T</span> <span class="o">+</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">num_faces</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.num_verts">
<span class="sig-name descname"><span class="pre">num_verts</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.num_verts" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of vertices.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">len(G)</span></code> and <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.num_verts" title="sage.graphs.generic_graph.GenericGraph.num_verts"><code class="xref py py-meth docutils literal notranslate"><span class="pre">num_verts()</span></code></a> also return the number of
vertices in <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">10</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">TetrahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.number_of_loops">
<span class="sig-name descname"><span class="pre">number_of_loops</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.number_of_loops" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of edges that are loops</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(0, 0), (1, 1), (2, 2), (2, 3), (3, 3)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">number_of_loops</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(0, 0), (1, 1), (2, 2), (2, 3), (3, 3)]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">number_of_loops</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.odd_girth">
<span class="sig-name descname"><span class="pre">odd_girth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'bfs'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.odd_girth" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the odd girth of the graph.</p>
<p>The odd girth is the length of the shortest cycle of odd length
in the graph (directed cycle if the graph is directed).
Bipartite graphs have infinite odd girth.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">&quot;bfs&quot;</span></code>); the algorithm to use:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;bfs&quot;</span></code> – BFS-based algorithm</p></li>
<li><p>any algorithm accepted by
<a class="reference external" href="../../../matrices/sage/matrix/matrix_integer_dense.html#sage.matrix.matrix_integer_dense.Matrix_integer_dense.charpoly" title="(in Sage 9.5 Reference Manual: Matrices and Spaces of Matrices v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">charpoly()</span></code></a>
for computation from the characteristic polynomial (see
<a class="reference internal" href="../../../references/index.html#har1962" id="id35"><span>[Har1962]</span></a> and <a class="reference internal" href="../../../references/index.html#big1993" id="id36"><span>[Big1993]</span></a>, p. 45)</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return
<code class="docutils literal notranslate"><span class="pre">(g,</span> <span class="pre">c)</span></code>, where <code class="docutils literal notranslate"><span class="pre">g</span></code> is the odd girth and <code class="docutils literal notranslate"><span class="pre">c</span></code> is a list of
vertices of a (directed) cycle of length <code class="docutils literal notranslate"><span class="pre">g</span></code> in the graph, thus
providing a certificate that the odd girth is at most <code class="docutils literal notranslate"><span class="pre">g</span></code>, or
<code class="docutils literal notranslate"><span class="pre">None</span></code> if <code class="docutils literal notranslate"><span class="pre">g</span></code> is infinite. So far, this parameter is accepted only
when <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;bfs&quot;</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>The McGee graph has girth 7 and therefore its odd girth is 7 as well:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">McGeeGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">girth</span><span class="p">()</span>
<span class="go">7</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">odd_girth</span><span class="p">()</span>
<span class="go">7</span>
</pre></div>
</div>
<p>Any complete (directed) graph on more than 2 vertices contains
a (directed) triangle and has thus odd girth 3:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">odd_girth</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># random</span>
<span class="go">(3, [2, 1, 0])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Complete</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">odd_girth</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># random</span>
<span class="go">(3, [1, 2, 0])</span>
</pre></div>
</div>
<p>Bipartite graphs have no odd cycle and consequently have
infinite odd girth:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomBipartite</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mf">.5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">odd_girth</span><span class="p">()</span>
<span class="go">+Infinity</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">odd_girth</span><span class="p">()</span>
<span class="go">+Infinity</span>
</pre></div>
</div>
<p>The odd girth of a (directed) graph with loops is 1:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mf">.5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_loops</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">odd_girth</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">RandomDirectedGNP</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mf">.5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_loops</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">odd_girth</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.girth" title="sage.graphs.generic_graph.GenericGraph.girth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">girth()</span></code></a> – return the girth of the graph.</p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.order">
<span class="sig-name descname"><span class="pre">order</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.order" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of vertices.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">len(G)</span></code> and <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.num_verts" title="sage.graphs.generic_graph.GenericGraph.num_verts"><code class="xref py py-meth docutils literal notranslate"><span class="pre">num_verts()</span></code></a> also return the number of
vertices in <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">10</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">TetrahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.pagerank">
<span class="sig-name descname"><span class="pre">pagerank</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.85</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">personalization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">by_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dangling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'scipy'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.pagerank" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the PageRank of the vertices of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>PageRank is a centrality measure earlier used to rank web pages.
The PageRank algorithm outputs the probability distribution that
a random walker in the graph visits a vertex.</p>
<p>See the <a class="reference external" href="https://en.wikipedia.org/wiki/PageRank">Wikipedia article PageRank</a> for more information.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">alpha</span></code> – float (default: <code class="docutils literal notranslate"><span class="pre">0.85</span></code>); damping parameter for
PageRank. <code class="docutils literal notranslate"><span class="pre">alpha</span></code> is the click-through probability useful for
preventing sinks. The probability at any step, that an imaginary
surfer who is randomly clicking on links will continue is a damping
factor d.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">personalization</span></code> – dict (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a dictionary keyed
by vertices associating to each vertex a value. The personalization
can be specified for a subset of the vertices, if not specified a
nodes personalization value will be taken as zero. The sum of the
values must be nonzero.
By default (<code class="docutils literal notranslate"><span class="pre">None</span></code>), a uniform distribution is used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">by_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, the edges
in the graph are weighted, otherwise all edges have weight 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
takes as input an edge <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></code> and outputs its weight. If not
<code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is automatically set to <code class="docutils literal notranslate"><span class="pre">True</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>
and <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, we use the edge label <code class="docutils literal notranslate"><span class="pre">l</span></code>, if <code class="docutils literal notranslate"><span class="pre">l</span></code>
is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, else <code class="docutils literal notranslate"><span class="pre">1</span></code> as a weight.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dangling</span></code> – dict (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a dictionary keyed by a
vertex the outedge of “dangling” vertices, (i.e., vertices without
any outedges) points to and the dict value is the weight of that
outedge. By default, dangling vertices are given outedges according
to the personalization vector (uniform if not specified). It may be
common to have the dangling dict to be the same as the personalization
dict.</p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the algorithm to use in</dt><dd><p>computing PageRank of <code class="docutils literal notranslate"><span class="pre">G</span></code>. The following algorithms are
supported:</p>
</dd>
</dl>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">NetworkX</span></code> – uses NetworkX’s default implementation (Scipy as of 2.6)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Scipy&quot;</span></code> – uses Scipy’s PageRank algorithm implementation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;igraph&quot;</span></code> – uses igraph’s PageRank algorithm implementation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;None&quot;</span></code> – uses best implementation available</p></li>
</ul>
</li>
</ul>
<p>OUTPUT: a dictionary containing the PageRank value of each node</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">alpha</span></code>, <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> and <code class="docutils literal notranslate"><span class="pre">weight_function</span></code> are common
to all algorithms. Parameters <code class="docutils literal notranslate"><span class="pre">personalization</span></code> and <code class="docutils literal notranslate"><span class="pre">dangling</span></code>
are used only by algorithms <code class="docutils literal notranslate"><span class="pre">NetworkX</span></code>, <code class="docutils literal notranslate"><span class="pre">Numpy</span></code> and <code class="docutils literal notranslate"><span class="pre">Scipy</span></code>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">pagerank</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Networkx&quot;</span><span class="p">)</span>
<span class="go">{0: 0.25, 1: 0.25, 2: 0.25, 3: 0.25}</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">pagerank</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.50</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;igraph&quot;</span><span class="p">)</span>  <span class="c1"># optional - python_igraph # abs tol 1e-9</span>
<span class="go">{0: 0.25, 1: 0.25, 2: 0.25, 3: 0.25}</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">70</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">80</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">20</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">pagerank</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;NetworkX&quot;</span><span class="p">)</span> <span class="c1"># abs tol 1e-9</span>
<span class="go">{1: 0.16112205885619563,</span>
<span class="go"> 2: 0.1619531043247219,</span>
<span class="go"> 3: 0.16112205885619563,</span>
<span class="go"> 4: 0.2374999999999999,</span>
<span class="go"> 5: 0.17775588228760858,</span>
<span class="go"> 6: 0.100546895675278}</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">pagerank</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;NetworkX&quot;</span><span class="p">,</span> <span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># abs tol 1e-9</span>
<span class="go">{1: 0.16459583718588994,</span>
<span class="go"> 2: 0.13977928595154515,</span>
<span class="go"> 3: 0.16539840184339605,</span>
<span class="go"> 4: 0.3063198690713853,</span>
<span class="go"> 5: 0.1700057609707141,</span>
<span class="go"> 6: 0.05390084497706962}</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">pagerank</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Scipy&quot;</span><span class="p">)</span> <span class="c1"># abs tol 1e-9</span>
<span class="go">{1: 0.16112205885619563,</span>
<span class="go"> 2: 0.1619531043247219,</span>
<span class="go"> 3: 0.16112205885619563,</span>
<span class="go"> 4: 0.2374999999999999,</span>
<span class="go"> 5: 0.17775588228760858,</span>
<span class="go"> 6: 0.100546895675278}</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">pagerank</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Scipy&quot;</span><span class="p">,</span> <span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># abs tol 1e-9</span>
<span class="go">{1: 0.16459583718588994,</span>
<span class="go"> 2: 0.13977928595154515,</span>
<span class="go"> 3: 0.16539840184339605,</span>
<span class="go"> 4: 0.3063198690713853,</span>
<span class="go"> 5: 0.1700057609707141,</span>
<span class="go"> 6: 0.05390084497706962}</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">pagerank</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;igraph&quot;</span><span class="p">)</span>  <span class="c1"># optional - python_igraph # abs tol 1e-9</span>
<span class="go">{1: 0.16112198303979128,</span>
<span class="go"> 2: 0.16195368558382262,</span>
<span class="go"> 3: 0.16112198303979125,</span>
<span class="go"> 4: 0.23749999999999993,</span>
<span class="go"> 5: 0.17775603392041744,</span>
<span class="go"> 6: 0.10054631441617742}</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">pagerank</span><span class="p">()</span> <span class="c1"># abs tol 1e-9</span>
<span class="go">{1: 0.16112205885619563,</span>
<span class="go"> 2: 0.1619531043247219,</span>
<span class="go"> 3: 0.16112205885619563,</span>
<span class="go"> 4: 0.2374999999999999,</span>
<span class="go"> 5: 0.17775588228760858,</span>
<span class="go"> 6: 0.100546895675278}</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">pagerank</span><span class="p">(</span><span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># abs tol 1e-9</span>
<span class="go">{1: 0.16459583718588994,</span>
<span class="go"> 2: 0.13977928595154515,</span>
<span class="go"> 3: 0.16539840184339605,</span>
<span class="go"> 4: 0.3063198690713853,</span>
<span class="go"> 5: 0.1700057609707141,</span>
<span class="go"> 6: 0.05390084497706962}</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/PageRank">Wikipedia article PageRank</a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.planar_dual">
<span class="sig-name descname"><span class="pre">planar_dual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">embedding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.planar_dual" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the planar dual of an embedded graph.</p>
<p>A combinatorial embedding of a graph is a clockwise ordering of the
neighbors of each vertex. From this information one can obtain the dual
of a plane graph, which is what the method returns. The vertices of the
dual graph correspond to faces of the primal graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">embedding</span></code> – dictionary (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a combinatorial
embedding dictionary. Format: <code class="docutils literal notranslate"><span class="pre">{v1:</span> <span class="pre">[v2,v3],</span> <span class="pre">v2:</span> <span class="pre">[v1],</span> <span class="pre">v3:</span> <span class="pre">[v1]}</span></code>
(clockwise ordering of neighbors at each vertex). If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>
(default) the method will use the embedding stored as
<code class="docutils literal notranslate"><span class="pre">self._embedding</span></code>. If none is stored, the method will compute the
set of faces from the embedding returned by <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_planar" title="sage.graphs.generic_graph.GenericGraph.is_planar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_planar()</span></code></a> (if the
graph is, of course, planar).</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">planar_dual</span><span class="p">()</span>
<span class="go">Graph on 6 vertices</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">IcosahedralGraph</span><span class="p">()</span><span class="o">.</span><span class="n">planar_dual</span><span class="p">()</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The planar dual of the planar dual is isomorphic to the graph itself:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">BuckyBall</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">planar_dual</span><span class="p">()</span><span class="o">.</span><span class="n">planar_dual</span><span class="p">()</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.faces" title="sage.graphs.generic_graph.GenericGraph.faces"><code class="xref py py-meth docutils literal notranslate"><span class="pre">faces()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.set_embedding" title="sage.graphs.generic_graph.GenericGraph.set_embedding"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_embedding()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.get_embedding" title="sage.graphs.generic_graph.GenericGraph.get_embedding"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_embedding()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.is_planar" title="sage.graphs.generic_graph.GenericGraph.is_planar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_planar()</span></code></a></p></li>
</ul>
</div>
<div class="admonition-todo admonition" id="id37">
<p class="admonition-title">Todo</p>
<p>Implement the method for graphs that are not 3-vertex-connected,
or at least have a faster 3-vertex-connectivity test (<a class="reference external" href="https://trac.sagemath.org/24635">trac ticket #24635</a>).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.plot">
<span class="sig-name descname"><span class="pre">plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <a class="reference external" href="../../../plotting/sage/plot/graphics.html#sage.plot.graphics.Graphics" title="(in Sage 9.5 Reference Manual: 2D Graphics v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graphics</span></code></a> object representing the
(di)graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pos</span></code> – an optional positioning dictionary</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">layout</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specifies a kind of layout
to use, takes precedence over pos</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'circular'</span></code> – plots the graph with vertices evenly distributed
on a circle</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'spring'</span></code> – uses the traditional spring layout, using the
graph’s current positions as initial positions</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'tree'</span></code> – the (di)graph must be a tree. One can specify the root
of the tree using the keyword tree_root, otherwise a root will be
selected at random. Then the tree will be plotted in levels,
depending on minimum distance for the root.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertex_labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether to print
vertex labels</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edge_labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to print edge
labels. If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the result of <code class="docutils literal notranslate"><span class="pre">str(l)</span></code> is printed on the edge
for each label <span class="math notranslate nohighlight">\(l\)</span>. Labels equal to <code class="docutils literal notranslate"><span class="pre">None</span></code> are not printed (to set
edge labels, see <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.set_edge_label" title="sage.graphs.generic_graph.GenericGraph.set_edge_label"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_edge_label()</span></code></a>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edge_labels_background</span></code> – the color of the edge labels
background. The default is “white”. To achieve a transparent
background use “transparent”.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertex_size</span></code> – size of vertices displayed</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertex_shape</span></code> – the shape to draw the vertices, for example
<code class="docutils literal notranslate"><span class="pre">&quot;o&quot;</span></code> for circle or <code class="docutils literal notranslate"><span class="pre">&quot;s&quot;</span></code> for square. Whole list is available at
<a class="reference external" href="https://matplotlib.org/api/markers_api.html">https://matplotlib.org/api/markers_api.html</a>.
(Not available for multiedge digraphs.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">graph_border</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to include a
box around the graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertex_colors</span></code> – dictionary (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); optional
dictionary to specify vertex colors: each key is a color recognizable
by matplotlib, and each corresponding entry is a list of vertices. If
a vertex is not listed, it looks invisible on the resulting plot (it
doesn’t get drawn).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edge_colors</span></code> – dictionary (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a dictionary
specifying edge colors: each key is a color recognized by matplotlib,
and each entry is a list of edges.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">partition</span></code> – a partition of the vertex set (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); if
specified, plot will show each cell in a different color.
<code class="docutils literal notranslate"><span class="pre">vertex_colors</span></code> takes precedence.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">talk</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, prints large
vertices with white backgrounds so that labels are legible on slides</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iterations</span></code> – integer; how many iterations of the spring layout
algorithm to go through, if applicable</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">color_by_label</span></code> – a boolean or dictionary or function (default:
<code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to color each edge with a different color
according to its label; the colors are chosen along a rainbow, unless
they are specified by a function or dictionary mapping labels to
colors; this option is incompatible with <code class="docutils literal notranslate"><span class="pre">edge_color</span></code> and
<code class="docutils literal notranslate"><span class="pre">edge_colors</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">heights</span></code> – dictionary (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); if specified, this is a
dictionary from a set of floating point heights to a set of vertices</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edge_style</span></code> – keyword arguments passed into the edge-drawing
routine.  This currently only works for directed graphs, since we pass
off the undirected graph to networkx</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tree_root</span></code> – a vertex (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); if specified, this
vertex is used as the root for the <code class="docutils literal notranslate"><span class="pre">layout=&quot;tree&quot;</span></code> option.
Otherwise, then one is chosen at random. Ignored unless
<code class="docutils literal notranslate"><span class="pre">layout='tree'</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tree_orientation</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">&quot;down&quot;</span></code>); one of “up” or
“down”.  If “up” (resp., “down”), then the root of the tree will
appear on the bottom (resp., top) and the tree will grow upwards
(resp. downwards). Ignored unless <code class="docutils literal notranslate"><span class="pre">layout='tree'</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">save_pos</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); save position computed
during plotting</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>This method supports any parameter accepted by
<a class="reference external" href="../../../plotting/sage/plot/graphics.html#sage.plot.graphics.Graphics.show" title="(in Sage 9.5 Reference Manual: 2D Graphics v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.plot.graphics.Graphics.show()</span></code></a>.</p></li>
<li><p>See the documentation of the <a class="reference internal" href="graph_plot.html#module-sage.graphs.graph_plot" title="sage.graphs.graph_plot"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.graphs.graph_plot</span></code></a> module
for information and examples of how to define parameters that will
be applied to <strong>all</strong> graph plots.</p></li>
<li><p>Default parameters for this method <em>and a specific graph</em> can also
be set through the <a class="reference external" href="../../../misc/sage/misc/decorators.html#sage.misc.decorators.options" title="(in Sage 9.5 Reference Manual: Utilities v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">options</span></code></a>
mechanism. For more information on this different way to set
default parameters, see the help of the <a class="reference external" href="../../../misc/sage/misc/decorators.html#sage.misc.decorators.options" title="(in Sage 9.5 Reference Manual: Utilities v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">options</span> <span class="pre">decorator</span></code></a>.</p></li>
<li><p>See also the <a class="reference internal" href="graph_latex.html#module-sage.graphs.graph_latex" title="sage.graphs.graph_latex"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.graphs.graph_latex</span></code></a> module for ways to use
LaTeX to produce an image of a graph.</p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_plot</span> <span class="kn">import</span> <span class="n">graphplot_options</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">graphplot_options</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[...]</span>

<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">pi</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;#FF0000&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="s1">&#39;#FF9900&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="s1">&#39;#FFFF00&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="s1">&#39;#00FF00&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="s1">&#39;#0000FF&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">]}</span>
<span class="gp">sage: </span><span class="n">pos_dict</span> <span class="o">=</span> <span class="p">{}</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">....: </span> <span class="n">x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="n">i</span><span class="p">))</span>
<span class="gp">....: </span> <span class="n">y</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="n">i</span><span class="p">))</span>
<span class="gp">....: </span> <span class="n">pos_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
<span class="gp">....: </span> <span class="n">x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="n">i</span><span class="p">))</span>
<span class="gp">....: </span> <span class="n">y</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="n">i</span><span class="p">))</span>
<span class="gp">....: </span> <span class="n">pos_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">pl</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="n">pos_dict</span><span class="p">,</span> <span class="n">vertex_colors</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pl</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">vertex_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">vertex_size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">graph_border</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">HeawoodGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">G</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;,&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span> <span class="p">{</span> <span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">19</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">19</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">17</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">7</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">14</span><span class="p">],</span> <span class="mi">8</span><span class="p">:</span> <span class="p">[</span><span class="mi">9</span><span class="p">],</span> <span class="mi">9</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">13</span><span class="p">],</span> <span class="mi">10</span><span class="p">:</span> <span class="p">[</span><span class="mi">11</span><span class="p">],</span> <span class="mi">11</span><span class="p">:</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">18</span><span class="p">],</span> <span class="mi">12</span><span class="p">:</span> <span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">13</span><span class="p">],</span> <span class="mi">13</span><span class="p">:</span> <span class="p">[</span><span class="mi">14</span><span class="p">],</span> <span class="mi">14</span><span class="p">:</span> <span class="p">[</span><span class="mi">15</span><span class="p">],</span> <span class="mi">15</span><span class="p">:</span> <span class="p">[</span><span class="mi">16</span><span class="p">],</span> <span class="mi">16</span><span class="p">:</span> <span class="p">[</span><span class="mi">17</span><span class="p">],</span> <span class="mi">17</span><span class="p">:</span> <span class="p">[</span><span class="mi">18</span><span class="p">],</span> <span class="mi">18</span><span class="p">:</span> <span class="p">[</span><span class="mi">19</span><span class="p">],</span> <span class="mi">19</span><span class="p">:</span> <span class="p">[]}</span> <span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">l</span> <span class="ow">in</span> <span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">D</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;,&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="s1">&#39;circular&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.plot.colors</span> <span class="kn">import</span> <span class="n">rainbow</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">rainbow</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">edge_colors</span> <span class="o">=</span> <span class="p">{</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)}</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">C</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="gp">....: </span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">....: </span>     <span class="k">if</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
<span class="gp">....: </span>         <span class="n">edge_colors</span><span class="p">[</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">l</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">vertex_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">vertex_size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">edge_colors</span><span class="o">=</span><span class="n">edge_colors</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Pi</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">16</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">19</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">]]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">partition</span><span class="o">=</span><span class="n">Pi</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_loops</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">]},</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">edge_colors</span><span class="o">=</span><span class="p">{(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)],</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]})</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pos</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.6</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.8</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.8</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">]}</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="s1">&#39;spring&#39;</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Graphics object consisting of 11 graphics primitives</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">axes</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">axes</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">get_pos</span><span class="p">()</span>
<span class="go">{0: (0.0..., 1.0...),</span>
<span class="go"> 1: (-0.95..., 0.30...),</span>
<span class="go"> 2: (-0.58..., -0.80...),</span>
<span class="go"> 3: (0.58..., -0.80...),</span>
<span class="go"> 4: (0.95..., 0.30...),</span>
<span class="go"> 5: (0.0..., 0.5...),</span>
<span class="go"> 6: (-0.47..., 0.15...),</span>
<span class="go"> 7: (-0.29..., -0.40...),</span>
<span class="go"> 8: (0.29..., -0.40...),</span>
<span class="go"> 9: (0.47..., 0.15...)}</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">save_pos</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="s1">&#39;spring&#39;</span><span class="p">)</span>

<span class="go">The following illustrates the format of a position dictionary.</span>

<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">get_pos</span><span class="p">()</span> <span class="c1"># currently random across platforms, see #9593</span>
<span class="go">{0: [1.17..., -0.855...],</span>
<span class="go"> 1: [1.81..., -0.0990...],</span>
<span class="go"> 2: [1.35..., 0.184...],</span>
<span class="go"> 3: [1.51..., 0.644...],</span>
<span class="go"> 4: [2.00..., -0.507...],</span>
<span class="go"> 5: [0.597..., -0.236...],</span>
<span class="go"> 6: [2.04..., 0.687...],</span>
<span class="go"> 7: [1.46..., -0.473...],</span>
<span class="go"> 8: [0.902..., 0.773...],</span>
<span class="go"> 9: [2.48..., -0.119...]}</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">trees</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">heights</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]})</span>
<span class="go">Graphics object consisting of 14 graphics primitives</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">trees</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">heights</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]})</span>
<span class="go">Graphics object consisting of 14 graphics primitives</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">99</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;spam&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">66</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">heights</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]},</span> <span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Graphics object consisting of 20 graphics primitives</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">trees</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">layout</span><span class="o">=</span><span class="s1">&#39;tree&#39;</span><span class="p">)</span>
<span class="go">Graphics object consisting of 14 graphics primitives</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="s1">&#39;JCC???@A??GO??CO??GO??&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">layout</span><span class="o">=</span><span class="s1">&#39;tree&#39;</span><span class="p">,</span> <span class="n">tree_root</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tree_orientation</span><span class="o">=</span><span class="s2">&quot;up&quot;</span><span class="p">)</span>
<span class="go">Graphics object consisting of 22 graphics primitives</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="go">Graphics object consisting of 16 graphics primitives</span>

<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">....: </span>  <span class="n">D</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">))</span>
<span class="gp">....: </span>  <span class="n">D</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">edge_colors</span><span class="o">=</span><span class="n">D</span><span class="o">.</span><span class="n">_color_by_label</span><span class="p">())</span>
<span class="go">Graphics object consisting of 34 graphics primitives</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">color_by_label</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="s1">&#39;red&#39;</span><span class="p">},</span> <span class="n">edge_style</span><span class="o">=</span><span class="s1">&#39;dashed&#39;</span><span class="p">)</span>
<span class="go">Graphics object consisting of 34 graphics primitives</span>

<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({},</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">),</span>
<span class="gp">....: </span>  <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">color_by_label</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">edge_style</span><span class="o">=</span><span class="s1">&#39;dashed&#39;</span><span class="p">)</span>
<span class="go">Graphics object consisting of 22 graphics primitives</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SupersingularModule</span><span class="p">(</span><span class="mi">389</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">hecke_matrix</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">=</span><span class="n">Graph</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;e&#39;</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">,</span><span class="s1">&#39;e&#39;</span><span class="p">],</span><span class="s1">&#39;c&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">],</span><span class="s1">&#39;d&#39;</span><span class="p">:[</span><span class="s1">&#39;e&#39;</span><span class="p">]},</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;c&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;d&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;e&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]})</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.plot3d">
<span class="sig-name descname"><span class="pre">plot3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bgcolor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1,</span> <span class="pre">1,</span> <span class="pre">1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.02</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_size2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0325</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos3d</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_by_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">engine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'threejs'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.plot3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a graph in three dimensions.</p>
<p>See also the <a class="reference internal" href="graph_latex.html#module-sage.graphs.graph_latex" title="sage.graphs.graph_latex"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.graphs.graph_latex</span></code></a> module for ways to use LaTeX
to produce an image of a graph.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">bgcolor</span></code> – rgb tuple (default: <code class="docutils literal notranslate"><span class="pre">(1,1,1)</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertex_size</span></code> – float (default: <code class="docutils literal notranslate"><span class="pre">0.06</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertex_labels</span></code> – a boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to
display vertices using text labels instead of spheres</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertex_colors</span></code> – dictionary (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); optional
dictionary to specify vertex colors: each key is a color recognizable
by <a class="reference external" href="../../../plot3d/sage/plot/plot3d/tachyon.html#module-sage.plot.plot3d.tachyon" title="(in Sage 9.5 Reference Manual: 3D Graphics v9.5)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tachyon</span></code></a> (rgb tuple (default: <code class="docutils literal notranslate"><span class="pre">(1,0,0)</span></code>)),
and each corresponding entry is a list of vertices. If a vertex is not
listed, it looks invisible on the resulting plot (it does not get
drawn).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edge_colors</span></code> – dictionary (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a dictionary
specifying edge colors: each key is a color recognized by
<a class="reference external" href="../../../plot3d/sage/plot/plot3d/tachyon.html#module-sage.plot.plot3d.tachyon" title="(in Sage 9.5 Reference Manual: 3D Graphics v9.5)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tachyon</span></code></a> (default: <code class="docutils literal notranslate"><span class="pre">(0,0,0)</span></code>), and each entry
is a list of edges.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">color_by_label</span></code> – a boolean or dictionary or function (default:
<code class="docutils literal notranslate"><span class="pre">False</span></code>) whether to color each edge with a different color according
to its label; the colors are chosen along a rainbow, unless they are
specified by a function or dictionary mapping labels to colors; this
option is incompatible with <code class="docutils literal notranslate"><span class="pre">edge_color</span></code> and <code class="docutils literal notranslate"><span class="pre">edge_colors</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edge_size</span></code> – float (default: <code class="docutils literal notranslate"><span class="pre">0.02</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edge_size2</span></code> – float (default: <code class="docutils literal notranslate"><span class="pre">0.0325</span></code>); used for
<a class="reference external" href="../../../plot3d/sage/plot/plot3d/tachyon.html#sage.plot.plot3d.tachyon.Tachyon" title="(in Sage 9.5 Reference Manual: 3D Graphics v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tachyon</span></code></a> sleeves</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pos3d</span></code> – a position dictionary for the vertices</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">layout</span></code>, <code class="docutils literal notranslate"><span class="pre">iterations</span></code>, … – layout options; see <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.layout" title="sage.graphs.generic_graph.GenericGraph.layout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">layout()</span></code></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">engine</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">'threejs'</span></code>); the renderer to use among:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'threejs'</span></code>: interactive web-based 3D viewer using JavaScript
and a WebGL renderer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'jmol'</span></code>: interactive 3D viewer using Java</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'tachyon'</span></code>: ray tracer generating a static PNG image</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">xres</span></code> – resolution</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">yres</span></code> – resolution</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">**kwds</span></code> – passed on to the rendering engine</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot3d</span><span class="p">(</span><span class="n">iterations</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">edge_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vertex_size</span><span class="o">=</span><span class="mf">0.04</span><span class="p">)</span> <span class="c1"># long time</span>
<span class="go">Graphics3d Object</span>
</pre></div>
</div>
<p>We plot a fairly complicated Cayley graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A5</span> <span class="o">=</span> <span class="n">AlternatingGroup</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="n">A5</span>
<span class="go">Alternating group of order 5!/2 as a permutation group</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">A5</span><span class="o">.</span><span class="n">cayley_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot3d</span><span class="p">(</span><span class="n">vertex_size</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="n">edge_size</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">vertex_colors</span><span class="o">=</span><span class="p">{(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="p">)},</span> <span class="n">bgcolor</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">color_by_label</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span> <span class="c1"># long time</span>
<span class="go">Graphics3d Object</span>
</pre></div>
</div>
<p>Some <a class="reference external" href="../../../plot3d/sage/plot/plot3d/tachyon.html#sage.plot.plot3d.tachyon.Tachyon" title="(in Sage 9.5 Reference Manual: 3D Graphics v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tachyon</span></code></a> examples:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P3D</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">plot3d</span><span class="p">(</span><span class="n">engine</span><span class="o">=</span><span class="s1">&#39;tachyon&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P3D</span><span class="o">.</span><span class="n">show</span><span class="p">()</span> <span class="c1"># long time</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot3d</span><span class="p">(</span><span class="n">engine</span><span class="o">=</span><span class="s1">&#39;tachyon&#39;</span><span class="p">,</span> <span class="n">vertex_colors</span><span class="o">=</span><span class="p">{(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="p">)})</span><span class="o">.</span><span class="n">show</span><span class="p">()</span> <span class="c1"># long time</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">plot3d</span><span class="p">(</span><span class="n">engine</span><span class="o">=</span><span class="s1">&#39;tachyon&#39;</span><span class="p">,</span> <span class="n">edge_colors</span><span class="o">=</span><span class="p">{(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span> <span class="n">C</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)},</span> <span class="n">vertex_colors</span><span class="o">=</span><span class="p">{(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span> <span class="nb">list</span><span class="p">(</span><span class="n">C</span><span class="p">)},</span> <span class="n">bgcolor</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">show</span><span class="p">()</span> <span class="c1"># long time</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">plot3d</span><span class="p">(</span><span class="n">engine</span><span class="o">=</span><span class="s1">&#39;tachyon&#39;</span><span class="p">,</span> <span class="n">edge_colors</span><span class="o">=</span><span class="p">{(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="kc">None</span><span class="p">)],</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="kc">None</span><span class="p">)],</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="kc">None</span><span class="p">)]})</span><span class="o">.</span><span class="n">show</span><span class="p">()</span> <span class="c1"># long time</span>
</pre></div>
</div>
<p>A directed version of the dodecahedron</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">19</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">19</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">17</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">7</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">14</span><span class="p">],</span> <span class="mi">8</span><span class="p">:</span> <span class="p">[</span><span class="mi">9</span><span class="p">],</span> <span class="mi">9</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">13</span><span class="p">],</span> <span class="mi">10</span><span class="p">:</span> <span class="p">[</span><span class="mi">11</span><span class="p">],</span> <span class="mi">11</span><span class="p">:</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">18</span><span class="p">],</span> <span class="mi">12</span><span class="p">:</span> <span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">13</span><span class="p">],</span> <span class="mi">13</span><span class="p">:</span> <span class="p">[</span><span class="mi">14</span><span class="p">],</span> <span class="mi">14</span><span class="p">:</span> <span class="p">[</span><span class="mi">15</span><span class="p">],</span> <span class="mi">15</span><span class="p">:</span> <span class="p">[</span><span class="mi">16</span><span class="p">],</span> <span class="mi">16</span><span class="p">:</span> <span class="p">[</span><span class="mi">17</span><span class="p">],</span> <span class="mi">17</span><span class="p">:</span> <span class="p">[</span><span class="mi">18</span><span class="p">],</span> <span class="mi">18</span><span class="p">:</span> <span class="p">[</span><span class="mi">19</span><span class="p">],</span> <span class="mi">19</span><span class="p">:</span> <span class="p">[]})</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">plot3d</span><span class="p">()</span><span class="o">.</span><span class="n">show</span><span class="p">()</span> <span class="c1"># long time</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.plot.colors</span> <span class="kn">import</span> <span class="n">rainbow</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">rainbow</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="s1">&#39;rgbtuple&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">edge_colors</span> <span class="o">=</span> <span class="p">{</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">())}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">plot3d</span><span class="p">(</span><span class="n">engine</span><span class="o">=</span><span class="s1">&#39;tachyon&#39;</span><span class="p">,</span> <span class="n">edge_colors</span><span class="o">=</span><span class="n">edge_colors</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span> <span class="c1"># long time</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">=</span><span class="n">Graph</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;e&#39;</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">,</span><span class="s1">&#39;e&#39;</span><span class="p">],</span><span class="s1">&#39;c&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">],</span><span class="s1">&#39;d&#39;</span><span class="p">:[</span><span class="s1">&#39;e&#39;</span><span class="p">]},</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show3d</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">NotImplementedError: 3D plotting of multiple edges or loops not implemented</span>
</pre></div>
</div>
<p>Using the <code class="docutils literal notranslate"><span class="pre">partition</span></code> keyword:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">WheelGraph</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot3d</span><span class="p">(</span><span class="n">partition</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="go">Graphics3d Object</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.plot" title="sage.graphs.generic_graph.GenericGraph.plot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.graphviz_string" title="sage.graphs.generic_graph.GenericGraph.graphviz_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graphviz_string()</span></code></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.random_edge">
<span class="sig-name descname"><span class="pre">random_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.random_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a random edge of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">**kwds</span></code> – arguments to be passed down to the <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.edge_iterator" title="sage.graphs.generic_graph.GenericGraph.edge_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">edge_iterator()</span></code></a>
method</p></li>
</ul>
<p>EXAMPLES:</p>
<p>The returned value is an edge of <code class="docutils literal notranslate"><span class="pre">self</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">random_edge</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>As the <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.edges" title="sage.graphs.generic_graph.GenericGraph.edges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">edges()</span></code></a> method would, this function returns by default a
triple <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></code> of values, in which <code class="docutils literal notranslate"><span class="pre">l</span></code> is the label of edge
<code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v)</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">random_edge</span><span class="p">()</span>  <span class="c1"># random</span>
<span class="go">(3, 4, None)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.random_edge_iterator">
<span class="sig-name descname"><span class="pre">random_edge_iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.random_edge_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over random edges of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The returned iterator enables to amortize the cost of accessing random
edges, as can be done with multiple calls to method <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.random_edge" title="sage.graphs.generic_graph.GenericGraph.random_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">random_edge()</span></code></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">*args</span></code> and <code class="docutils literal notranslate"><span class="pre">**kwds</span></code> – arguments to be passed down to the
<a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.edge_iterator" title="sage.graphs.generic_graph.GenericGraph.edge_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">edge_iterator()</span></code></a> method.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>The returned value is an iterator over the edges of <code class="docutils literal notranslate"><span class="pre">self</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">random_edge_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="go">[True, True, True, True, True]</span>
</pre></div>
</div>
<p>As the <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.edges" title="sage.graphs.generic_graph.GenericGraph.edges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">edges()</span></code></a> method would, this function returns by default a
triple <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></code> of values, in which <code class="docutils literal notranslate"><span class="pre">l</span></code> is the label of edge
<code class="docutils literal notranslate"><span class="pre">(u,v)</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">random_edge_iterator</span><span class="p">()))</span> <span class="c1"># random</span>
<span class="go">(0, 5, None)</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">random_edge_iterator</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)))</span> <span class="c1"># random</span>
<span class="go">(5, 7)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.random_subgraph">
<span class="sig-name descname"><span class="pre">random_subgraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.random_subgraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a random subgraph containing each vertex with probability <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">p</span></code> – the probability of choosing a vertex</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inplace</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); using <code class="docutils literal notranslate"><span class="pre">inplace=True</span></code>
will simply delete the extra vertices and edges from the current
graph. This will modify the graph.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">random_subgraph</span><span class="p">(</span><span class="mf">.25</span><span class="p">)</span>
<span class="go">Subgraph of (Petersen graph): Graph on ... vert...</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.random_vertex">
<span class="sig-name descname"><span class="pre">random_vertex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.random_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a random vertex of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">**kwds</span></code> – arguments to be passed down to the
<a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.vertex_iterator" title="sage.graphs.generic_graph.GenericGraph.vertex_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertex_iterator()</span></code></a> method</p></li>
</ul>
<p>EXAMPLES:</p>
<p>The returned value is a vertex of self:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">random_vertex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="ow">in</span> <span class="n">g</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.random_vertex_iterator">
<span class="sig-name descname"><span class="pre">random_vertex_iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.random_vertex_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over random vertices of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The returned iterator enables to amortize the cost of accessing random
vertices, as can be done with multiple calls to method
<a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.random_vertex" title="sage.graphs.generic_graph.GenericGraph.random_vertex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">random_vertex()</span></code></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">*args</span></code> and <code class="docutils literal notranslate"><span class="pre">**kwds</span></code> – arguments to be passed down to the
<a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.vertex_iterator" title="sage.graphs.generic_graph.GenericGraph.vertex_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertex_iterator()</span></code></a> method</p></li>
</ul>
<p>EXAMPLES:</p>
<p>The returned value is an iterator over the vertices of <code class="docutils literal notranslate"><span class="pre">self</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">random_vertex_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="ow">in</span> <span class="n">g</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="go">[True, True, True, True, True]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.relabel">
<span class="sig-name descname"><span class="pre">relabel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">perm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">complete_partial_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">immutable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.relabel" title="Permalink to this definition">¶</a></dt>
<dd><p>Relabels the vertices of <code class="docutils literal notranslate"><span class="pre">self</span></code></p>
<p>INPUT:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">perm</span></code> – a function, dictionary, iterable, permutation, or
<code class="docutils literal notranslate"><span class="pre">None</span></code> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inplace</span></code> – a boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">return_map</span></code> – a boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_input</span></code> (boolean) – whether to test input for
correctness. <em>This can potentially be very time-consuming !</em>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">complete_partial_function</span></code> (boolean) – whether to automatically
complete the permutation if some elements of the graph are not
associated with any new name. In this case, those elements are not
relabeled <em>This can potentially be very time-consuming !</em>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">immutable</span></code> (boolean) – with <code class="docutils literal notranslate"><span class="pre">inplace=False</span></code>, whether to create
a mutable/immutable relabelled copy. <code class="docutils literal notranslate"><span class="pre">immutable=None</span></code> (default)
means that the graph and its copy will behave the same way.</p></li>
</ul>
</div></blockquote>
<p>If <code class="docutils literal notranslate"><span class="pre">perm</span></code> is a function <code class="docutils literal notranslate"><span class="pre">f</span></code>, then each vertex <code class="docutils literal notranslate"><span class="pre">v</span></code> is
relabeled to <code class="docutils literal notranslate"><span class="pre">f(v)</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">perm</span></code> is a dictionary <code class="docutils literal notranslate"><span class="pre">d</span></code>, then each vertex <code class="docutils literal notranslate"><span class="pre">v</span></code> (which should
be a key of <code class="docutils literal notranslate"><span class="pre">d</span></code>) is relabeled to <code class="docutils literal notranslate"><span class="pre">d[v]</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">perm</span></code> is a list (or more generally, any iterable) of
length <code class="docutils literal notranslate"><span class="pre">n</span></code>, then the first vertex returned by <code class="docutils literal notranslate"><span class="pre">G.vertices()</span></code>
is relabeled to <code class="docutils literal notranslate"><span class="pre">l[0]</span></code>, the second to <code class="docutils literal notranslate"><span class="pre">l[1]</span></code>, …</p>
<p>If <code class="docutils literal notranslate"><span class="pre">perm</span></code> is a permutation, then each vertex <code class="docutils literal notranslate"><span class="pre">v</span></code> is
relabeled to <code class="docutils literal notranslate"><span class="pre">perm(v)</span></code>. Caveat: this assumes that the
vertices are labelled <span class="math notranslate nohighlight">\(\{0,1,...,n-1\}\)</span>; since permutations
act by default on the set <span class="math notranslate nohighlight">\(\{1,2,...,n\}\)</span>, this is achieved by
identifying <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(0\)</span>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">perm</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, the graph is relabeled to be on the
vertices <span class="math notranslate nohighlight">\(\{0,1,...,n-1\}\)</span>. This is <em>not</em> any kind of canonical
labeling, but it is consistent (relabeling twice will give the
same result).</p>
<p>If <code class="docutils literal notranslate"><span class="pre">inplace</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, the graph is modified in place and
<code class="docutils literal notranslate"><span class="pre">None</span></code> is returned. Otherwise a relabeled copy of the graph
is returned.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">return_map</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> a dictionary representing the
relabelling map is returned (incompatible with <code class="docutils literal notranslate"><span class="pre">inplace==False</span></code>).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">am</span><span class="p">()</span>
<span class="go">[0 1 0]</span>
<span class="go">[1 0 1]</span>
<span class="go">[0 1 0]</span>
</pre></div>
</div>
<p>Relabeling using a dictionary. Note that the dictionary does not define
the new label of vertex <span class="math notranslate nohighlight">\(0\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">relabel</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">1</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">am</span><span class="p">()</span>
<span class="go">[0 0 1]</span>
<span class="go">[0 0 1]</span>
<span class="go">[1 1 0]</span>
</pre></div>
</div>
<p>This is because the method automatically “extends” the relabeling to the
missing vertices (whose label will not change). Checking that all
vertices have an image can require some time, and this feature can be
disabled (at your own risk):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">relabel</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">1</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">complete_partial_function</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">am</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">KeyError: 0</span>
</pre></div>
</div>
<p>Relabeling using a list:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">relabel</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">am</span><span class="p">()</span>
<span class="go">[0 0 1]</span>
<span class="go">[0 0 1]</span>
<span class="go">[1 1 0]</span>
</pre></div>
</div>
<p>Relabeling using an iterable:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="nb">iter</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">am</span><span class="p">()</span>
<span class="go">[0 0 1]</span>
<span class="go">[0 0 1]</span>
<span class="go">[1 1 0]</span>
</pre></div>
</div>
<p>Relabeling using a Sage permutation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.groups.perm_gps.permgroup_named</span> <span class="kn">import</span> <span class="n">SymmetricGroup</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SymmetricGroup</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">gamma</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="s1">&#39;(1,2)&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">am</span><span class="p">()</span>
<span class="go">[0 0 1]</span>
<span class="go">[0 0 1]</span>
<span class="go">[1 1 0]</span>
</pre></div>
</div>
<p>A way to get a random relabeling:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">set_random_seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># Results are reproducible</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">Permutations</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span><span class="o">.</span><span class="n">random_element</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">sources</span><span class="p">()</span>
<span class="go">[1, 4]</span>
</pre></div>
</div>
<p>Relabeling using an injective function:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None), (1, 2, None)]</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span><span class="o">+</span><span class="mi">10</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[10, 11, 12]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(10, 11, None), (11, 12, None)]</span>
</pre></div>
</div>
<p>Relabeling using a non injective function has no meaning:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None), (1, 2, None)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">NotImplementedError: Non injective relabeling</span>
</pre></div>
</div>
<p>But this test can be disabled, which can lead to … problems:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None), (1, 2, None)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">check_input</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>Recovering the relabeling with <code class="docutils literal notranslate"><span class="pre">return_map</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">return_map</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{&#39;000&#39;: 0,</span>
<span class="go"> &#39;001&#39;: 1,</span>
<span class="go"> &#39;010&#39;: 2,</span>
<span class="go"> &#39;011&#39;: 3,</span>
<span class="go"> &#39;100&#39;: 4,</span>
<span class="go"> &#39;101&#39;: 5,</span>
<span class="go"> &#39;110&#39;: 6,</span>
<span class="go"> &#39;111&#39;: 7}</span>
</pre></div>
</div>
<p>When no permutation is given, the relabeling is done to integers
from 0 to N-1 but in an arbitrary order:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;010&#39;, &#39;011&#39;, &#39;100&#39;, &#39;101&#39;, &#39;110&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">relabel</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7]</span>
</pre></div>
</div>
<p>In the above case, the mapping is arbitrary but consistent:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">map1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_map</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">map2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_map</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">map1</span> <span class="o">==</span> <span class="n">map2</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span><span class="o">+</span><span class="mi">10</span><span class="p">,</span> <span class="n">return_map</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{0: 10, 1: 11, 2: 12}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.remove_loops">
<span class="sig-name descname"><span class="pre">remove_loops</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.remove_loops" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove loops on vertices in <code class="docutils literal notranslate"><span class="pre">vertices</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">vertices</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, removes all loops.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(0, 0), (1, 1), (2, 2), (2, 3), (3, 3)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">remove_loops</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(2, 3)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allows_loops</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(0, 0), (1, 1), (2, 2), (2, 3), (3, 3)]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">remove_loops</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(2, 3)]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">allows_loops</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">has_loops</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.remove_multiple_edges">
<span class="sig-name descname"><span class="pre">remove_multiple_edges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.remove_multiple_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all multiple edges, retaining one edge for each.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See also <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.allow_multiple_edges" title="sage.graphs.generic_graph.GenericGraph.allow_multiple_edges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">allow_multiple_edges()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(0, 1), (0, 1), (0, 1), (0, 1), (1, 2)]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">remove_multiple_edges</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(0, 1), (1, 2)]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(0, 1), (0, 1), (0, 1), (0, 1), (1, 2)]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">remove_multiple_edges</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(0, 1), (1, 2)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.set_edge_label">
<span class="sig-name descname"><span class="pre">set_edge_label</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.set_edge_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the edge label of a given edge.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There can be only one edge from u to v for this to make
sense. Otherwise, an error is raised.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">u,</span> <span class="pre">v</span></code> – the vertices (and direction if digraph) of the edge</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">l</span></code> – the new label</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SD</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">18</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">6</span><span class="p">:[</span><span class="mi">13</span><span class="p">,</span><span class="mi">12</span><span class="p">],</span> <span class="mi">7</span><span class="p">:[</span><span class="mi">18</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="mi">8</span><span class="p">:[</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="mi">9</span><span class="p">:[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">10</span><span class="p">:[</span><span class="mi">11</span><span class="p">,</span><span class="mi">13</span><span class="p">],</span> <span class="mi">11</span><span class="p">:[</span><span class="mi">12</span><span class="p">],</span> <span class="mi">12</span><span class="p">:[</span><span class="mi">13</span><span class="p">],</span> <span class="mi">13</span><span class="p">:[</span><span class="mi">17</span><span class="p">,</span><span class="mi">14</span><span class="p">],</span> <span class="mi">14</span><span class="p">:[</span><span class="mi">16</span><span class="p">,</span><span class="mi">15</span><span class="p">],</span> <span class="mi">15</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">16</span><span class="p">:[</span><span class="mi">13</span><span class="p">],</span> <span class="mi">17</span><span class="p">:[</span><span class="mi">15</span><span class="p">,</span><span class="mi">13</span><span class="p">],</span> <span class="mi">18</span><span class="p">:[</span><span class="mi">13</span><span class="p">]},</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">SD</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="s1">&#39;discrete&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">SD</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;discrete&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">SD</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;h = 0&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">SD</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="s1">&#39;h = 0&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">SD</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;aut&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">SD</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;aut&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">SD</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">SD</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;no label&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">SD</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="s1">&#39;k &gt; h&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">SD</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="s1">&#39;k = h&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">SD</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="mi">17</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="s1">&#39;v_k finite&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">SD</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="s1">&#39;v_k m.c.r.&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">posn</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:[</span> <span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span>  <span class="mi">2</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>  <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">13</span><span class="p">],</span>  <span class="mi">4</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span>  <span class="mi">5</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>  <span class="mi">6</span><span class="p">:[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">13</span><span class="p">],</span> <span class="mi">7</span><span class="p">:[</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>  <span class="mi">8</span><span class="p">:[</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span>  <span class="mi">9</span><span class="p">:[</span><span class="mi">6</span><span class="p">,</span><span class="mi">11</span><span class="p">],</span> <span class="mi">10</span><span class="p">:[</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">11</span><span class="p">:[</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="mi">12</span><span class="p">:[</span><span class="mi">13</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="mi">13</span><span class="p">:[</span><span class="mi">16</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">14</span><span class="p">:[</span><span class="mi">10</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">],</span> <span class="mi">15</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">],</span> <span class="mi">16</span><span class="p">:[</span><span class="mi">14</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">],</span> <span class="mi">17</span><span class="p">:[</span><span class="mi">16</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">],</span> <span class="mi">18</span><span class="p">:[</span><span class="mi">6</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">]}</span>
<span class="gp">sage: </span><span class="n">SD</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="n">posn</span><span class="p">,</span> <span class="n">vertex_size</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span> <span class="n">vertex_colors</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;#FFFFFF&#39;</span><span class="p">:</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">19</span><span class="p">))},</span> <span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span> <span class="c1"># long time</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">HeawoodGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">l</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="gp">....: </span> <span class="n">G</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;,&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">    [(0, 1, &#39;(0,1)&#39;),</span>
<span class="go">     (0, 5, &#39;(0,5)&#39;),</span>
<span class="go">     (0, 13, &#39;(0,13)&#39;),</span>
<span class="go">     ...</span>
<span class="go">     (11, 12, &#39;(11,12)&#39;),</span>
<span class="go">     (12, 13, &#39;(12,13)&#39;)]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]},</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;test&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 0, &#39;test&#39;), (0, 1, None), (0, 1, None), (0, 2, None)]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;test2&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;test3&#39;</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">RuntimeError: cannot set edge label, since there are multiple edges from 0 to 0</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">dg</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]},</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">dg</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">dg</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">dg</span><span class="o">.</span><span class="n">outgoing_edges</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[(1, 0, 9)]</span>
<span class="gp">sage: </span><span class="n">dg</span><span class="o">.</span><span class="n">incoming_edges</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[(0, 1, 5)]</span>
<span class="gp">sage: </span><span class="n">dg</span><span class="o">.</span><span class="n">outgoing_edges</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[(0, 1, 5)]</span>
<span class="gp">sage: </span><span class="n">dg</span><span class="o">.</span><span class="n">incoming_edges</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[(1, 0, 9)]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">}},</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.set_embedding">
<span class="sig-name descname"><span class="pre">set_embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">embedding</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.set_embedding" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a combinatorial embedding dictionary to <code class="docutils literal notranslate"><span class="pre">_embedding</span></code> attribute.</p>
<p>The dictionary <code class="docutils literal notranslate"><span class="pre">embedding</span></code> represents a combinatorial embedding of
<code class="docutils literal notranslate"><span class="pre">self</span></code> and is organized as a mapping from vertex labels to list of
vertex neighbors in clockwise order.</p>
<p>Parameter <code class="docutils literal notranslate"><span class="pre">embedding</span></code> is error-checked for validity.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Combinatorial embeddings are defined for simple graphs only (i.e.,
without loops or multiple edges). Therefore, an error is raised when
this method is used for a graph with loops or multiple edges.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">embedding</span></code> – dictionary representing a combinatorial embedding of
<code class="docutils literal notranslate"><span class="pre">self</span></code>. Format: “{v1: [v2,v3], v2: [v1], v3: [v1]}” (clockwise
ordering of neighbors at each vertex).</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">set_embedding</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="mi">7</span><span class="p">:</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">8</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">9</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">set_embedding</span><span class="p">({</span><span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="mi">7</span><span class="p">:</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">8</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">9</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: vertices in [&#39;s&#39;] from the embedding do not belong to the graph</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.set_latex_options">
<span class="sig-name descname"><span class="pre">set_latex_options</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.set_latex_options" title="Permalink to this definition">¶</a></dt>
<dd><p>Set multiple options for rendering a graph with LaTeX.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">kwds</span></code> – any number of option/value pairs to set many graph latex
options at once (a variable number, in any order). Existing values are
overwritten, new values are added.  Existing values can be cleared by
setting the value to <code class="docutils literal notranslate"><span class="pre">None</span></code>.  Possible options are documented at
<a class="reference internal" href="graph_latex.html#sage.graphs.graph_latex.GraphLatex.set_option" title="sage.graphs.graph_latex.GraphLatex.set_option"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.graphs.graph_latex.GraphLatex.set_option()</span></code></a>.</p></li>
</ul>
<p>This method is a convenience for setting the options of a graph directly
on an instance of the graph.  For a full explanation of how to use LaTeX
to render graphs, see the introduction to the
<a class="reference internal" href="graph_latex.html#module-sage.graphs.graph_latex" title="sage.graphs.graph_latex"><code class="xref py py-mod docutils literal notranslate"><span class="pre">graph_latex</span></code></a> module.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">set_latex_options</span><span class="p">(</span><span class="n">tkz_style</span><span class="o">=</span><span class="s1">&#39;Welsh&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">opts</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">latex_options</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">opts</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s1">&#39;tkz_style&#39;</span><span class="p">)</span>
<span class="go">&#39;Welsh&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.set_pos">
<span class="sig-name descname"><span class="pre">set_pos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.set_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the position dictionary.</p>
<p>The position dictionary specifies the coordinates of each vertex.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pos</span></code> – a position dictionary for the vertices of the (di)graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dim</span></code> – integer (default: 2); the number of coordinates per vertex</p></li>
</ul>
<p>EXAMPLES:</p>
<p>Note that <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.set_pos" title="sage.graphs.generic_graph.GenericGraph.set_pos"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_pos()</span></code></a> will allow you to do ridiculous
things, which will not blow up until plotting:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">get_pos</span><span class="p">()</span>
<span class="go">{0: (..., ...),</span>
<span class="go"> ...</span>
<span class="go"> 9: (..., ...)}</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">set_pos</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: string indices must be integers...</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.set_vertex">
<span class="sig-name descname"><span class="pre">set_vertex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.set_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Associate an arbitrary object with a vertex.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertex</span></code> – which vertex</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">object</span></code> – object to associate to vertex</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">TetrahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">set_vertex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">graphs</span><span class="o">.</span><span class="n">FlowerSnark</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">get_vertex</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Flower Snark: Graph on 20 vertices</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">set_vertex</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: vertex (4) not in the graph</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.set_vertices">
<span class="sig-name descname"><span class="pre">set_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertex_dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.set_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Associate arbitrary objects with each vertex, via an association
dictionary.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertex_dict</span></code> – the association dictionary</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">(),</span> <span class="mi">1</span><span class="p">:</span> <span class="n">graphs</span><span class="o">.</span><span class="n">FlowerSnark</span><span class="p">(),</span> <span class="mi">2</span><span class="p">:</span> <span class="n">graphs</span><span class="o">.</span><span class="n">MoebiusKantorGraph</span><span class="p">(),</span> <span class="mi">3</span><span class="p">:</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()}</span>
<span class="gp">sage: </span><span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">Moebius-Kantor Graph: Graph on 16 vertices</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">TetrahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">set_vertices</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">get_vertex</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Flower Snark: Graph on 20 vertices</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.shortest_path">
<span class="sig-name descname"><span class="pre">shortest_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">by_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.shortest_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of vertices representing some shortest path from <code class="docutils literal notranslate"><span class="pre">u</span></code> to
<code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<p>If there is no path from <span class="math notranslate nohighlight">\(u\)</span> to <span class="math notranslate nohighlight">\(v\)</span>, the returned list is empty.</p>
<p>For more information and more examples, see
<a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.shortest_paths" title="sage.graphs.generic_graph.GenericGraph.shortest_paths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shortest_paths()</span></code></a> (the inputs are very similar).</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">u</span></code>, <code class="docutils literal notranslate"><span class="pre">v</span></code> – the start and the end vertices of the paths</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">by_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, the edges
in the graph are weighted, otherwise all edges have weight 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); one of the following
algorithms:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'BFS'</span></code>: performs a BFS from <code class="docutils literal notranslate"><span class="pre">u</span></code>. Does not work with edge
weights.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'BFS_Bid'</span></code>: performs a BFS from <code class="docutils literal notranslate"><span class="pre">u</span></code> and from <code class="docutils literal notranslate"><span class="pre">v</span></code>. Does not
work with edge weights.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Dijkstra_NetworkX'</span></code>: the Dijkstra algorithm, implemented in
NetworkX. Works only with positive weights.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Dijkstra_Bid_NetworkX'</span></code>: performs a Dijkstra visit from <code class="docutils literal notranslate"><span class="pre">u</span></code>
and from <code class="docutils literal notranslate"><span class="pre">v</span></code> (NetworkX implementation). Works only with positive
weights.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Dijkstra_Bid'</span></code>: a Cython implementation that performs
a Dijkstra visit from <code class="docutils literal notranslate"><span class="pre">u</span></code> and from <code class="docutils literal notranslate"><span class="pre">v</span></code>. Works only with positive
weights.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Bellman-Ford_Boost'</span></code>: the Bellman-Ford algorithm, implemented in
Boost. Works also with negative weights, if there is no negative
cycle.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> (default): Sage chooses the best algorithm: <code class="docutils literal notranslate"><span class="pre">'BFS_Bid'</span></code>
if <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, <code class="docutils literal notranslate"><span class="pre">'Dijkstra_Bid'</span></code> otherwise.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If there are negative weights and algorithm is <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
result is not reliable. This occurs because, for performance
reasons, we cannot check whether there are edges with negative
weights before running the algorithm. If there are, the user
should explicitly input <code class="docutils literal notranslate"><span class="pre">algorithm='Bellman-Ford_Boost'</span></code>.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
takes as input an edge <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></code> and outputs its weight. If not
<code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is automatically set to <code class="docutils literal notranslate"><span class="pre">True</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>
and <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, we use the edge label <code class="docutils literal notranslate"><span class="pre">l</span></code>, if <code class="docutils literal notranslate"><span class="pre">l</span></code>
is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, else <code class="docutils literal notranslate"><span class="pre">1</span></code> as a weight.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, we check
that the weight_function outputs a number for each edge</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="go">[4, 17, 16, 12, 13, 9]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;BFS&#39;</span><span class="p">)</span>
<span class="go">[4, 3, 2, 1, 8, 9]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Dijkstra_NetworkX&#39;</span><span class="p">)</span>
<span class="go">[4, 3, 2, 1, 8]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Dijkstra_Bid_NetworkX&#39;</span><span class="p">)</span>
<span class="go">[4, 3, 2, 1, 8]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Dijkstra_Bid&#39;</span><span class="p">)</span>
<span class="go">[4, 3, 19, 0, 10, 9]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">[5]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">delete_edges</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">edges_incident</span><span class="p">(</span><span class="mi">13</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">3</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="mi">4</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="mi">4</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">2</span><span class="p">}},</span> <span class="n">sparse</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span> <span class="c1"># long time</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[0, 4, 3]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Dijkstra_NetworkX&#39;</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Dijkstra_Bid_NetworkX&#39;</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.shortest_path_all_pairs">
<span class="sig-name descname"><span class="pre">shortest_path_all_pairs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">by_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.shortest_path_all_pairs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a shortest path between each pair of vertices.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">by_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, the edges
in the graph are weighted, otherwise all edges have weight 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); one of the following
algorithms:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'BFS'</span></code>: the computation is done through a BFS centered on each
vertex successively. Works only if <code class="docutils literal notranslate"><span class="pre">by_weight==False</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Floyd-Warshall-Cython'</span></code>: the Cython implementation of the
Floyd-Warshall algorithm. Works only if <code class="docutils literal notranslate"><span class="pre">by_weight==False</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Floyd-Warshall-Python'</span></code>: the Python implementation of the
Floyd-Warshall algorithm. Works also with weighted graphs, even with
negative weights (but no negative cycle is allowed).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Floyd-Warshall_Boost'</span></code>: the Boost implementation of the
Floyd-Warshall algorithm. Works also with weighted graphs, even with
negative weights (but no negative cycle is allowed).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Floyd-Warshall_SciPy'</span></code>: the SciPy implementation of the
Floyd-Warshall algorithm. Works also with weighted graphs, even with
negative weights (but no negative cycle is allowed).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Dijkstra_NetworkX'</span></code>: the Dijkstra algorithm, implemented in
NetworkX. It works with weighted graphs, but no negative weight is
allowed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Dijkstra_Boost'</span></code>: the Dijkstra algorithm, implemented in Boost
(works only with positive weights).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Johnson_Boost'</span></code>: the Johnson algorithm, implemented in Boost
(works also with negative weights, if there is no negative cycle).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> (default): Sage chooses the best algorithm: <code class="docutils literal notranslate"><span class="pre">'BFS'</span></code> if
<code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, <code class="docutils literal notranslate"><span class="pre">'Dijkstra_Boost'</span></code> if all weights are
positive, <code class="docutils literal notranslate"><span class="pre">'Floyd-Warshall_Boost'</span></code> otherwise.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
takes as input an edge <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></code> and outputs its weight. If not
<code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is automatically set to <code class="docutils literal notranslate"><span class="pre">True</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>
and <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, we use the edge label <code class="docutils literal notranslate"><span class="pre">l</span></code>, if <code class="docutils literal notranslate"><span class="pre">l</span></code>
is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, else <code class="docutils literal notranslate"><span class="pre">1</span></code> as a weight.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, we check
that the weight_function outputs a number for each edge</p></li>
</ul>
<p>OUTPUT:</p>
<p>A tuple <code class="docutils literal notranslate"><span class="pre">(dist,</span> <span class="pre">pred)</span></code>. They are both dicts of dicts. The first
indicates the length <code class="docutils literal notranslate"><span class="pre">dist[u][v]</span></code> of the shortest weighted path from
<span class="math notranslate nohighlight">\(u\)</span> to <span class="math notranslate nohighlight">\(v\)</span>. The second is a compact representation of all the paths - it
indicates the predecessor <code class="docutils literal notranslate"><span class="pre">pred[u][v]</span></code> of <span class="math notranslate nohighlight">\(v\)</span> in the shortest path
from <span class="math notranslate nohighlight">\(u\)</span> to <span class="math notranslate nohighlight">\(v\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only reachable vertices are present in the dictionaries.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is a Cython version of this method that is usually much faster
for large graphs, as most of the time is actually spent building the
final double dictionary. Everything on the subject is to be found in
the <a class="reference internal" href="distances_all_pairs.html#module-sage.graphs.distances_all_pairs" title="sage.graphs.distances_all_pairs"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distances_all_pairs</span></code></a> module.</p>
</div>
<p>EXAMPLES:</p>
<p>Some standard examples (see <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.shortest_paths" title="sage.graphs.generic_graph.GenericGraph.shortest_paths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shortest_paths()</span></code></a> for
more examples on how to use the input variables):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span> <span class="p">{</span> <span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">3</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="mi">4</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="mi">4</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span> <span class="p">},</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span> <span class="c1"># long time</span>
<span class="gp">sage: </span><span class="n">dist</span><span class="p">,</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">by_weight</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">dist</span>
<span class="go">{0: {0: 0, 1: 1, 2: 2, 3: 3, 4: 2}, 1: {0: 1, 1: 0, 2: 1, 3: 2, 4: 3}, 2: {0: 2, 1: 1, 2: 0, 3: 1, 4: 3}, 3: {0: 3, 1: 2, 2: 1, 3: 0, 4: 2}, 4: {0: 2, 1: 3, 2: 3, 3: 2, 4: 0}}</span>
<span class="gp">sage: </span><span class="n">pred</span>
<span class="go">{0: {0: None, 1: 0, 2: 1, 3: 2, 4: 0}, 1: {0: 1, 1: None, 2: 1, 3: 2, 4: 0}, 2: {0: 1, 1: 2, 2: None, 3: 2, 4: 3}, 3: {0: 1, 1: 2, 2: 3, 3: None, 4: 3}, 4: {0: 4, 1: 0, 2: 3, 3: 4, 4: None}}</span>
<span class="gp">sage: </span><span class="n">pred</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">{0: None, 1: 0, 2: 1, 3: 2, 4: 0}</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span> <span class="p">{</span> <span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}},</span> <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}},</span> <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="mi">4</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">}},</span> <span class="mi">4</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">}}</span> <span class="p">},</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">dist</span><span class="p">,</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">weight_function</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">e</span><span class="p">:</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">dist</span>
<span class="go">{0: {0: 0, 1: 1, 2: 2, 3: 3, 4: 2}, 1: {0: 1, 1: 0, 2: 1, 3: 2, 4: 3}, 2: {0: 2, 1: 1, 2: 0, 3: 1, 4: 3}, 3: {0: 3, 1: 2, 2: 1, 3: 0, 4: 2}, 4: {0: 2, 1: 3, 2: 3, 3: 2, 4: 0}}</span>
<span class="gp">sage: </span><span class="n">pred</span>
<span class="go">{0: {0: None, 1: 0, 2: 1, 3: 2, 4: 0}, 1: {0: 1, 1: None, 2: 1, 3: 2, 4: 0}, 2: {0: 1, 1: 2, 2: None, 3: 2, 4: 3}, 3: {0: 1, 1: 2, 2: 3, 3: None, 4: 3}, 4: {0: 4, 1: 0, 2: 3, 3: 4, 4: None}}</span>
</pre></div>
</div>
<p>So for example the shortest weighted path from <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(3\)</span> is obtained as
follows. The predecessor of <span class="math notranslate nohighlight">\(3\)</span> is <code class="docutils literal notranslate"><span class="pre">pred[0][3]</span> <span class="pre">==</span> <span class="pre">2</span></code>, the predecessor
of <span class="math notranslate nohighlight">\(2\)</span> is <code class="docutils literal notranslate"><span class="pre">pred[0][2]</span> <span class="pre">==</span> <span class="pre">1</span></code>, and the predecessor of <span class="math notranslate nohighlight">\(1\)</span> is
<code class="docutils literal notranslate"><span class="pre">pred[0][1]</span> <span class="pre">==</span> <span class="pre">0</span></code>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span> <span class="p">{</span> <span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="kc">None</span><span class="p">},</span> <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span><span class="kc">None</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">3</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="mi">4</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="mi">4</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span> <span class="p">},</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">()</span>
<span class="go">({0: {0: 0, 1: 1, 2: 2, 3: 2, 4: 1},</span>
<span class="go">1: {0: 1, 1: 0, 2: 1, 3: 2, 4: 2},</span>
<span class="go">2: {0: 2, 1: 1, 2: 0, 3: 1, 4: 2},</span>
<span class="go">3: {0: 2, 1: 2, 2: 1, 3: 0, 4: 1},</span>
<span class="go">4: {0: 1, 1: 2, 2: 2, 3: 1, 4: 0}},</span>
<span class="go">{0: {0: None, 1: 0, 2: 1, 3: 4, 4: 0},</span>
<span class="go">1: {0: 1, 1: None, 2: 1, 3: 2, 4: 0},</span>
<span class="go">2: {0: 1, 1: 2, 2: None, 3: 2, 4: 3},</span>
<span class="go">3: {0: 4, 1: 2, 2: 3, 3: None, 4: 3},</span>
<span class="go">4: {0: 4, 1: 0, 2: 3, 3: 4, 4: None}})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">weight_function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:(</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">({0: {0: 0, 1: 1, 2: 2, 3: 3, 4: 2},</span>
<span class="go">1: {0: 1, 1: 0, 2: 1, 3: 2, 4: 3},</span>
<span class="go">2: {0: 2, 1: 1, 2: 0, 3: 1, 4: 3},</span>
<span class="go">3: {0: 3, 1: 2, 2: 1, 3: 0, 4: 2},</span>
<span class="go">4: {0: 2, 1: 3, 2: 3, 3: 2, 4: 0}},</span>
<span class="go">{0: {0: None, 1: 0, 2: 1, 3: 2, 4: 0},</span>
<span class="go">1: {0: 1, 1: None, 2: 1, 3: 2, 4: 0},</span>
<span class="go">2: {0: 1, 1: 2, 2: None, 3: 2, 4: 3},</span>
<span class="go">3: {0: 1, 1: 2, 2: 3, 3: None, 4: 3},</span>
<span class="go">4: {0: 4, 1: 0, 2: 3, 3: 4, 4: None}})</span>
</pre></div>
</div>
<p>Checking that distances are equal regardless of the algorithm used:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;BFS&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Floyd-Warshall-Cython&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d3</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Floyd-Warshall-Python&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d4</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Dijkstra_NetworkX&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d5</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Dijkstra_Boost&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d6</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Johnson_Boost&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d7</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Floyd-Warshall_Boost&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d8</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Floyd-Warshall_SciPy&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d1</span> <span class="o">==</span> <span class="n">d2</span> <span class="o">==</span> <span class="n">d3</span> <span class="o">==</span> <span class="n">d4</span> <span class="o">==</span> <span class="n">d5</span> <span class="o">==</span> <span class="n">d6</span> <span class="o">==</span> <span class="n">d7</span> <span class="o">==</span> <span class="n">d8</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Checking that distances are equal regardless of the algorithm used:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">RandomDirectedGNM</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;BFS&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Floyd-Warshall-Cython&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d3</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Floyd-Warshall-Python&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d4</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Dijkstra_NetworkX&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d5</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Dijkstra_Boost&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d6</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Johnson_Boost&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d7</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Floyd-Warshall_Boost&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d8</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Floyd-Warshall_SciPy&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d1</span> <span class="o">==</span> <span class="n">d2</span> <span class="o">==</span> <span class="n">d3</span> <span class="o">==</span> <span class="n">d4</span> <span class="o">==</span> <span class="n">d5</span> <span class="o">==</span> <span class="n">d6</span> <span class="o">==</span> <span class="n">d7</span> <span class="o">==</span> <span class="n">d8</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Checking that weighted distances are equal regardless of the algorithm
used:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">random</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">d1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Floyd-Warshall-Python&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Dijkstra_NetworkX&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d3</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Dijkstra_Boost&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d4</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Johnson_Boost&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d5</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Floyd-Warshall_Boost&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d6</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Floyd-Warshall_SciPy&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d1</span> <span class="o">==</span> <span class="n">d2</span> <span class="o">==</span> <span class="n">d3</span> <span class="o">==</span> <span class="n">d4</span> <span class="o">==</span> <span class="n">d5</span> <span class="o">==</span> <span class="n">d6</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Checking a random path is valid:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">dist</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;BFS&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">random_vertex</span><span class="p">(),</span> <span class="n">g</span><span class="o">.</span><span class="n">random_vertex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span>
<span class="gp">sage: </span><span class="k">while</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">....: </span>  <span class="n">p</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">path</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Negative weights:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: the graph contains a negative cycle</span>
</pre></div>
</div>
<p>Unreachable vertices are not present in the dictionaries:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;BFS&#39;</span><span class="p">)</span>
<span class="go">({0: {0: 0, 1: 1, 2: 2}, 1: {1: 0, 2: 1}, 2: {2: 0}},</span>
<span class="go"> {0: {0: None, 1: 0, 2: 1}, 1: {1: None, 2: 1}, 2: {2: None}})</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Dijkstra_NetworkX&#39;</span><span class="p">)</span>
<span class="go">({0: {0: 0, 1: 1, 2: 2}, 1: {1: 0, 2: 1}, 2: {2: 0}},</span>
<span class="go"> {0: {0: None, 1: 1, 2: 1}, 1: {1: None, 2: 2}, 2: {2: None}})</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Dijkstra_Boost&#39;</span><span class="p">)</span>
<span class="go">({0: {0: 0, 1: 1, 2: 2}, 1: {1: 0, 2: 1}, 2: {2: 0}},</span>
<span class="go"> {0: {0: None, 1: 0, 2: 1}, 1: {1: None, 2: 1}, 2: {2: None}})</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Floyd-Warshall-Python&#39;</span><span class="p">)</span>
<span class="go">({0: {0: 0, 1: 1, 2: 2}, 1: {1: 0, 2: 1}, 2: {2: 0}},</span>
<span class="go"> {0: {0: None, 1: 0, 2: 1}, 1: {1: None, 2: 1}, 2: {2: None}})</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Floyd-Warshall-Cython&#39;</span><span class="p">)</span>
<span class="go">({0: {0: 0, 1: 1, 2: 2}, 1: {1: 0, 2: 1}, 2: {2: 0}},</span>
<span class="go"> {0: {0: None, 1: 0, 2: 1}, 1: {1: None, 2: 1}, 2: {2: None}})</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Floyd-Warshall_SciPy&#39;</span><span class="p">)</span>
<span class="go">({0: {0: 0.0, 1: 1.0, 2: 2.0}, 1: {1: 0.0, 2: 1.0}, 2: {2: 0.0}},</span>
<span class="go"> {0: {0: None, 1: 0, 2: 1}, 1: {1: None, 2: 1}, 2: {2: None}})</span>
</pre></div>
</div>
<p>In order to change the default behavior if the graph is disconnected,
we can use default values with dictionaries:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">()</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">itertools</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.infinity</span> <span class="kn">import</span> <span class="n">Infinity</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">vertex_iterator</span><span class="p">(),</span> <span class="mi">2</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;dist(</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">) = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="o">+</span><span class="n">Infinity</span><span class="p">)))</span>
<span class="go">dist(0, 1) = 1</span>
<span class="go">dist(0, 2) = +Infinity</span>
<span class="go">dist(0, 3) = +Infinity</span>
<span class="go">dist(1, 2) = +Infinity</span>
<span class="go">dist(1, 3) = +Infinity</span>
<span class="go">dist(2, 3) = 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.shortest_path_length">
<span class="sig-name descname"><span class="pre">shortest_path_length</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">by_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.shortest_path_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimal length of a path from <code class="docutils literal notranslate"><span class="pre">u</span></code> to <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<p>If there is no path from <span class="math notranslate nohighlight">\(u\)</span> to <span class="math notranslate nohighlight">\(v\)</span>, returns <code class="docutils literal notranslate"><span class="pre">Infinity</span></code>.</p>
<p>For more information and more examples, we refer to
<a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.shortest_path" title="sage.graphs.generic_graph.GenericGraph.shortest_path"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shortest_path()</span></code></a> and
<a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.shortest_paths" title="sage.graphs.generic_graph.GenericGraph.shortest_paths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shortest_paths()</span></code></a>, which have very similar inputs.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">u</span></code>, <code class="docutils literal notranslate"><span class="pre">v</span></code> – the start and the end vertices of the paths</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">by_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, the edges
in the graph are weighted, otherwise all edges have weight 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); one of the following
algorithms:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'BFS'</span></code>: performs a BFS from <code class="docutils literal notranslate"><span class="pre">u</span></code>. Does not work with edge
weights.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'BFS_Bid'</span></code>: performs a BFS from <code class="docutils literal notranslate"><span class="pre">u</span></code> and from <code class="docutils literal notranslate"><span class="pre">v</span></code>. Does not
work with edge weights.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Dijkstra_NetworkX'</span></code>: the Dijkstra algorithm, implemented in
NetworkX. Works only with positive weights.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Dijkstra_Bid_NetworkX'</span></code>: performs a Dijkstra visit from <code class="docutils literal notranslate"><span class="pre">u</span></code>
and from <code class="docutils literal notranslate"><span class="pre">v</span></code> (NetworkX implementation). Works only with positive
weights.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Dijkstra_Bid'</span></code>: a Cython implementation that performs
a Dijkstra visit from <code class="docutils literal notranslate"><span class="pre">u</span></code> and from <code class="docutils literal notranslate"><span class="pre">v</span></code>. Works only with positive
weights.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Bellman-Ford_Boost'</span></code>: the Bellman-Ford algorithm, implemented in
Boost. Works also with negative weights, if there is no negative
cycle.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> (default): Sage chooses the best algorithm: <code class="docutils literal notranslate"><span class="pre">'BFS_Bid'</span></code>
if <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, <code class="docutils literal notranslate"><span class="pre">'Dijkstra_Bid'</span></code> otherwise.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If there are negative weights and algorithm is <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
result is not reliable. This occurs because, for performance
reasons, we cannot check whether there are edges with negative
weights before running the algorithm. If there are, the user
should explicitly input <code class="docutils literal notranslate"><span class="pre">algorithm='Bellman-Ford_Boost'</span></code>.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
takes as input an edge <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></code> and outputs its weight. If not
<code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is automatically set to <code class="docutils literal notranslate"><span class="pre">True</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>
and <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, we use the edge label <code class="docutils literal notranslate"><span class="pre">l</span></code>, if <code class="docutils literal notranslate"><span class="pre">l</span></code>
is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, else <code class="docutils literal notranslate"><span class="pre">1</span></code> as a weight.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, we check
that the weight_function outputs a number for each edge</p></li>
</ul>
<p>EXAMPLES:</p>
<p>Standard examples:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;BFS&#39;</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Dijkstra_NetworkX&#39;</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Dijkstra_Bid_NetworkX&#39;</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Dijkstra_Bid&#39;</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Bellman-Ford_Boost&#39;</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">delete_edges</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">edges_incident</span><span class="p">(</span><span class="mi">13</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">+Infinity</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">3</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="mi">4</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="mi">4</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">2</span><span class="p">}},</span> <span class="n">sparse</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span> <span class="c1"># long time</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Dijkstra_NetworkX&#39;</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Dijkstra_Bid_NetworkX&#39;</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>If Dijkstra is used with negative weights, usually it raises an error:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">3</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="mi">4</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="mi">4</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">}},</span> <span class="n">sparse</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: the graph contains an edge with negative weight</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Bellman-Ford_Boost&#39;</span><span class="p">)</span>
<span class="go">-1</span>
</pre></div>
</div>
<p>However, sometimes the result may be wrong, and no error is raised:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1000</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">3000</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1000</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Bellman-Ford_Boost&#39;</span><span class="p">)</span>
<span class="go">-1000</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.shortest_path_lengths">
<span class="sig-name descname"><span class="pre">shortest_path_lengths</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">by_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.shortest_path_lengths" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the length of a shortest path from <code class="docutils literal notranslate"><span class="pre">u</span></code> to any other vertex.</p>
<p>Returns a dictionary of shortest path lengths keyed by targets,
excluding all vertices that are not reachable from <span class="math notranslate nohighlight">\(u\)</span>.</p>
<p>For more information on the input variables and more examples, we refer
to <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.shortest_paths" title="sage.graphs.generic_graph.GenericGraph.shortest_paths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shortest_paths()</span></code></a> which has the same input
variables.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">u</span></code> – the starting vertex</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">by_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, the edges
in the graph are weighted, otherwise all edges have weight 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); one of the following
algorithms:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'BFS'</span></code>: performs a BFS from <code class="docutils literal notranslate"><span class="pre">u</span></code>. Does not work with edge
weights.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Dijkstra_NetworkX'</span></code>: the Dijkstra algorithm, implemented in
NetworkX (works only with positive weights).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Dijkstra_Boost'</span></code>: the Dijkstra algorithm, implemented in Boost
(works only with positive weights).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Bellman-Ford_Boost'</span></code>: the Bellman-Ford algorithm, implemented in
Boost (works also with negative weights, if there is no negative
cycle).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> (default): Sage chooses the best algorithm: <code class="docutils literal notranslate"><span class="pre">'BFS'</span></code> if
<code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, <code class="docutils literal notranslate"><span class="pre">'Dijkstra_Boost'</span></code> if all weights are
positive, <code class="docutils literal notranslate"><span class="pre">'Bellman-Ford_Boost'</span></code> otherwise.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
takes as input an edge <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></code> and outputs its weight. If not
<code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is automatically set to <code class="docutils literal notranslate"><span class="pre">True</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>
and <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, we use the edge label <code class="docutils literal notranslate"><span class="pre">l</span></code>, if <code class="docutils literal notranslate"><span class="pre">l</span></code>
is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, else <code class="docutils literal notranslate"><span class="pre">1</span></code> as a weight.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, we check
that the weight_function outputs a number for each edge</p></li>
</ul>
<p>EXAMPLES:</p>
<p>Unweighted case:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_path_lengths</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">{0: 0, 1: 1, 2: 2, 3: 2, 4: 3, 5: 4, 6: 3, 7: 3, 8: 2, 9: 2, 10: 1, 11: 2, 12: 3, 13: 3, 14: 4, 15: 5, 16: 4, 17: 3, 18: 2, 19: 1}</span>
</pre></div>
</div>
<p>Weighted case:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span> <span class="p">{</span> <span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">3</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="mi">4</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="mi">4</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span> <span class="p">},</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span> <span class="c1"># long time</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">shortest_path_lengths</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{0: 0, 1: 1, 2: 2, 3: 3, 4: 2}</span>
</pre></div>
</div>
<p>Using a weight function:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">}),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">})])</span>
<span class="gp">sage: </span><span class="n">weight_function</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">e</span><span class="p">:</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_path_lengths</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Dijkstra_NetworkX&#39;</span><span class="p">,</span> <span class="n">by_weight</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">{1: 0, 2: 1}</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_path_lengths</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">weight_function</span><span class="o">=</span><span class="n">weight_function</span><span class="p">)</span>
<span class="go">{0: 0, 1: 1, 2: 4}</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_path_lengths</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">weight_function</span><span class="o">=</span><span class="n">weight_function</span><span class="p">)</span>
<span class="go">{1: 0, 2: 3}</span>
</pre></div>
</div>
<p>Negative weights:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">}),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">}),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">})])</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_path_lengths</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">weight_function</span><span class="o">=</span><span class="n">weight_function</span><span class="p">)</span>
<span class="go">{0: 0, 1: -1, 2: 2}</span>
</pre></div>
</div>
<p>Negative cycles:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">}),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">}),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">})])</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_path_lengths</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">weight_function</span><span class="o">=</span><span class="n">weight_function</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: the graph contains a negative cycle</span>
</pre></div>
</div>
<p>Checking that distances are equal regardless of the algorithm used:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d1</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shortest_path_lengths</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;BFS&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shortest_path_lengths</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Dijkstra_NetworkX&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d3</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shortest_path_lengths</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Dijkstra_Boost&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d4</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shortest_path_lengths</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Bellman-Ford_Boost&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d1</span> <span class="o">==</span> <span class="n">d2</span> <span class="o">==</span> <span class="n">d3</span> <span class="o">==</span> <span class="n">d4</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.shortest_paths">
<span class="sig-name descname"><span class="pre">shortest_paths</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">by_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.shortest_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary associating to each vertex <code class="docutils literal notranslate"><span class="pre">v</span></code> a shortest path
from <code class="docutils literal notranslate"><span class="pre">u</span></code> to <code class="docutils literal notranslate"><span class="pre">v</span></code>, if it exists.</p>
<p>If <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> are not connected, vertex <span class="math notranslate nohighlight">\(v\)</span> is not present in the
dictionary.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">u</span></code> – the starting vertex</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">by_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, the edges
in the graph are weighted, otherwise all edges have weight 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); one of the following
algorithms:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'BFS'</span></code>: performs a BFS from <code class="docutils literal notranslate"><span class="pre">u</span></code>. Does not work with edge
weights.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Dijkstra_NetworkX'</span></code>: the Dijkstra algorithm, implemented in
NetworkX (works only with positive weights).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Dijkstra_Boost'</span></code>: the Dijkstra algorithm, implemented in Boost
(works only with positive weights).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Bellman-Ford_Boost'</span></code>: the Bellman-Ford algorithm, implemented in
Boost (works also with negative weights, if there is no negative
cycle).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> (default): Sage chooses the best algorithm: <code class="docutils literal notranslate"><span class="pre">'BFS'</span></code> if
<code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, <code class="docutils literal notranslate"><span class="pre">'Dijkstra_Boost'</span></code> if all weights are
positive, <code class="docutils literal notranslate"><span class="pre">'Bellman-Ford_Boost'</span></code> otherwise.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
takes as input an edge <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></code> and outputs its weight. If not
<code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is automatically set to <code class="docutils literal notranslate"><span class="pre">True</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>
and <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, we use the edge label <code class="docutils literal notranslate"><span class="pre">l</span></code>, if <code class="docutils literal notranslate"><span class="pre">l</span></code>
is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, else <code class="docutils literal notranslate"><span class="pre">1</span></code> as a weight.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, we check
that the weight_function outputs a number for each edge</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cutoff</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); integer depth to stop
search (used only if <code class="docutils literal notranslate"><span class="pre">algorithm=='BFS'</span></code>)</p></li>
</ul>
<p>EXAMPLES:</p>
<p>Standard example:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_paths</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">{0: [0], 1: [0, 1], 2: [0, 1, 2], 3: [0, 19, 3], 4: [0, 19, 3, 4], 5: [0, 1, 2, 6, 5], 6: [0, 1, 2, 6], 7: [0, 1, 8, 7], 8: [0, 1, 8], 9: [0, 10, 9], 10: [0, 10], 11: [0, 10, 11], 12: [0, 10, 11, 12], 13: [0, 10, 9, 13], 14: [0, 1, 8, 7, 14], 15: [0, 19, 18, 17, 16, 15], 16: [0, 19, 18, 17, 16], 17: [0, 19, 18, 17], 18: [0, 19, 18], 19: [0, 19]}</span>
</pre></div>
</div>
<p>All these paths are obviously induced graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">D</span><span class="o">.</span><span class="n">shortest_paths</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_paths</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">{0: [0], 1: [0, 1], 2: [0, 1, 2], 3: [0, 19, 3], 8: [0, 1, 8], 9: [0, 10, 9], 10: [0, 10], 11: [0, 10, 11], 18: [0, 19, 18], 19: [0, 19]}</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span> <span class="p">{</span> <span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">3</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="mi">4</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="mi">4</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span> <span class="p">},</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span> <span class="c1"># long time</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">shortest_paths</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{0: [0], 1: [0, 1], 2: [0, 1, 2], 3: [0, 1, 2, 3], 4: [0, 4]}</span>
</pre></div>
</div>
<p>Weighted shortest paths:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_paths</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">{0: [0], 1: [0, 1], 2: [0, 2]}</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_paths</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{0: [0], 1: [0, 1], 2: [0, 1, 2]}</span>
</pre></div>
</div>
<p>Using a weight function (this way, <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">}),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">})])</span>
<span class="gp">sage: </span><span class="n">weight_function</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">e</span><span class="p">:</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_paths</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">weight_function</span><span class="o">=</span><span class="n">weight_function</span><span class="p">)</span>
<span class="go">{0: [0], 1: [0, 1], 2: [0, 1, 2]}</span>
</pre></div>
</div>
<p>If the weight function does not match the label:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_paths</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">weight_function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: the weight function cannot find the weight of (0, 1, {&#39;weight&#39;: 1})</span>
</pre></div>
</div>
<p>However, if <code class="docutils literal notranslate"><span class="pre">check_weight</span></code> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code>, unexpected behavior
may occur:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_paths</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Dijkstra_NetworkX&#39;</span><span class="p">,</span> <span class="n">weight_function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">check_weight</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: unsupported operand type(s) for +: &#39;int&#39; and &#39;dict&#39;</span>
</pre></div>
</div>
<p>Negative weights:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_paths</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{0: [0], 1: [0, 1], 2: [0, 1, 2]}</span>
</pre></div>
</div>
<p>Negative cycles:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">shortest_paths</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: the graph contains a negative cycle</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.shortest_simple_paths">
<span class="sig-name descname"><span class="pre">shortest_simple_paths</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">by_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">report_edges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">report_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.shortest_simple_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over the simple paths between a pair of vertices.</p>
<p>This method returns an iterator over the simple paths (i.e., without
repetition) from <code class="docutils literal notranslate"><span class="pre">source</span></code> to <code class="docutils literal notranslate"><span class="pre">target</span></code>. By default (<code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is
<code class="docutils literal notranslate"><span class="pre">False</span></code>), the paths are reported by increasing number of edges. When
<code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, the paths are reported by increasing weights.</p>
<p>In case of weighted graphs negative weights are not allowed.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">source</span></code> is the same vertex as <code class="docutils literal notranslate"><span class="pre">target</span></code>, then <code class="docutils literal notranslate"><span class="pre">[[source]]</span></code> is
returned – a list containing the 1-vertex, 0-edge path <code class="docutils literal notranslate"><span class="pre">source</span></code>.</p>
<p>By default <code class="docutils literal notranslate"><span class="pre">Yen's</span></code> algorithm <a class="reference internal" href="../../../references/index.html#yen1970" id="id38"><span>[Yen1970]</span></a> is used for undirected graphs and
<code class="docutils literal notranslate"><span class="pre">Feng's</span></code> algorithm is used for directed graphs <a class="reference internal" href="../../../references/index.html#feng2014" id="id39"><span>[Feng2014]</span></a>.</p>
<p>The loops and the multiedges if present in the given graph are ignored and
only minimum of the edge labels is kept in case of multiedges.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">source</span></code> – a vertex of the graph, where to start</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">target</span></code> – a vertex of the graph, where to end</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
takes as input an edge <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></code> and outputs its weight. If not
<code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is automatically set to <code class="docutils literal notranslate"><span class="pre">True</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>
and <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, we use the edge label <code class="docutils literal notranslate"><span class="pre">l</span></code> as a
weight.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">by_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, the edges
in the graph are weighted, otherwise all edges have weight 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether to check that the
<code class="docutils literal notranslate"><span class="pre">weight_function</span></code> outputs a number for each edge.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the algorithm to use in
computing <code class="docutils literal notranslate"><span class="pre">k</span></code> shortest paths of <code class="docutils literal notranslate"><span class="pre">self</span></code>. The following algorithms are
supported:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Yen&quot;</span></code> – Yen’s algorithm <a class="reference internal" href="../../../references/index.html#yen1970" id="id40"><span>[Yen1970]</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Feng&quot;</span></code> – an improved version of Yen’s algorithm but that works only
for directed graphs <a class="reference internal" href="../../../references/index.html#feng2014" id="id41"><span>[Feng2014]</span></a></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">report_edges</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to report paths
as list of vertices (default) or list of edges. When set to <code class="docutils literal notranslate"><span class="pre">False</span></code>, the
<code class="docutils literal notranslate"><span class="pre">labels</span></code> parameter is ignored.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">False</span></code>, each edge is
simply a pair <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v)</span></code> of vertices. Otherwise a list of edges along
with its edge labels are used to represent the path.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">report_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">False</span></code>, just the
path between <code class="docutils literal notranslate"><span class="pre">source</span></code> and <code class="docutils literal notranslate"><span class="pre">target</span></code> is returned. Otherwise a tuple of
path length and path is returned.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">30</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">shortest_simple_paths</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Yen&quot;</span><span class="p">))</span>
<span class="go">[[1, 3, 5], [1, 2, 5], [1, 4, 5]]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">shortest_simple_paths</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Yen&quot;</span><span class="p">))</span>
<span class="go">[[1, 2, 5], [1, 3, 5], [1, 4, 5]]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">shortest_simple_paths</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">[[1]]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">shortest_simple_paths</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">report_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">report_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(20, [(1, 3, 10), (3, 5, 10)]),</span>
<span class="go"> (40, [(1, 2, 20), (2, 5, 20)]),</span>
<span class="go"> (60, [(1, 4, 30), (4, 5, 30)])]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">shortest_simple_paths</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Feng&quot;</span><span class="p">,</span> <span class="n">report_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">report_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(20, [(1, 3), (3, 5)]), (40, [(1, 2), (2, 5)]), (60, [(1, 4), (4, 5)])]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">shortest_simple_paths</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">report_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">report_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(2, [(1, 4), (4, 5)]), (2, [(1, 3), (3, 5)]), (2, [(1, 2), (2, 5)])]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">shortest_simple_paths</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">report_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[[(1, 3), (3, 5)], [(1, 2), (2, 5)], [(1, 4), (4, 5)]]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">shortest_simple_paths</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Feng&quot;</span><span class="p">,</span> <span class="n">report_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[[(1, 3, 10), (3, 5, 10)], [(1, 2, 20), (2, 5, 20)], [(1, 4, 30), (4, 5, 30)]]</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">shortest_simple_paths</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">by_weight</span> <span class="o">=</span> <span class="kc">True</span><span class="p">))</span>
<span class="go">[[1, 3, 5, 6], [1, 2, 5, 6], [1, 4, 5, 6], [1, 6]]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">shortest_simple_paths</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Yen&quot;</span><span class="p">))</span>
<span class="go">[[1, 6], [1, 2, 5, 6], [1, 3, 5, 6], [1, 4, 5, 6]]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">shortest_simple_paths</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">report_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">report_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(1, [(1, 6, 100)]),</span>
<span class="go"> (3, [(1, 2, 20), (2, 5, 20), (5, 6, 5)]),</span>
<span class="go"> (3, [(1, 3, 10), (3, 5, 10), (5, 6, 5)]),</span>
<span class="go"> (3, [(1, 4, 30), (4, 5, 30), (5, 6, 5)])]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">shortest_simple_paths</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">report_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">report_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(25, [(1, 3, 10), (3, 5, 10), (5, 6, 5)]),</span>
<span class="go"> (45, [(1, 2, 20), (2, 5, 20), (5, 6, 5)]),</span>
<span class="go"> (65, [(1, 4, 30), (4, 5, 30), (5, 6, 5)]),</span>
<span class="go"> (100, [(1, 6, 100)])]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">shortest_simple_paths</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">report_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[[(1, 3, 10), (3, 5, 10), (5, 6, 5)],</span>
<span class="go"> [(1, 2, 20), (2, 5, 20), (5, 6, 5)],</span>
<span class="go"> [(1, 4, 30), (4, 5, 30), (5, 6, 5)],</span>
<span class="go"> [(1, 6, 100)]]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">shortest_simple_paths</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">report_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[[(1, 6, 100)],</span>
<span class="go"> [(1, 2, 20), (2, 5, 20), (5, 6, 5)],</span>
<span class="go"> [(1, 3, 10), (3, 5, 10), (5, 6, 5)],</span>
<span class="go"> [(1, 4, 30), (4, 5, 30), (5, 6, 5)]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.show">
<span class="sig-name descname"><span class="pre">show</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'matplotlib'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Show the (di)graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">method</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">&quot;matplotlib&quot;</span></code>); method to use to
display the graph, either <code class="docutils literal notranslate"><span class="pre">&quot;matplotlib&quot;</span></code>, or <code class="docutils literal notranslate"><span class="pre">&quot;js&quot;</span></code> to visualize
it in a browser using <a class="reference external" href="http://d3js.org/">d3.js</a>.</p></li>
<li><p>Any other argument supported by the drawing functions:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;matplotlib&quot;</span></code> – see <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.plot" title="sage.graphs.generic_graph.GenericGraph.plot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GenericGraph.plot</span></code></a> and
<a class="reference external" href="../../../plotting/sage/plot/graphics.html#sage.plot.graphics.Graphics.show" title="(in Sage 9.5 Reference Manual: 2D Graphics v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.plot.graphics.Graphics.show()</span></code></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;js&quot;</span></code> – see <a class="reference internal" href="graph_plot_js.html#sage.graphs.graph_plot_js.gen_html_code" title="sage.graphs.graph_plot_js.gen_html_code"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gen_html_code()</span></code></a></p></li>
</ul>
</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">vertex_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">vertex_size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">graph_border</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  <span class="c1"># long time (3s on sage.math, 2011)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.show3d">
<span class="sig-name descname"><span class="pre">show3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bgcolor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1,</span> <span class="pre">1,</span> <span class="pre">1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.02</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_size2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0325</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos3d</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_by_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">engine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'threejs'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.show3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the graph and show the resulting plot.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">bgcolor</span></code> – rgb tuple (default: <code class="docutils literal notranslate"><span class="pre">(1,1,1)</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertex_size</span></code> – float (default: <code class="docutils literal notranslate"><span class="pre">0.06</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertex_labels</span></code> – a boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to
display vertices using text labels instead of spheres</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertex_colors</span></code> – dictionary (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); optional
dictionary to specify vertex colors: each key is a color recognizable
by <a class="reference external" href="../../../plot3d/sage/plot/plot3d/tachyon.html#module-sage.plot.plot3d.tachyon" title="(in Sage 9.5 Reference Manual: 3D Graphics v9.5)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tachyon</span></code></a> (rgb tuple (default:
<code class="docutils literal notranslate"><span class="pre">(1,0,0)</span></code>)), and each corresponding entry is a list of vertices. If
a vertex is not listed, it looks invisible on the resulting plot (it
doesn’t get drawn).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edge_colors</span></code> – dictionary (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a dictionary
specifying edge colors: each key is a color recognized by
<a class="reference external" href="../../../plot3d/sage/plot/plot3d/tachyon.html#module-sage.plot.plot3d.tachyon" title="(in Sage 9.5 Reference Manual: 3D Graphics v9.5)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tachyon</span></code></a> (default: <code class="docutils literal notranslate"><span class="pre">(0,0,0)</span></code>), and each
entry is a list of edges.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">color_by_label</span></code> – a boolean or dictionary or function (default:
<code class="docutils literal notranslate"><span class="pre">False</span></code>) whether to color each edge with a different color according
to its label; the colors are chosen along a rainbow, unless they are
specified by a function or dictionary mapping labels to colors; this
option is incompatible with <code class="docutils literal notranslate"><span class="pre">edge_color</span></code> and <code class="docutils literal notranslate"><span class="pre">edge_colors</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edge_size</span></code> – float (default: <code class="docutils literal notranslate"><span class="pre">0.02</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edge_size2</span></code> – float (default: <code class="docutils literal notranslate"><span class="pre">0.0325</span></code>); used for
<a class="reference external" href="../../../plot3d/sage/plot/plot3d/tachyon.html#sage.plot.plot3d.tachyon.Tachyon" title="(in Sage 9.5 Reference Manual: 3D Graphics v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tachyon</span></code></a> sleeves</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pos3d</span></code> – a position dictionary for the vertices</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">layout</span></code>, <code class="docutils literal notranslate"><span class="pre">iterations</span></code>, … – layout options; see <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.layout" title="sage.graphs.generic_graph.GenericGraph.layout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">layout()</span></code></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">engine</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">'threejs'</span></code>); the renderer to use among:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'threejs'</span></code>: interactive web-based 3D viewer using JavaScript
and a WebGL renderer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'jmol'</span></code>: interactive 3D viewer using Java</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'tachyon'</span></code>: ray tracer generating a static PNG image</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">xres</span></code> – resolution</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">yres</span></code> – resolution</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">**kwds</span></code> – passed on to the rendering engine</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show3d</span><span class="p">(</span><span class="n">iterations</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">edge_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vertex_size</span><span class="o">=</span><span class="mf">0.04</span><span class="p">)</span> <span class="c1"># long time</span>
</pre></div>
</div>
<p>We plot a fairly complicated Cayley graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A5</span> <span class="o">=</span> <span class="n">AlternatingGroup</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="n">A5</span>
<span class="go">Alternating group of order 5!/2 as a permutation group</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">A5</span><span class="o">.</span><span class="n">cayley_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show3d</span><span class="p">(</span><span class="n">vertex_size</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="n">edge_size</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">edge_size2</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">vertex_colors</span><span class="o">=</span><span class="p">{(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="p">)},</span> <span class="n">bgcolor</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">color_by_label</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span> <span class="c1"># long time</span>
</pre></div>
</div>
<p>Some <a class="reference external" href="../../../plot3d/sage/plot/plot3d/tachyon.html#sage.plot.plot3d.tachyon.Tachyon" title="(in Sage 9.5 Reference Manual: 3D Graphics v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tachyon</span></code></a> examples:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">show3d</span><span class="p">(</span><span class="n">engine</span><span class="o">=</span><span class="s1">&#39;tachyon&#39;</span><span class="p">)</span> <span class="c1"># long time</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show3d</span><span class="p">(</span><span class="n">engine</span><span class="o">=</span><span class="s1">&#39;tachyon&#39;</span><span class="p">,</span> <span class="n">vertex_colors</span><span class="o">=</span><span class="p">{(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="p">)})</span> <span class="c1"># long time</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">show3d</span><span class="p">(</span><span class="n">engine</span><span class="o">=</span><span class="s1">&#39;tachyon&#39;</span><span class="p">,</span> <span class="n">edge_colors</span><span class="o">=</span><span class="p">{(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span> <span class="n">C</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)},</span> <span class="n">vertex_colors</span><span class="o">=</span><span class="p">{(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span> <span class="nb">list</span><span class="p">(</span><span class="n">C</span><span class="p">)},</span> <span class="n">bgcolor</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="c1"># long time</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">show3d</span><span class="p">(</span><span class="n">engine</span><span class="o">=</span><span class="s1">&#39;tachyon&#39;</span><span class="p">,</span> <span class="n">edge_colors</span><span class="o">=</span><span class="p">{(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)],</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)],</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]})</span> <span class="c1"># long time</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.size">
<span class="sig-name descname"><span class="pre">size</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of edges.</p>
<p>Note that <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.num_edges" title="sage.graphs.generic_graph.GenericGraph.num_edges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">num_edges()</span></code></a> also returns the number of edges in <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">15</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.spanning_trees_count">
<span class="sig-name descname"><span class="pre">spanning_trees_count</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root_vertex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.spanning_trees_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of spanning trees in a graph.</p>
<p>In the case of a digraph, counts the number of spanning out-trees rooted
in <code class="docutils literal notranslate"><span class="pre">root_vertex</span></code>.  Default is to set first vertex as root.</p>
<p>This computation uses Kirchhoff’s Matrix Tree Theorem [1] to calculate
the number of spanning trees. For complete graphs on <span class="math notranslate nohighlight">\(n\)</span> vertices the
result can also be reached using Cayley’s formula: the number of
spanning trees are <span class="math notranslate nohighlight">\(n^(n-2)\)</span>.</p>
<p>For digraphs, the augmented Kirchhoff Matrix as defined in [2] is used
for calculations. Here the result is the number of out-trees rooted at a
specific vertex.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">root_vertex</span></code> – a vertex (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the vertex that will
be used as root for all spanning out-trees if the graph is a directed
graph. Otherwise, the first vertex returned by <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.vertex_iterator" title="sage.graphs.generic_graph.GenericGraph.vertex_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertex_iterator()</span></code></a>
is used. This argument is ignored if the graph is not a digraph.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="graph.html#sage.graphs.graph.Graph.spanning_trees" title="sage.graphs.graph.Graph.spanning_trees"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spanning_trees()</span></code></a> – enumerates all
spanning trees of a graph</p>
</div>
<p>REFERENCES:</p>
<ul class="simple">
<li><p>[1] <a class="reference external" href="http://mathworld.wolfram.com/MatrixTreeTheorem.html">http://mathworld.wolfram.com/MatrixTreeTheorem.html</a></p></li>
<li><p>[2] Lih-Hsing Hsu, Cheng-Kuan Lin, “Graph Theory and
Interconnection Networks”</p></li>
</ul>
<p>AUTHORS:</p>
<ul class="simple">
<li><p>Anders Jonsson (2009-10-10)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">spanning_trees_count</span><span class="p">()</span>
<span class="go">2000</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="mi">11</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ST</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">spanning_trees_count</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ST</span> <span class="o">==</span> <span class="n">n</span> <span class="o">^</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">spanning_trees_count</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">spanning_trees_count</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">spanning_trees_count</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.spectral_radius">
<span class="sig-name descname"><span class="pre">spectral_radius</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.spectral_radius" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an interval of floating point number that encloses the spectral
radius of this graph</p>
<p>The input graph <code class="docutils literal notranslate"><span class="pre">G</span></code> must be <em>strongly connected</em>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">prec</span></code> – (default <code class="docutils literal notranslate"><span class="pre">1e-10</span></code>) an upper bound for the relative precision
of the interval</p></li>
</ul>
<p>The algorithm is iterative and uses an inequality valid for non-negative
matrices. Namely, if <span class="math notranslate nohighlight">\(A\)</span> is a non-negative square matrix with
Perron-Frobenius eigenvalue <span class="math notranslate nohighlight">\(\lambda\)</span> then the following inequality is valid
for any vector <span class="math notranslate nohighlight">\(x\)</span></p>
<div class="math notranslate nohighlight">
\[\min_i  \frac{(Ax)_i}{x_i} \leq \lambda \leq \max_i \frac{(Ax)_i}{x_i}\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The speed of convergence of the algorithm is governed by the spectral
gap (the distance to the second largest modulus of other eigenvalues).
If this gap is small, then this function might not be appropriate.</p>
<p>The algorithm is not smart and not parallel! It uses basic interval
arithmetic and native floating point arithmetic.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.static_sparse_graph</span> <span class="kn">import</span> <span class="n">spectral_radius</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="p">(</span><span class="n">RR</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">RR</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span> <span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
<span class="gp">sage: </span><span class="n">phi</span>  <span class="c1"># abs tol 1e-14</span>
<span class="go">1.618033988749895</span>
<span class="gp">sage: </span><span class="n">e_min</span><span class="p">,</span> <span class="n">e_max</span> <span class="o">=</span> <span class="n">spectral_radius</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mf">1e-14</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e_min</span><span class="p">,</span> <span class="n">e_max</span>     <span class="c1"># abs tol 1e-14</span>
<span class="go">(1.618033988749894, 1.618033988749896)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">e_max</span> <span class="o">-</span> <span class="n">e_min</span><span class="p">)</span>  <span class="c1"># abs tol 1e-14</span>
<span class="go">1e-14</span>
<span class="gp">sage: </span><span class="n">e_min</span> <span class="o">&lt;</span> <span class="n">phi</span> <span class="o">&lt;</span> <span class="n">e_max</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This function also works for graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">e_min</span><span class="p">,</span> <span class="n">e_max</span> <span class="o">=</span> <span class="n">spectral_radius</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mf">1e-14</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">charpoly</span><span class="p">()</span><span class="o">.</span><span class="n">roots</span><span class="p">(</span><span class="n">AA</span><span class="p">,</span> <span class="n">multiplicities</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">e_min</span> <span class="o">&lt;</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="n">e_max</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">spectral_radius</span><span class="p">()</span>  <span class="c1"># abs tol 1e-9</span>
<span class="go">(2.48119430408, 2.4811943041)</span>
</pre></div>
</div>
<p>A larger example:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">200</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e_min</span><span class="p">,</span> <span class="n">e_max</span> <span class="o">=</span> <span class="n">spectral_radius</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mf">0.00001</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">charpoly</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span>
<span class="go">x^201 - x^199 - 1</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">roots</span><span class="p">(</span><span class="n">AA</span><span class="p">,</span> <span class="n">multiplicities</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">e_min</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">e_max</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A much larger example:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="mi">100000</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">100000</span><span class="p">))</span>
<span class="gp">sage: </span><span class="k">while</span> <span class="ow">not</span> <span class="n">G</span><span class="o">.</span><span class="n">is_strongly_connected</span><span class="p">():</span>
<span class="gp">....: </span>    <span class="n">shuffle</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">loops</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">spectral_radius</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mf">1e-10</span><span class="p">)</span>  <span class="c1"># random</span>
<span class="go">(1.9997956006500042, 1.9998043797692782)</span>
</pre></div>
</div>
<p>The algorithm takes care of multiple edges:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">spectral_radius</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mf">1e-14</span><span class="p">)</span>  <span class="c1"># abs tol 1e-14</span>
<span class="go">(2.414213562373094, 2.414213562373095)</span>
<span class="gp">sage: </span><span class="nb">max</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">(</span><span class="n">AA</span><span class="p">))</span>
<span class="go">2.414213562373095?</span>
</pre></div>
</div>
<p>Some bipartite graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">spectral_radius</span><span class="p">()</span>  <span class="c1"># abs tol 1e-10</span>
<span class="go">(1.6180339887253428, 1.6180339887592732)</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">spectral_radius</span><span class="p">()</span> <span class="c1"># abs tol 1e-10</span>
<span class="go">(1.5537739740270458, 1.553773974033029)</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">spectral_radius</span><span class="p">()</span>  <span class="c1"># abs tol 1e-10</span>
<span class="go">(1.7320508075688772, 1.7320508075688774)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.spectrum">
<span class="sig-name descname"><span class="pre">spectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">laplacian</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the eigenvalues of the adjacency matrix.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">laplacian</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, use the
Laplacian matrix (see <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.kirchhoff_matrix" title="sage.graphs.generic_graph.GenericGraph.kirchhoff_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kirchhoff_matrix()</span></code></a>)</p></li>
</ul>
<p>OUTPUT:</p>
<p>A list of the eigenvalues, including multiplicities, sorted with the
largest eigenvalue first.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The method <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.spectral_radius" title="sage.graphs.generic_graph.GenericGraph.spectral_radius"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spectral_radius()</span></code></a> returns floating point
approximation of the maximum eigenvalue.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">spectrum</span><span class="p">()</span>
<span class="go">[3, 1, 1, 1, 1, 1, -2, -2, -2, -2]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">spectrum</span><span class="p">(</span><span class="n">laplacian</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[5, 5, 5, 5, 2, 2, 2, 2, 2, 0]</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">delete_edge</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">spectrum</span><span class="p">()</span>
<span class="go">[2.9032119259..., 1, 1, 1, 1, 0.8060634335..., -1.7092753594..., -2, -2, -2]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">spectrum</span><span class="p">()</span>
<span class="go">[2, 1.4142135623..., 1.4142135623..., 0, 0, -1.4142135623..., -1.4142135623..., -2]</span>
</pre></div>
</div>
<p>A digraph may have complex eigenvalues. Previously, the complex parts of
graph eigenvalues were being dropped. For a 3-cycle, we have:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">spectrum</span><span class="p">()</span>
<span class="go">[1, -0.5000000000... + 0.8660254037...*I, -0.5000000000... - 0.8660254037...*I]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.steiner_tree">
<span class="sig-name descname"><span class="pre">steiner_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighted</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.steiner_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tree of minimum weight connecting the given set of vertices.</p>
<p>Definition :</p>
<p>Computing a minimum spanning tree in a graph can be done in <span class="math notranslate nohighlight">\(n \log(n)\)</span>
time (and in linear time if all weights are equal) where <span class="math notranslate nohighlight">\(n = V + E\)</span>. On
the other hand, if one is given a large (possibly weighted) graph and a
subset of its vertices, it is NP-Hard to find a tree of minimum weight
connecting the given set of vertices, which is then called a Steiner
Tree.</p>
<p>See the <a class="reference external" href="https://en.wikipedia.org/wiki/Steiner_tree_problem">Wikipedia article Steiner_tree_problem</a> for more information.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – the vertices to be connected by the Steiner
Tree.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">weighted</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to consider the
graph as weighted, and use each edge’s label as a weight, considering
<code class="docutils literal notranslate"><span class="pre">None</span></code> as a weight of <span class="math notranslate nohighlight">\(1\)</span>. If <code class="docutils literal notranslate"><span class="pre">weighted=False</span></code> (default) all edges
are considered to have a weight of <span class="math notranslate nohighlight">\(1\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>This problem being defined on undirected graphs, the orientation
is not considered if the current graph is actually a digraph.</p></li>
<li><p>The graph is assumed not to have multiple edges.</p></li>
</ul>
</div>
<p>ALGORITHM:</p>
<p>Solved through Linear Programming.</p>
<p>COMPLEXITY:</p>
<p>NP-Hard.</p>
<p>Note that this algorithm first checks whether the given set of vertices
induces a connected graph, returning one of its spanning trees if
<code class="docutils literal notranslate"><span class="pre">weighted</span></code> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code>, and thus answering very quickly in
some cases</p>
<p>EXAMPLES:</p>
<p>The Steiner Tree of the first 5 vertices in a random graph is, of
course, always a tree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mf">.5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">first5</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">()[:</span><span class="mi">5</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">st</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">steiner_tree</span><span class="p">(</span><span class="n">first5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">st</span><span class="o">.</span><span class="n">is_tree</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>And all the 5 vertices are contained in this tree</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">v</span> <span class="ow">in</span> <span class="n">st</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">first5</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>An exception is raised when the problem is impossible, i.e.  if the
given vertices are not all included in the same connected component:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">st</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">steiner_tree</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">15</span><span class="p">])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">EmptySetError: the given vertices do not all belong to the same connected component. This problem has no solution !</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.strong_product">
<span class="sig-name descname"><span class="pre">strong_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.strong_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the strong product of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>The strong product of <span class="math notranslate nohighlight">\(G\)</span> and <span class="math notranslate nohighlight">\(H\)</span> is the graph <span class="math notranslate nohighlight">\(L\)</span> with vertex set
<span class="math notranslate nohighlight">\(V(L)=V(G)\times V(H)\)</span>, and <span class="math notranslate nohighlight">\(((u,v), (w,x))\)</span> is an edge of <span class="math notranslate nohighlight">\(L\)</span> iff
either :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\((u, w)\)</span> is an edge of <span class="math notranslate nohighlight">\(G\)</span> and <span class="math notranslate nohighlight">\(v = x\)</span>, or</p></li>
<li><p><span class="math notranslate nohighlight">\((v, x)\)</span> is an edge of <span class="math notranslate nohighlight">\(H\)</span> and <span class="math notranslate nohighlight">\(u = w\)</span>, or</p></li>
<li><p><span class="math notranslate nohighlight">\((u, w)\)</span> is an edge of <span class="math notranslate nohighlight">\(G\)</span> and <span class="math notranslate nohighlight">\((v, x)\)</span> is an edge of <span class="math notranslate nohighlight">\(H\)</span>.</p></li>
</ul>
<p>In other words, the edges of the strong product is the union of the
edges of the tensor and Cartesian products.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">strong_product</span><span class="p">(</span><span class="n">Z</span><span class="p">);</span> <span class="n">S</span>
<span class="go">Graph on 10 vertices</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span> <span class="c1"># long time</span>
<span class="go">Graphics object consisting of 36 graphics primitives</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">strong_product</span><span class="p">(</span><span class="n">P</span><span class="p">);</span> <span class="n">S</span>
<span class="go">Graph on 200 vertices</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span> <span class="c1"># long time</span>
<span class="go">Graphics object consisting of 1701 graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.subdivide_edge">
<span class="sig-name descname"><span class="pre">subdivide_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.subdivide_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivide an edge <span class="math notranslate nohighlight">\(k\)</span> times.</p>
<p>INPUT:</p>
<p>The following forms are all accepted to subdivide <span class="math notranslate nohighlight">\(8\)</span> times the edge
between vertices <span class="math notranslate nohighlight">\(1\)</span> and <span class="math notranslate nohighlight">\(2\)</span> labeled with <code class="docutils literal notranslate"><span class="pre">&quot;my_label&quot;</span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G.subdivide_edge(</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">8</span> <span class="pre">)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">G.subdivide_edge(</span> <span class="pre">(1,</span> <span class="pre">2),</span> <span class="pre">8</span> <span class="pre">)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">G.subdivide_edge(</span> <span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">&quot;my_label&quot;),</span> <span class="pre">8</span> <span class="pre">)</span></code></p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>If the given edge is labelled with <span class="math notranslate nohighlight">\(l\)</span>, all the edges created by
the subdivision will have the same label</p></li>
<li><p>If no label is given, the label used will be the one returned by
the method <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.edge_label" title="sage.graphs.generic_graph.GenericGraph.edge_label"><code class="xref py py-meth docutils literal notranslate"><span class="pre">edge_label()</span></code></a> on the pair <code class="docutils literal notranslate"><span class="pre">u,v</span></code></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>Subdividing <span class="math notranslate nohighlight">\(5\)</span> times an edge in a path of length <span class="math notranslate nohighlight">\(3\)</span> makes it a path of
length <span class="math notranslate nohighlight">\(8\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">edge</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">subdivide_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Subdividing a labelled edge in two ways:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;label1&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;label2&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
<span class="go">[(0, 1, &#39;label1&#39;), (1, 2, &#39;label2&#39;)]</span>
</pre></div>
</div>
<p>Specifying the label:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">subdivide_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;label1&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
<span class="go">[(0, 3, &#39;label1&#39;), (1, 2, &#39;label2&#39;), (1, 5, &#39;label1&#39;), (3, 4, &#39;label1&#39;), (4, 5, &#39;label1&#39;)]</span>
</pre></div>
</div>
<p>The lazy way:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">subdivide_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;label2&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
<span class="go">[(0, 3, &#39;label1&#39;), (1, 5, &#39;label1&#39;), (1, 6, &#39;label2&#39;), (2, 10, &#39;label2&#39;), (3, 4, &#39;label1&#39;), (4, 5, &#39;label1&#39;), (6, 7, &#39;label2&#39;), (7, 8, &#39;label2&#39;), (8, 9, &#39;label2&#39;), (9, 10, &#39;label2&#39;)]</span>
</pre></div>
</div>
<p>If too many arguments are given, an exception is raised</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">subdivide_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: this method takes at most 4 arguments</span>
</pre></div>
</div>
<p>The same goes when the given edge does not exist:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">subdivide_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;fake_label&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: the given edge does not exist</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.subdivide_edges" title="sage.graphs.generic_graph.GenericGraph.subdivide_edges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subdivide_edges()</span></code></a> – subdivides multiples edges at a time</p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.subdivide_edges">
<span class="sig-name descname"><span class="pre">subdivide_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edges</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.subdivide_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivide <span class="math notranslate nohighlight">\(k\)</span> times edges from an iterable container.</p>
<p>For more information on the behaviour of this method, please refer to
the documentation of <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.subdivide_edge" title="sage.graphs.generic_graph.GenericGraph.subdivide_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subdivide_edge()</span></code></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">edges</span></code> – a list of edges</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> – integer; common length of the subdivisions</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If a given edge is labelled with <span class="math notranslate nohighlight">\(l\)</span>, all the edges created by its
subdivision will have the same label.</p>
</div>
<p>EXAMPLES:</p>
<p>If we are given the disjoint union of several paths:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">paths</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">,</span> <span class="n">paths</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
<span class="gp">....: </span>  <span class="n">g</span> <span class="o">=</span> <span class="n">g</span> <span class="o">+</span> <span class="n">P</span>
</pre></div>
</div>
<p>Subdividing edges in each of them will only change their lengths:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">())</span> <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">connected_components_subgraphs</span><span class="p">()]</span>
<span class="gp">sage: </span><span class="n">k</span> <span class="o">=</span> <span class="mi">6</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">subdivide_edges</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
</pre></div>
</div>
<p>Let us check this by creating the graph we expect to have built through
subdivision:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">paths2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="mi">5</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="mi">9</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">paths2</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">,</span> <span class="n">paths2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g2</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">paths2</span><span class="p">:</span>
<span class="gp">....: </span>  <span class="n">g2</span> <span class="o">=</span> <span class="n">g2</span> <span class="o">+</span> <span class="n">P</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">g2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.subdivide_edge" title="sage.graphs.generic_graph.GenericGraph.subdivide_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subdivide_edge()</span></code></a> – subdivides one edge</p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.subgraph">
<span class="sig-name descname"><span class="pre">subgraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_property</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_property</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">immutable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.subgraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the subgraph containing the given vertices and edges.</p>
<p>If either vertices or edges are not specified, they are assumed to be
all vertices or edges. If edges are not specified, returns the subgraph
induced by the vertices.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">inplace</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); using <code class="docutils literal notranslate"><span class="pre">inplace=True</span></code>
will simply delete the extra vertices and edges from the current
graph. This will modify the graph.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – a single vertex or an iterable container of vertices,
e.g. a list, set, graph, file or numeric array. If not passed (i.e.,
<code class="docutils literal notranslate"><span class="pre">None</span></code>), defaults to the entire graph.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edges</span></code> – as with <code class="docutils literal notranslate"><span class="pre">vertices</span></code>, edges can be a single edge or an
iterable container of edges (e.g., a list, set, file, numeric array,
etc.). By default (<code class="docutils literal notranslate"><span class="pre">edges=None</span></code>), all edges are assumed and the
returned graph is an induced subgraph. In the case of multiple edges,
specifying an edge as <span class="math notranslate nohighlight">\((u,v)\)</span> means to keep all edges <span class="math notranslate nohighlight">\((u,v)\)</span>,
regardless of the label.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertex_property</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
inputs a vertex and outputs a boolean value, i.e., a vertex <code class="docutils literal notranslate"><span class="pre">v</span></code> in
<code class="docutils literal notranslate"><span class="pre">vertices</span></code> is kept if <code class="docutils literal notranslate"><span class="pre">vertex_property(v)</span> <span class="pre">==</span> <span class="pre">True</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edge_property</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
inputs an edge and outputs a boolean value, i.e., a edge <code class="docutils literal notranslate"><span class="pre">e</span></code> in
<code class="docutils literal notranslate"><span class="pre">edges</span></code> is kept if <code class="docutils literal notranslate"><span class="pre">edge_property(e)</span> <span class="pre">==</span> <span class="pre">True</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); one of the following:</p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">algorithm=&quot;delete&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">inplace=True</span></code>, then the graph is
constructed by deleting edges and vertices</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">algorithm=&quot;add&quot;</span></code>, then the graph is constructed by building a
new graph from the appropriate vertices and edges. Implies
<code class="docutils literal notranslate"><span class="pre">inplace=False</span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">algorithm=None</span></code>, then the algorithm is chosen based on the
number of vertices in the subgraph.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">immutable</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); whether to create a
mutable/immutable subgraph. <code class="docutils literal notranslate"><span class="pre">immutable=None</span></code> (default) means that
the graph and its subgraph will behave the same way.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span> <span class="n">H</span>
<span class="go">Subgraph of (Complete graph): Graph on 3 vertices</span>
<span class="gp">sage: </span><span class="n">G</span>
<span class="go">Complete graph: Graph on 9 vertices</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(0, 1)]</span>
<span class="gp">sage: </span><span class="nb">set</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Subgraph of (Complete graph): Graph on 3 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">()</span> <span class="o">==</span> <span class="n">G</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Complete</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">subgraph</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span> <span class="n">H</span>
<span class="go">Subgraph of (Complete digraph): Digraph on 3 vertices</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(0, 1), (0, 2)]</span>
<span class="gp">sage: </span><span class="nb">set</span><span class="p">(</span><span class="n">H</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span>
<span class="go">Complete digraph: Digraph on 9 vertices</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">subgraph</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">D</span>
<span class="go">Subgraph of (Complete digraph): Digraph on 3 vertices</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">subgraph</span><span class="p">()</span> <span class="o">==</span> <span class="n">D</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A more complicated example involving multiple edges and labels:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;not in graph&#39;</span><span class="p">)])</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, &#39;a&#39;), (0, 1, &#39;b&#39;), (0, 1, &#39;c&#39;), (0, 2, &#39;d&#39;)]</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">edges</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, &#39;a&#39;)]</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 1]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">G</span><span class="p">)</span> <span class="o">==</span> <span class="n">G</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;not in graph&#39;</span><span class="p">)])</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, &#39;a&#39;), (0, 1, &#39;b&#39;), (0, 2, &#39;d&#39;)]</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">edges</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, &#39;a&#39;)]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 1]</span>
</pre></div>
</div>
<p>Using the property arguments:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">vertex_property</span><span class="o">=</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="ow">not</span> <span class="p">(</span><span class="n">v</span> <span class="o">%</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 2, 4, 6, 8]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">edge_property</span><span class="o">=</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(&#39;00&#39;, &#39;01&#39;, None), (&#39;00&#39;, &#39;10&#39;, None), (&#39;01&#39;, &#39;11&#39;, None), (&#39;10&#39;, &#39;11&#39;, None)]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(&#39;00&#39;, &#39;01&#39;, None), (&#39;10&#39;, &#39;11&#39;, None)]</span>
</pre></div>
</div>
<p>The algorithm is not specified, then a reasonable choice is made for
speed:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)))</span>  <span class="c1"># uses the &#39;add&#39; algorithm</span>
<span class="go">Subgraph of (Path graph): Graph on 10 vertices</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.subgraph_search">
<span class="sig-name descname"><span class="pre">subgraph_search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">induced</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.subgraph_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of <code class="docutils literal notranslate"><span class="pre">G</span></code> in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – the (di)graph whose copy we are looking for in <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">induced</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether or not to search
for an induced copy of <code class="docutils literal notranslate"><span class="pre">G</span></code> in <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<p>If <code class="docutils literal notranslate"><span class="pre">induced=False</span></code>, return a copy of <code class="docutils literal notranslate"><span class="pre">G</span></code> in this graph.  Otherwise,
return an induced copy of <code class="docutils literal notranslate"><span class="pre">G</span></code> in <code class="docutils literal notranslate"><span class="pre">self</span></code>. If <code class="docutils literal notranslate"><span class="pre">G</span></code> is the empty
graph, return the empty graph since it is a subgraph of every graph. Now
suppose <code class="docutils literal notranslate"><span class="pre">G</span></code> is not the empty graph. If there is no copy (induced or
otherwise) of <code class="docutils literal notranslate"><span class="pre">G</span></code> in <code class="docutils literal notranslate"><span class="pre">self</span></code>, we return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The vertex labels and the edge labels in the graph are ignored.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.subgraph_search_count" title="sage.graphs.generic_graph.GenericGraph.subgraph_search_count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subgraph_search_count()</span></code></a> – counts the number
of copies of <span class="math notranslate nohighlight">\(H\)</span> inside of <span class="math notranslate nohighlight">\(G\)</span></p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.subgraph_search_iterator" title="sage.graphs.generic_graph.GenericGraph.subgraph_search_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subgraph_search_iterator()</span></code></a> – iterator over
the copies of <span class="math notranslate nohighlight">\(H\)</span> inside of <span class="math notranslate nohighlight">\(G\)</span></p></li>
</ul>
</div>
<p>ALGORITHM:</p>
<p>See the documentation of
<a class="reference internal" href="generic_graph_pyx.html#sage.graphs.generic_graph_pyx.SubgraphSearch" title="sage.graphs.generic_graph_pyx.SubgraphSearch"><code class="xref py py-class docutils literal notranslate"><span class="pre">SubgraphSearch</span></code></a>.</p>
<p>EXAMPLES:</p>
<p>The Petersen graph contains the path graph <span class="math notranslate nohighlight">\(P_5\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h1</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">subgraph_search</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span> <span class="n">h1</span>
<span class="go">Subgraph of (Petersen graph): Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">h1</span><span class="o">.</span><span class="n">vertices</span><span class="p">();</span> <span class="n">h1</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 4]</span>
<span class="go">[(0, 1), (1, 2), (2, 3), (3, 4)]</span>
<span class="gp">sage: </span><span class="n">I1</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">subgraph_search</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">induced</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">I1</span>
<span class="go">Subgraph of (Petersen graph): Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">I1</span><span class="o">.</span><span class="n">vertices</span><span class="p">();</span> <span class="n">I1</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 8]</span>
<span class="go">[(0, 1), (1, 2), (2, 3), (3, 8)]</span>
</pre></div>
</div>
<p>It also contains the claw <span class="math notranslate nohighlight">\(K_{1,3}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">subgraph_search</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">ClawGraph</span><span class="p">());</span> <span class="n">h2</span>
<span class="go">Subgraph of (Petersen graph): Graph on 4 vertices</span>
<span class="gp">sage: </span><span class="n">h2</span><span class="o">.</span><span class="n">vertices</span><span class="p">();</span> <span class="n">h2</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[0, 1, 4, 5]</span>
<span class="go">[(0, 1), (0, 4), (0, 5)]</span>
<span class="gp">sage: </span><span class="n">I2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">subgraph_search</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">ClawGraph</span><span class="p">(),</span> <span class="n">induced</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">I2</span>
<span class="go">Subgraph of (Petersen graph): Graph on 4 vertices</span>
<span class="gp">sage: </span><span class="n">I2</span><span class="o">.</span><span class="n">vertices</span><span class="p">();</span> <span class="n">I2</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[0, 1, 4, 5]</span>
<span class="go">[(0, 1), (0, 4), (0, 5)]</span>
</pre></div>
</div>
<p>Of course the induced copies are isomorphic to the graphs we were
looking for:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">I1</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">I2</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">ClawGraph</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
<p>However, the Petersen graph does not contain a subgraph isomorphic to
<span class="math notranslate nohighlight">\(K_3\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">subgraph_search</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Nor does it contain a nonempty induced subgraph isomorphic to <span class="math notranslate nohighlight">\(P_6\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">subgraph_search</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="n">induced</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The empty graph is a subgraph of every graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">subgraph_search</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">EmptyGraph</span><span class="p">())</span>
<span class="go">Graph on 0 vertices</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">subgraph_search</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">EmptyGraph</span><span class="p">(),</span> <span class="n">induced</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Graph on 0 vertices</span>
</pre></div>
</div>
<p>The subgraph may just have edges missing:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">k3</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">k3</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">k3</span><span class="o">.</span><span class="n">subgraph_search</span><span class="p">(</span><span class="n">p3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(&#39;a&#39;, &#39;b&#39;), (&#39;b&#39;, &#39;c&#39;)]</span>
</pre></div>
</div>
<p>Of course, <span class="math notranslate nohighlight">\(P_3\)</span> is not an induced subgraph of <span class="math notranslate nohighlight">\(K_3\)</span>, though:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">k3</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">k3</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">k3</span><span class="o">.</span><span class="n">subgraph_search</span><span class="p">(</span><span class="n">p3</span><span class="p">,</span> <span class="n">induced</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If the graph has labels, the labels are just ignored:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">set_vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">subgraph_search</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">get_vertices</span><span class="p">()</span>
<span class="go">{0: &#39;foo&#39;, 1: None, 2: None, 3: None, 4: None}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.subgraph_search_count">
<span class="sig-name descname"><span class="pre">subgraph_search_count</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">induced</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.subgraph_search_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of labelled occurrences of <code class="docutils literal notranslate"><span class="pre">G</span></code> in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – the (di)graph whose copies we are looking for in <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">induced</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether or not to count
induced copies of <code class="docutils literal notranslate"><span class="pre">G</span></code> in <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The vertex labels and the edge labels in the graph are ignored.</p>
</div>
<p>ALGORITHM:</p>
<p>See the documentation of
<a class="reference internal" href="generic_graph_pyx.html#sage.graphs.generic_graph_pyx.SubgraphSearch" title="sage.graphs.generic_graph_pyx.SubgraphSearch"><code class="xref py py-class docutils literal notranslate"><span class="pre">SubgraphSearch</span></code></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.subgraph_search" title="sage.graphs.generic_graph.GenericGraph.subgraph_search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subgraph_search()</span></code></a> – finds an subgraph
isomorphic to <span class="math notranslate nohighlight">\(H\)</span> inside of a graph <span class="math notranslate nohighlight">\(G\)</span></p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.subgraph_search_iterator" title="sage.graphs.generic_graph.GenericGraph.subgraph_search_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subgraph_search_iterator()</span></code></a> – iterator over
the copies of a graph <span class="math notranslate nohighlight">\(H\)</span> inside of a graph <span class="math notranslate nohighlight">\(G\)</span></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>Counting the number of paths <span class="math notranslate nohighlight">\(P_5\)</span> in a PetersenGraph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">subgraph_search_count</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">240</span>
</pre></div>
</div>
<p>Requiring these subgraphs be induced:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">subgraph_search_count</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">induced</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">120</span>
</pre></div>
</div>
<p>If we define the graph <span class="math notranslate nohighlight">\(T_k\)</span> (the transitive tournament on <span class="math notranslate nohighlight">\(k\)</span> vertices)
as the graph on <span class="math notranslate nohighlight">\(\{0, ..., k-1\}\)</span> such that <span class="math notranslate nohighlight">\(ij \in T_k\)</span> if <span class="math notranslate nohighlight">\(i&lt;j\)</span>, how
many directed triangles can be found in <span class="math notranslate nohighlight">\(T_5\)</span> ? The answer is of course
<span class="math notranslate nohighlight">\(0\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T5</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">TransitiveTournament</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T5</span><span class="o">.</span><span class="n">subgraph_search_count</span><span class="p">(</span><span class="n">digraphs</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">0</span>
</pre></div>
</div>
<p>If we count instead the number of <span class="math notranslate nohighlight">\(T_3\)</span> in <span class="math notranslate nohighlight">\(T_5\)</span>, we expect
the answer to be <span class="math notranslate nohighlight">\(\binom{5}{3}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T3</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">TransitiveTournament</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T5</span><span class="o">.</span><span class="n">subgraph_search_count</span><span class="p">(</span><span class="n">T3</span><span class="p">)</span>
<span class="go">10</span>
<span class="gp">sage: </span><span class="n">binomial</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">10</span>
<span class="gp">sage: </span><span class="n">T3</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">T5</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The empty graph is a subgraph of every graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">subgraph_search_count</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">EmptyGraph</span><span class="p">())</span>
<span class="go">1</span>
</pre></div>
</div>
<p>If the graph has vertex labels or edge labels, the label is just ignored:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">set_vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">subgraph_search_count</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">240</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.subgraph_search_iterator">
<span class="sig-name descname"><span class="pre">subgraph_search_iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">induced</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.subgraph_search_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over the labelled copies of <code class="docutils literal notranslate"><span class="pre">G</span></code> in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – the graph whose copies we are looking for in <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">induced</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether or not to iterate
over the induced copies of <code class="docutils literal notranslate"><span class="pre">G</span></code> in <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The vertex labels and the edge labels in the graph are ignored.</p>
</div>
<p>ALGORITHM:</p>
<p>See the documentation of
<a class="reference internal" href="generic_graph_pyx.html#sage.graphs.generic_graph_pyx.SubgraphSearch" title="sage.graphs.generic_graph_pyx.SubgraphSearch"><code class="xref py py-class docutils literal notranslate"><span class="pre">SubgraphSearch</span></code></a>.</p>
<p>OUTPUT:</p>
<p>Iterator over the labelled copies of <code class="docutils literal notranslate"><span class="pre">G</span></code> in <code class="docutils literal notranslate"><span class="pre">self</span></code>, as <em>lists</em>. For
each value <span class="math notranslate nohighlight">\((v_1, v_2, ..., v_k)\)</span> returned, the first vertex of <span class="math notranslate nohighlight">\(G\)</span> is
associated with <span class="math notranslate nohighlight">\(v_1\)</span>, the second with <span class="math notranslate nohighlight">\(v_2\)</span>, etc.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method also works on digraphs.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.subgraph_search" title="sage.graphs.generic_graph.GenericGraph.subgraph_search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subgraph_search()</span></code></a> – finds an subgraph
isomorphic to <span class="math notranslate nohighlight">\(H\)</span> inside of <span class="math notranslate nohighlight">\(G\)</span></p></li>
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.subgraph_search_count" title="sage.graphs.generic_graph.GenericGraph.subgraph_search_count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subgraph_search_count()</span></code></a> – counts the number
of copies of <span class="math notranslate nohighlight">\(H\)</span> inside of <span class="math notranslate nohighlight">\(G\)</span></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>Iterating through all the labelled <span class="math notranslate nohighlight">\(P_3\)</span> of <span class="math notranslate nohighlight">\(P_5\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">subgraph_search_iterator</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">[0, 1, 2]</span>
<span class="go">[1, 2, 3]</span>
<span class="go">[2, 1, 0]</span>
<span class="go">[2, 3, 4]</span>
<span class="go">[3, 2, 1]</span>
<span class="go">[4, 3, 2]</span>
</pre></div>
</div>
<p>If the graph has vertex labels or edge labels, the label is just ignored:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">set_vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">subgraph_search_iterator</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">[0, 1, 2]</span>
<span class="go">[1, 2, 3]</span>
<span class="go">[2, 1, 0]</span>
<span class="go">[2, 3, 4]</span>
<span class="go">[3, 2, 1]</span>
<span class="go">[4, 3, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.symmetric_edge_polytope">
<span class="sig-name descname"><span class="pre">symmetric_edge_polytope</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.symmetric_edge_polytope" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the symmetric edge polytope of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The symmetric edge polytope (SEP) of a Graph on <span class="math notranslate nohighlight">\(n\)</span> vertices
is the polytope in <span class="math notranslate nohighlight">\(\ZZ^{n}\)</span> defined as the convex hull of
<span class="math notranslate nohighlight">\(e_i - e_j\)</span> and <span class="math notranslate nohighlight">\(e_j - e_i\)</span> for each edge <span class="math notranslate nohighlight">\((i, j)\)</span>.
Here <span class="math notranslate nohighlight">\(e_1, \dots, e_n\)</span> denotes the standard basis.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">backend</span></code> – string or <code class="docutils literal notranslate"><span class="pre">None</span></code> (default); the backend to use;
see <code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.geometry.polyhedron.constructor.Polyhedron()</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<p>The SEP of a <span class="math notranslate nohighlight">\(4\)</span>-cycle is a cube:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">symmetric_edge_polytope</span><span class="p">();</span> <span class="n">P</span>
<span class="go">A 3-dimensional polyhedron in ZZ^4 defined as the convex hull of 8 vertices</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_combinatorially_isomorphic</span><span class="p">(</span><span class="n">polytopes</span><span class="o">.</span><span class="n">cube</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The SEP of a complete graph on <span class="math notranslate nohighlight">\(4\)</span> vertices is a cuboctahedron:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">symmetric_edge_polytope</span><span class="p">();</span> <span class="n">P</span>
<span class="go">A 3-dimensional polyhedron in ZZ^4 defined as the convex hull of 12 vertices</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_combinatorially_isomorphic</span><span class="p">(</span><span class="n">polytopes</span><span class="o">.</span><span class="n">cuboctahedron</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The SEP of a graph with edges on <span class="math notranslate nohighlight">\(n\)</span> vertices has dimension <span class="math notranslate nohighlight">\(n\)</span>
minus the number of connected components:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">while</span> <span class="ow">not</span> <span class="n">G</span><span class="o">.</span><span class="n">num_edges</span><span class="p">():</span>
<span class="gp">....: </span>    <span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">symmetric_edge_polytope</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">ambient_dim</span><span class="p">()</span> <span class="o">==</span> <span class="n">n</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="n">G</span><span class="o">.</span><span class="n">connected_components_number</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The SEP of a graph is isomorphic to the subdirect sum of
its connected components SEP’s:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G1</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G2</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">G1</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">G2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">symmetric_edge_polytope</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">G1</span><span class="o">.</span><span class="n">symmetric_edge_polytope</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">G2</span><span class="o">.</span><span class="n">symmetric_edge_polytope</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_combinatorially_isomorphic</span><span class="p">(</span><span class="n">P1</span><span class="o">.</span><span class="n">subdirect_sum</span><span class="p">(</span><span class="n">P2</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>All trees on <span class="math notranslate nohighlight">\(n\)</span> vertices have isomorphic SEPs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G1</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomTree</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G2</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomTree</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">G1</span><span class="o">.</span><span class="n">symmetric_edge_polytope</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">G2</span><span class="o">.</span><span class="n">symmetric_edge_polytope</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P1</span><span class="o">.</span><span class="n">is_combinatorially_isomorphic</span><span class="p">(</span><span class="n">P2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>However, there are still many different SEPs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">graphs</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span>
<span class="go">34</span>
<span class="gp">sage: </span><span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">G</span> <span class="ow">in</span> <span class="n">graphs</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">P</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">symmetric_edge_polytope</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">P1</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="n">P</span><span class="o">.</span><span class="n">is_combinatorially_isomorphic</span><span class="p">(</span><span class="n">P1</span><span class="p">):</span>
<span class="gp">....: </span>            <span class="k">break</span>
<span class="gp">....: </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="gp">....:</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span>
<span class="go">25</span>
</pre></div>
</div>
<p>A non-trivial example of two graphs with isomorphic SEPs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G1</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G1</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">G2</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">G1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G1</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">G2</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">G1</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">G2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">G1</span><span class="o">.</span><span class="n">symmetric_edge_polytope</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">G2</span><span class="o">.</span><span class="n">symmetric_edge_polytope</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P1</span><span class="o">.</span><span class="n">is_combinatorially_isomorphic</span><span class="p">(</span><span class="n">P2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Apparently, glueing two graphs together on a vertex
gives isomorphic SEPs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g1</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g2</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">g1</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">g2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">merge_vertices</span><span class="p">(((</span><span class="mi">0</span><span class="p">,</span> <span class="n">randrange</span><span class="p">(</span><span class="n">n</span><span class="p">)),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">randrange</span><span class="p">(</span><span class="n">n</span><span class="p">))))</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">merge_vertices</span><span class="p">(((</span><span class="mi">0</span><span class="p">,</span> <span class="n">randrange</span><span class="p">(</span><span class="n">n</span><span class="p">)),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">randrange</span><span class="p">(</span><span class="n">n</span><span class="p">))))</span>
<span class="gp">sage: </span><span class="n">PG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">symmetric_edge_polytope</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">PH</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">symmetric_edge_polytope</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">PG</span><span class="o">.</span><span class="n">is_combinatorially_isomorphic</span><span class="p">(</span><span class="n">PH</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.szeged_index">
<span class="sig-name descname"><span class="pre">szeged_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.szeged_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Szeged index of the graph <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>Let <span class="math notranslate nohighlight">\(G = (V, E)\)</span> be a connected graph, and for any <span class="math notranslate nohighlight">\(uv\in E\)</span>, let <span class="math notranslate nohighlight">\(N_u(uv) =
\{w\in V:d(u,w)&lt;d(v,w)\}\)</span> and <span class="math notranslate nohighlight">\(n_u(uv)=|N_u(uv)|\)</span>. The Szeged index of <span class="math notranslate nohighlight">\(G\)</span>
is then defined as <a class="reference internal" href="../../../references/index.html#krg1996" id="id42"><span>[KRG1996]</span></a></p>
<div class="math notranslate nohighlight">
\[`\sum_{uv \in E(G)}n_u(uv)\times n_v(uv)`\]</div>
<p>See the <a class="reference external" href="https://en.wikipedia.org/wiki/Szeged_index">Wikipedia article Szeged_index</a> for more details.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a Sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); algorithm to use among:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;low&quot;</span></code> – algorithm with time complexity in <span class="math notranslate nohighlight">\(O(nm)\)</span> and space
complexity in <span class="math notranslate nohighlight">\(O(m)\)</span>. This implementation is currently valid only for
simple (without loops or multiple edges) connected graphs.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;high&quot;</span></code> – algorithm with time complexity in <span class="math notranslate nohighlight">\(O(nm)\)</span> and space
complexity in <span class="math notranslate nohighlight">\(O(n^2)\)</span>. It cannot be used on graphs with more than
<span class="math notranslate nohighlight">\(65536 = 2^{16}\)</span> vertices.</p></li>
</ul>
<p>By default (<code class="docutils literal notranslate"><span class="pre">None</span></code>), the <code class="docutils literal notranslate"><span class="pre">&quot;low&quot;</span></code> algorithm is used for graphs and the
<code class="docutils literal notranslate"><span class="pre">&quot;high&quot;</span></code> algorithm for digraphs.</p>
</li>
</ul>
<p>EXAMPLES:</p>
<p>True for any connected graph <a class="reference internal" href="../../../references/index.html#krg1996" id="id43"><span>[KRG1996]</span></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.distances_all_pairs</span> <span class="kn">import</span> <span class="n">szeged_index</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">wiener_index</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">szeged_index</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>True for all trees <a class="reference internal" href="../../../references/index.html#krg1996" id="id44"><span>[KRG1996]</span></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">wiener_index</span><span class="p">()</span> <span class="o">==</span> <span class="n">szeged_index</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Check that both algorithms return same value:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomBarabasiAlbert</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># long time</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">szeged_index</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;low&#39;</span><span class="p">)</span>  <span class="c1"># long time</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">szeged_index</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;high&#39;</span><span class="p">)</span>  <span class="c1"># long time</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span>  <span class="c1"># long time</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Szeged index of a directed circuit of order <span class="math notranslate nohighlight">\(n\)</span> is <span class="math notranslate nohighlight">\((n-1)^2\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">digraphs</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">szeged_index</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)]</span>
<span class="go">[0, 1, 4, 9, 16, 25, 36]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.tensor_product">
<span class="sig-name descname"><span class="pre">tensor_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.tensor_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the tensor product of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>The tensor product of <span class="math notranslate nohighlight">\(G\)</span> and <span class="math notranslate nohighlight">\(H\)</span> is the graph <span class="math notranslate nohighlight">\(L\)</span> with vertex set
<span class="math notranslate nohighlight">\(V(L)\)</span> equal to the Cartesian product of the vertices <span class="math notranslate nohighlight">\(V(G)\)</span> and <span class="math notranslate nohighlight">\(V(H)\)</span>,
and <span class="math notranslate nohighlight">\(((u,v), (w,x))\)</span> is an edge iff - <span class="math notranslate nohighlight">\((u, w)\)</span> is an edge of self, and -
<span class="math notranslate nohighlight">\((v, x)\)</span> is an edge of other.</p>
<p>The tensor product is also known as the categorical product and the
Kronecker product (referring to the Kronecker matrix product). See
the <a class="reference external" href="https://en.wikipedia.org/wiki/Kronecker_product">Wikipedia article Kronecker_product</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">tensor_product</span><span class="p">(</span><span class="n">Z</span><span class="p">);</span> <span class="n">T</span>
<span class="go">Graph on 10 vertices</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">10</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span> <span class="c1"># long time</span>
<span class="go">Graphics object consisting of 21 graphics primitives</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">tensor_product</span><span class="p">(</span><span class="n">P</span><span class="p">);</span> <span class="n">T</span>
<span class="go">Graph on 200 vertices</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">900</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span> <span class="c1"># long time</span>
<span class="go">Graphics object consisting of 1101 graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.to_dictionary">
<span class="sig-name descname"><span class="pre">to_dictionary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multiple_edges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.to_dictionary" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the graph as a dictionary.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">edge_labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to include
edge labels in the output</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">multiple_edges</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to include
multiple edges in the output</p></li>
</ul>
<p>OUTPUT:</p>
<p>The output depends on the input:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">edge_labels</span> <span class="pre">==</span> <span class="pre">False</span></code> and <code class="docutils literal notranslate"><span class="pre">multiple_edges</span> <span class="pre">==</span> <span class="pre">False</span></code>, the
output is a dictionary associating to each vertex the list of its
neighbors.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">edge_labels</span> <span class="pre">==</span> <span class="pre">False</span></code> and <code class="docutils literal notranslate"><span class="pre">multiple_edges</span> <span class="pre">==</span> <span class="pre">True</span></code>, the output
is a dictionary the same as previously with one difference: the
neighbors are listed with multiplicity.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">edge_labels</span> <span class="pre">==</span> <span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">multiple_edges</span> <span class="pre">==</span> <span class="pre">False</span></code>, the output
is a dictionary associating to each vertex <span class="math notranslate nohighlight">\(u\)</span> [a dictionary
associating to each vertex <span class="math notranslate nohighlight">\(v\)</span> incident to <span class="math notranslate nohighlight">\(u\)</span> the label of edge
<span class="math notranslate nohighlight">\((u,v)\)</span>].</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">edge_labels</span> <span class="pre">==</span> <span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">multiple_edges</span> <span class="pre">==</span> <span class="pre">True</span></code>, the output
is a dictionary associating to each vertex <span class="math notranslate nohighlight">\(u\)</span> [a dictionary
associating to each vertex <span class="math notranslate nohighlight">\(v\)</span> incident to <span class="math notranslate nohighlight">\(u\)</span> [the list of labels of
all edges between <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span>]].</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When used on directed graphs, the explanations above can be
understood by replacing the word “neighbors” by “out-neighbors”</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">to_dictionary</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[(</span><span class="n">key</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">g</span><span class="p">]</span>
<span class="go">[(0, [1, 4, 5]),</span>
<span class="go"> (1, [0, 2, 6]),</span>
<span class="go"> (2, [1, 3, 7]),</span>
<span class="go"> (3, [2, 4, 8]),</span>
<span class="go"> (4, [0, 3, 9]),</span>
<span class="go"> (5, [0, 7, 8]),</span>
<span class="go"> (6, [1, 8, 9]),</span>
<span class="go"> (7, [2, 5, 9]),</span>
<span class="go"> (8, [3, 5, 6]),</span>
<span class="go"> (9, [4, 6, 7])]</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">to_dictionary</span><span class="p">(</span><span class="n">multiple_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{0: [1, 4, 5], 1: [0, 2, 6],</span>
<span class="go"> 2: [1, 3, 7], 3: [2, 4, 8],</span>
<span class="go"> 4: [0, 3, 9], 5: [0, 7, 8],</span>
<span class="go"> 6: [1, 8, 9], 7: [2, 5, 9],</span>
<span class="go"> 8: [3, 5, 6], 9: [4, 6, 7]}</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">to_dictionary</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{0: {1: None, 4: None, 5: None},</span>
<span class="go"> 1: {0: None, 2: None, 6: None},</span>
<span class="go"> 2: {1: None, 3: None, 7: None},</span>
<span class="go"> 3: {2: None, 4: None, 8: None},</span>
<span class="go"> 4: {0: None, 3: None, 9: None},</span>
<span class="go"> 5: {0: None, 7: None, 8: None},</span>
<span class="go"> 6: {1: None, 8: None, 9: None},</span>
<span class="go"> 7: {2: None, 5: None, 9: None},</span>
<span class="go"> 8: {3: None, 5: None, 6: None},</span>
<span class="go"> 9: {4: None, 6: None, 7: None}}</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">to_dictionary</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">multiple_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{0: {1: [None], 4: [None], 5: [None]},</span>
<span class="go"> 1: {0: [None], 2: [None], 6: [None]},</span>
<span class="go"> 2: {1: [None], 3: [None], 7: [None]},</span>
<span class="go"> 3: {2: [None], 4: [None], 8: [None]},</span>
<span class="go"> 4: {0: [None], 3: [None], 9: [None]},</span>
<span class="go"> 5: {0: [None], 7: [None], 8: [None]},</span>
<span class="go"> 6: {1: [None], 8: [None], 9: [None]},</span>
<span class="go"> 7: {2: [None], 5: [None], 9: [None]},</span>
<span class="go"> 8: {3: [None], 5: [None], 6: [None]},</span>
<span class="go"> 9: {4: [None], 6: [None], 7: [None]}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.to_simple">
<span class="sig-name descname"><span class="pre">to_simple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">to_undirected</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'any'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">immutable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.to_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a simple version of the <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>In particular, loops and multiple edges are removed, and the graph might
optionally be converted to an undirected graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">to_undirected</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, the
graph is also converted to an undirected graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">keep_label</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">'any'</span></code>); if there are multiple
edges with different labels, this variable defines which label should
be kept:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'any'</span></code> – any label</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'min'</span></code> – the smallest label</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'max'</span></code> – the largest label</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="docutils literal notranslate"><span class="pre">'min'</span></code> and <code class="docutils literal notranslate"><span class="pre">'max'</span></code> only works if the labels can be compared. A
<code class="docutils literal notranslate"><span class="pre">TypeError</span></code> might be raised when working with non-comparable
objects in Python 3.</p>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">immutable</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">Non</span></code>); whether to create a
mutable/immutable copy. <code class="docutils literal notranslate"><span class="pre">immutable=None</span></code> (default) means that the
graph and its copy will behave the same way.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(0, 0), (1, 1), (2, 2), (2, 3), (2, 3), (3, 2)]</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">to_simple</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(2, 3)]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">is_directed</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">allows_loops</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">allows_multiple_edges</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">to_simple</span><span class="p">(</span><span class="n">to_undirected</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keep_label</span><span class="o">=</span><span class="s1">&#39;min&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(2, 3, 1), (3, 2, None)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">to_simple</span><span class="p">(</span><span class="n">to_undirected</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keep_label</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(2, 3, 2), (3, 2, None)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.transitive_closure">
<span class="sig-name descname"><span class="pre">transitive_closure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.transitive_closure" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the transitive closure of the (di)graph.</p>
<p>The transitive closure of a graph <span class="math notranslate nohighlight">\(G\)</span> has an edge <span class="math notranslate nohighlight">\((x, y)\)</span> if and only
if there is a path between <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> in <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>The transitive closure of any (strongly) connected component of a
(di)graph is a complete graph. The transitive closure of a directed
acyclic graph is a directed acyclic graph representing the full partial
order.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the (di)graph allows loops, its transitive closure will by
default have one loop edge per vertex. This can be prevented by
disallowing loops in the (di)graph (<code class="docutils literal notranslate"><span class="pre">self.allow_loops(False)</span></code>).</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">transitive_closure</span><span class="p">()</span>
<span class="go">Transitive closure of Path graph: Graph on 4 vertices</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">transitive_closure</span><span class="p">()</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">transitive_closure</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 3), (2, 4), (2, 5)]</span>
</pre></div>
</div>
<p>On an immutable digraph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">digraphs</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">immutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">transitive_closure</span><span class="p">()</span>
<span class="go">Transitive closure of Path: Digraph on 5 vertices</span>
</pre></div>
</div>
<p>The transitive closure of a (di)graph allowing loops has by default a
loop edge per vertex. Parameter <code class="docutils literal notranslate"><span class="pre">loops</span></code> allows to prevent that:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">transitive_closure</span><span class="p">()</span><span class="o">.</span><span class="n">loop_edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_loops</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">transitive_closure</span><span class="p">()</span><span class="o">.</span><span class="n">loop_edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(0, 0), (1, 1), (2, 2)]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">transitive_closure</span><span class="p">()</span><span class="o">.</span><span class="n">loop_edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_loops</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">transitive_closure</span><span class="p">()</span><span class="o">.</span><span class="n">loop_edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(0, 0), (1, 1), (2, 2)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.transitive_reduction">
<span class="sig-name descname"><span class="pre">transitive_reduction</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.transitive_reduction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a transitive reduction of a graph.</p>
<p>A transitive reduction <span class="math notranslate nohighlight">\(H\)</span> of <span class="math notranslate nohighlight">\(G\)</span> has a path from <span class="math notranslate nohighlight">\(x\)</span> to <span class="math notranslate nohighlight">\(y\)</span> if and only
if there was a path from <span class="math notranslate nohighlight">\(x\)</span> to <span class="math notranslate nohighlight">\(y\)</span> in <span class="math notranslate nohighlight">\(G\)</span>. Deleting any edge of <span class="math notranslate nohighlight">\(H\)</span>
destroys this property. A transitive reduction is not unique in
general. A transitive reduction has the same transitive closure as the
original graph.</p>
<p>A transitive reduction of a complete graph is a tree. A transitive
reduction of a tree is itself.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">transitive_reduction</span><span class="p">()</span> <span class="o">==</span> <span class="n">g</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">transitive_reduction</span><span class="p">();</span> <span class="n">h</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">transitive_reduction</span><span class="p">()</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.traveling_salesman_problem">
<span class="sig-name descname"><span class="pre">traveling_salesman_problem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">use_edge_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraint_generation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.traveling_salesman_problem" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the traveling salesman problem (TSP)</p>
<p>Given a graph (resp. a digraph) <span class="math notranslate nohighlight">\(G\)</span> with weighted edges, the traveling
salesman problem consists in finding a Hamiltonian cycle (resp. circuit)
of the graph of minimum cost.</p>
<p>This TSP is one of the most famous NP-Complete problems, this function
can thus be expected to take some time before returning its result.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">use_edge_labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to solve
the weighted traveling salesman problem where the weight of an edge is
defined by its label (a label set to <code class="docutils literal notranslate"><span class="pre">None</span></code> or <code class="docutils literal notranslate"><span class="pre">{}</span></code> being
considered as a weight of <span class="math notranslate nohighlight">\(1\)</span>), or the non-weighted version (i.e., the
Hamiltonian cycle problem)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">maximize</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to compute a
minimum (default) or a maximum (when <code class="docutils literal notranslate"><span class="pre">maximize</span> <span class="pre">==</span> <span class="pre">True</span></code>) weight tour
(or Hamiltonian cycle). This parameter is considered only if
<code class="docutils literal notranslate"><span class="pre">use_edge_labels</span> <span class="pre">==</span> <span class="pre">True</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">constraint_generation</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); whether to
use constraint generation when solving the Mixed Integer Linear
Program.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">constraint_generation</span> <span class="pre">=</span> <span class="pre">None</span></code>, constraint generation is used
whenever the graph has a density larger than 70%.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose_constraints</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to
display which constraints are being generated</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A solution to the TSP, as a <code class="docutils literal notranslate"><span class="pre">Graph</span></code> object whose vertex set is <span class="math notranslate nohighlight">\(V(G)\)</span>,
and whose edges are only those of the solution.</p>
<p>ALGORITHM:</p>
<p>This optimization problem is solved through the use of Linear
Programming.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is correctly defined for both graph and digraphs. In
the second case, the returned cycle is a circuit of optimal cost.</p>
</div>
<p>EXAMPLES:</p>
<p>The Heawood graph is known to be Hamiltonian:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">HeawoodGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">tsp</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">traveling_salesman_problem</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">tsp</span>
<span class="go">TSP from Heawood graph: Graph on 14 vertices</span>
</pre></div>
</div>
<p>The solution to the TSP has to be connected:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">tsp</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>It must also be a <span class="math notranslate nohighlight">\(2\)</span>-regular graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">tsp</span><span class="o">.</span><span class="n">is_regular</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>And obviously it is a subgraph of the Heawood graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">tsp</span><span class="o">.</span><span class="n">is_subgraph</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">induced</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>On the other hand, the Petersen Graph is known not to be Hamiltonian:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">tsp</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">traveling_salesman_problem</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">EmptySetError: the given graph is not Hamiltonian</span>
</pre></div>
</div>
<p>One easy way to change it is obviously to add to this graph the edges
corresponding to a Hamiltonian cycle. If we do this by setting the cost
of these new edges to <span class="math notranslate nohighlight">\(2\)</span>, while the others are set to <span class="math notranslate nohighlight">\(1\)</span>, we notice
that not all the edges we added are used in the optimal solution</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">....: </span>   <span class="n">g</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="gp">sage: </span><span class="n">cycle</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">cycle</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="gp">....: </span>   <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="gp">....: </span>       <span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="gp">....: </span>   <span class="n">g</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="gp">sage: </span><span class="n">tsp</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">traveling_salesman_problem</span><span class="p">(</span><span class="n">use_edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sum</span><span class="p">(</span> <span class="n">tsp</span><span class="o">.</span><span class="n">edge_labels</span><span class="p">()</span> <span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">10</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If we pick <span class="math notranslate nohighlight">\(1/2\)</span> instead of <span class="math notranslate nohighlight">\(2\)</span> as a cost for these new edges, they
clearly become the optimal solution:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cycle</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="gp">....: </span>   <span class="n">g</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

<span class="gp">sage: </span><span class="n">tsp</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">traveling_salesman_problem</span><span class="p">(</span><span class="n">use_edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sum</span><span class="p">(</span><span class="n">tsp</span><span class="o">.</span><span class="n">edge_labels</span><span class="p">())</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Search for a minimum and a maximum weight Hamiltonian cycle:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">tsp</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">traveling_salesman_problem</span><span class="p">(</span><span class="n">use_edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">maximize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">tsp</span><span class="o">.</span><span class="n">edge_labels</span><span class="p">()))</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">tsp</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">traveling_salesman_problem</span><span class="p">(</span><span class="n">use_edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">maximize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">tsp</span><span class="o">.</span><span class="n">edge_labels</span><span class="p">()))</span>
<span class="go">6</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.triangles_count">
<span class="sig-name descname"><span class="pre">triangles_count</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.triangles_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of triangles in the (di)graph.</p>
<p>For digraphs, we count the number of directed circuit of length 3.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specifies the algorithm
to use (note that only <code class="docutils literal notranslate"><span class="pre">'iter'</span></code> is available for directed graphs):</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'sparse_copy'</span></code> – counts the triangles in a sparse copy of the
graph (see <a class="reference internal" href="base/static_sparse_graph.html#module-sage.graphs.base.static_sparse_graph" title="sage.graphs.base.static_sparse_graph"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.graphs.base.static_sparse_graph</span></code></a>). Calls
<a class="reference internal" href="base/static_sparse_graph.html#sage.graphs.base.static_sparse_graph.triangles_count" title="sage.graphs.base.static_sparse_graph.triangles_count"><code class="xref py py-func docutils literal notranslate"><span class="pre">static_sparse_graph.triangles_count</span></code></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'dense_copy'</span></code> – counts the triangles in a dense copy of the
graph (see <a class="reference internal" href="base/static_dense_graph.html#module-sage.graphs.base.static_dense_graph" title="sage.graphs.base.static_dense_graph"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.graphs.base.static_dense_graph</span></code></a>). Calls
<a class="reference internal" href="base/static_dense_graph.html#sage.graphs.base.static_dense_graph.triangles_count" title="sage.graphs.base.static_dense_graph.triangles_count"><code class="xref py py-func docutils literal notranslate"><span class="pre">static_dense_graph.triangles_count</span></code></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'matrix'</span></code> uses the trace of the cube of the adjacency matrix</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'iter'</span></code> iterates over the pairs of neighbors of each vertex. No
copy of the graph is performed</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> – for undirected graphs, uses <code class="docutils literal notranslate"><span class="pre">&quot;sparse_copy&quot;</span></code> or
<code class="docutils literal notranslate"><span class="pre">&quot;dense_copy&quot;</span></code> depending on whether the graph is stored as dense
or sparse. For directed graphs, uses <code class="docutils literal notranslate"><span class="pre">'iter'</span></code>.</p></li>
</ul>
</li>
</ul>
<p>EXAMPLES:</p>
<p>The Petersen graph is triangle free and thus:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">triangles_count</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Any triple of vertices in the complete graph induces a triangle so we
have:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">triangles_count</span><span class="p">()</span> <span class="o">==</span> <span class="n">binomial</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The 2-dimensional DeBruijn graph of 2 symbols has 2 directed <span class="math notranslate nohighlight">\(C_3\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">DeBruijn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">triangles_count</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
<p>The directed <span class="math notranslate nohighlight">\(n\)</span>-cycle is trivially triangle free for <span class="math notranslate nohighlight">\(n &gt; 3\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">triangles_count</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.union">
<span class="sig-name descname"><span class="pre">union</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">immutable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the union of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>If the graphs have common vertices, the common vertices will be
identified.</p>
<p>If one of the two graphs allows loops (or multiple edges), the resulting
graph will allow loops (or multiple edges).</p>
<p>If both graphs are weighted the resulting graphs is weighted.</p>
<p>If both graphs are immutable, the resulting graph is immutable, unless
requested otherwise.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">immutable</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); whether to create a
mutable/immutable union. <code class="docutils literal notranslate"><span class="pre">immutable=None</span></code> (default) means that the
graphs and their union will behave the same way.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.disjoint_union" title="sage.graphs.generic_graph.GenericGraph.disjoint_union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">disjoint_union()</span></code></a></p></li>
<li><p><a class="reference internal" href="graph.html#sage.graphs.graph.Graph.join" title="sage.graphs.graph.Graph.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">H</span><span class="p">);</span> <span class="n">J</span>
<span class="go">Graph on 4 vertices</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(0, 1), (0, 2), (0, 3), (1, 2), (2, 3)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.vertex_boundary">
<span class="sig-name descname"><span class="pre">vertex_boundary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.vertex_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of all vertices in the external boundary of <code class="docutils literal notranslate"><span class="pre">vertices1</span></code>,
intersected with <code class="docutils literal notranslate"><span class="pre">vertices2</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">vertices2</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, then <code class="docutils literal notranslate"><span class="pre">vertices2</span></code> is the complement of
<code class="docutils literal notranslate"><span class="pre">vertices1</span></code>. This is much faster if <code class="docutils literal notranslate"><span class="pre">vertices1</span></code> is smaller than
<code class="docutils literal notranslate"><span class="pre">vertices2</span></code>.</p>
<p>The external boundary of a set of vertices is the union of the
neighborhoods of each vertex in the set. Note that in this
implementation, since <code class="docutils literal notranslate"><span class="pre">vertices2</span></code> defaults to the complement of
<code class="docutils literal notranslate"><span class="pre">vertices1</span></code>, if a vertex <span class="math notranslate nohighlight">\(v\)</span> has a loop, then <code class="docutils literal notranslate"><span class="pre">vertex_boundary(v)</span></code>
will not contain <span class="math notranslate nohighlight">\(v\)</span>.</p>
<p>In a digraph, the external boundary of a vertex <span class="math notranslate nohighlight">\(v\)</span> are those vertices
<span class="math notranslate nohighlight">\(u\)</span> with an arc <span class="math notranslate nohighlight">\((v, u)\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;0111&#39;</span><span class="p">,</span> <span class="s1">&#39;0000&#39;</span><span class="p">,</span> <span class="s1">&#39;0001&#39;</span><span class="p">,</span> <span class="s1">&#39;0011&#39;</span><span class="p">,</span> <span class="s1">&#39;0010&#39;</span><span class="p">,</span> <span class="s1">&#39;0101&#39;</span><span class="p">,</span> <span class="s1">&#39;0100&#39;</span><span class="p">,</span> <span class="s1">&#39;1111&#39;</span><span class="p">,</span> <span class="s1">&#39;1101&#39;</span><span class="p">,</span> <span class="s1">&#39;1011&#39;</span><span class="p">,</span> <span class="s1">&#39;1001&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">vertex_boundary</span><span class="p">([</span><span class="s1">&#39;0000&#39;</span><span class="p">,</span> <span class="s1">&#39;1111&#39;</span><span class="p">],</span> <span class="n">l</span><span class="p">))</span>
<span class="go">[&#39;0001&#39;, &#39;0010&#39;, &#39;0100&#39;, &#39;0111&#39;, &#39;1011&#39;, &#39;1101&#39;]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">vertex_boundary</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[1, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.vertex_connectivity">
<span class="sig-name descname"><span class="pre">vertex_connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.vertex_connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex connectivity of the graph.</p>
<p>For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Connectivity_(graph_theory)">Wikipedia article Connectivity_(graph_theory)</a> and
the <a class="reference external" href="https://en.wikipedia.org/wiki/K-vertex-connected_graph">Wikipedia article K-vertex-connected_graph</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>When the graph is directed, this method actually computes the <em>strong</em>
connectivity, (i.e. a directed graph is strongly <span class="math notranslate nohighlight">\(k\)</span>-connected if
there are <span class="math notranslate nohighlight">\(k\)</span> vertex disjoint paths between any two vertices <span class="math notranslate nohighlight">\(u,
v\)</span>). If you do not want to consider strong connectivity, the best is
probably to convert your <code class="docutils literal notranslate"><span class="pre">DiGraph</span></code> object to a <code class="docutils literal notranslate"><span class="pre">Graph</span></code> object, and
compute the connectivity of this other graph.</p></li>
<li><p>By convention, a complete graph on <span class="math notranslate nohighlight">\(n\)</span> vertices is <span class="math notranslate nohighlight">\(n-1\)</span> connected. In
this case, no certificate can be given as there is no pair of vertices
split by a cut of order <span class="math notranslate nohighlight">\(k-1\)</span>. For this reason, the certificates
returned in this situation are empty.</p></li>
</ul>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – the input Sage (Di)Graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value_only</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<ul>
<li><p>When set to <code class="docutils literal notranslate"><span class="pre">True</span></code> (default), only the value is returned.</p></li>
<li><p>When set to <code class="docutils literal notranslate"><span class="pre">False</span></code>, both the value and a minimum vertex cut are
returned.</p></li>
</ul>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sets</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to also return the two</dt><dd><p>sets of vertices that are disconnected by the cut (implies
<code class="docutils literal notranslate"><span class="pre">value_only=False</span></code>)</p>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); when specified, check if the vertex
connectivity of the (di)graph is larger or equal to <span class="math notranslate nohighlight">\(k\)</span>. The method thus
outputs a boolean only.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer Linear
Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one
is used. For more information on MILP solvers and which default solver is
used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of verbosity. Set
to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP solvers
over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>A basic application on a <code class="docutils literal notranslate"><span class="pre">PappusGraph</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.connectivity</span> <span class="kn">import</span> <span class="n">vertex_connectivity</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">PappusGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">vertex_connectivity</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">vertex_connectivity</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>In a grid, the vertex connectivity is equal to the minimum degree, in which
case one of the two sets is of cardinality <span class="math notranslate nohighlight">\(1\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">GridGraph</span><span class="p">([</span> <span class="mi">3</span><span class="p">,</span><span class="mi">3</span> <span class="p">])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">value</span><span class="p">,</span> <span class="n">cut</span><span class="p">,</span> <span class="p">[</span> <span class="n">setA</span><span class="p">,</span> <span class="n">setB</span> <span class="p">]]</span> <span class="o">=</span> <span class="n">vertex_connectivity</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">sets</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">setA</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">setB</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A vertex cut in a tree is any internal vertex:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">tree</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomTree</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">val</span><span class="p">,</span> <span class="p">[</span><span class="n">cut_vertex</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertex_connectivity</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">value_only</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">tree</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">cut_vertex</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
<span class="go">True</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">value_only</span> <span class="pre">=</span> <span class="pre">True</span></code>, this function is optimized for small
connectivity values and does not need to build a linear program.</p>
<p>It is the case for connected graphs which are not connected:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">vertex_connectivity</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Or if they are just 1-connected:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">vertex_connectivity</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>For directed graphs, the strong connectivity is tested through the dedicated
function:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">ButterflyGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">vertex_connectivity</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>A complete graph on <span class="math notranslate nohighlight">\(10\)</span> vertices is <span class="math notranslate nohighlight">\(9\)</span>-connected:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">vertex_connectivity</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">9</span>
</pre></div>
</div>
<p>A complete digraph on <span class="math notranslate nohighlight">\(10\)</span> vertices is <span class="math notranslate nohighlight">\(9\)</span>-connected:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">vertex_connectivity</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">9</span>
</pre></div>
</div>
<p>When parameter <code class="docutils literal notranslate"><span class="pre">k</span></code> is set, we only check for the existence of a vertex cut
of order at least <code class="docutils literal notranslate"><span class="pre">k</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PappusGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">vertex_connectivity</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">vertex_connectivity</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.vertex_cut">
<span class="sig-name descname"><span class="pre">vertex_cut</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_only</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.vertex_cut" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a minimum vertex cut between non-adjacent vertices <span class="math notranslate nohighlight">\(s\)</span> and <span class="math notranslate nohighlight">\(t\)</span>
represented by a list of vertices.</p>
<p>A vertex cut between two non-adjacent vertices is a set <span class="math notranslate nohighlight">\(U\)</span> of vertices
of <code class="docutils literal notranslate"><span class="pre">self</span></code> such that the graph obtained by removing <span class="math notranslate nohighlight">\(U\)</span> from <code class="docutils literal notranslate"><span class="pre">self</span></code>
is disconnected. For more information, see the
<a class="reference external" href="https://en.wikipedia.org/wiki/Cut_(graph_theory)">Wikipedia article Cut_(graph_theory)</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">value_only</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether to return only
the size of the minimum cut, or to also return the set <span class="math notranslate nohighlight">\(U\)</span> of vertices
of the cut</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to also return
the two sets of vertices that are disconnected by the cut. Implies
<code class="docutils literal notranslate"><span class="pre">value_only</span></code> set to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>Real number or tuple, depending on the given arguments
(examples are given below).</p>
<p>EXAMPLES:</p>
<p>A basic application in the Pappus graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PappusGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">vertex_cut</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">value_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>In the bipartite complete graph <span class="math notranslate nohighlight">\(K_{2,8}\)</span>, a cut between the two
vertices in the size <span class="math notranslate nohighlight">\(2\)</span> part consists of the other <span class="math notranslate nohighlight">\(8\)</span> vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">value</span><span class="p">,</span> <span class="n">vertices</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex_cut</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">value_only</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="go">8</span>
<span class="gp">sage: </span><span class="n">vertices</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Clearly, in this case the two sides of the cut are singletons:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">value</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="p">[</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex_cut</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">set1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">set2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.vertex_disjoint_paths">
<span class="sig-name descname"><span class="pre">vertex_disjoint_paths</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.vertex_disjoint_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of vertex-disjoint paths between two vertices.</p>
<p>The vertex version of Menger’s theorem asserts that the size of the
minimum vertex cut between two vertices <span class="math notranslate nohighlight">\(s\)</span> and <span class="math notranslate nohighlight">\(t\)</span> (the minimum number
of vertices whose removal disconnects <span class="math notranslate nohighlight">\(s\)</span> and <span class="math notranslate nohighlight">\(t\)</span>) is equal to the
maximum number of pairwise vertex-independent paths from <span class="math notranslate nohighlight">\(s\)</span> to <span class="math notranslate nohighlight">\(t\)</span>.</p>
<p>This function returns a list of such paths.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">s,t</span></code> – two vertices of the graph.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>In a complete bipartite graph</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">vertex_disjoint_paths</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[[0, 2, 1], [0, 3, 1], [0, 4, 1]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.vertex_iterator">
<span class="sig-name descname"><span class="pre">vertex_iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_property</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.vertex_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over the given vertices.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">False</span></code> if not given a vertex, sequence, iterator or
<code class="docutils literal notranslate"><span class="pre">None</span></code>. <code class="docutils literal notranslate"><span class="pre">None</span></code> is equivalent to a list of every vertex. Note that
<code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">v</span> <span class="pre">in</span> <span class="pre">G</span></code> syntax is allowed.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – iterated vertices are these intersected with the
vertices of the (di)graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">degree</span></code> – a nonnegative integer (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>);
a vertex <code class="docutils literal notranslate"><span class="pre">v</span></code> is kept if <code class="docutils literal notranslate"><span class="pre">degree(v)</span> <span class="pre">==</span> <span class="pre">degree</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertex_property</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function
that inputs a vertex and outputs a boolean value, i.e., a vertex
<code class="docutils literal notranslate"><span class="pre">v</span></code> is kept if <code class="docutils literal notranslate"><span class="pre">vertex_property(v)</span> <span class="pre">==</span> <span class="pre">True</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">vertex_iterator</span><span class="p">():</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">0</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">...</span>
<span class="go">8</span>
<span class="go">9</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">TetrahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">0</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">prop</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="n">l</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">H</span><span class="o">.</span><span class="n">vertex_iterator</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">vertex_property</span><span class="o">=</span><span class="n">prop</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">4</span>
</pre></div>
</div>
<p>Note that since the intersection option is available, the
vertex_iterator() function is sub-optimal, speed-wise, but note the
following optimization:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">timeit</span> <span class="n">V</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>                   <span class="c1"># not tested</span>
<span class="go">100000 loops, best of 3: 8.85 [micro]s per loop</span>
<span class="gp">sage: </span><span class="n">timeit</span> <span class="n">V</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">vertex_iterator</span><span class="p">())</span>      <span class="c1"># not tested</span>
<span class="go">100000 loops, best of 3: 5.74 [micro]s per loop</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.vertices">
<span class="sig-name descname"><span class="pre">vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_property</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the vertices.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sort</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, vertices are
sorted according to the default ordering</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">key</span></code> – a function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that takes a
vertex as its one argument and returns a value that can be used for
comparisons in the sorting algorithm (we must have <code class="docutils literal notranslate"><span class="pre">sort=True</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">degree</span></code> – a nonnegative integer (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>);
a vertex <code class="docutils literal notranslate"><span class="pre">v</span></code> is kept if <code class="docutils literal notranslate"><span class="pre">degree(v)</span> <span class="pre">==</span> <span class="pre">degree</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertex_property</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function
that inputs a vertex and outputs a boolean value, i.e., a vertex
<code class="docutils literal notranslate"><span class="pre">v</span></code> is kept if <code class="docutils literal notranslate"><span class="pre">vertex_property(v)</span> <span class="pre">==</span> <span class="pre">True</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<p>The list of vertices of the (di)graph.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Since any object may be a vertex, there is no guarantee that any two
vertices will be comparable. With default objects for vertices (all
integers), or when all the vertices are of the same simple type,
then there should not be a problem with how the vertices will be
sorted.  However, if you need to guarantee a total order for the
sorting of the edges, use the <code class="docutils literal notranslate"><span class="pre">key</span></code> argument, as illustrated in
the examples below.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
</pre></div>
</div>
<p>If you do not care about sorted output and you are concerned about the
time taken to sort, consider the following alternative:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">timeit</span> <span class="n">V</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>                     <span class="c1"># not tested</span>
<span class="go">625 loops, best of 3: 3.86 [micro]s per loop</span>
<span class="gp">sage: </span><span class="n">timeit</span> <span class="n">V</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">vertices</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>           <span class="c1"># not tested</span>
<span class="go">625 loops, best of 3: 2.06 [micro]s per loop</span>
<span class="gp">sage: </span><span class="n">timeit</span> <span class="n">V</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">vertex_iterator</span><span class="p">())</span>        <span class="c1"># not tested</span>
<span class="go">625 loops, best of 3: 2.05 [micro]s per loop</span>
<span class="gp">sage: </span><span class="n">timeit</span><span class="p">(</span><span class="s1">&#39;V = list(P)&#39;</span><span class="p">)</span>                       <span class="c1"># not tested</span>
<span class="go">625 loops, best of 3: 1.98 [micro]s per loop</span>
</pre></div>
</div>
<p>We illustrate various ways to use a <code class="docutils literal notranslate"><span class="pre">key</span></code> to sort the list:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">HanoiTowerGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4, ... 22, 23, 24, 25, 26]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">vertices</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">)</span>
<span class="go">[26, 25, 24, 23, 22, ... 4, 3, 2, 1, 0]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">HanoiTowerGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[(0, 0, 0), (0, 0, 1), (0, 0, 2), (0, 1, 0), ... (2, 2, 1), (2, 2, 2)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="go">[(0, 0, 0), (1, 0, 0), (2, 0, 0), (0, 0, 1), ... (1, 2, 2), (2, 2, 2)]</span>
</pre></div>
</div>
<p>The discriminant of a polynomial is a function that returns an integer.
We build a graph whose vertices are polynomials, and use the
discriminant function to provide an ordering. Note that since functions
are first-class objects in Python, we can specify precisely the function
from the Sage library that we wish to use as the key:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">5</span><span class="o">*</span><span class="n">t</span><span class="p">:</span> <span class="p">[</span><span class="n">t</span><span class="o">^</span><span class="mi">2</span><span class="p">],</span> <span class="n">t</span><span class="o">^</span><span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="n">t</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="p">],</span> <span class="n">t</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="n">t</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="mi">6</span><span class="p">],</span> <span class="mi">4</span><span class="o">*</span><span class="n">t</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="o">*</span><span class="n">t</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">dsc</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">rings</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">polynomial_rational_flint</span><span class="o">.</span><span class="n">Polynomial_rational_flint</span><span class="o">.</span><span class="n">discriminant</span>
<span class="gp">sage: </span><span class="n">verts</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">vertices</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">dsc</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">verts</span>
<span class="go">[t^2 + 2, t^2, 5*t, 4*t^2 - 6]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">discriminant</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">verts</span><span class="p">]</span>
<span class="go">[-8, 0, 1, 96]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.weighted">
<span class="sig-name descname"><span class="pre">weighted</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.weighted" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the (di)graph is to be considered as a weighted (di)graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">new</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); if it is provided, then the
weightedness flag is set accordingly. This is not allowed for
immutable graphs.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Changing the weightedness flag changes the <code class="docutils literal notranslate"><span class="pre">==</span></code>-class of a graph
and is thus not allowed for immutable graphs.</p>
<p>Edge weightings can still exist for (di)graphs <code class="docutils literal notranslate"><span class="pre">G</span></code> where
<code class="docutils literal notranslate"><span class="pre">G.weighted()</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</div>
<p>EXAMPLES:</p>
<p>Here we have two graphs with different labels, but <code class="docutils literal notranslate"><span class="pre">weighted()</span></code> is
<code class="docutils literal notranslate"><span class="pre">False</span></code> for both, so we just check for the presence of edges:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;a&#39;</span><span class="p">}},</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;b&#39;</span><span class="p">}},</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">==</span> <span class="n">H</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Now one is weighted and the other is not, and thus the graphs are not
equal:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">weighted</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">weighted</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">==</span> <span class="n">H</span>
<span class="go">False</span>
</pre></div>
</div>
<p>However, if both are weighted, then we finally compare ‘a’ to ‘b’:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">weighted</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">==</span> <span class="n">H</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.weighted_adjacency_matrix">
<span class="sig-name descname"><span class="pre">weighted_adjacency_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.weighted_adjacency_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the weighted adjacency matrix of the graph.</p>
<p>By default, each vertex is represented by its position in the list
returned by method <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.vertices" title="sage.graphs.generic_graph.GenericGraph.vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertices()</span></code></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sparse</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether to use a sparse or
a dense matrix</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – list (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); when specified, each vertex
is represented by its position in the list <code class="docutils literal notranslate"><span class="pre">vertices</span></code>, otherwise
each vertex is represented by its position in the list returned by
method <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.vertices" title="sage.graphs.generic_graph.GenericGraph.vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertices()</span></code></a></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">weighted_adjacency_matrix</span><span class="p">();</span> <span class="n">M</span>
<span class="go">[0 1 3 4]</span>
<span class="go">[1 0 2 0]</span>
<span class="go">[3 2 0 0]</span>
<span class="go">[4 0 0 0]</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">M</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;weighted_adjacency_matrix&#39;</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">==</span> <span class="n">G</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">weighted_adjacency_matrix</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">[0 0 0 4]</span>
<span class="go">[0 0 2 3]</span>
<span class="go">[0 2 0 1]</span>
<span class="go">[4 3 1 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.GenericGraph.wiener_index">
<span class="sig-name descname"><span class="pre">wiener_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">by_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.GenericGraph.wiener_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Wiener index of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The graph is expected to have no cycles of negative weight.</p>
<p>The Wiener index of a undirected graph <span class="math notranslate nohighlight">\(G\)</span> is <span class="math notranslate nohighlight">\(W(G) = \frac{1}{2}
\sum_{u,v\in G} d(u,v)\)</span> where <span class="math notranslate nohighlight">\(d(u,v)\)</span> denotes the distance between
vertices <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> (see <a class="reference internal" href="../../../references/index.html#krg1996" id="id45"><span>[KRG1996]</span></a>).</p>
<p>The Wiener index of a directed graph <span class="math notranslate nohighlight">\(G\)</span> is defined as the sum of the
distances between each pairs of vertices, i.e.,
<span class="math notranslate nohighlight">\(W(G) = \sum_{u,v\in G} d(u,v)\)</span>.</p>
<p>For more information on the input variables and more examples, we refer
to <a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.shortest_paths" title="sage.graphs.generic_graph.GenericGraph.shortest_paths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shortest_paths()</span></code></a> and
<a class="reference internal" href="#sage.graphs.generic_graph.GenericGraph.shortest_path_all_pairs" title="sage.graphs.generic_graph.GenericGraph.shortest_path_all_pairs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shortest_path_all_pairs()</span></code></a>, which have very similar
input variables.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">by_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, the edges
in the graph are weighted, otherwise all edges have weight 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); one of the following
algorithms:</p>
<ul>
<li><p>For <code class="docutils literal notranslate"><span class="pre">by_weight==False</span></code> only:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'BFS'</span></code> - the computation is done through a BFS centered on
each vertex successively.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Floyd-Warshall-Cython'</span></code> - the Cython implementation of
the Floyd-Warshall algorithm. Usually slower than <code class="docutils literal notranslate"><span class="pre">'BFS'</span></code>.</p></li>
</ul>
</li>
<li><p>For graphs without negative weights:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'Dijkstra_Boost'</span></code>: the Dijkstra algorithm, implemented in
Boost.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Dijkstra_NetworkX'</span></code>: the Dijkstra algorithm, implemented in
NetworkX. Usually slower than <code class="docutils literal notranslate"><span class="pre">'Dijkstra_Boost'</span></code>.</p></li>
</ul>
</li>
<li><p>For graphs with negative weights:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'Bellman-Ford_Boost'</span></code>: the Bellman-Ford algorithm, implemented
in Boost.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Johnson_Boost'</span></code>: the Johnson algorithm, implemented in
Boost.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Floyd-Warshall-Python'</span></code> - the Python implementation of
the Floyd-Warshall algorithm. Usually slower than
<code class="docutils literal notranslate"><span class="pre">'Johnson_Boost'</span></code>.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> (default): Sage chooses the best algorithm: <code class="docutils literal notranslate"><span class="pre">'BFS'</span></code> for
unweighted graphs, <code class="docutils literal notranslate"><span class="pre">'Dijkstra_Boost'</span></code> if all weights are
positive, <code class="docutils literal notranslate"><span class="pre">'Johnson_Boost'</span></code>, otherwise.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
takes as input an edge <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></code> and outputs its weight. If not
<code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is automatically set to <code class="docutils literal notranslate"><span class="pre">True</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>
and <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, we use the edge label <code class="docutils literal notranslate"><span class="pre">l</span></code> as a
weight, if <code class="docutils literal notranslate"><span class="pre">l</span></code> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, else <code class="docutils literal notranslate"><span class="pre">1</span></code> as a weight.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, we check
that the weight_function outputs a number for each edge</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Some algorithms (e.g., Boost algorithms) use floating point numbers
for internal computations. Whenever the solution is integral, we try
to convert the returned value to an integer.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span> <span class="p">{</span> <span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span> <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">3</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="mi">4</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="mi">4</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span> <span class="p">},</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">wiener_index</span><span class="p">()</span>
<span class="go">15</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">wiener_index</span><span class="p">(</span><span class="n">weight_function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:(</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">20</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">wiener_index</span><span class="p">(</span><span class="n">weight_function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:(</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">200</span><span class="p">))</span>
<span class="go">820</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">wiener_index</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;BFS&#39;</span><span class="p">)</span>
<span class="go">15</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">wiener_index</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Floyd-Warshall-Cython&#39;</span><span class="p">)</span>
<span class="go">15</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">wiener_index</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Floyd-Warshall-Python&#39;</span><span class="p">)</span>
<span class="go">15</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">wiener_index</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Dijkstra_Boost&#39;</span><span class="p">)</span>
<span class="go">15</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">wiener_index</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Bellman-Ford_Boost&#39;</span><span class="p">)</span>
<span class="go">15</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">wiener_index</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Johnson_Boost&#39;</span><span class="p">)</span>
<span class="go">15</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">wiener_index</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Dijkstra_NetworkX&#39;</span><span class="p">)</span>
<span class="go">15</span>
</pre></div>
</div>
<p>Wiener index of complete (di)graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">wiener_index</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Complete</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">wiener_index</span><span class="p">()</span> <span class="o">==</span> <span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Wiener index of circuit digraphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="mi">7</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">wiener_index</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Dijkstra_Boost&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">w</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Wiener index of a graph of order 1:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">wiener_index</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<p>The Wiener index is not defined on the empty graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">wiener_index</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: Wiener index is not defined for the empty graph</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.graph_isom_equivalent_non_edge_labeled_graph">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.generic_graph.</span></span><span class="sig-name descname"><span class="pre">graph_isom_equivalent_non_edge_labeled_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">partition</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standard_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_relabeling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_edge_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_edge_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.graph_isom_equivalent_non_edge_labeled_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for canonical labeling of edge labeled (di)graphs.</p>
<p>Translates to a bipartite incidence-structure type graph appropriate for
computing canonical labels of edge labeled and/or multi-edge graphs.
Note that this is actually computationally equivalent to implementing a
change on an inner loop of the main algorithm – namely making the
refinement procedure sort for each label.</p>
<p>If the graph is a multigraph, it is translated to a non-multigraph,
where each instance of multiple edges is converted to a single
edge labeled with a list <code class="docutils literal notranslate"><span class="pre">[[label1,</span> <span class="pre">multiplicity],</span> <span class="pre">[label2,</span>
<span class="pre">multiplicity],</span> <span class="pre">...]</span></code> describing how many edges of each label were
originally there. Then in either case we are working on a graph
without multiple edges. At this point, we create another
(partially bipartite) graph, whose left vertices are the original
vertices of the graph, and whose right vertices represent the
labeled edges. Any unlabeled edges in the original graph are also
present in the new graph, and – this is the bipartite aspect –
for every labeled edge <span class="math notranslate nohighlight">\(e\)</span> from <span class="math notranslate nohighlight">\(v\)</span> to <span class="math notranslate nohighlight">\(w\)</span> in the original graph,
there is an edge between the right vertex corresponding to <span class="math notranslate nohighlight">\(e\)</span> and
each of the left vertices corresponding to <span class="math notranslate nohighlight">\(v\)</span> and <span class="math notranslate nohighlight">\(w\)</span>. We
partition the left vertices as they were originally, and the right
vertices by common labels: only automorphisms taking edges to
like-labeled edges are allowed, and this additional partition
information enforces this on the new graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">g</span></code> – Graph or DiGraph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">partition</span></code> – list (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a partition of the
vertices as a list of lists of vertices. If given, the partition
of the vertices is as well relabeled</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">standard_label</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); edges in <code class="docutils literal notranslate"><span class="pre">g</span></code> with
this label are preserved in the new graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">return_relabeling</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether
to return a dictionary containing the relabeling</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">return_edge_labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether
the different <code class="docutils literal notranslate"><span class="pre">edge_labels</span></code> are returned (useful if inplace is
<code class="docutils literal notranslate"><span class="pre">True</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inplace</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether the input
(di)graph <code class="docutils literal notranslate"><span class="pre">g</span></code> is modified or the return a new (di)graph. Note
that attributes of <code class="docutils literal notranslate"><span class="pre">g</span></code> are <em>not</em> copied for speed issues, only
edges and vertices.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ignore_edge_labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>): if
<code class="docutils literal notranslate"><span class="pre">True</span></code>, ignore edge labels, so when constructing the new
graph, only multiple edges are replaced with vertices. Labels on
multiple edges are ignored – only the multiplicity is relevant,
so multiple edges with the same multiplicity in the original
graph correspond to right vertices in the same partition in the
new graph.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>if <code class="docutils literal notranslate"><span class="pre">inplace</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>: the unlabeled graph without
multiple edges</p></li>
<li><p>the partition of the vertices</p></li>
<li><p>if <code class="docutils literal notranslate"><span class="pre">return_relabeling</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>: a dictionary containing
the relabeling</p></li>
<li><p>if <code class="docutils literal notranslate"><span class="pre">return_edge_labels</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>: the list of (former) edge
labels is returned</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.generic_graph</span> <span class="kn">import</span> <span class="n">graph_isom_equivalent_non_edge_labeled_graph</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;string&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">123</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">graph_isom_equivalent_non_edge_labeled_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">partition</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">123</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span>
<span class="go">[Graph on 6 vertices, [[1, 0], [2, 3], [5], [4]]]</span>

<span class="gp">sage: </span><span class="n">g</span><span class="p">,</span> <span class="n">part</span> <span class="o">=</span> <span class="n">graph_isom_equivalent_non_edge_labeled_graph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
<span class="go">(Graph on 6 vertices, [[0, 1, 2, 3], [4], [5]])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(0, 3, None), (1, 4, None), (2, 4, None), (2, 5, None), (3, 5, None)]</span>

<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graph_isom_equivalent_non_edge_labeled_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">standard_label</span><span class="o">=</span><span class="s1">&#39;string&#39;</span><span class="p">,</span><span class="n">return_edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">Graph on 6 vertices</span>
<span class="gp">sage: </span><span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(0, 5, None), (1, 4, None), (2, 3, None), (2, 4, None), (3, 5, None)]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">[[0, 1, 2, 3], [4], [5]]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[[[&#39;string&#39;, 1]], [[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1], [6, 1], [7, 1], [8, 1], [9, 1]], [[None, 1]]]</span>

<span class="gp">sage: </span><span class="n">graph_isom_equivalent_non_edge_labeled_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[[[0, 1, 2, 3], [5], [4]]]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(0, 3, None), (1, 4, None), (2, 4, None), (2, 5, None), (3, 5, None)]</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">graph_isom_equivalent_non_edge_labeled_graph</span><span class="p">(</span><span class="n">G</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">Graph on 8 vertices</span>
<span class="gp">sage: </span><span class="n">graph_isom_equivalent_non_edge_labeled_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">ignore_edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">Graph on 5 vertices</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">g0</span> <span class="o">=</span> <span class="n">graph_isom_equivalent_non_edge_labeled_graph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g1</span> <span class="o">=</span> <span class="n">graph_isom_equivalent_non_edge_labeled_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">ignore_edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g0</span>
<span class="go">[Graph on 7 vertices, [[0, 1, 2, 3], [4], [5], [6]]]</span>
<span class="gp">sage: </span><span class="n">g1</span>
<span class="go">[Graph on 7 vertices, [[0, 1, 2, 3], [6], [4, 5]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.igraph_feature">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.generic_graph.</span></span><span class="sig-name descname"><span class="pre">igraph_feature</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.igraph_feature" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method to check whether optional package <code class="docutils literal notranslate"><span class="pre">igraph</span></code> is installed.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.generic_graph.tachyon_vertex_plot">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.generic_graph.</span></span><span class="sig-name descname"><span class="pre">tachyon_vertex_plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgcolor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1,</span> <span class="pre">1,</span> <span class="pre">1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos3d</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.generic_graph.tachyon_vertex_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for plotting graphs in 3d with
<a class="reference external" href="../../../plot3d/sage/plot/plot3d/tachyon.html#sage.plot.plot3d.tachyon.Tachyon" title="(in Sage 9.5 Reference Manual: 3D Graphics v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tachyon</span></code></a>.</p>
<p>Returns a plot containing only the vertices, as well as the 3d position
dictionary used for the plot.</p>
<dl class="simple">
<dt>INPUT:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pos3d</span></code> – a 3D layout of the vertices</p></li>
<li><p>various rendering options</p></li>
</ul>
</dd>
</dl>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">TetrahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.generic_graph</span> <span class="kn">import</span> <span class="n">tachyon_vertex_plot</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">,</span><span class="n">p</span> <span class="o">=</span> <span class="n">tachyon_vertex_plot</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos3d</span><span class="o">=</span><span class="n">G</span><span class="o">.</span><span class="n">layout</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.plot.plot3d.tachyon.Tachyon&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">&lt;... &#39;dict&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Generic graphs (common to directed/undirected)</a><ul>
<li><a class="reference internal" href="#methods">Methods</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../../index.html"
                        title="previous chapter">Graph Theory</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="graph.html"
                        title="next chapter">Undirected graphs</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/sage/graphs/generic_graph.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="graph.html" title="Undirected graphs"
             >next</a> |</li>
        <li class="right" >
          <a href="../../index.html" title="Graph Theory"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Sage 9.5 Reference Manual: Graph Theory</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">Generic graphs (common to directed/undirected)</a></li> 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2022, The Sage Development Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.2.0.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* The sidebar toggle adapts its height to the bodywrapper height. */
    const resizeObserver = new ResizeObserver(entries => {
        tog.height(bod.height());
    });
    resizeObserver.observe(bod[0]);

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>