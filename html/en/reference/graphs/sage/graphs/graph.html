
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Undirected graphs &#8212; Sage 9.5 Reference Manual: Graph Theory</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sage.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <script data-url_root="../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script async="async" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Directed graphs" href="digraph.html" />
    <link rel="prev" title="Generic graphs (common to directed/undirected)" href="generic_graph.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="digraph.html" title="Directed graphs"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="generic_graph.html" title="Generic graphs (common to directed/undirected)"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Sage 9.5 Reference Manual: Graph Theory</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">Undirected graphs</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="undirected-graphs">
<span id="sage-graphs-graph"></span><h1>Undirected graphs<a class="headerlink" href="#undirected-graphs" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.graphs.graph"></span><p>This module implements functions and operations involving undirected graphs.</p>
<p><strong>Algorithmically hard stuff</strong></p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">convexity_properties()</span></code></p></td>
<td><p>Return a <code class="docutils literal notranslate"><span class="pre">ConvexityProperties</span></code> object corresponding to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">has_homomorphism_to()</span></code></p></td>
<td><p>Checks whether there is a homomorphism between two graphs.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">independent_set()</span></code></p></td>
<td><p>Return a maximum independent set.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">independent_set_of_representatives()</span></code></p></td>
<td><p>Return an independent set of representatives.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">is_perfect()</span></code></p></td>
<td><p>Tests whether the graph is perfect.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="matchpoly.html#sage.graphs.matchpoly.matching_polynomial" title="sage.graphs.matchpoly.matching_polynomial"><code class="xref py py-func docutils literal notranslate"><span class="pre">matching_polynomial()</span></code></a></p></td>
<td><p>Computes the matching polynomial of the graph <span class="math notranslate nohighlight">\(G\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">minor()</span></code></p></td>
<td><p>Return the vertices of a minor isomorphic to <span class="math notranslate nohighlight">\(H\)</span> in the current graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="graph_decompositions/vertex_separation.html#sage.graphs.graph_decompositions.vertex_separation.pathwidth" title="sage.graphs.graph_decompositions.vertex_separation.pathwidth"><code class="xref py py-func docutils literal notranslate"><span class="pre">pathwidth()</span></code></a></p></td>
<td><p>Compute the pathwidth of <code class="docutils literal notranslate"><span class="pre">self</span></code> (and provides a decomposition)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="graph_decompositions/rankwidth.html#sage.graphs.graph_decompositions.rankwidth.rank_decomposition" title="sage.graphs.graph_decompositions.rankwidth.rank_decomposition"><code class="xref py py-func docutils literal notranslate"><span class="pre">rank_decomposition()</span></code></a></p></td>
<td><p>Compute an optimal rank-decomposition of the given graph.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">topological_minor()</span></code></p></td>
<td><p>Return a topological <span class="math notranslate nohighlight">\(H\)</span>-minor from <code class="docutils literal notranslate"><span class="pre">self</span></code> if one exists.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="graph_decompositions/tree_decomposition.html#sage.graphs.graph_decompositions.tree_decomposition.treelength" title="sage.graphs.graph_decompositions.tree_decomposition.treelength"><code class="xref py py-func docutils literal notranslate"><span class="pre">treelength()</span></code></a></p></td>
<td><p>Compute the treelength of <span class="math notranslate nohighlight">\(G\)</span> (and provide a decomposition).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="graph_decompositions/tree_decomposition.html#sage.graphs.graph_decompositions.tree_decomposition.treewidth" title="sage.graphs.graph_decompositions.tree_decomposition.treewidth"><code class="xref py py-func docutils literal notranslate"><span class="pre">treewidth()</span></code></a></p></td>
<td><p>Compute the treewidth of <span class="math notranslate nohighlight">\(g\)</span> (and provide a decomposition).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="tutte_polynomial.html#sage.graphs.tutte_polynomial.tutte_polynomial" title="sage.graphs.tutte_polynomial.tutte_polynomial"><code class="xref py py-func docutils literal notranslate"><span class="pre">tutte_polynomial()</span></code></a></p></td>
<td><p>Return the Tutte polynomial of the graph <span class="math notranslate nohighlight">\(G\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">vertex_cover()</span></code></p></td>
<td><p>Return a minimum vertex cover of self represented by a set of vertices.</p></td>
</tr>
</tbody>
</table>
<p><strong>Basic methods</strong></p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">bipartite_color()</span></code></p></td>
<td><p>Return a dictionary with vertices as the keys and the color class as the values.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">bipartite_double()</span></code></p></td>
<td><p>Return the (extended) bipartite double of this graph.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">bipartite_sets()</span></code></p></td>
<td><p>Return <span class="math notranslate nohighlight">\((X,Y)\)</span> where <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> are the nodes in each bipartite set of graph <span class="math notranslate nohighlight">\(G\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">graph6_string()</span></code></p></td>
<td><p>Return the graph6 representation of the graph as an ASCII string.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">is_directed()</span></code></p></td>
<td><p>Since graph is undirected, returns False.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">join()</span></code></p></td>
<td><p>Return the join of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">sparse6_string()</span></code></p></td>
<td><p>Return the sparse6 representation of the graph as an ASCII string.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">to_directed()</span></code></p></td>
<td><p>Return a directed version of the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">to_undirected()</span></code></p></td>
<td><p>Since the graph is already undirected, simply returns a copy of itself.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">write_to_eps()</span></code></p></td>
<td><p>Write a plot of the graph to <code class="docutils literal notranslate"><span class="pre">filename</span></code> in <code class="docutils literal notranslate"><span class="pre">eps</span></code> format.</p></td>
</tr>
</tbody>
</table>
<p><strong>Clique-related methods</strong></p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="cliquer.html#sage.graphs.cliquer.all_cliques" title="sage.graphs.cliquer.all_cliques"><code class="xref py py-func docutils literal notranslate"><span class="pre">all_cliques()</span></code></a></p></td>
<td><p>Iterator over the cliques in <code class="docutils literal notranslate"><span class="pre">graph</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="graph_decompositions/clique_separators.html#sage.graphs.graph_decompositions.clique_separators.atoms_and_clique_separators" title="sage.graphs.graph_decompositions.clique_separators.atoms_and_clique_separators"><code class="xref py py-func docutils literal notranslate"><span class="pre">atoms_and_clique_separators()</span></code></a></p></td>
<td><p>Return the atoms of the decomposition of <span class="math notranslate nohighlight">\(G\)</span> by clique minimal separators.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">clique_complex()</span></code></p></td>
<td><p>Return the clique complex of self.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">clique_maximum()</span></code></p></td>
<td><p>Return the vertex set of a maximal order complete subgraph.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">clique_number()</span></code></p></td>
<td><p>Return the order of the largest clique of the graph</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">clique_polynomial()</span></code></p></td>
<td><p>Return the clique polynomial of self.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">cliques_containing_vertex()</span></code></p></td>
<td><p>Return the cliques containing each vertex, represented as a dictionary of lists of lists, keyed by vertex.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">cliques_get_clique_bipartite()</span></code></p></td>
<td><p>Return a bipartite graph constructed such that maximal cliques are the right vertices and the left vertices are retained from the given graph. Right and left vertices are connected if the bottom vertex belongs to the clique represented by a top vertex.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">cliques_get_max_clique_graph()</span></code></p></td>
<td><p>Return the clique graph.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">cliques_maximal()</span></code></p></td>
<td><p>Return the list of all maximal cliques.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">cliques_maximum()</span></code></p></td>
<td><p>Returns the vertex sets of <em>ALL</em> the maximum complete subgraphs.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">cliques_number_of()</span></code></p></td>
<td><p>Return a dictionary of the number of maximal cliques containing each vertex, keyed by vertex.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">cliques_vertex_clique_number()</span></code></p></td>
<td><p>Return a dictionary of sizes of the largest maximal cliques containing each vertex, keyed by vertex.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">fractional_clique_number()</span></code></p></td>
<td><p>Return the fractional clique number of the graph.</p></td>
</tr>
</tbody>
</table>
<p><strong>Coloring</strong></p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">chromatic_index()</span></code></p></td>
<td><p>Return the chromatic index of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">chromatic_number()</span></code></p></td>
<td><p>Return the minimal number of colors needed to color the vertices of the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">chromatic_polynomial()</span></code></p></td>
<td><p>Compute the chromatic polynomial of the graph G.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">chromatic_quasisymmetric_function()</span></code></p></td>
<td><p>Return the chromatic quasisymmetric function of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">chromatic_symmetric_function()</span></code></p></td>
<td><p>Return the chromatic symmetric function of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">coloring()</span></code></p></td>
<td><p>Return the first (optimal) proper vertex-coloring found.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="graph_coloring.html#sage.graphs.graph_coloring.fractional_chromatic_index" title="sage.graphs.graph_coloring.fractional_chromatic_index"><code class="xref py py-func docutils literal notranslate"><span class="pre">fractional_chromatic_index()</span></code></a></p></td>
<td><p>Return the fractional chromatic index of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="graph_coloring.html#sage.graphs.graph_coloring.fractional_chromatic_number" title="sage.graphs.graph_coloring.fractional_chromatic_number"><code class="xref py py-func docutils literal notranslate"><span class="pre">fractional_chromatic_number()</span></code></a></p></td>
<td><p>Return the fractional chromatic number of the graph.</p></td>
</tr>
</tbody>
</table>
<p><strong>Connectivity, orientations, trees</strong></p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">bounded_outdegree_orientation()</span></code></p></td>
<td><p>Computes an orientation of <code class="docutils literal notranslate"><span class="pre">self</span></code> such that every vertex <span class="math notranslate nohighlight">\(v\)</span> has out-degree less than <span class="math notranslate nohighlight">\(b(v)\)</span></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="connectivity.html#sage.graphs.connectivity.bridges" title="sage.graphs.connectivity.bridges"><code class="xref py py-func docutils literal notranslate"><span class="pre">bridges()</span></code></a></p></td>
<td><p>Return an iterator over the bridges (or cut edges).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="connectivity.html#sage.graphs.connectivity.cleave" title="sage.graphs.connectivity.cleave"><code class="xref py py-func docutils literal notranslate"><span class="pre">cleave()</span></code></a></p></td>
<td><p>Return the connected subgraphs separated by the input vertex cut.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">degree_constrained_subgraph()</span></code></p></td>
<td><p>Returns a degree-constrained subgraph.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">ear_decomposition()</span></code></p></td>
<td><p>Return an Ear decomposition of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">gomory_hu_tree()</span></code></p></td>
<td><p>Return a Gomory-Hu tree of self.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="connectivity.html#sage.graphs.connectivity.is_triconnected" title="sage.graphs.connectivity.is_triconnected"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_triconnected()</span></code></a></p></td>
<td><p>Check whether the graph is triconnected.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">minimum_outdegree_orientation()</span></code></p></td>
<td><p>Returns an orientation of <code class="docutils literal notranslate"><span class="pre">self</span></code> with the smallest possible maximum outdegree.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">orientations()</span></code></p></td>
<td><p>Return an iterator over orientations of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="orientations.html#sage.graphs.orientations.random_orientation" title="sage.graphs.orientations.random_orientation"><code class="xref py py-func docutils literal notranslate"><span class="pre">random_orientation()</span></code></a></p></td>
<td><p>Return a random orientation of a graph <span class="math notranslate nohighlight">\(G\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="spanning_tree.html#sage.graphs.spanning_tree.random_spanning_tree" title="sage.graphs.spanning_tree.random_spanning_tree"><code class="xref py py-func docutils literal notranslate"><span class="pre">random_spanning_tree()</span></code></a></p></td>
<td><p>Return a random spanning tree of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="spanning_tree.html#sage.graphs.spanning_tree.spanning_trees" title="sage.graphs.spanning_tree.spanning_trees"><code class="xref py py-func docutils literal notranslate"><span class="pre">spanning_trees()</span></code></a></p></td>
<td><p>Return an iterator over all spanning trees of the graph <span class="math notranslate nohighlight">\(g\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="connectivity.html#sage.graphs.connectivity.spqr_tree" title="sage.graphs.connectivity.spqr_tree"><code class="xref py py-func docutils literal notranslate"><span class="pre">spqr_tree()</span></code></a></p></td>
<td><p>Return an SPQR-tree representing the triconnected components of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">strong_orientation()</span></code></p></td>
<td><p>Returns a strongly connected orientation of the current graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="orientations.html#sage.graphs.orientations.strong_orientations_iterator" title="sage.graphs.orientations.strong_orientations_iterator"><code class="xref py py-func docutils literal notranslate"><span class="pre">strong_orientations_iterator()</span></code></a></p></td>
<td><p>Returns an iterator over all strong orientations of a graph <span class="math notranslate nohighlight">\(G\)</span>.</p></td>
</tr>
</tbody>
</table>
<p><strong>Distances</strong></p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">center()</span></code></p></td>
<td><p>Return the set of vertices in the center of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">centrality_degree()</span></code></p></td>
<td><p>Return the degree centrality of a vertex.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">diameter()</span></code></p></td>
<td><p>Return the diameter of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">eccentricity()</span></code></p></td>
<td><p>Return the eccentricity of vertex (or vertices) <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">periphery()</span></code></p></td>
<td><p>Return the set of vertices in the periphery of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">radius()</span></code></p></td>
<td><p>Return the radius of the graph.</p></td>
</tr>
</tbody>
</table>
<p><strong>Domination</strong></p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="domination.html#sage.graphs.domination.is_dominating" title="sage.graphs.domination.is_dominating"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_dominating()</span></code></a></p></td>
<td><p>Check whether <code class="docutils literal notranslate"><span class="pre">dom</span></code> is a dominating set of <code class="docutils literal notranslate"><span class="pre">G</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="domination.html#sage.graphs.domination.is_redundant" title="sage.graphs.domination.is_redundant"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_redundant()</span></code></a></p></td>
<td><p>Check whether <code class="docutils literal notranslate"><span class="pre">dom</span></code> has redundant vertices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="domination.html#sage.graphs.domination.minimal_dominating_sets" title="sage.graphs.domination.minimal_dominating_sets"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimal_dominating_sets()</span></code></a></p></td>
<td><p>Return an iterator over the minimal dominating sets of a graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="domination.html#sage.graphs.domination.private_neighbors" title="sage.graphs.domination.private_neighbors"><code class="xref py py-func docutils literal notranslate"><span class="pre">private_neighbors()</span></code></a></p></td>
<td><p>Return the private neighbors of a vertex with respect to other vertices.</p></td>
</tr>
</tbody>
</table>
<p><strong>Expansion properties</strong></p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">cheeger_constant()</span></code></p></td>
<td><p>Return the cheeger constant of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">edge_isoperimetric_number()</span></code></p></td>
<td><p>Return the edge-isoperimetric number of the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">vertex_isoperimetric_number()</span></code></p></td>
<td><p>Return the vertex-isoperimetric number of the graph.</p></td>
</tr>
</tbody>
</table>
<p><strong>Graph properties</strong></p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">apex_vertices()</span></code></p></td>
<td><p>Return the list of apex vertices.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">is_antipodal()</span></code></p></td>
<td><p>Check whether this graph is antipodal.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">is_apex()</span></code></p></td>
<td><p>Test if the graph is apex.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">is_arc_transitive()</span></code></p></td>
<td><p>Check if self is an arc-transitive graph</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="asteroidal_triples.html#sage.graphs.asteroidal_triples.is_asteroidal_triple_free" title="sage.graphs.asteroidal_triples.is_asteroidal_triple_free"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_asteroidal_triple_free()</span></code></a></p></td>
<td><p>Test if the input graph is asteroidal triple-free</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">is_biconnected()</span></code></p></td>
<td><p>Test if the graph is biconnected.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">is_block_graph()</span></code></p></td>
<td><p>Return whether this graph is a block graph.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">is_cactus()</span></code></p></td>
<td><p>Check whether the graph is cactus graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="graph_decompositions/graph_products.html#sage.graphs.graph_decompositions.graph_products.is_cartesian_product" title="sage.graphs.graph_decompositions.graph_products.is_cartesian_product"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_cartesian_product()</span></code></a></p></td>
<td><p>Test whether the graph is a Cartesian product.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">is_circumscribable()</span></code></p></td>
<td><p>Test whether the graph is the graph of a circumscribed polyhedron.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">is_cograph()</span></code></p></td>
<td><p>Check whether the graph is cograph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="comparability.html#sage.graphs.comparability.is_comparability" title="sage.graphs.comparability.is_comparability"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_comparability()</span></code></a></p></td>
<td><p>Tests whether the graph is a comparability graph</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="distances_all_pairs.html#sage.graphs.distances_all_pairs.is_distance_regular" title="sage.graphs.distances_all_pairs.is_distance_regular"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_distance_regular()</span></code></a></p></td>
<td><p>Test if the graph is distance-regular</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">is_edge_transitive()</span></code></p></td>
<td><p>Check if self is an edge transitive graph.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">is_even_hole_free()</span></code></p></td>
<td><p>Tests whether <code class="docutils literal notranslate"><span class="pre">self</span></code> contains an induced even hole.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">is_forest()</span></code></p></td>
<td><p>Tests if the graph is a forest, i.e. a disjoint union of trees.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">is_half_transitive()</span></code></p></td>
<td><p>Check if self is a half-transitive graph.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">is_inscribable()</span></code></p></td>
<td><p>Test whether the graph is the graph of an inscribed polyhedron.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="line_graph.html#sage.graphs.line_graph.is_line_graph" title="sage.graphs.line_graph.is_line_graph"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_line_graph()</span></code></a></p></td>
<td><p>Check whether the graph <span class="math notranslate nohighlight">\(g\)</span> is a line graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="weakly_chordal.html#sage.graphs.weakly_chordal.is_long_antihole_free" title="sage.graphs.weakly_chordal.is_long_antihole_free"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_long_antihole_free()</span></code></a></p></td>
<td><p>Tests whether the given graph contains an induced subgraph that is isomorphic to the complement of a cycle of length at least 5.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="weakly_chordal.html#sage.graphs.weakly_chordal.is_long_hole_free" title="sage.graphs.weakly_chordal.is_long_hole_free"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_long_hole_free()</span></code></a></p></td>
<td><p>Tests whether <code class="docutils literal notranslate"><span class="pre">g</span></code> contains an induced cycle of length at least 5.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">is_odd_hole_free()</span></code></p></td>
<td><p>Tests whether <code class="docutils literal notranslate"><span class="pre">self</span></code> contains an induced odd hole.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">is_overfull()</span></code></p></td>
<td><p>Tests whether the current graph is overfull.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="partial_cube.html#sage.graphs.partial_cube.is_partial_cube" title="sage.graphs.partial_cube.is_partial_cube"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_partial_cube()</span></code></a></p></td>
<td><p>Test whether the given graph is a partial cube.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">is_path()</span></code></p></td>
<td><p>Check whether <code class="docutils literal notranslate"><span class="pre">self</span></code> is a path.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="comparability.html#sage.graphs.comparability.is_permutation" title="sage.graphs.comparability.is_permutation"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_permutation()</span></code></a></p></td>
<td><p>Tests whether the graph is a permutation graph.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">is_polyhedral()</span></code></p></td>
<td><p>Check whether the graph is the graph of the polyhedron.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">is_prime()</span></code></p></td>
<td><p>Test whether the current graph is prime.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">is_semi_symmetric()</span></code></p></td>
<td><p>Check if self is semi-symmetric.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">is_split()</span></code></p></td>
<td><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the graph is a Split graph, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="base/static_dense_graph.html#sage.graphs.base.static_dense_graph.is_strongly_regular" title="sage.graphs.base.static_dense_graph.is_strongly_regular"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_strongly_regular()</span></code></a></p></td>
<td><p>Check whether the graph is strongly regular.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">is_tree()</span></code></p></td>
<td><p>Tests if the graph is a tree</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">is_triangle_free()</span></code></p></td>
<td><p>Check whether <code class="docutils literal notranslate"><span class="pre">self</span></code> is triangle-free</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="weakly_chordal.html#sage.graphs.weakly_chordal.is_weakly_chordal" title="sage.graphs.weakly_chordal.is_weakly_chordal"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_weakly_chordal()</span></code></a></p></td>
<td><p>Tests whether the given graph is weakly chordal, i.e., the graph and its complement have no induced cycle of length at least 5.</p></td>
</tr>
</tbody>
</table>
<p><strong>Leftovers</strong></p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">antipodal_graph()</span></code></p></td>
<td><p>Return the antipodal graph of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">arboricity()</span></code></p></td>
<td><p>Return the arboricity of the graph and an optional certificate.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">common_neighbors_matrix()</span></code></p></td>
<td><p>Return a matrix of numbers of common neighbors between each pairs.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">cores()</span></code></p></td>
<td><p>Return the core number for each vertex in an ordered list.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">effective_resistance()</span></code></p></td>
<td><p>Return the effective resistance between nodes <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">effective_resistance_matrix()</span></code></p></td>
<td><p>Return a matrix whose (<span class="math notranslate nohighlight">\(i\)</span> , <span class="math notranslate nohighlight">\(j\)</span>) entry gives the effective resistance between vertices <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">folded_graph()</span></code></p></td>
<td><p>Return the antipodal fold of this graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="convexity_properties.html#sage.graphs.convexity_properties.geodetic_closure" title="sage.graphs.convexity_properties.geodetic_closure"><code class="xref py py-func docutils literal notranslate"><span class="pre">geodetic_closure()</span></code></a></p></td>
<td><p>Return the geodetic closure of the set of vertices <span class="math notranslate nohighlight">\(S\)</span> in <span class="math notranslate nohighlight">\(G\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">has_perfect_matching()</span></code></p></td>
<td><p>Return whether this graph has a perfect matching. INPUT:</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">ihara_zeta_function_inverse()</span></code></p></td>
<td><p>Compute the inverse of the Ihara zeta function of the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">kirchhoff_symanzik_polynomial()</span></code></p></td>
<td><p>Return the Kirchhoff-Symanzik polynomial of a graph.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">least_effective_resistance()</span></code></p></td>
<td><p>Return a list of pairs of nodes with the least effective resistance.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="lovasz_theta.html#sage.graphs.lovasz_theta.lovasz_theta" title="sage.graphs.lovasz_theta.lovasz_theta"><code class="xref py py-func docutils literal notranslate"><span class="pre">lovasz_theta()</span></code></a></p></td>
<td><p>Return the value of Lovász theta-function of graph</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">magnitude_function()</span></code></p></td>
<td><p>Return the magnitude function of the graph as a rational function.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">matching()</span></code></p></td>
<td><p>Return a maximum weighted matching of the graph represented by the list of its edges.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">maximum_average_degree()</span></code></p></td>
<td><p>Return the Maximum Average Degree (MAD) of the current graph.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">modular_decomposition()</span></code></p></td>
<td><p>Return the modular decomposition of the current graph.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">most_common_neighbors()</span></code></p></td>
<td><p>Return vertex pairs with maximal number of common neighbors.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">perfect_matchings()</span></code></p></td>
<td><p>Return an iterator over all perfect matchings of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">seidel_adjacency_matrix()</span></code></p></td>
<td><p>Return the Seidel adjacency matrix of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">seidel_switching()</span></code></p></td>
<td><p>Return the Seidel switching of <code class="docutils literal notranslate"><span class="pre">self</span></code> w.r.t. subset of vertices <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">two_factor_petersen()</span></code></p></td>
<td><p>Return a decomposition of the graph into 2-factors.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-func docutils literal notranslate"><span class="pre">twograph()</span></code></p></td>
<td><p>Return the two-graph of <code class="docutils literal notranslate"><span class="pre">self</span></code></p></td>
</tr>
</tbody>
</table>
<p><strong>Traversals</strong></p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="traversals.html#sage.graphs.traversals.lex_M" title="sage.graphs.traversals.lex_M"><code class="xref py py-func docutils literal notranslate"><span class="pre">lex_M()</span></code></a></p></td>
<td><p>Return an ordering of the vertices according the LexM graph traversal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="traversals.html#sage.graphs.traversals.maximum_cardinality_search" title="sage.graphs.traversals.maximum_cardinality_search"><code class="xref py py-func docutils literal notranslate"><span class="pre">maximum_cardinality_search()</span></code></a></p></td>
<td><p>Return an ordering of the vertices according a maximum cardinality search.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="traversals.html#sage.graphs.traversals.maximum_cardinality_search_M" title="sage.graphs.traversals.maximum_cardinality_search_M"><code class="xref py py-func docutils literal notranslate"><span class="pre">maximum_cardinality_search_M()</span></code></a></p></td>
<td><p>Return the ordering and the edges of the triangulation produced by MCS-M.</p></td>
</tr>
</tbody>
</table>
<p>AUTHORS:</p>
<ul class="simple">
<li><p>Robert L. Miller (2006-10-22): initial version</p></li>
<li><p>William Stein (2006-12-05): Editing</p></li>
<li><dl class="simple">
<dt>Robert L. Miller (2007-01-13): refactoring, adjusting for NetworkX-0.33, fixed</dt><dd><p>plotting bugs (2007-01-23): basic tutorial, edge labels, loops, multiple
edges and arcs (2007-02-07): graph6 and sparse6 formats, matrix input</p>
</dd>
</dl>
</li>
<li><p>Emily Kirkmann (2007-02-11): added graph_border option to plot and show</p></li>
<li><dl class="simple">
<dt>Robert L. Miller (2007-02-12): vertex color-maps, graph boundaries, graph6</dt><dd><p>helper functions in Cython</p>
</dd>
</dl>
</li>
<li><p>Robert L. Miller Sage Days 3 (2007-02-17-21): 3d plotting in Tachyon</p></li>
<li><p>Robert L. Miller (2007-02-25): display a partition</p></li>
<li><dl class="simple">
<dt>Robert L. Miller (2007-02-28): associate arbitrary objects to vertices, edge</dt><dd><p>and arc label display (in 2d), edge coloring</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Robert L. Miller (2007-03-21): Automorphism group, isomorphism check,</dt><dd><p>canonical label</p>
</dd>
</dl>
</li>
<li><p>Robert L. Miller (2007-06-07-09): NetworkX function wrapping</p></li>
<li><p>Michael W. Hansen (2007-06-09): Topological sort generation</p></li>
<li><p>Emily Kirkman, Robert L. Miller Sage Days 4: Finished wrapping NetworkX</p></li>
<li><dl class="simple">
<dt>Emily Kirkman (2007-07-21): Genus (including circular planar, all embeddings</dt><dd><p>and all planar embeddings), all paths, interior paths</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Bobby Moretti (2007-08-12): fixed up plotting of graphs with edge colors</dt><dd><p>differentiated by label</p>
</dd>
</dl>
</li>
<li><p>Jason Grout (2007-09-25): Added functions, bug fixes, and general enhancements</p></li>
<li><p>Robert L. Miller (Sage Days 7): Edge labeled graph isomorphism</p></li>
<li><p>Tom Boothby (Sage Days 7): Miscellaneous awesomeness</p></li>
<li><p>Tom Boothby (2008-01-09): Added graphviz output</p></li>
<li><p>David Joyner (2009-2): Fixed docstring bug related to GAP.</p></li>
<li><dl class="simple">
<dt>Stephen Hartke (2009-07-26): Fixed bug in blocks_and_cut_vertices() that</dt><dd><p>caused an incorrect result when the vertex 0 was a cut vertex.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Stephen Hartke (2009-08-22): Fixed bug in blocks_and_cut_vertices() where the</dt><dd><p>list of cut_vertices is not treated as a set.</p>
</dd>
</dl>
</li>
<li><p>Anders Jonsson (2009-10-10): Counting of spanning trees and out-trees added.</p></li>
<li><dl class="simple">
<dt>Nathann Cohen (2009-09)<span class="classifier">Cliquer, Connectivity, Flows and everything that</span></dt><dd><p>uses Linear Programming and class numerical.MIP</p>
</dd>
</dl>
</li>
<li><p>Nicolas M. Thiery (2010-02): graph layout code refactoring, dot2tex/graphviz
interface</p></li>
<li><p>David Coudert (2012-04) : Reduction rules in vertex_cover.</p></li>
<li><dl class="simple">
<dt>Birk Eisermann (2012-06): added recognition of weakly chordal graphs and</dt><dd><p>long-hole-free / long-antihole-free graphs</p>
</dd>
</dl>
</li>
<li><p>Alexandre P. Zuge (2013-07): added join operation.</p></li>
<li><p>Amritanshu Prasad (2014-08): added clique polynomial</p></li>
<li><p>Julian Rüth (2018-06-21): upgrade to NetworkX 2</p></li>
<li><p>David Coudert (2018-10-07): cleaning</p></li>
<li><p>Amanda Francis, Caitlin Lienkaemper, Kate Collins, Rajat Mittal (2019-03-10):
methods for computing effective resistance</p></li>
<li><p>Amanda Francis, Caitlin Lienkaemper, Kate Collins, Rajat Mittal (2019-03-19):
most_common_neighbors and common_neighbors_matrix added.</p></li>
<li><dl class="simple">
<dt>Jean-Florent Raymond (2019-04): is_redundant, is_dominating,</dt><dd><p>private_neighbors</p>
</dd>
</dl>
</li>
</ul>
<section id="graph-format">
<h2>Graph Format<a class="headerlink" href="#graph-format" title="Permalink to this headline">¶</a></h2>
<section id="supported-formats">
<h3>Supported formats<a class="headerlink" href="#supported-formats" title="Permalink to this headline">¶</a></h3>
<p>Sage Graphs can be created from a wide range of inputs. A few examples are
covered here.</p>
<ul>
<li><p>NetworkX dictionary format:</p>
<blockquote>
<div><div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">9</span><span class="p">],</span> \
<span class="go">      5: [7, 8], 6: [8,9], 7: [9]}</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">d</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Graph on 10 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>    <span class="c1"># or G.show()</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>A NetworkX graph:</p>
<blockquote>
<div><div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">networkx</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">complete_bipartite_graph</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">[7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 12, 12, 12, 12, 12, 12, 12]</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>graph6 or sparse6 format:</p>
<blockquote>
<div><div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;:I`AKGsaOs`cI]Gb~&#39;</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Looped multi-graph on 10 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>    <span class="c1"># or G.show()</span>
</pre></div>
</div>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">\</span></code> character is an escape character in Python, and also a
character used by graph6 strings:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;Ihe</span><span class="se">\n</span><span class="s1">@GUA&#39;</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">RuntimeError: the string (Ihe) seems corrupt: for n = 10, the string is too short</span>
</pre></div>
</div>
<p>In Python, the escaped character <code class="docutils literal notranslate"><span class="pre">\</span></code> is represented by <code class="docutils literal notranslate"><span class="pre">\\</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;Ihe</span><span class="se">\\</span><span class="s1">n@GUA&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>    <span class="c1"># or G.show()</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><dl>
<dt>adjacency matrix: In an adjacency matrix, each column and each row represent a</dt><dd><p>vertex. If a 1 shows up in row <span class="math notranslate nohighlight">\(i\)</span>, column <span class="math notranslate nohighlight">\(j\)</span>, there is an edge <span class="math notranslate nohighlight">\((i,j)\)</span>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> \
<span class="go">(0,1,0,1,0,0,0,1,0,0), (0,0,1,0,1,0,0,0,1,0),(1,0,0,1,0,0,0,0,0,1), \</span>
<span class="go">(1,0,0,0,0,0,0,1,1,0), (0,1,0,0,0,0,0,0,1,1),(0,0,1,0,0,1,0,0,0,1), \</span>
<span class="go">(0,0,0,1,0,1,1,0,0,0), (0,0,0,0,1,0,1,1,0,0)])</span>
<span class="gp">sage: </span><span class="n">M</span>
<span class="go">[0 1 0 0 1 1 0 0 0 0]</span>
<span class="go">[1 0 1 0 0 0 1 0 0 0]</span>
<span class="go">[0 1 0 1 0 0 0 1 0 0]</span>
<span class="go">[0 0 1 0 1 0 0 0 1 0]</span>
<span class="go">[1 0 0 1 0 0 0 0 0 1]</span>
<span class="go">[1 0 0 0 0 0 0 1 1 0]</span>
<span class="go">[0 1 0 0 0 0 0 0 1 1]</span>
<span class="go">[0 0 1 0 0 1 0 0 0 1]</span>
<span class="go">[0 0 0 1 0 1 1 0 0 0]</span>
<span class="go">[0 0 0 0 1 0 1 1 0 0]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">M</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Graph on 10 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>    <span class="c1"># or G.show()</span>
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl>
<dt>incidence matrix: In an incidence matrix, each row represents a vertex and</dt><dd><p>each column represents an edge.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">....: </span>            <span class="p">(</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">....: </span>            <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">....: </span>            <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">....: </span>            <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
<span class="gp">....: </span>            <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">....: </span>            <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">....: </span>            <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">....: </span>            <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">....: </span>            <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">M</span>
<span class="go">[-1  0  0  0  1  0  0  0  0  0 -1  0  0  0  0]</span>
<span class="go">[ 1 -1  0  0  0  0  0  0  0  0  0 -1  0  0  0]</span>
<span class="go">[ 0  1 -1  0  0  0  0  0  0  0  0  0 -1  0  0]</span>
<span class="go">[ 0  0  1 -1  0  0  0  0  0  0  0  0  0 -1  0]</span>
<span class="go">[ 0  0  0  1 -1  0  0  0  0  0  0  0  0  0 -1]</span>
<span class="go">[ 0  0  0  0  0 -1  0  0  0  1  1  0  0  0  0]</span>
<span class="go">[ 0  0  0  0  0  0  0  1 -1  0  0  1  0  0  0]</span>
<span class="go">[ 0  0  0  0  0  1 -1  0  0  0  0  0  1  0  0]</span>
<span class="go">[ 0  0  0  0  0  0  0  0  1 -1  0  0  0  1  0]</span>
<span class="go">[ 0  0  0  0  0  0  1 -1  0  0  0  0  0  0  1]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">M</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Graph on 10 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>    <span class="c1"># or G.show()</span>
<span class="gp">sage: </span><span class="n">DiGraph</span><span class="p">(</span><span class="n">matrix</span><span class="p">(</span><span class="mi">2</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;incidence_matrix&quot;</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: there must be two nonzero entries (-1 &amp; 1) per column</span>
</pre></div>
</div>
</dd>
</dl>
</li>
<li><p>a list of edges:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span>
<span class="go">Graph on 5 vertices</span>
</pre></div>
</div>
</li>
<li><p>an igraph Graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">igraph</span>                                <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">igraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)]))</span> <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">g</span>                                            <span class="c1"># optional - python_igraph</span>
<span class="go">Graph on 4 vertices</span>
</pre></div>
</div>
</li>
</ul>
</section>
</section>
<section id="generators">
<h2>Generators<a class="headerlink" href="#generators" title="Permalink to this headline">¶</a></h2>
<p>Use <code class="docutils literal notranslate"><span class="pre">graphs(n)</span></code> to iterate through all non-isomorphic graphs of given size:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">graphs</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">degree_sequence</span><span class="p">())</span>
<span class="go">[0, 0, 0, 0]</span>
<span class="go">[1, 1, 0, 0]</span>
<span class="go">[2, 1, 1, 0]</span>
<span class="go">[3, 1, 1, 1]</span>
<span class="go">[1, 1, 1, 1]</span>
<span class="go">[2, 2, 1, 1]</span>
<span class="go">[2, 2, 2, 0]</span>
<span class="go">[3, 2, 2, 1]</span>
<span class="go">[2, 2, 2, 2]</span>
<span class="go">[3, 3, 2, 2]</span>
<span class="go">[3, 3, 3, 3]</span>
</pre></div>
</div>
<p>Similarly <code class="docutils literal notranslate"><span class="pre">graphs()</span></code> will iterate through all graphs. The complete graph of 4
vertices is of course the smallest graph with chromatic number bigger than
three:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">graphs</span><span class="p">():</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="k">break</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>For some commonly used graphs to play with, type:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="p">[</span><span class="n">tab</span><span class="p">]</span>          <span class="c1"># not tested</span>
</pre></div>
</div>
<p>and hit {tab}. Most of these graphs come with their own custom plot, so you can
see how people usually visualize these graphs.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>    <span class="c1"># or G.show()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">degree_histogram</span><span class="p">()</span>
<span class="go">[0, 0, 0, 10]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span>
<span class="go">[0 1 0 0 1 1 0 0 0 0]</span>
<span class="go">[1 0 1 0 0 0 1 0 0 0]</span>
<span class="go">[0 1 0 1 0 0 0 1 0 0]</span>
<span class="go">[0 0 1 0 1 0 0 0 1 0]</span>
<span class="go">[1 0 0 1 0 0 0 0 0 1]</span>
<span class="go">[1 0 0 0 0 0 0 1 1 0]</span>
<span class="go">[0 1 0 0 0 0 0 0 1 1]</span>
<span class="go">[0 0 1 0 0 1 0 0 0 1]</span>
<span class="go">[0 0 0 1 0 1 1 0 0 0]</span>
<span class="go">[0 0 0 0 1 0 1 1 0 0]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>    <span class="c1"># or S.show()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">density</span><span class="p">()</span>
<span class="go">1/2</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">GraphQuery</span><span class="p">(</span><span class="n">display_cols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;graph6&#39;</span><span class="p">],</span> <span class="n">num_vertices</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">diameter</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">get_graphs_list</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">graphs_list</span><span class="o">.</span><span class="n">show_graphs</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="labels">
<span id="graph-labels"></span><h2>Labels<a class="headerlink" href="#labels" title="Permalink to this headline">¶</a></h2>
<p>Each vertex can have any hashable object as a label. These are things like
strings, numbers, and tuples. Each edge is given a default label of <code class="docutils literal notranslate"><span class="pre">None</span></code>,
but if specified, edges can have any label at all. Edges between vertices <span class="math notranslate nohighlight">\(u\)</span>
and <span class="math notranslate nohighlight">\(v\)</span> are represented typically as <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></code>, where <code class="docutils literal notranslate"><span class="pre">l</span></code> is the label for
the edge.</p>
<p>Note that vertex labels themselves cannot be mutable items:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span> <span class="mi">0</span> <span class="p">:</span> <span class="p">{</span> <span class="n">M</span> <span class="p">:</span> <span class="kc">None</span> <span class="p">}</span> <span class="p">})</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: mutable matrices are unhashable</span>
</pre></div>
</div>
<p>However, if one wants to define a dictionary, with the same keys and arbitrary
objects for entries, one can make that association:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span> <span class="p">:</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">(),</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">graphs</span><span class="o">.</span><span class="n">FlowerSnark</span><span class="p">(),</span> \
<span class="go">      2 : graphs.MoebiusKantorGraph(), 3 : graphs.PetersenGraph() }</span>
<span class="gp">sage: </span><span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">Moebius-Kantor Graph: Graph on 16 vertices</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">TetrahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">set_vertices</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">get_vertex</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Flower Snark: Graph on 20 vertices</span>
</pre></div>
</div>
</section>
<section id="database">
<h2>Database<a class="headerlink" href="#database" title="Permalink to this headline">¶</a></h2>
<p>There is a database available for searching for graphs that satisfy a certain
set of parameters, including number of vertices and edges, density, maximum and
minimum degree, diameter, radius, and connectivity. To see a list of all search
parameter keywords broken down by their designated table names, type</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graph_db_info</span><span class="p">()</span>
<span class="go">{...}</span>
</pre></div>
</div>
<p>For more details on data types or keyword input, enter</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">GraphQuery</span><span class="err">?</span>    <span class="c1"># not tested</span>
</pre></div>
</div>
<p>The results of a query can be viewed with the show method, or can be viewed
individually by iterating through the results</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">GraphQuery</span><span class="p">(</span><span class="n">display_cols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;graph6&#39;</span><span class="p">],</span><span class="n">num_vertices</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">diameter</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="go">Graph6</span>
<span class="gt">--------------------</span>
<span class="n">F</span><span class="err">?`</span><span class="n">po</span>
<span class="n">F</span><span class="err">?</span><span class="n">gqg</span>
<span class="n">F</span><span class="o">@</span><span class="err">?</span><span class="p">]</span><span class="n">O</span>
<span class="n">F</span><span class="nd">@OKg</span>
<span class="n">F</span><span class="nd">@R@o</span>
<span class="n">FA_pW</span>
<span class="n">FEOhW</span>
<span class="n">FGC</span><span class="p">{</span><span class="n">o</span>
<span class="n">FIAHo</span>
</pre></div>
</div>
<p>Show each graph as you iterate through the results:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">Q</span><span class="p">:</span>
<span class="gp">....: </span>    <span class="n">show</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="visualization">
<h2>Visualization<a class="headerlink" href="#visualization" title="Permalink to this headline">¶</a></h2>
<p>To see a graph <span class="math notranslate nohighlight">\(G\)</span> you are working with, there are three main options. You can
view the graph in two dimensions via matplotlib with <code class="docutils literal notranslate"><span class="pre">show()</span></code>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mf">.3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>And you can view it in three dimensions via jmol with <code class="docutils literal notranslate"><span class="pre">show3d()</span></code>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show3d</span><span class="p">()</span>
</pre></div>
</div>
<p>Or it can be rendered with <span class="math notranslate nohighlight">\(\LaTeX\)</span>.  This requires the right additions to a
standard <span class="math notranslate nohighlight">\(\mbox{\rm\TeX}\)</span> installation.  Then standard Sage commands, such as
<code class="docutils literal notranslate"><span class="pre">view(G)</span></code> will display the graph, or <code class="docutils literal notranslate"><span class="pre">latex(G)</span></code> will produce a string
suitable for inclusion in a <span class="math notranslate nohighlight">\(\LaTeX\)</span> document.  More details on this are at the
<a class="reference internal" href="graph_latex.html#module-sage.graphs.graph_latex" title="sage.graphs.graph_latex"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.graphs.graph_latex</span></code></a> module.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_latex</span> <span class="kn">import</span> <span class="n">check_tkz_graph</span>
<span class="gp">sage: </span><span class="n">check_tkz_graph</span><span class="p">()</span>  <span class="c1"># random - depends on TeX installation</span>
<span class="gp">sage: </span><span class="n">latex</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">\begin{tikzpicture}</span>
<span class="go">...</span>
<span class="go">\end{tikzpicture}</span>
</pre></div>
</div>
</section>
<section id="mutability">
<h2>Mutability<a class="headerlink" href="#mutability" title="Permalink to this headline">¶</a></h2>
<p>Graphs are mutable, and thus unusable as dictionary keys, unless
<code class="docutils literal notranslate"><span class="pre">data_structure=&quot;static_sparse&quot;</span></code> is used:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">{</span><span class="n">G</span><span class="p">:</span><span class="mi">1</span><span class="p">}[</span><span class="n">G</span><span class="p">]</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: This graph is mutable, and thus not hashable. Create an immutable copy by `g.copy(immutable=True)`</span>
<span class="gp">sage: </span><span class="n">G_immutable</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">immutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G_immutable</span> <span class="o">==</span> <span class="n">G</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">{</span><span class="n">G_immutable</span><span class="p">:</span><span class="mi">1</span><span class="p">}[</span><span class="n">G_immutable</span><span class="p">]</span>
<span class="go">1</span>
</pre></div>
</div>
</section>
<section id="methods">
<h2>Methods<a class="headerlink" href="#methods" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sage.graphs.graph.</span></span><span class="sig-name descname"><span class="pre">Graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_structure</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sparse'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multiedges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convert_empty_dict_labels_to_None</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">immutable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph" title="sage.graphs.generic_graph.GenericGraph"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.graphs.generic_graph.GenericGraph</span></code></a></p>
<p>Undirected graph.</p>
<p>A graph is a set of vertices connected by edges. See the
<a class="reference external" href="https://en.wikipedia.org/wiki/Graph_(mathematics)">Wikipedia article Graph_(mathematics)</a> for more information. For a collection of
pre-defined graphs, see the <a class="reference internal" href="graph_generators.html#module-sage.graphs.graph_generators" title="sage.graphs.graph_generators"><code class="xref py py-mod docutils literal notranslate"><span class="pre">graph_generators</span></code></a> module.</p>
<p>A <a class="reference internal" href="#sage.graphs.graph.Graph" title="sage.graphs.graph.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a> object has many methods whose list can be obtained by
typing <code class="docutils literal notranslate"><span class="pre">g.&lt;tab&gt;</span></code> (i.e. hit the ‘tab’ key) or by reading the documentation
of <a class="reference internal" href="#module-sage.graphs.graph" title="sage.graphs.graph"><code class="xref py py-mod docutils literal notranslate"><span class="pre">graph</span></code></a>, <a class="reference internal" href="generic_graph.html#module-sage.graphs.generic_graph" title="sage.graphs.generic_graph"><code class="xref py py-mod docutils literal notranslate"><span class="pre">generic_graph</span></code></a>, and
<a class="reference internal" href="digraph.html#module-sage.graphs.digraph" title="sage.graphs.digraph"><code class="xref py py-mod docutils literal notranslate"><span class="pre">digraph</span></code></a>.</p>
<p>INPUT:</p>
<p>By default, a <a class="reference internal" href="#sage.graphs.graph.Graph" title="sage.graphs.graph.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a> object is simple (i.e. no <em>loops</em> nor <em>multiple
edges</em>) and unweighted. This can be easily tuned with the appropriate flags
(see below).</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">data</span></code> – can be any of the following (see the <code class="docutils literal notranslate"><span class="pre">format</span></code> argument):</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">Graph()</span></code> – build a graph on 0 vertices.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Graph(5)</span></code> – return an edgeless graph on the 5 vertices 0,…,4.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Graph([list_of_vertices,</span> <span class="pre">list_of_edges])</span></code> – returns a graph with
given vertices/edges.</p>
<p>To bypass auto-detection, prefer the more explicit
<code class="docutils literal notranslate"><span class="pre">Graph([V,</span> <span class="pre">E],</span> <span class="pre">format='vertices_and_edges')</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Graph(list_of_edges)</span></code> – return a graph with a given list of edges
(see documentation of
<a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.add_edges" title="sage.graphs.generic_graph.GenericGraph.add_edges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_edges()</span></code></a>).</p>
<p>To bypass auto-detection, prefer the more explicit
<code class="docutils literal notranslate"><span class="pre">Graph(L,</span> <span class="pre">format='list_of_edges')</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Graph({1:</span> <span class="pre">[2,</span> <span class="pre">3,</span> <span class="pre">4],</span> <span class="pre">3:</span> <span class="pre">[4]})</span></code> – return a graph by associating to
each vertex the list of its neighbors.</p>
<p>To bypass auto-detection, prefer the more explicit
<code class="docutils literal notranslate"><span class="pre">Graph(D,</span> <span class="pre">format='dict_of_lists')</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Graph({1:</span> <span class="pre">{2:</span> <span class="pre">'a',</span> <span class="pre">3:'b'}</span> <span class="pre">,3:{2:'c'}})</span></code> – return a graph by
associating a list of neighbors to each vertex and providing its edge
label.</p>
<p>To bypass auto-detection, prefer the more explicit
<code class="docutils literal notranslate"><span class="pre">Graph(D,</span> <span class="pre">format='dict_of_dicts')</span></code>.</p>
<p>For graphs with multiple edges, you can provide a list of labels
instead, e.g.: <code class="docutils literal notranslate"><span class="pre">Graph({1:</span> <span class="pre">{2:</span> <span class="pre">['a1',</span> <span class="pre">'a2'],</span> <span class="pre">3:['b']}</span> <span class="pre">,3:{2:['c']}})</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Graph(a_symmetric_matrix)</span></code> – return a graph with given (weighted)
adjacency matrix (see documentation of
<a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.adjacency_matrix" title="sage.graphs.generic_graph.GenericGraph.adjacency_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">adjacency_matrix()</span></code></a>).</p>
<p>To bypass auto-detection, prefer the more explicit <code class="docutils literal notranslate"><span class="pre">Graph(M,</span>
<span class="pre">format='adjacency_matrix')</span></code>. To take weights into account, use
<code class="docutils literal notranslate"><span class="pre">format='weighted_adjacency_matrix'</span></code> instead.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Graph(a_nonsymmetric_matrix)</span></code> – return a graph with given incidence
matrix (see documentation of
<a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.incidence_matrix" title="sage.graphs.generic_graph.GenericGraph.incidence_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">incidence_matrix()</span></code></a>).</p>
<p>To bypass auto-detection, prefer the more explicit
<code class="docutils literal notranslate"><span class="pre">Graph(M,</span> <span class="pre">format='incidence_matrix')</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Graph([V,</span> <span class="pre">f])</span></code> – return a graph from a vertex set <code class="docutils literal notranslate"><span class="pre">V</span></code> and a
<em>symmetric</em> function <code class="docutils literal notranslate"><span class="pre">f</span></code>. The graph contains an edge <span class="math notranslate nohighlight">\(u,v\)</span> whenever
<code class="docutils literal notranslate"><span class="pre">f(u,v)</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>.. Example: <code class="docutils literal notranslate"><span class="pre">Graph([</span> <span class="pre">[1..10],</span> <span class="pre">lambda</span> <span class="pre">x,y:</span>
<span class="pre">abs(x-y).is_square()])</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Graph(':I`ES&#64;obGkqegW~')</span></code> – return a graph from a graph6 or sparse6
string (see documentation of <a class="reference internal" href="#sage.graphs.graph.Graph.graph6_string" title="sage.graphs.graph.Graph.graph6_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph6_string()</span></code></a> or
<a class="reference internal" href="#sage.graphs.graph.Graph.sparse6_string" title="sage.graphs.graph.Graph.sparse6_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sparse6_string()</span></code></a>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Graph(a_seidel_matrix,</span> <span class="pre">format='seidel_adjacency_matrix')</span></code> – return
a graph with a given Seidel adjacency matrix (see documentation of
<a class="reference internal" href="#sage.graphs.graph.Graph.seidel_adjacency_matrix" title="sage.graphs.graph.Graph.seidel_adjacency_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">seidel_adjacency_matrix()</span></code></a>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Graph(another_graph)</span></code> – return a graph from a Sage (di)graph,
<a class="reference external" href="https://pygraphviz.github.io/">pygraphviz</a> graph, <a class="reference external" href="https://networkx.github.io/">NetworkX</a> graph, or <a class="reference external" href="http://igraph.org/python/">igraph</a> graph.</p></li>
</ol>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">pos</span></code> – a positioning dictionary (cf. documentation of
<a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.layout" title="sage.graphs.generic_graph.GenericGraph.layout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">layout()</span></code></a>). For example, to
draw 4 vertices on a square:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">{0: [-1,-1],</span>
<span class="go"> 1: [ 1,-1],</span>
<span class="go"> 2: [ 1, 1],</span>
<span class="go"> 3: [-1, 1]}</span>
</pre></div>
</div>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code> – (must be an explicitly named parameter, i.e.,</dt><dd><p><code class="docutils literal notranslate"><span class="pre">name=&quot;complete&quot;)</span></code> gives the graph a name</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">loops</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); whether to allow loops (ignored</dt><dd><p>if data is an instance of the <code class="docutils literal notranslate"><span class="pre">Graph</span></code> class)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">multiedges</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); whether to allow multiple</dt><dd><p>edges (ignored if data is an instance of the <code class="docutils literal notranslate"><span class="pre">Graph</span></code> class).</p>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">weighted</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); whether graph thinks of
itself as weighted or not. See
<a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.weighted" title="sage.graphs.generic_graph.GenericGraph.weighted"><code class="xref py py-meth docutils literal notranslate"><span class="pre">weighted()</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">format</span></code> – if set to <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), <a class="reference internal" href="#sage.graphs.graph.Graph" title="sage.graphs.graph.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a> tries to guess
input’s format. To avoid this possibly time-consuming step, one of the
following values can be specified (see description above): <code class="docutils literal notranslate"><span class="pre">&quot;int&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;graph6&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;sparse6&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;rule&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;list_of_edges&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;dict_of_lists&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;dict_of_dicts&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;adjacency_matrix&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;weighted_adjacency_matrix&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;seidel_adjacency_matrix&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;incidence_matrix&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;NX&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;igraph&quot;</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sparse</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); <code class="docutils literal notranslate"><span class="pre">sparse=True</span></code> is an alias for
<code class="docutils literal notranslate"><span class="pre">data_structure=&quot;sparse&quot;</span></code>, and <code class="docutils literal notranslate"><span class="pre">sparse=False</span></code> is an alias for
<code class="docutils literal notranslate"><span class="pre">data_structure=&quot;dense&quot;</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">data_structure</span></code> – one of the following (for more information, see
<a class="reference internal" href="base/overview.html#module-sage.graphs.base.overview" title="sage.graphs.base.overview"><code class="xref py py-mod docutils literal notranslate"><span class="pre">overview</span></code></a>)</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;dense&quot;</span></code> – selects the <a class="reference internal" href="base/dense_graph.html#module-sage.graphs.base.dense_graph" title="sage.graphs.base.dense_graph"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dense_graph</span></code></a>
backend.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;sparse&quot;</span></code> – selects the <a class="reference internal" href="base/sparse_graph.html#module-sage.graphs.base.sparse_graph" title="sage.graphs.base.sparse_graph"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sparse_graph</span></code></a>
backend.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;static_sparse&quot;</span></code> – selects the
<a class="reference internal" href="base/static_sparse_backend.html#module-sage.graphs.base.static_sparse_backend" title="sage.graphs.base.static_sparse_backend"><code class="xref py py-mod docutils literal notranslate"><span class="pre">static_sparse_backend</span></code></a> (this backend is faster
than the sparse backend and smaller in memory, and it is immutable, so
that the resulting graphs can be used as dictionary keys).</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">immutable</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to create a
immutable graph. Note that <code class="docutils literal notranslate"><span class="pre">immutable=True</span></code> is actually a shortcut for
<code class="docutils literal notranslate"><span class="pre">data_structure='static_sparse'</span></code>. Set to <code class="docutils literal notranslate"><span class="pre">False</span></code> by default.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertex_labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether to allow any
object as a vertex (slower), or only the integers <span class="math notranslate nohighlight">\(0,...,n-1\)</span>, where <span class="math notranslate nohighlight">\(n\)</span>
is the number of vertices.</p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">convert_empty_dict_labels_to_None</span></code> – this arguments sets the default</dt><dd><p>edge labels used by NetworkX (empty dictionaries) to be replaced by
<code class="docutils literal notranslate"><span class="pre">None</span></code>, the default Sage edge label. It is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> iff a
NetworkX graph is on the input.</p>
</dd>
</dl>
</li>
</ul>
<p>EXAMPLES:</p>
<p>We illustrate the first seven input formats (the other two involve packages
that are currently not standard in Sage):</p>
<ol class="arabic">
<li><p>An integer giving the number of vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="n">g</span>
<span class="go">Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
</li>
<li><p>A dictionary of dictionaries:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:{</span><span class="mi">1</span><span class="p">:</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="s1">&#39;z&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">:</span><span class="s1">&#39;a&#39;</span><span class="p">},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">5</span><span class="p">:</span><span class="s1">&#39;out&#39;</span><span class="p">}});</span> <span class="n">g</span>
<span class="go">Graph on 5 vertices</span>
</pre></div>
</div>
<p>The labels (‘x’, ‘z’, ‘a’, ‘out’) are labels for edges. For example,
‘out’ is the label for the edge on 2 and 5. Labels can be used as
weights, if all the labels share some common parent.:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">f</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">SymmetricGroup</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">({</span><span class="n">b</span><span class="p">:{</span><span class="n">d</span><span class="p">:</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="n">e</span><span class="p">:</span><span class="s1">&#39;p&#39;</span><span class="p">},</span> <span class="n">c</span><span class="p">:{</span><span class="n">d</span><span class="p">:</span><span class="s1">&#39;p&#39;</span><span class="p">,</span><span class="n">e</span><span class="p">:</span><span class="s1">&#39;c&#39;</span><span class="p">}})</span>
<span class="go">Graph on 4 vertices</span>
</pre></div>
</div>
</li>
<li><p>A dictionary of lists:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">]});</span> <span class="n">g</span>
<span class="go">Graph on 5 vertices</span>
</pre></div>
</div>
</li>
<li><p>A list of vertices and a function describing adjacencies. Note that the
list of vertices and the function must be enclosed in a list (i.e., [list
of vertices, function]).</p>
<p>Construct the Paley graph over GF(13).:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">=</span><span class="n">Graph</span><span class="p">([</span><span class="n">GF</span><span class="p">(</span><span class="mi">13</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">:</span> <span class="n">i</span><span class="o">!=</span><span class="n">j</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">is_square</span><span class="p">()])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span>
<span class="go">[0 1 0 1 1 0 0 0 0 1 1 0 1]</span>
<span class="go">[1 0 1 0 1 1 0 0 0 0 1 1 0]</span>
<span class="go">[0 1 0 1 0 1 1 0 0 0 0 1 1]</span>
<span class="go">[1 0 1 0 1 0 1 1 0 0 0 0 1]</span>
<span class="go">[1 1 0 1 0 1 0 1 1 0 0 0 0]</span>
<span class="go">[0 1 1 0 1 0 1 0 1 1 0 0 0]</span>
<span class="go">[0 0 1 1 0 1 0 1 0 1 1 0 0]</span>
<span class="go">[0 0 0 1 1 0 1 0 1 0 1 1 0]</span>
<span class="go">[0 0 0 0 1 1 0 1 0 1 0 1 1]</span>
<span class="go">[1 0 0 0 0 1 1 0 1 0 1 0 1]</span>
<span class="go">[1 1 0 0 0 0 1 1 0 1 0 1 0]</span>
<span class="go">[0 1 1 0 0 0 0 1 1 0 1 0 1]</span>
<span class="go">[1 0 1 1 0 0 0 0 1 1 0 1 0]</span>
</pre></div>
</div>
<p>Construct the line graph of a complete graph.:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">line_graph</span><span class="o">=</span><span class="n">Graph</span><span class="p">([</span><span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="n">false</span><span class="p">),</span> \
<span class="go">       lambda i,j: len(set(i).intersection(set(j)))&gt;0], \</span>
<span class="go">       loops=False)</span>
<span class="gp">sage: </span><span class="n">line_graph</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]</span>
<span class="gp">sage: </span><span class="n">line_graph</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span>
<span class="go">[0 1 1 1 1 0]</span>
<span class="go">[1 0 1 1 0 1]</span>
<span class="go">[1 1 0 0 1 1]</span>
<span class="go">[1 1 0 0 1 1]</span>
<span class="go">[1 0 1 1 0 1]</span>
<span class="go">[0 1 1 1 1 0]</span>
</pre></div>
</div>
</li>
<li><p>A graph6 or sparse6 string: Sage automatically recognizes whether a
string is in graph6 or sparse6 format:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;:I`AKGsaOs`cI]Gb~&#39;</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Looped multi-graph on 10 vertices</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;G?????&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s2">&quot;G&#39;?G?C&quot;</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">RuntimeError: the string seems corrupt: valid characters are</span>
<span class="go">?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;G??????&#39;</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">RuntimeError: the string (G??????) seems corrupt: for n = 8, the string is too long</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s2">&quot;:I&#39;AKGsaOs`cI]Gb~&quot;</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">RuntimeError: the string seems corrupt: valid characters are</span>
<span class="go">?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~</span>
</pre></div>
</div>
<p>There are also list functions to take care of lists of graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;:IgMoqoCUOqeb</span><span class="se">\n</span><span class="s1">:I`AKGsaOs`cI]Gb~</span><span class="se">\n</span><span class="s1">:I`EDOAEQ?PccSsge</span><span class="se">\\</span><span class="s1">N</span><span class="se">\n</span><span class="s1">&#39;</span>
<span class="gp">sage: </span><span class="n">graphs_list</span><span class="o">.</span><span class="n">from_sparse6</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[Looped multi-graph on 10 vertices, Looped multi-graph on 10 vertices, Looped multi-graph on 10 vertices]</span>
</pre></div>
</div>
</li>
<li><p>A Sage matrix:
Note: If format is not specified, then Sage assumes a symmetric square
matrix is an adjacency matrix, otherwise an incidence matrix.</p>
<ul>
<li><p>an adjacency matrix:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">am</span><span class="p">();</span> <span class="n">M</span>
<span class="go">[0 1 0 0 1 1 0 0 0 0]</span>
<span class="go">[1 0 1 0 0 0 1 0 0 0]</span>
<span class="go">[0 1 0 1 0 0 0 1 0 0]</span>
<span class="go">[0 0 1 0 1 0 0 0 1 0]</span>
<span class="go">[1 0 0 1 0 0 0 0 0 1]</span>
<span class="go">[1 0 0 0 0 0 0 1 1 0]</span>
<span class="go">[0 1 0 0 0 0 0 0 1 1]</span>
<span class="go">[0 0 1 0 0 1 0 0 0 1]</span>
<span class="go">[0 0 0 1 0 1 1 0 0 0]</span>
<span class="go">[0 0 0 0 1 0 1 1 0 0]</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="go">Graph on 10 vertices</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]]),</span><span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Looped multi-graph on 2 vertices</span>

<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]]);</span> <span class="n">M</span>
<span class="go">[   0    1   -1]</span>
<span class="go">[   1    0 -1/2]</span>
<span class="go">[  -1 -1/2    0]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Graph on 3 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">weighted</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</li>
<li><p>an incidence matrix:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]);</span> <span class="n">M</span>
<span class="go">[-1  0  0  0  1]</span>
<span class="go">[ 1 -1  0  0  0]</span>
<span class="go">[ 0  1 -1  0  0]</span>
<span class="go">[ 0  0  1 -1  0]</span>
<span class="go">[ 0  0  0  1 -1]</span>
<span class="go">[ 0  0  0  0  0]</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="go">Graph on 6 vertices</span>

<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">]]))</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: there must be one or two nonzero entries per column in an incidence matrix, got entries [1, 1, 1] in column 0</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">]]))</span>
<span class="go">Graph on 3 vertices</span>

<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]);</span> <span class="n">M</span>
<span class="go">[ 0  1 -1]</span>
<span class="go">[ 1  0 -1]</span>
<span class="go">[-1 -1  0]</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Graph on 3 vertices</span>

<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]);</span> <span class="n">M</span>
<span class="go">[ 0  1  1]</span>
<span class="go">[ 1  0  1]</span>
<span class="go">[-1 -1  0]</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: there must be one or two nonzero entries per column in an incidence matrix, got entries [1, 1] in column 2</span>
</pre></div>
</div>
</li>
</ul>
<blockquote>
<div><p>Check that <a class="reference external" href="https://trac.sagemath.org/9714">trac ticket #9714</a> is fixed:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">MA</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">GA</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">MA</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;adjacency_matrix&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">MI</span> <span class="o">=</span> <span class="n">GA</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">(</span><span class="n">oriented</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">MI</span>
<span class="go">[2 1 1 0 0 0]</span>
<span class="go">[0 1 1 2 2 0]</span>
<span class="go">[0 0 0 0 0 2]</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">MI</span><span class="p">)</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="go">[(0, 0), (0, 1), (0, 1), (1, 1), (1, 1), (2, 2)]</span>

<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]);</span> <span class="n">M</span>
<span class="go">[ 1]</span>
<span class="go">[-1]</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">M</span><span class="p">)</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None)]</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>A Seidel adjacency matrix:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.matrices.hadamard_matrix</span> <span class="kn">import</span> \
<span class="gp">....: </span> <span class="n">regular_symmetric_hadamard_matrix_with_constant_diagonal</span> <span class="k">as</span> <span class="n">rshcd</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">=</span><span class="n">rshcd</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span> <span class="n">matrix</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="nb">format</span><span class="o">=</span><span class="s2">&quot;seidel_adjacency_matrix&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(16, 6, 2, 2)</span>
</pre></div>
</div>
</li>
<li><p>List of edges, or labelled edges:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span>
<span class="go">Graph on 5 vertices</span>

<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s2">&quot;Peace&quot;</span><span class="p">),(</span><span class="mi">7</span><span class="p">,</span><span class="o">-</span><span class="mi">9</span><span class="p">,</span><span class="s2">&quot;and&quot;</span><span class="p">),(</span><span class="mi">77</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Love&quot;</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span>
<span class="go">Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">)],</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">loops</span><span class="p">()</span>
<span class="go">[(3, 3, &#39;2&#39;)]</span>
</pre></div>
</div>
</li>
<li><p>A NetworkX MultiGraph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">networkx</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">MultiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">Multi-graph on 5 vertices</span>
</pre></div>
</div>
</li>
<li><p>A NetworkX graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">networkx</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">DiGraph</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">Digraph on 5 vertices</span>
</pre></div>
</div>
</li>
<li><p>An igraph Graph (see also
<a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.igraph_graph" title="sage.graphs.generic_graph.GenericGraph.igraph_graph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">igraph_graph()</span></code></a>):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">igraph</span>                      <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">igraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span> <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>                           <span class="c1"># optional - python_igraph</span>
<span class="go">Graph on 3 vertices</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">vertex_labels</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, the names of the vertices are given by
the vertex attribute <code class="docutils literal notranslate"><span class="pre">'name'</span></code>, if available:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">igraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span> <span class="n">vertex_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">]})</span>  <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>                                                   <span class="c1"># optional - python_igraph</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">igraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span> <span class="n">vertex_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">]})</span> <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>                                                   <span class="c1"># optional - python_igraph</span>
<span class="go">[0, 1, 2]</span>
</pre></div>
</div>
<p>If the igraph Graph has edge attributes, they are used as edge labels:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">igraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span> <span class="n">edge_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;weight&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]})</span> <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>                                                               <span class="c1"># optional - python_igraph</span>
<span class="go">[(0, 1, {&#39;name&#39;: &#39;a&#39;, &#39;weight&#39;: 1}), (0, 2, {&#39;name&#39;: &#39;b&#39;, &#39;weight&#39;: 3})]</span>
</pre></div>
</div>
</li>
</ol>
<p>When defining an undirected graph from a function <code class="docutils literal notranslate"><span class="pre">f</span></code>, it is <em>very</em>
important that <code class="docutils literal notranslate"><span class="pre">f</span></code> be symmetric. If it is not, anything can happen:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f_sym</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">f_nonsym</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">G_sym</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">f_sym</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G_sym</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G_nonsym</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">f_nonsym</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G_nonsym</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">G_nonsym</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">G_sym</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>By default, graphs are mutable and can thus not be used as a dictionary
key:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">{</span><span class="n">G</span><span class="p">:</span><span class="mi">1</span><span class="p">}[</span><span class="n">G</span><span class="p">]</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: This graph is mutable, and thus not hashable. Create an immutable copy by `g.copy(immutable=True)`</span>
</pre></div>
</div>
<p>When providing the optional arguments <code class="docutils literal notranslate"><span class="pre">data_structure=&quot;static_sparse&quot;</span></code> or
<code class="docutils literal notranslate"><span class="pre">immutable=True</span></code> (both mean the same), then an immutable graph results.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G_imm</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">immutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H_imm</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">data_structure</span><span class="o">=</span><span class="s1">&#39;static_sparse&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G_imm</span> <span class="o">==</span> <span class="n">H_imm</span> <span class="o">==</span> <span class="n">G</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">{</span><span class="n">G_imm</span><span class="p">:</span><span class="mi">1</span><span class="p">}[</span><span class="n">H_imm</span><span class="p">]</span>
<span class="go">1</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.all_cliques">
<span class="sig-name descname"><span class="pre">all_cliques</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.all_cliques" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator over the cliques in <code class="docutils literal notranslate"><span class="pre">graph</span></code>.</p>
<p>A clique is an induced complete subgraph. This method is an iterator over
all the cliques with size in between <code class="docutils literal notranslate"><span class="pre">min_size</span></code> and <code class="docutils literal notranslate"><span class="pre">max_size</span></code>. By
default, this method returns only maximum cliques. Each yielded clique is
represented by a list of vertices.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently only implemented for undirected graphs. Use
<a class="reference internal" href="digraph.html#sage.graphs.digraph.DiGraph.to_undirected" title="sage.graphs.digraph.DiGraph.to_undirected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_undirected()</span></code></a> to convert a digraph
to an undirected graph.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">min_size</span></code> – integer (default: 0); minimum size of reported cliques.
When set to 0 (default), this method searches for maximum cliques. In such
case, parameter <code class="docutils literal notranslate"><span class="pre">max_size</span></code> must also be set to 0.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_size</span></code> – integer (default: 0); maximum size of reported cliques.
When set to 0 (default), the maximum size of the cliques is unbounded.
When <code class="docutils literal notranslate"><span class="pre">min_size</span></code> is set to 0, this parameter must be set to 0.</p></li>
</ul>
<p>ALGORITHM:</p>
<p>This function is based on Cliquer <a class="reference internal" href="../../../references/index.html#no2003" id="id1"><span>[NO2003]</span></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">sage</span><span class="o">.</span><span class="n">graphs</span><span class="o">.</span><span class="n">cliquer</span><span class="o">.</span><span class="n">all_cliques</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
<span class="go">[[0, 1, 2, 3, 4]]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">sage</span><span class="o">.</span><span class="n">graphs</span><span class="o">.</span><span class="n">cliquer</span><span class="o">.</span><span class="n">all_cliques</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">[[3, 4],</span>
<span class="go"> [2, 3],</span>
<span class="go"> [2, 3, 4],</span>
<span class="go"> [2, 4],</span>
<span class="go"> [1, 2],</span>
<span class="go"> [1, 2, 3],</span>
<span class="go"> [1, 2, 4],</span>
<span class="go"> [1, 3],</span>
<span class="go"> [1, 3, 4],</span>
<span class="go"> [1, 4],</span>
<span class="go"> [0, 1],</span>
<span class="go"> [0, 1, 2],</span>
<span class="go"> [0, 1, 3],</span>
<span class="go"> [0, 1, 4],</span>
<span class="go"> [0, 2],</span>
<span class="go"> [0, 2, 3],</span>
<span class="go"> [0, 2, 4],</span>
<span class="go"> [0, 3],</span>
<span class="go"> [0, 3, 4],</span>
<span class="go"> [0, 4]]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">delete_edge</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">sage</span><span class="o">.</span><span class="n">graphs</span><span class="o">.</span><span class="n">cliquer</span><span class="o">.</span><span class="n">all_cliques</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
<span class="go">[[0, 2, 3, 4], [0, 1, 2, 4]]</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="id3">
<p class="admonition-title">Todo</p>
<p>Use the re-entrant functionality of Cliquer <a class="reference internal" href="../../../references/index.html#no2003" id="id2"><span>[NO2003]</span></a> to avoid storing
all cliques.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.antipodal_graph">
<span class="sig-name descname"><span class="pre">antipodal_graph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.antipodal_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the antipodal graph of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The antipodal graph of a graph <span class="math notranslate nohighlight">\(G\)</span> has the same vertex set of <span class="math notranslate nohighlight">\(G\)</span> and
two vertices are adjacent if their distance in <span class="math notranslate nohighlight">\(G\)</span> is equal to the
diameter of <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>OUTPUT:</p>
<p>A new graph. <code class="docutils literal notranslate"><span class="pre">self</span></code> is not touched.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">JohnsonGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">antipodal_graph</span><span class="p">()</span>
<span class="go">Antipodal graph of Johnson graph with parameters 10,5: Graph on 252 vertices</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">HammingGraph</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">antipodal_graph</span><span class="p">()</span>
<span class="go">Antipodal graph of Hamming Graph with parameters 8,2: Graph on 256 vertices</span>
</pre></div>
</div>
<p>The antipodal graph of a disconnected graph is its complement:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">antipodal_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">complement</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.apex_vertices">
<span class="sig-name descname"><span class="pre">apex_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.apex_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of apex vertices.</p>
<p>A graph is apex if it can be made planar by the removal of a single
vertex. The deleted vertex is called <code class="docutils literal notranslate"><span class="pre">an</span> <span class="pre">apex</span></code> of the graph, and a
graph may have more than one apex. For instance, in the minimal
nonplanar graphs <span class="math notranslate nohighlight">\(K_5\)</span> or <span class="math notranslate nohighlight">\(K_{3,3}\)</span>, every vertex is an apex. The apex
graphs include graphs that are themselves planar, in which case again
every vertex is an apex. The null graph is also counted as an apex graph
even though it has no vertex to remove.  If the graph is not connected,
we say that it is apex if it has at most one non planar connected
component and that this component is apex.  See the
<a class="reference external" href="https://en.wikipedia.org/wiki/Apex_graph">Wikipedia article Apex_graph</a> for more information.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.is_apex" title="sage.graphs.graph.Graph.is_apex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_apex()</span></code></a></p></li>
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.is_planar" title="sage.graphs.generic_graph.GenericGraph.is_planar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_planar()</span></code></a></p></li>
</ul>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); when set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the method
returns the list of all apex of the graph, possibly empty if the graph
is not apex. When set to a positive integer, the method ends as soon
as <span class="math notranslate nohighlight">\(k\)</span> apex vertices are found.</p></li>
</ul>
<p>OUTPUT:</p>
<p>By default, the method returns the list of all apex of the graph. When
parameter <code class="docutils literal notranslate"><span class="pre">k</span></code> is set to a positive integer, the returned list is
bounded to <span class="math notranslate nohighlight">\(k\)</span> apex vertices.</p>
<p>EXAMPLES:</p>
<p><span class="math notranslate nohighlight">\(K_5\)</span> and <span class="math notranslate nohighlight">\(K_{3,3}\)</span> are apex graphs, and each of their vertices is an
apex:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">apex_vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_apex</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">apex_vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4, 5]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">apex_vertices</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[0, 1, 2]</span>
</pre></div>
</div>
<p>A <span class="math notranslate nohighlight">\(4\\times 4\)</span>-grid is apex and each of its vertices is an apex. When
adding a universal vertex, the resulting graph is apex and the universal
vertex is the unique apex vertex</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">set</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">apex_vertices</span><span class="p">())</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="s1">&#39;universal&#39;</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">apex_vertices</span><span class="p">()</span>
<span class="go">[&#39;universal&#39;]</span>
</pre></div>
</div>
<p>The Petersen graph is not apex:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">apex_vertices</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>A graph is apex if all its connected components are apex, but at most
one is not planar:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K5</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">M</span><span class="o">+</span><span class="n">K5</span><span class="p">)</span><span class="o">.</span><span class="n">apex_vertices</span><span class="p">()</span>
<span class="go">[9, 10, 11, 12, 13]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">M</span><span class="o">+</span><span class="n">K5</span><span class="o">+</span><span class="n">K5</span><span class="p">)</span><span class="o">.</span><span class="n">apex_vertices</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>Neighbors of an apex of degree 2 are apex:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="mi">666</span><span class="p">,</span> <span class="mi">666</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_path</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_planar</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">apex_vertices</span><span class="p">())</span>
<span class="go">[(1, 1), (2, 2), (3, 3), (666, 666)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.arboricity">
<span class="sig-name descname"><span class="pre">arboricity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.arboricity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the arboricity of the graph and an optional certificate.</p>
<p>The arboricity is the minimum number of forests that covers the
graph.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Arboricity">Wikipedia article Arboricity</a></p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return
a certificate.</p></li>
</ul>
<p>OUTPUT:</p>
<p>When <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></code>, then the function returns <span class="math notranslate nohighlight">\((a, F)\)</span>
where <span class="math notranslate nohighlight">\(a\)</span> is the arboricity and <span class="math notranslate nohighlight">\(F\)</span> is a list of <span class="math notranslate nohighlight">\(a\)</span> disjoint forests
that partitions the edge set of <span class="math notranslate nohighlight">\(g\)</span>. The forests are represented as
subgraphs of the original graph.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">False</span></code>, the function returns just a integer
indicating the arboricity.</p>
<p>ALGORITHM:</p>
<p>Represent the graph as a graphical matroid, then apply matroid
<code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.matroid.partition()</span></code> algorithm from the matroids module.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span><span class="p">,</span><span class="n">F</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">arboricity</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">([</span><span class="n">f</span><span class="o">.</span><span class="n">is_forest</span><span class="p">()</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">F</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">F</span><span class="p">]))</span> <span class="o">==</span> <span class="n">G</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.atoms_and_clique_separators">
<span class="sig-name descname"><span class="pre">atoms_and_clique_separators</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rooted_tree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">separators</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.atoms_and_clique_separators" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the atoms of the decomposition of <span class="math notranslate nohighlight">\(G\)</span> by clique minimal separators.</p>
<p>Let <span class="math notranslate nohighlight">\(G = (V, E)\)</span> be a graph. A set <span class="math notranslate nohighlight">\(S \subset V\)</span> is a clique separator if
<span class="math notranslate nohighlight">\(G[S]\)</span> is a clique and the graph <span class="math notranslate nohighlight">\(G \setminus S\)</span> has at least 2 connected
components. Let <span class="math notranslate nohighlight">\(C \subset V\)</span> be the vertices of a connected component of <span class="math notranslate nohighlight">\(G
\setminus S\)</span>. The graph <span class="math notranslate nohighlight">\(G[C + S]\)</span> is an <em>atom</em> if it has no clique
separator.</p>
<p>This method implements the algorithm proposed in <a class="reference internal" href="../../../references/index.html#bps2010" id="id4"><span>[BPS2010]</span></a>, that improves
upon the algorithm proposed in <a class="reference internal" href="../../../references/index.html#ty1984" id="id5"><span>[TY1984]</span></a>, for computing the atoms and the
clique minimal separators of a graph. This algorithm is based on the
<a class="reference internal" href="traversals.html#sage.graphs.traversals.maximum_cardinality_search_M" title="sage.graphs.traversals.maximum_cardinality_search_M"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximum_cardinality_search_M()</span></code></a> graph traversal
and has time complexity in <span class="math notranslate nohighlight">\(O(|V|\cdot|E|)\)</span>.</p>
<p>If the graph is not connected, we insert empty separators between the lists
of separators of each connected components. See the examples below for more
details.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a Sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tree</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the result as
a directed tree in which internal nodes are clique separators and leaves
are the atoms of the decomposition. Since a clique separator is repeated
when its removal partition the graph into 3 or more connected components,
vertices are labels by tuples <span class="math notranslate nohighlight">\((i, S)\)</span>, where <span class="math notranslate nohighlight">\(S\)</span> is the set of vertices
of the atom or the clique separator, and <span class="math notranslate nohighlight">\(0 \leq i \leq |T|\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rooted_tree</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
result as a <a class="reference external" href="../../../combinat/sage/combinat/rooted_tree.html#sage.combinat.rooted_tree.LabelledRootedTree" title="(in Sage 9.5 Reference Manual: Combinatorics v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">LabelledRootedTree</span></code></a>. When
<code class="docutils literal notranslate"><span class="pre">tree</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, this parameter is ignored.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">separators</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to also return the
complete list of separators considered during the execution of the
algorithm. When <code class="docutils literal notranslate"><span class="pre">tree</span></code> or <code class="docutils literal notranslate"><span class="pre">rooted_tree</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, this parameter is
ignored.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>By default, return a tuple <span class="math notranslate nohighlight">\((A, S_c)\)</span>, where <span class="math notranslate nohighlight">\(A\)</span> is the list of atoms of
the graph in the order of discovery, and <span class="math notranslate nohighlight">\(S_c\)</span> is the list of clique
separators, with possible repetitions, in the order the separator has been
considered. If furthermore <code class="docutils literal notranslate"><span class="pre">separators</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, return a tuple <span class="math notranslate nohighlight">\((A,
S_h, S_c)\)</span>, where <span class="math notranslate nohighlight">\(S_c\)</span> is the list of considered separators of the graph
in the order they have been considered.</p></li>
<li><p>When <code class="docutils literal notranslate"><span class="pre">tree</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, format the result as a directed tree</p></li>
<li><p>When <code class="docutils literal notranslate"><span class="pre">rooted_tree</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">tree</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, format the
output as a <a class="reference external" href="../../../combinat/sage/combinat/rooted_tree.html#sage.combinat.rooted_tree.LabelledRootedTree" title="(in Sage 9.5 Reference Manual: Combinatorics v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">LabelledRootedTree</span></code></a></p></li>
</ul>
<p>EXAMPLES:</p>
<p>Example of <a class="reference internal" href="../../../references/index.html#bps2010" id="id6"><span>[BPS2010]</span></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">],</span>
<span class="gp">....: </span>           <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">],</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;g&#39;</span><span class="p">],</span>
<span class="gp">....: </span>           <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">],</span> <span class="s1">&#39;g&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">],</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">],</span>
<span class="gp">....: </span>           <span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">],</span> <span class="s1">&#39;j&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">atoms</span><span class="p">,</span> <span class="n">cliques</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">atoms_and_clique_separators</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">)</span>
<span class="go">[[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;k&#39;],</span>
<span class="go"> [&#39;c&#39;, &#39;d&#39;, &#39;j&#39;, &#39;k&#39;],</span>
<span class="go"> [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;j&#39;, &#39;k&#39;],</span>
<span class="go"> [&#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;]]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cliques</span><span class="p">)</span>
<span class="go">[[&#39;c&#39;, &#39;k&#39;], [&#39;d&#39;, &#39;j&#39;, &#39;k&#39;], [&#39;j&#39;, &#39;k&#39;]]</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">atoms_and_clique_separators</span><span class="p">(</span><span class="n">tree</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">is_tree</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">diameter</span><span class="p">()</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">atoms</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">T</span> <span class="k">if</span> <span class="n">T</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">cliques</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">T</span> <span class="k">if</span> <span class="n">T</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A graph without clique separator:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">atoms_and_clique_separators</span><span class="p">()</span>
<span class="go">([{0, 1, 2, 3, 4}], [])</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">atoms_and_clique_separators</span><span class="p">(</span><span class="n">rooted_tree</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">{0, 1, 2, 3, 4}</span>
</pre></div>
</div>
<p>Graphs with several biconnected components:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">atoms_and_clique_separators</span><span class="p">(</span><span class="n">rooted_tree</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">  ____{2}____</span>
<span class="go"> /          /</span>
<span class="go">{2, 3}   __{1}__</span>
<span class="go">        /      /</span>
<span class="go">       {1, 2} {0, 1}</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">WindmillGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">atoms_and_clique_separators</span><span class="p">()</span>
<span class="go">([{0, 1, 2}, {0, 3, 4}, {0, 5, 6}, {0, 8, 7}], [{0}, {0}, {0}])</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">atoms_and_clique_separators</span><span class="p">(</span><span class="n">rooted_tree</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">  ________{0}________</span>
<span class="go"> /                  /</span>
<span class="go">{0, 1, 2}   _______{0}______</span>
<span class="go">           /               /</span>
<span class="go">          {0, 3, 4}   ____{0}___</span>
<span class="go">                     /         /</span>
<span class="go">                    {0, 8, 7} {0, 5, 6}</span>
</pre></div>
</div>
<p>When the removal of a clique separator results in <span class="math notranslate nohighlight">\(k &gt; 2\)</span> connected
components, this separator is repeated <span class="math notranslate nohighlight">\(k - 1\)</span> times, but the repetitions
are not necessarily contiguous:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">G</span><span class="o">.</span><span class="n">add_cycle</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">()])</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">atoms_and_clique_separators</span><span class="p">(</span><span class="n">rooted_tree</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">  _________{0, 1}_____</span>
<span class="go"> /                   /</span>
<span class="go">{0, 1, 4}   ________{0, 1}_____</span>
<span class="go">           /                  /</span>
<span class="go">          {0, 1, 2}   _______{0, 1}___</span>
<span class="go">                     /               /</span>
<span class="go">                    {0, 1, 3}   ____{0, 1}</span>
<span class="go">                               /         /</span>
<span class="go">                              {0, 1, 5} {0, 1, 6}</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">StarGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">subdivide_edges</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(),</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">atoms_and_clique_separators</span><span class="p">(</span><span class="n">rooted_tree</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">  ______{5}______</span>
<span class="go"> /              /</span>
<span class="go">{1, 5}   ______{7}______</span>
<span class="go">        /              /</span>
<span class="go">       {2, 7}   ______{9}______</span>
<span class="go">               /              /</span>
<span class="go">              {9, 3}   ______{6}______</span>
<span class="go">                      /              /</span>
<span class="go">                     {6, 7}   ______{4}_____</span>
<span class="go">                             /             /</span>
<span class="go">                            {4, 5}   _____{0}_____</span>
<span class="go">                                    /            /</span>
<span class="go">                                   {0, 6}   ____{8}____</span>
<span class="go">                                           /          /</span>
<span class="go">                                          {8, 9}   __{0}__</span>
<span class="go">                                                  /      /</span>
<span class="go">                                                 {0, 8} {0, 4}</span>
</pre></div>
</div>
<p>If the graph is not connected, we insert empty separators between the lists
of separators of each connected components. For instance, let <span class="math notranslate nohighlight">\(G\)</span> be a graph
with 3 connected components. The method returns the list <span class="math notranslate nohighlight">\(S_c =
[S_0,\cdots,S_{i},\ldots, S_{j},\ldots,S_{k-1}]\)</span> of <span class="math notranslate nohighlight">\(k\)</span> clique separators,
where <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> are the indexes of the inserted empty separators and <span class="math notranslate nohighlight">\(0
\leq i &lt; j &lt; k - 1\)</span>. The method also returns the list <span class="math notranslate nohighlight">\(A =
[A_0,\ldots,S_{k}]\)</span> of the <span class="math notranslate nohighlight">\(k + 1\)</span> atoms, with <span class="math notranslate nohighlight">\(k + 1 \geq 3\)</span>. The lists of
atoms and clique separators of each of the connected components are
respectively <span class="math notranslate nohighlight">\([A_0,\ldots,A_{i}]\)</span> and <span class="math notranslate nohighlight">\([S_0,\ldots,S_{i-1}]\)</span>,
<span class="math notranslate nohighlight">\([A_{i+1},\ldots,A_{j}]\)</span> and <span class="math notranslate nohighlight">\([S_{i+1},\ldots,S_{j-1}]\)</span>, and
<span class="math notranslate nohighlight">\([A_{j+1},\ldots,A_{k}]\)</span> and <span class="math notranslate nohighlight">\([S_{j+1},\ldots,S_{k-1}]\)</span>. One can check that
for each connected component, we get one atom more than clique separators:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">,</span> <span class="n">Sc</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">atoms_and_clique_separators</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span>
<span class="go">[{1, 2}, {0, 1}, {4, 5}, {3, 4}, {8, 7}, {6, 7}]</span>
<span class="gp">sage: </span><span class="n">Sc</span>
<span class="go">[{1}, {}, {4}, {}, {7}]</span>
<span class="gp">sage: </span><span class="n">i</span> <span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Sc</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">i</span><span class="p">,</span> <span class="n">j</span>
<span class="go">(1, 3)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">[:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">Sc</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>
<span class="go">([{1, 2}, {0, 1}], [{1}])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">Sc</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">j</span><span class="p">]</span>
<span class="go">([{4, 5}, {3, 4}], [{4}])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="n">Sc</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="go">([{8, 7}, {6, 7}], [{7}])</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">Sc</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">I</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">Sc</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">j</span><span class="p">])</span>
<span class="go">[{1, 2}, {0, 1}] [{1}]</span>
<span class="go">[{4, 5}, {3, 4}] [{4}]</span>
<span class="go">[{8, 7}, {6, 7}] [{7}]</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">atoms_and_clique_separators</span><span class="p">(</span><span class="n">rooted_tree</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">  ______{1}______</span>
<span class="go"> /              /</span>
<span class="go">{1, 2}   ______{}______</span>
<span class="go">        /             /</span>
<span class="go">       {0, 1}   _____{4}_____</span>
<span class="go">               /            /</span>
<span class="go">              {4, 5}   ____{}_____</span>
<span class="go">                      /          /</span>
<span class="go">                     {3, 4}   __{7}__</span>
<span class="go">                             /      /</span>
<span class="go">                            {6, 7} {8, 7}</span>
</pre></div>
</div>
<p>Loops and multiple edges are ignored:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_loops</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">G</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_multiple_edges</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">atoms_and_clique_separators</span><span class="p">(</span><span class="n">rooted_tree</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">  ______{1}______</span>
<span class="go"> /              /</span>
<span class="go">{1, 2}   ______{}______</span>
<span class="go">        /             /</span>
<span class="go">       {0, 1}   _____{4}_____</span>
<span class="go">               /            /</span>
<span class="go">              {4, 5}   ____{}_____</span>
<span class="go">                      /          /</span>
<span class="go">                     {3, 4}   __{7}__</span>
<span class="go">                             /      /</span>
<span class="go">                            {6, 7} {8, 7}</span>
</pre></div>
</div>
<p>We can check that the returned list of separators is valid:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mf">.1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">while</span> <span class="ow">not</span> <span class="n">G</span><span class="o">.</span><span class="n">is_connected</span><span class="p">():</span>
<span class="gp">....: </span>    <span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mf">.1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">separators</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">atoms_and_clique_separators</span><span class="p">(</span><span class="n">separators</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">S</span> <span class="ow">in</span> <span class="n">separators</span><span class="p">:</span>
<span class="gp">....: </span>    <span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="n">H</span><span class="o">.</span><span class="n">delete_vertices</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="n">H</span><span class="o">.</span><span class="n">is_connected</span><span class="p">():</span>
<span class="gp">....: </span>        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;something goes wrong&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.bipartite_color">
<span class="sig-name descname"><span class="pre">bipartite_color</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.bipartite_color" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary with vertices as the keys and the color class
as the values.</p>
<p>Fails with an error if the graph is not bipartite.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">bipartite_color</span><span class="p">()</span>
<span class="go">{0: 1, 1: 0, 2: 1, 3: 0}</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">bipartite_color</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">RuntimeError: Graph is not bipartite.</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.bipartite_double">
<span class="sig-name descname"><span class="pre">bipartite_double</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">extended</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.bipartite_double" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the (extended) bipartite double of this graph.</p>
<p>The bipartite double of a graph <span class="math notranslate nohighlight">\(G\)</span> has vertex set
<span class="math notranslate nohighlight">\(\{ (v,0), (v,1) : v \in G\}\)</span> and for any edge <span class="math notranslate nohighlight">\((u, v)\)</span> in <span class="math notranslate nohighlight">\(G\)</span>
it has edges <span class="math notranslate nohighlight">\(((u,0),(v,1))\)</span> and <span class="math notranslate nohighlight">\(((u,1),(v,0))\)</span>.
Note that this is the tensor product of <span class="math notranslate nohighlight">\(G\)</span> with <span class="math notranslate nohighlight">\(K_2\)</span>.</p>
<p>The extended bipartite double of <span class="math notranslate nohighlight">\(G\)</span> is the bipartite double of
<span class="math notranslate nohighlight">\(G\)</span> after added all edges <span class="math notranslate nohighlight">\(((v,0),(v,1))\)</span> for all vertices <span class="math notranslate nohighlight">\(v\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">extended</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); Whether to return the
extended bipartite double, or only the bipartite double (default)</p></li>
</ul>
<p>OUTPUT:</p>
<p>A graph; <code class="docutils literal notranslate"><span class="pre">self</span></code> is left untouched.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">bipartite_double</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">==</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>  <span class="c1"># G is left invariant</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">order</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">G</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">is_bipartite</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">bipartite_sets</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="nb">set</span><span class="p">([(</span><span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">]),</span>
<span class="gp">....: </span><span class="nb">set</span><span class="p">([(</span><span class="n">v</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">]))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">tensor_product</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Behaviour with disconnected graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G1</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G2</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">HoffmanGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">G1</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">G2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">bipartite_double</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H1</span> <span class="o">=</span> <span class="n">G1</span><span class="o">.</span><span class="n">bipartite_double</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H2</span> <span class="o">=</span> <span class="n">G2</span><span class="o">.</span><span class="n">bipartite_double</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">H1</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">H2</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Bipartite_double_cover">Wikipedia article Bipartite_double_cover</a>,
<a class="reference external" href="https://mathworld.wolfram.com/BipartiteDoubleGraph.html">WolframAlpha Bipartite Double</a>,
<a class="reference internal" href="../../../references/index.html#vdkt2016" id="id7"><span>[VDKT2016]</span></a> p. 20 for the extended bipartite double.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.bipartite_sets">
<span class="sig-name descname"><span class="pre">bipartite_sets</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.bipartite_sets" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <span class="math notranslate nohighlight">\((X,Y)\)</span> where <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> are the nodes in each bipartite set of
graph <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>Fails with an error if graph is not bipartite.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">bipartite_sets</span><span class="p">()</span>
<span class="go">({0, 2}, {1, 3})</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">bipartite_sets</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">RuntimeError: Graph is not bipartite.</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.bounded_outdegree_orientation">
<span class="sig-name descname"><span class="pre">bounded_outdegree_orientation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bound</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.bounded_outdegree_orientation" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes an orientation of <code class="docutils literal notranslate"><span class="pre">self</span></code> such that every vertex <span class="math notranslate nohighlight">\(v\)</span> has
out-degree less than <span class="math notranslate nohighlight">\(b(v)\)</span></p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bound</span></code> – Maximum bound on the out-degree. Can be of three
different types :</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>An integer <span class="math notranslate nohighlight">\(k\)</span>. In this case, computes an orientation whose maximum
out-degree is less than <span class="math notranslate nohighlight">\(k\)</span>.</p></li>
<li><p>A dictionary associating to each vertex its associated maximum
out-degree.</p></li>
<li><p>A function associating to each vertex its associated maximum
out-degree.</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A DiGraph representing the orientation if it exists. A <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>
exception is raised otherwise.</p>
<p>ALGORITHM:</p>
<p>The problem is solved through a maximum flow :</p>
<p>Given a graph <span class="math notranslate nohighlight">\(G\)</span>, we create a <code class="docutils literal notranslate"><span class="pre">DiGraph</span></code> <span class="math notranslate nohighlight">\(D\)</span> defined on <span class="math notranslate nohighlight">\(E(G)\cup
V(G)\cup \{s,t\}\)</span>. We then link <span class="math notranslate nohighlight">\(s\)</span> to all of <span class="math notranslate nohighlight">\(V(G)\)</span> (these edges having
a capacity equal to the bound associated to each element of <span class="math notranslate nohighlight">\(V(G)\)</span>), and
all the elements of <span class="math notranslate nohighlight">\(E(G)\)</span> to <span class="math notranslate nohighlight">\(t\)</span> . We then link each <span class="math notranslate nohighlight">\(v \in V(G)\)</span> to
each of its incident edges in <span class="math notranslate nohighlight">\(G\)</span>. A maximum integer flow of value
<span class="math notranslate nohighlight">\(|E(G)|\)</span> corresponds to an admissible orientation of <span class="math notranslate nohighlight">\(G\)</span>. Otherwise,
none exists.</p>
<p>EXAMPLES:</p>
<p>There is always an orientation of a graph <span class="math notranslate nohighlight">\(G\)</span> such that a vertex <span class="math notranslate nohighlight">\(v\)</span> has
out-degree at most <span class="math notranslate nohighlight">\(\lceil \frac {d(v)} 2 \rceil\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mf">.4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">integer_ceil</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">bounded_outdegree_orientation</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">D</span><span class="o">.</span><span class="n">out_degree</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">g</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Chvatal’s graph, being 4-regular, can be oriented in such a way that its
maximum out-degree is 2:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">bounded_outdegree_orientation</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">max</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">out_degree</span><span class="p">())</span>
<span class="go">2</span>
</pre></div>
</div>
<p>For any graph <span class="math notranslate nohighlight">\(G\)</span>, it is possible to compute an orientation such that
the maximum out-degree is at most the maximum average degree of <span class="math notranslate nohighlight">\(G\)</span>
divided by 2. Anything less, though, is impossible.</p>
<blockquote>
<div><p>sage: g = graphs.RandomGNP(40, .4)
sage: mad = g.maximum_average_degree()</p>
</div></blockquote>
<p>Hence this is possible</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">bounded_outdegree_orientation</span><span class="p">(</span><span class="n">integer_ceil</span><span class="p">(</span><span class="n">mad</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>While this is not:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">try</span><span class="p">:</span>
<span class="gp">....: </span>    <span class="n">g</span><span class="o">.</span><span class="n">bounded_outdegree_orientation</span><span class="p">(</span><span class="n">integer_ceil</span><span class="p">(</span><span class="n">mad</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error&quot;</span><span class="p">)</span>
<span class="gp">....: </span><span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
<span class="gp">....: </span>    <span class="k">pass</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.bridges">
<span class="sig-name descname"><span class="pre">bridges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.bridges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over the bridges (or cut edges).</p>
<p>A bridge is an edge whose deletion disconnects the undirected graph.
A disconnected graph has no bridge.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">False</span></code>, each bridge is a
tuple <span class="math notranslate nohighlight">\((u, v)\)</span> of vertices</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.connectivity</span> <span class="kn">import</span> <span class="n">bridges</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.connectivity</span> <span class="kn">import</span> <span class="n">is_connected</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">is_connected</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">bridges</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
<span class="go">[(1, 10, None)]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">bridges</span><span class="p">())</span>
<span class="go">[(1, 10, None)]</span>
</pre></div>
</div>
<p>Every edge of a tree is a bridge:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomTree</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">bridges</span><span class="p">())</span> <span class="o">==</span> <span class="mi">99</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.center">
<span class="sig-name descname"><span class="pre">center</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">by_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.center" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the set of vertices in the center of the graph.</p>
<p>The center is the set of vertices whose eccentricity is equal to the
radius of the graph, i.e., achieving the minimum eccentricity.</p>
<p>For more information and examples on how to use input variables,
see <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.shortest_paths" title="sage.graphs.generic_graph.GenericGraph.shortest_paths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shortest_paths()</span></code></a> and
<a class="reference internal" href="#sage.graphs.graph.Graph.eccentricity" title="sage.graphs.graph.Graph.eccentricity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eccentricity()</span></code></a></p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">by_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, edge
weights are taken into account; if False, all edges have weight 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); see method
<a class="reference internal" href="#sage.graphs.graph.Graph.eccentricity" title="sage.graphs.graph.Graph.eccentricity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eccentricity()</span></code></a> for the list of available algorithms</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
takes as input an edge <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></code> and outputs its weight. If not
<code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is automatically set to <code class="docutils literal notranslate"><span class="pre">True</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>
and <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, we use the edge label <code class="docutils literal notranslate"><span class="pre">l</span></code> as a
weight, if <code class="docutils literal notranslate"><span class="pre">l</span></code> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, else <code class="docutils literal notranslate"><span class="pre">1</span></code> as a weight.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, we check
that the <code class="docutils literal notranslate"><span class="pre">weight_function</span></code> outputs a number for each edge</p></li>
</ul>
<p>EXAMPLES:</p>
<p>Is Central African Republic in the center of Africa in graph theoretic
sense? Yes:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">AfricaMap</span><span class="p">(</span><span class="n">continental</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">center</span><span class="p">())</span>
<span class="go">[&#39;Cameroon&#39;, &#39;Central Africa&#39;]</span>
</pre></div>
</div>
<p>Some other graphs. Center can be the whole graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DiamondGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">center</span><span class="p">()</span>
<span class="go">[1, 2]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">center</span><span class="p">())</span> <span class="o">==</span> <span class="n">P</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">StarGraph</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">center</span><span class="p">()</span>
<span class="go">[0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.centrality_degree">
<span class="sig-name descname"><span class="pre">centrality_degree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.centrality_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the degree centrality of a vertex.</p>
<p>The degree centrality of a vertex <span class="math notranslate nohighlight">\(v\)</span> is its degree, divided by
<span class="math notranslate nohighlight">\(|V(G)|-1\)</span>. For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Centrality">Wikipedia article Centrality</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">v</span></code> – a vertex (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); set to <code class="docutils literal notranslate"><span class="pre">None</span></code> (default) to
get a dictionary associating each vertex with its centrality degree.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.centrality_closeness" title="sage.graphs.generic_graph.GenericGraph.centrality_closeness"><code class="xref py py-meth docutils literal notranslate"><span class="pre">centrality_closeness()</span></code></a></p></li>
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.centrality_betweenness" title="sage.graphs.generic_graph.GenericGraph.centrality_betweenness"><code class="xref py py-meth docutils literal notranslate"><span class="pre">centrality_betweenness()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">())</span><span class="o">.</span><span class="n">centrality_degree</span><span class="p">()</span>
<span class="go">{0: 4/11, 1: 4/11, 2: 4/11, 3: 4/11,  4: 4/11,  5: 4/11,</span>
<span class="go"> 6: 4/11, 7: 4/11, 8: 4/11, 9: 4/11, 10: 4/11, 11: 4/11}</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DiamondGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">centrality_degree</span><span class="p">()</span>
<span class="go">{0: 2/3, 1: 1, 2: 1, 3: 2/3}</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">centrality_degree</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.cheeger_constant">
<span class="sig-name descname"><span class="pre">cheeger_constant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.cheeger_constant" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cheeger constant of the graph.</p>
<p>The Cheeger constant of a graph <span class="math notranslate nohighlight">\(G = (V,E)\)</span> is the minimum of <span class="math notranslate nohighlight">\(|\partial S|
/ |Vol(S)|\)</span> where <span class="math notranslate nohighlight">\(Vol(S)\)</span> is the sum of degrees of element in <span class="math notranslate nohighlight">\(S\)</span>,
<span class="math notranslate nohighlight">\(\partial S\)</span> is the edge boundary of <span class="math notranslate nohighlight">\(S\)</span> (number of edges with one end in
<span class="math notranslate nohighlight">\(S\)</span> and one end in <span class="math notranslate nohighlight">\(V \setminus S\)</span>) and the minimum is taken over all
non-empty subsets <span class="math notranslate nohighlight">\(S\)</span> of vertices so that <span class="math notranslate nohighlight">\(|Vol(S)| \leq |E|\)</span>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Alternative but similar quantities can be obtained via the methods
<a class="reference internal" href="#sage.graphs.graph.Graph.edge_isoperimetric_number" title="sage.graphs.graph.Graph.edge_isoperimetric_number"><code class="xref py py-meth docutils literal notranslate"><span class="pre">edge_isoperimetric_number()</span></code></a> and <a class="reference internal" href="#sage.graphs.graph.Graph.vertex_isoperimetric_number" title="sage.graphs.graph.Graph.vertex_isoperimetric_number"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertex_isoperimetric_number()</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">cheeger_constant</span><span class="p">()</span>
<span class="go">1/3</span>
</pre></div>
</div>
<p>The Cheeger constant of a cycle on <span class="math notranslate nohighlight">\(n\)</span> vertices is
<span class="math notranslate nohighlight">\(1/\lfloor n/2 \rfloor\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">cheeger_constant</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">10</span><span class="p">)]</span>
<span class="go">[1, 1, 1/2, 1/2, 1/3, 1/3, 1/4, 1/4]</span>
</pre></div>
</div>
<p>The Cheeger constant of a complete graph on <span class="math notranslate nohighlight">\(n\)</span> vertices is
<span class="math notranslate nohighlight">\(\lceil n/2 \rceil / (n-1)\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">cheeger_constant</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">10</span><span class="p">)]</span>
<span class="go">[1, 1, 2/3, 3/4, 3/5, 2/3, 4/7, 5/8]</span>
</pre></div>
</div>
<p>For complete bipartite:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">cheeger_constant</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">)]</span>
<span class="go">[3/5, 1/2, 3/5, 5/9, 4/7, 5/9, 1/2, 5/9, 1/2, 5/9]</span>
</pre></div>
</div>
<p>More examples:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
<span class="gp">....: </span>           <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cheeger_constant</span><span class="p">()</span>
<span class="go">1/6</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cheeger_constant</span><span class="p">()</span>
<span class="go">1/2</span>

<span class="gp">sage: </span><span class="n">Graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)]])</span><span class="o">.</span><span class="n">cheeger_constant</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.chromatic_index">
<span class="sig-name descname"><span class="pre">chromatic_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solver</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.chromatic_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chromatic index of the graph.</p>
<p>The chromatic index is the minimal number of colors needed to properly
color the edges of the graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>This method is a frontend for method
<a class="reference internal" href="graph_coloring.html#sage.graphs.graph_coloring.edge_coloring" title="sage.graphs.graph_coloring.edge_coloring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.graphs.graph_coloring.edge_coloring()</span></code></a> that uses a mixed
integer-linear programming formulation to compute the chromatic index.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Edge_coloring">Wikipedia article Edge_coloring</a> for further details on edge coloring</p></li>
<li><p><a class="reference internal" href="graph_coloring.html#sage.graphs.graph_coloring.edge_coloring" title="sage.graphs.graph_coloring.edge_coloring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.graphs.graph_coloring.edge_coloring()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.fractional_chromatic_index" title="sage.graphs.graph.Graph.fractional_chromatic_index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fractional_chromatic_index()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.chromatic_number" title="sage.graphs.graph.Graph.chromatic_number"><code class="xref py py-meth docutils literal notranslate"><span class="pre">chromatic_number()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>The clique <span class="math notranslate nohighlight">\(K_n\)</span> has chromatic index <span class="math notranslate nohighlight">\(n\)</span> when <span class="math notranslate nohighlight">\(n\)</span> is odd and <span class="math notranslate nohighlight">\(n-1\)</span> when
<span class="math notranslate nohighlight">\(n\)</span> is even:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_index</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_index</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_index</span><span class="p">()</span>
<span class="go">5</span>
</pre></div>
</div>
<p>The path <span class="math notranslate nohighlight">\(P_n\)</span> with <span class="math notranslate nohighlight">\(n \geq 2\)</span> has chromatic index 2:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_index</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
<p>The windmill graph with parameters <span class="math notranslate nohighlight">\(k,n\)</span> has chromatic index <span class="math notranslate nohighlight">\((k-1)n\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">k</span><span class="p">,</span><span class="n">n</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span><span class="mi">4</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">WindmillGraph</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">chromatic_index</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.chromatic_number">
<span class="sig-name descname"><span class="pre">chromatic_number</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DLX'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.chromatic_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimal number of colors needed to color the vertices of the
graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – Select an algorithm from the following supported
algorithms:</p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">algorithm=&quot;DLX&quot;</span></code> (default), the chromatic number is computed
using the dancing link algorithm. It is inefficient speedwise to
compute the chromatic number through the dancing link algorithm
because this algorithm computes <em>all</em> the possible colorings to
check that one exists.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">algorithm=&quot;CP&quot;</span></code>, the chromatic number is computed using the
coefficients of the chromatic polynomial. Again, this method is
inefficient in terms of speed and it only useful for small graphs.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">algorithm=&quot;MILP&quot;</span></code>, the chromatic number is computed using a
mixed integer linear program. The performance of this implementation
is affected by whether optional MILP solvers have been installed
(see the <a class="reference external" href="../../../numerical/sage/numerical/mip.html#module-sage.numerical.mip" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">MILP</span> <span class="pre">module</span></code></a>, or Sage’s tutorial
on Linear Programming).</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>For more functions related to graph coloring, see the module
<a class="reference internal" href="graph_coloring.html#module-sage.graphs.graph_coloring" title="sage.graphs.graph_coloring"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.graphs.graph_coloring</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;DLX&quot;</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;MILP&quot;</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;CP&quot;</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>A bipartite graph has (by definition) chromatic number 2:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">RandomBipartite</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mf">0.7</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
<p>A complete multipartite graph with k parts has chromatic number <span class="math notranslate nohighlight">\(k\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteMultipartiteGraph</span><span class="p">([</span><span class="mi">5</span><span class="p">]</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">()</span> <span class="o">==</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The complete graph has the largest chromatic number from all the graphs
of order <span class="math notranslate nohighlight">\(n\)</span>. Namely its chromatic number is <span class="math notranslate nohighlight">\(n\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">()</span> <span class="o">==</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Kneser graph with parameters <span class="math notranslate nohighlight">\((n, 2)\)</span> for <span class="math notranslate nohighlight">\(n &gt; 3\)</span> has chromatic
number <span class="math notranslate nohighlight">\(n-2\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">KneserGraph</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">()</span> <span class="o">==</span> <span class="n">i</span><span class="o">-</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Flower Snark graph has chromatic index 4 hence its line graph has
chromatic number 4:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">FlowerSnark</span><span class="p">()</span><span class="o">.</span><span class="n">line_graph</span><span class="p">()</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.chromatic_polynomial">
<span class="sig-name descname"><span class="pre">chromatic_polynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_tree_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'C'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cache</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.chromatic_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the chromatic polynomial of the graph G.</p>
<p>The algorithm used is a recursive one, based on the following observations
of Read:</p>
<blockquote>
<div><ul class="simple">
<li><p>The chromatic polynomial of a tree on n vertices is x(x-1)^(n-1).</p></li>
<li><p>If e is an edge of G, G’ is the result of deleting the edge e, and G’’
is the result of contracting e, then the chromatic polynomial of G is
equal to that of G’ minus that of G’’.</p></li>
</ul>
</div></blockquote>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a Sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">return_tree_basis</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); not used yet</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">&quot;C&quot;</span></code>); the algorithm to use among</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;C&quot;</span></code>, an implementation in C by Robert Miller and Gordon Royle.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Python&quot;</span></code>, an implementation in Python using caching to avoid
recomputing the chromatic polynomial of a graph that has already been
seen. This seems faster on some dense graphs.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">cache</span></code> – dictionary (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); this parameter is used only
for algorithm <code class="docutils literal notranslate"><span class="pre">&quot;Python&quot;</span></code>. It is a dictionary keyed by canonical
labelings of graphs and used to cache the chromatic polynomials of the
graphs generated by the algorithm. In other words, it avoids computing
twice the chromatic polynomial of isometric graphs. One will be created
automatically if not provided.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span>
<span class="go">x^4 - 4*x^3 + 6*x^2 - 3*x</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span>
<span class="go">x^3 - 3*x^2 + 2*x</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span>
<span class="go">x^8 - 12*x^7 + 66*x^6 - 214*x^5 + 441*x^4 - 572*x^3 + 423*x^2 - 133*x</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span>
<span class="go">x^10 - 15*x^9 + 105*x^8 - 455*x^7 + 1353*x^6 - 2861*x^5 + 4275*x^4 - 4305*x^3 + 2606*x^2 - 704*x</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span>
<span class="go">x^6 - 9*x^5 + 36*x^4 - 75*x^3 + 78*x^2 - 31*x</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">(x - 1) * x</span>
<span class="go">(x - 2) * (x - 1) * x</span>
<span class="go">(x - 3) * (x - 2) * (x - 1) * x</span>
<span class="go">(x - 4) * (x - 3) * (x - 2) * (x - 1) * x</span>
<span class="go">(x - 5) * (x - 4) * (x - 3) * (x - 2) * (x - 1) * x</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">(x - 2) * (x - 1) * x * (x^2 - 2*x + 2)</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">OctahedralGraph</span><span class="p">()</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">(x - 2) * (x - 1) * x * (x^3 - 9*x^2 + 29*x - 32)</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">WheelGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">(x - 2) * (x - 1) * x * (x^2 - 5*x + 7)</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">WheelGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">(x - 3) * (x - 2) * (x - 1) * x * (x^2 - 4*x + 5)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">LCFGraph</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">],</span> <span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span>  <span class="c1"># long time (6s on sage.math, 2011)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># long time</span>
<span class="go">0</span>
</pre></div>
</div>
<p>By definition, the chromatic number of a graph G is the least integer k such that
the chromatic polynomial of G is strictly positive at k:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">min</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">if</span> <span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mf">0.7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">min</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">if</span> <span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Check that algorithms <code class="docutils literal notranslate"><span class="pre">&quot;C&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;Python&quot;</span></code> return the same results:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Python&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">==</span> <span class="n">p</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.chromatic_quasisymmetric_function">
<span class="sig-name descname"><span class="pre">chromatic_quasisymmetric_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.chromatic_quasisymmetric_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chromatic quasisymmetric function of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Let <span class="math notranslate nohighlight">\(G\)</span> be a graph whose vertex set is totally ordered. The chromatic
quasisymmetric function <span class="math notranslate nohighlight">\(X_G(t)\)</span> was first described in <a class="reference internal" href="../../../references/index.html#sw2012" id="id8"><span>[SW2012]</span></a>. We
use the equivalent definition given in <a class="reference internal" href="../../../references/index.html#bc2018" id="id9"><span>[BC2018]</span></a>:</p>
<div class="math notranslate nohighlight">
\[X_G(t) = \sum_{\sigma=(\sigma_1,\ldots,\sigma_n)}
t^{\operatorname{asc}(\sigma)}
M_{|\sigma_1|,\ldots,|\sigma_n|},\]</div>
<p>where we sum over all ordered set partitions of the vertex set of <span class="math notranslate nohighlight">\(G\)</span>
such that each block <span class="math notranslate nohighlight">\(\sigma_i\)</span> is an independent (i.e., stable) set of
<span class="math notranslate nohighlight">\(G\)</span>, and where <span class="math notranslate nohighlight">\(\operatorname{asc}(\sigma)\)</span> denotes the number of edges
<span class="math notranslate nohighlight">\(\{u, v\}\)</span> of <span class="math notranslate nohighlight">\(G\)</span> such that <span class="math notranslate nohighlight">\(u &lt; v\)</span> and <span class="math notranslate nohighlight">\(v\)</span> appears in a later part of
<span class="math notranslate nohighlight">\(\sigma\)</span> than <span class="math notranslate nohighlight">\(u\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code> – (optional) the parameter <span class="math notranslate nohighlight">\(t\)</span>; uses the variable <span class="math notranslate nohighlight">\(t\)</span> in
<span class="math notranslate nohighlight">\(\ZZ[t]\)</span> by default</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">R</span></code> – (optional) the base ring for the quasisymmetric functions;
uses the parent of <span class="math notranslate nohighlight">\(t\)</span> by default</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">chromatic_quasisymmetric_function</span><span class="p">()</span>
<span class="go">(2*t^2+2*t+2)*M[1, 1, 1] + M[1, 2] + t^2*M[2, 1]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">XG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_quasisymmetric_function</span><span class="p">();</span> <span class="n">XG</span>
<span class="go">(t^3+11*t^2+11*t+1)*M[1, 1, 1, 1] + (3*t^2+3*t)*M[1, 1, 2]</span>
<span class="go"> + (3*t^2+3*t)*M[1, 2, 1] + (3*t^2+3*t)*M[2, 1, 1]</span>
<span class="go"> + (t^2+t)*M[2, 2]</span>
<span class="gp">sage: </span><span class="n">XG</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="go">(t^3+11*t^2+11*t+1)*m[1, 1, 1, 1] + (3*t^2+3*t)*m[2, 1, 1]</span>
<span class="go"> + (t^2+t)*m[2, 2]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">chromatic_quasisymmetric_function</span><span class="p">()</span>
<span class="go">(t^6+3*t^5+5*t^4+6*t^3+5*t^2+3*t+1)*M[1, 1, 1, 1]</span>
</pre></div>
</div>
<p>Not all chromatic quasisymmetric functions are symmetric:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">chromatic_quasisymmetric_function</span><span class="p">()</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We check that at <span class="math notranslate nohighlight">\(t = 1\)</span>, we recover the usual chromatic symmetric
function:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">XG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_quasisymmetric_function</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span> <span class="n">XG</span>
<span class="go">120*M[1, 1, 1, 1, 1] + 30*M[1, 1, 1, 2] + 30*M[1, 1, 2, 1]</span>
<span class="go"> + 30*M[1, 2, 1, 1] + 10*M[1, 2, 2] + 30*M[2, 1, 1, 1]</span>
<span class="go"> + 10*M[2, 1, 2] + 10*M[2, 2, 1]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="n">XG</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">())</span>
<span class="go">p[1, 1, 1, 1, 1] - 5*p[2, 1, 1, 1] + 5*p[2, 2, 1]</span>
<span class="go"> + 5*p[3, 1, 1] - 5*p[3, 2] - 5*p[4, 1] + 4*p[5]</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">ClawGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">XG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_quasisymmetric_function</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span> <span class="n">XG</span>
<span class="go">24*M[1, 1, 1, 1] + 6*M[1, 1, 2] + 6*M[1, 2, 1] + M[1, 3]</span>
<span class="go"> + 6*M[2, 1, 1] + M[3, 1]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="n">XG</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">())</span>
<span class="go">p[1, 1, 1, 1] - 3*p[2, 1, 1] + 3*p[3, 1] - p[4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.chromatic_symmetric_function">
<span class="sig-name descname"><span class="pre">chromatic_symmetric_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.chromatic_symmetric_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chromatic symmetric function of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Let <span class="math notranslate nohighlight">\(G\)</span> be a graph. The chromatic symmetric function <span class="math notranslate nohighlight">\(X_G\)</span> was described
in <a class="reference internal" href="../../../references/index.html#sta1995" id="id10"><span>[Sta1995]</span></a>, specifically Theorem 2.5 states that</p>
<div class="math notranslate nohighlight">
\[X_G = \sum_{F \subseteq E(G)} (-1)^{|F|} p_{\lambda(F)},\]</div>
<p>where <span class="math notranslate nohighlight">\(\lambda(F)\)</span> is the partition of the sizes of the connected
components of the subgraph induced by the edges <span class="math notranslate nohighlight">\(F\)</span> and <span class="math notranslate nohighlight">\(p_{\mu}\)</span> is the
powersum symmetric function.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">R</span></code> – (optional) the base ring for the symmetric functions;
this uses <span class="math notranslate nohighlight">\(\ZZ\)</span> by default</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">XG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_symmetric_function</span><span class="p">();</span> <span class="n">XG</span>
<span class="go">p[1, 1, 1, 1, 1] - 5*p[2, 1, 1, 1] + 5*p[2, 2, 1]</span>
<span class="go"> + 5*p[3, 1, 1] - 5*p[3, 2] - 5*p[4, 1] + 4*p[5]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">XG</span><span class="p">)</span>
<span class="go">30*s[1, 1, 1, 1, 1] + 10*s[2, 1, 1, 1] + 10*s[2, 2, 1]</span>
</pre></div>
</div>
<p>Not all graphs have a positive Schur expansion:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">ClawGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">XG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_symmetric_function</span><span class="p">();</span> <span class="n">XG</span>
<span class="go">p[1, 1, 1, 1] - 3*p[2, 1, 1] + 3*p[3, 1] - p[4]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">XG</span><span class="p">)</span>
<span class="go">8*s[1, 1, 1, 1] + 5*s[2, 1, 1] - s[2, 2] + s[3, 1]</span>
</pre></div>
</div>
<p>We show that given a triangle <span class="math notranslate nohighlight">\(\{e_1, e_2, e_3\}\)</span>, we have
<span class="math notranslate nohighlight">\(X_G = X_{G - e_1} + X_{G - e_2} - X_{G - e_1 - e_2}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">XG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_symmetric_function</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G1</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G1</span><span class="o">.</span><span class="n">delete_edge</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">XG1</span> <span class="o">=</span> <span class="n">G1</span><span class="o">.</span><span class="n">chromatic_symmetric_function</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G2</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G2</span><span class="o">.</span><span class="n">delete_edge</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">XG2</span> <span class="o">=</span> <span class="n">G2</span><span class="o">.</span><span class="n">chromatic_symmetric_function</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G3</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">G1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G3</span><span class="o">.</span><span class="n">delete_edge</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">XG3</span> <span class="o">=</span> <span class="n">G3</span><span class="o">.</span><span class="n">chromatic_symmetric_function</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">XG</span> <span class="o">==</span> <span class="n">XG1</span> <span class="o">+</span> <span class="n">XG2</span> <span class="o">-</span> <span class="n">XG3</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.cleave">
<span class="sig-name descname"><span class="pre">cleave</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cut_vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">virtual_edges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.cleave" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the connected subgraphs separated by the input vertex cut.</p>
<p>Given a connected (multi)graph <span class="math notranslate nohighlight">\(G\)</span> and a vertex cut <span class="math notranslate nohighlight">\(X\)</span>, this method
computes the list of subgraphs of <span class="math notranslate nohighlight">\(G\)</span> induced by each connected component
<span class="math notranslate nohighlight">\(c\)</span> of <span class="math notranslate nohighlight">\(G\setminus X\)</span> plus <span class="math notranslate nohighlight">\(X\)</span>, i.e., <span class="math notranslate nohighlight">\(G[c\cup X]\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a Graph.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cut_vertices</span></code> – iterable container of vertices (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a
set of vertices representing a vertex cut of <code class="docutils literal notranslate"><span class="pre">G</span></code>. If no vertex cut is
given, the method will compute one via a call to
<a class="reference internal" href="connectivity.html#sage.graphs.connectivity.vertex_connectivity" title="sage.graphs.connectivity.vertex_connectivity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertex_connectivity()</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">virtual_edges</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether to add virtual
edges to the sides of the cut or not. A virtual edge is an edge between a
pair of vertices of the cut that are not connected by an edge in <code class="docutils literal notranslate"><span class="pre">G</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer Linear
Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one
is used. For more information on MILP solvers and which default solver is
used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of verbosity. Set
to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP solvers
over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>OUTPUT: A triple <span class="math notranslate nohighlight">\((S, C, f)\)</span>, where</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(S\)</span> is a list of the graphs that are sides of the vertex cut.</p></li>
<li><p><span class="math notranslate nohighlight">\(C\)</span> is the graph of the cocycles. For each pair of vertices of the cut,
if there exists an edge between them, <span class="math notranslate nohighlight">\(C\)</span> has one copy of each edge
connecting them in <code class="docutils literal notranslate"><span class="pre">G</span></code> per sides of the cut plus one extra copy.
Furthermore, when <code class="docutils literal notranslate"><span class="pre">virtual_edges</span> <span class="pre">==</span> <span class="pre">True</span></code>, if a pair of vertices of the
cut is not connected by an edge in <code class="docutils literal notranslate"><span class="pre">G</span></code>, then it has one virtual edge
between them per sides of the cut.</p></li>
<li><p><span class="math notranslate nohighlight">\(f\)</span> is the complement of the subgraph of <code class="docutils literal notranslate"><span class="pre">G</span></code> induced by the vertex
cut. Hence, its vertex set is the vertex cut, and its edge set is the set
of virtual edges (i.e., edges between pairs of vertices of the cut that
are not connected by an edge in <code class="docutils literal notranslate"><span class="pre">G</span></code>). When <code class="docutils literal notranslate"><span class="pre">virtual_edges</span> <span class="pre">==</span> <span class="pre">False</span></code>,
the edge set is empty.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>If there is an edge between cut vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.connectivity</span> <span class="kn">import</span> <span class="n">cleave</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">G</span><span class="o">.</span><span class="n">add_clique</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(),</span> <span class="n">G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">()])</span>
<span class="gp">sage: </span><span class="n">S1</span><span class="p">,</span><span class="n">C1</span><span class="p">,</span><span class="n">f1</span> <span class="o">=</span> <span class="n">cleave</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cut_vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">S1</span><span class="p">]</span>
<span class="go">[4, 4, 4]</span>
<span class="gp">sage: </span><span class="n">C1</span><span class="o">.</span><span class="n">order</span><span class="p">(),</span> <span class="n">C1</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">(2, 4)</span>
<span class="gp">sage: </span><span class="n">f1</span><span class="o">.</span><span class="n">vertices</span><span class="p">(),</span> <span class="n">f1</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">([0, 1], [])</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">virtual_edges</span> <span class="pre">==</span> <span class="pre">False</span></code> and there is an edge between cut vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span> <span class="o">==</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[]])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="p">,</span><span class="n">C2</span><span class="p">,</span><span class="n">f2</span> <span class="o">=</span> <span class="n">cleave</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cut_vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">virtual_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S1</span> <span class="o">==</span> <span class="n">S2</span><span class="p">,</span> <span class="n">C1</span> <span class="o">==</span> <span class="n">C2</span><span class="p">,</span> <span class="n">f1</span> <span class="o">==</span> <span class="n">f2</span><span class="p">)</span>
<span class="go">(True, True, True)</span>
</pre></div>
</div>
<p>If cut vertices doesn’t have edge between them:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">delete_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S1</span><span class="p">,</span><span class="n">C1</span><span class="p">,</span><span class="n">f1</span> <span class="o">=</span> <span class="n">cleave</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cut_vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">S1</span><span class="p">]</span>
<span class="go">[4, 4, 4]</span>
<span class="gp">sage: </span><span class="n">C1</span><span class="o">.</span><span class="n">order</span><span class="p">(),</span> <span class="n">C1</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">(2, 3)</span>
<span class="gp">sage: </span><span class="n">f1</span><span class="o">.</span><span class="n">vertices</span><span class="p">(),</span> <span class="n">f1</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">([0, 1], [(0, 1, None)])</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">virtual_edges</span> <span class="pre">==</span> <span class="pre">False</span></code> and the cut vertices are not connected by an
edge:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span> <span class="o">==</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[]])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="p">,</span><span class="n">C2</span><span class="p">,</span><span class="n">f2</span> <span class="o">=</span> <span class="n">cleave</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cut_vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">virtual_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">S2</span><span class="p">]</span>
<span class="go">[4, 4, 4]</span>
<span class="gp">sage: </span><span class="n">C2</span><span class="o">.</span><span class="n">order</span><span class="p">(),</span> <span class="n">C2</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">(2, 0)</span>
<span class="gp">sage: </span><span class="n">f2</span><span class="o">.</span><span class="n">vertices</span><span class="p">(),</span> <span class="n">f2</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">([0, 1], [])</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S1</span> <span class="o">==</span> <span class="n">S2</span><span class="p">,</span> <span class="n">C1</span> <span class="o">==</span> <span class="n">C2</span><span class="p">,</span> <span class="n">f1</span> <span class="o">==</span> <span class="n">f2</span><span class="p">)</span>
<span class="go">(False, False, False)</span>
</pre></div>
</div>
<p>If <span class="math notranslate nohighlight">\(G\)</span> is a biconnected multigraph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_multiple_edges</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="n">f</span> <span class="o">=</span> <span class="n">cleave</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cut_vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">S</span><span class="p">:</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[(0, 1), (0, 1), (0, 1), (0, 2), (0, 2), (0, 3), (0, 3), (1, 2), (1, 2), (1, 3), (1, 3), (2, 3), (2, 3)]</span>
<span class="go">[(0, 1), (0, 1), (0, 1), (0, 4), (0, 4), (1, 4), (1, 4)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.clique_complex">
<span class="sig-name descname"><span class="pre">clique_complex</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.clique_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the clique complex of self.</p>
<p>This is the largest simplicial complex on the vertices of self whose
1-skeleton is self.</p>
<p>This is only makes sense for undirected simple graphs.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span><span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">clique_complex</span><span class="p">()</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 4) and facets {(4,), (0, 1, 2)}</span>

<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">clique_complex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3, 4) and facets {(0, 1, 4), (0, 1, 2, 3)}</span>
<span class="gp">sage: </span><span class="n">i</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">i</span><span class="o">==</span><span class="n">h</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">==</span><span class="n">i</span><span class="o">.</span><span class="n">clique_complex</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.clique_maximum">
<span class="sig-name descname"><span class="pre">clique_maximum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Cliquer'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.clique_maximum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex set of a maximal order complete subgraph.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – the algorithm to be used :</p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;Cliquer&quot;</span></code> (default), wraps the C program
Cliquer <a class="reference internal" href="../../../references/index.html#no2003" id="id11"><span>[NO2003]</span></a>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;MILP&quot;</span></code>, the problem is solved through a Mixed
Integer Linear Program.</p>
<p>(see <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>)</p>
</li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;mcqd&quot;</span></code>, uses the MCQD solver
(<a class="reference external" href="http://www.sicmm.org/~konc/maxclique/">http://www.sicmm.org/~konc/maxclique/</a>). Note that the MCQD
package must be installed.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">solver</span></code> and <code class="docutils literal notranslate"><span class="pre">verbose</span></code> are used only when
<code class="docutils literal notranslate"><span class="pre">algorithm=&quot;MILP&quot;</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently only implemented for undirected graphs. Use to_undirected
to convert a digraph to an undirected graph.</p>
</div>
<p>ALGORITHM:</p>
<p>This function is based on Cliquer <a class="reference internal" href="../../../references/index.html#no2003" id="id12"><span>[NO2003]</span></a>.</p>
<p>EXAMPLES:</p>
<p>Using Cliquer (default):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">clique_maximum</span><span class="p">()</span>
<span class="go">[7, 9]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;DJ{&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">clique_maximum</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4]</span>
</pre></div>
</div>
<p>Through a Linear Program:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">clique_maximum</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;MILP&quot;</span><span class="p">))</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.clique_number">
<span class="sig-name descname"><span class="pre">clique_number</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cliques</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Cliquer'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.clique_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the order of the largest clique of the graph</p>
<p>This is also called as the clique number.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently only implemented for undirected graphs. Use <code class="docutils literal notranslate"><span class="pre">to_undirected</span></code>
to convert a digraph to an undirected graph.</p>
</div>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – the algorithm to be used :</p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;Cliquer&quot;</span></code>, wraps the C program Cliquer
<a class="reference internal" href="../../../references/index.html#no2003" id="id13"><span>[NO2003]</span></a>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;networkx&quot;</span></code>, uses the NetworkX’s implementation of
the Bron and Kerbosch Algorithm <a class="reference internal" href="../../../references/index.html#bk1973" id="id14"><span>[BK1973]</span></a>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;MILP&quot;</span></code>, the problem is solved through a Mixed
Integer Linear Program.</p>
<p>(see <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>)</p>
</li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;mcqd&quot;</span></code>, uses the MCQD solver
(<a class="reference external" href="http://insilab.org/maxclique/">http://insilab.org/maxclique/</a>). Note that the MCQD
package must be installed.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">cliques</span></code> – an optional list of cliques that can be input if
already computed. Ignored unless <code class="docutils literal notranslate"><span class="pre">algorithm==&quot;networkx&quot;</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>ALGORITHM:</p>
<p>This function is based on Cliquer <a class="reference internal" href="../../../references/index.html#no2003" id="id15"><span>[NO2003]</span></a> and <a class="reference internal" href="../../../references/index.html#bk1973" id="id16"><span>[BK1973]</span></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;DJ{&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">clique_number</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">clique_number</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>By definition the clique number of a complete graph is its order:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">clique_number</span><span class="p">()</span> <span class="o">==</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">15</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A non-empty graph without edges has a clique number of 1:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">((</span><span class="n">i</span><span class="o">*</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">clique_number</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">15</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A complete multipartite graph with k parts has clique number k:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">((</span><span class="n">i</span><span class="o">*</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteMultipartiteGraph</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="p">[</span><span class="mi">5</span><span class="p">]))</span><span class="o">.</span><span class="n">clique_number</span><span class="p">()</span> <span class="o">==</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.clique_polynomial">
<span class="sig-name descname"><span class="pre">clique_polynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.clique_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the clique polynomial of self.</p>
<p>This is the polynomial where the coefficient of <span class="math notranslate nohighlight">\(t^n\)</span> is the number of
cliques in the graph with <span class="math notranslate nohighlight">\(n\)</span> vertices. The constant term of the clique
polynomial is always taken to be one.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">clique_polynomial</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">clique_polynomial</span><span class="p">()</span>
<span class="go">t^2 + 2*t + 1</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">clique_polynomial</span><span class="p">()</span>
<span class="go">4*t^2 + 4*t + 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.cliques_containing_vertex">
<span class="sig-name descname"><span class="pre">cliques_containing_vertex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cliques</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.cliques_containing_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cliques containing each vertex, represented as a dictionary
of lists of lists, keyed by vertex.</p>
<p>Returns a single list if only one input vertex.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently only implemented for undirected graphs. Use to_undirected
to convert a digraph to an undirected graph.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – the vertices to inspect (default is entire graph)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cliques</span></code> – list of cliques (if already computed)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;DJ{&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_containing_vertex</span><span class="p">()</span>
<span class="go">{0: [[4, 0]], 1: [[4, 1, 2, 3]], 2: [[4, 1, 2, 3]], 3: [[4, 1, 2, 3]], 4: [[4, 0], [4, 1, 2, 3]]}</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">cliques_maximal</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">E</span>
<span class="go">[[0, 4], [1, 2, 3, 4]]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_containing_vertex</span><span class="p">(</span><span class="n">cliques</span><span class="o">=</span><span class="n">E</span><span class="p">)</span>
<span class="go">{0: [[0, 4]], 1: [[1, 2, 3, 4]], 2: [[1, 2, 3, 4]], 3: [[1, 2, 3, 4]], 4: [[0, 4], [1, 2, 3, 4]]}</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cliques_containing_vertex</span><span class="p">()</span>
<span class="go">{0: [[0, 1, 2], [0, 1, 3]], 1: [[0, 1, 2], [0, 1, 3]], 2: [[0, 1, 2]], 3: [[0, 1, 3]]}</span>
</pre></div>
</div>
<p>Since each clique of a 2 dimensional grid corresponds to an edge, the
number of cliques in which a vertex is involved equals its degree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">cliques_containing_vertex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">cliques</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">cliques</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">cliques_containing_vertex</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">[(0, 1)]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">L</span><span class="p">)</span> <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="go">[[(0, 0), (0, 1)], [(0, 1), (0, 2)], [(0, 1), (1, 1)]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.cliques_get_clique_bipartite">
<span class="sig-name descname"><span class="pre">cliques_get_clique_bipartite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.cliques_get_clique_bipartite" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a bipartite graph constructed such that maximal cliques are the
right vertices and the left vertices are retained from the given
graph. Right and left vertices are connected if the bottom vertex
belongs to the clique represented by a top vertex.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently only implemented for undirected graphs. Use to_undirected
to convert a digraph to an undirected graph.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">())</span><span class="o">.</span><span class="n">cliques_get_clique_bipartite</span><span class="p">()</span>
<span class="go">Bipartite graph on 36 vertices</span>
<span class="gp">sage: </span><span class="p">((</span><span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">())</span><span class="o">.</span><span class="n">cliques_get_clique_bipartite</span><span class="p">())</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">vertex_size</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">vertex_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cliques_get_clique_bipartite</span><span class="p">()</span>
<span class="go">Bipartite graph on 6 vertices</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">cliques_get_clique_bipartite</span><span class="p">())</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.cliques_get_max_clique_graph">
<span class="sig-name descname"><span class="pre">cliques_get_max_clique_graph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.cliques_get_max_clique_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the clique graph.</p>
<p>Vertices of the result are the maximal cliques of the graph, and edges
of the result are between maximal cliques with common members in the
original graph.</p>
<p>For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Clique_graph">Wikipedia article Clique_graph</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently only implemented for undirected graphs. Use to_undirected
to convert a digraph to an undirected graph.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">())</span><span class="o">.</span><span class="n">cliques_get_max_clique_graph</span><span class="p">()</span>
<span class="go">Graph on 24 vertices</span>
<span class="gp">sage: </span><span class="p">((</span><span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">())</span><span class="o">.</span><span class="n">cliques_get_max_clique_graph</span><span class="p">())</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">vertex_size</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">vertex_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cliques_get_max_clique_graph</span><span class="p">()</span>
<span class="go">Graph on 2 vertices</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">cliques_get_max_clique_graph</span><span class="p">())</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.cliques_maximal">
<span class="sig-name descname"><span class="pre">cliques_maximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'native'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.cliques_maximal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of all maximal cliques.</p>
<p>Each clique is represented by a list of vertices. A clique is an induced
complete subgraph, and a maximal clique is one not contained in a larger
one.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – can be set to <code class="docutils literal notranslate"><span class="pre">&quot;native&quot;</span></code> (default) to use Sage’s
own implementation, or to <code class="docutils literal notranslate"><span class="pre">&quot;NetworkX&quot;</span></code> to use NetworkX’
implementation of the Bron and Kerbosch Algorithm <a class="reference internal" href="../../../references/index.html#bk1973" id="id17"><span>[BK1973]</span></a>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method sorts its output before returning it. If you prefer to
save the extra time, you can call
<a class="reference internal" href="independent_sets.html#sage.graphs.independent_sets.IndependentSets" title="sage.graphs.independent_sets.IndependentSets"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.graphs.independent_sets.IndependentSets</span></code></a> directly.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Sage’s implementation of the enumeration of <em>maximal</em> independent
sets is not much faster than NetworkX’ (expect a 2x speedup), which
is surprising as it is written in Cython. This being said, the
algorithm from NetworkX appears to be slightly different from this
one, and that would be a good thing to explore if one wants to
improve the implementation.</p>
</div>
<p>ALGORITHM:</p>
<p>This function is based on NetworkX’s implementation of the Bron and
Kerbosch Algorithm <a class="reference internal" href="../../../references/index.html#bk1973" id="id18"><span>[BK1973]</span></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">()</span><span class="o">.</span><span class="n">cliques_maximal</span><span class="p">()</span>
<span class="go">[[0, 1], [0, 4], [0, 6], [0, 9], [1, 2], [1, 5], [1, 7], [2, 3],</span>
<span class="go"> [2, 6], [2, 8], [3, 4], [3, 7], [3, 9], [4, 5], [4, 8], [5, 10],</span>
<span class="go"> [5, 11], [6, 10], [6, 11], [7, 8], [7, 11], [8, 10], [9, 10], [9, 11]]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cliques_maximal</span><span class="p">()</span>
<span class="go">[[0, 1, 2], [0, 1, 3]]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_maximal</span><span class="p">()</span>
<span class="go">[[0, 1], [0, 4], [0, 5], [1, 2], [1, 6], [2, 3], [2, 7], [3, 4],</span>
<span class="go"> [3, 8], [4, 9], [5, 7], [5, 8], [6, 8], [6, 9], [7, 9]]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;DJ{&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_maximal</span><span class="p">()</span>
<span class="go">[[0, 4], [1, 2, 3, 4]]</span>
</pre></div>
</div>
<p>Comparing the two implementations:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mf">.7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s1</span> <span class="o">=</span> <span class="n">Set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">cliques_maximal</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;NetworkX&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">s2</span> <span class="o">=</span> <span class="n">Set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">cliques_maximal</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;native&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.cliques_maximum">
<span class="sig-name descname"><span class="pre">cliques_maximum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.cliques_maximum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the vertex sets of <em>ALL</em> the maximum complete subgraphs.</p>
<p>Returns the list of all maximum cliques, with each clique represented by a
list of vertices. A clique is an induced complete subgraph, and a maximum
clique is one of maximal order.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently only implemented for undirected graphs. Use
<a class="reference internal" href="digraph.html#sage.graphs.digraph.DiGraph.to_undirected" title="sage.graphs.digraph.DiGraph.to_undirected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_undirected()</span></code></a> to convert a digraph
to an undirected graph.</p>
</div>
<p>ALGORITHM:</p>
<p>This function is based on Cliquer <a class="reference internal" href="../../../references/index.html#no2003" id="id19"><span>[NO2003]</span></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">()</span><span class="o">.</span><span class="n">cliques_maximum</span><span class="p">()</span> <span class="c1"># indirect doctest</span>
<span class="go">[[0, 1], [0, 4], [0, 6], [0, 9], [1, 2], [1, 5], [1, 7], [2, 3],</span>
<span class="go"> [2, 6], [2, 8], [3, 4], [3, 7], [3, 9], [4, 5], [4, 8], [5, 10],</span>
<span class="go"> [5, 11], [6, 10], [6, 11], [7, 8], [7, 11], [8, 10], [9, 10], [9, 11]]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cliques_maximum</span><span class="p">()</span>
<span class="go">[[0, 1, 2], [0, 1, 3]]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_maximum</span><span class="p">()</span>
<span class="go">[[0, 1], [0, 4], [0, 5], [1, 2], [1, 6], [2, 3], [2, 7], [3, 4],</span>
<span class="go"> [3, 8], [4, 9], [5, 7], [5, 8], [6, 8], [6, 9], [7, 9]]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;DJ{&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_maximum</span><span class="p">()</span>
<span class="go">[[1, 2, 3, 4]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.cliques_number_of">
<span class="sig-name descname"><span class="pre">cliques_number_of</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cliques</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.cliques_number_of" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary of the number of maximal cliques containing each
vertex, keyed by vertex.</p>
<p>This returns a single value if only one input vertex.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently only implemented for undirected graphs. Use to_undirected
to convert a digraph to an undirected graph.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – the vertices to inspect (default is entire graph)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cliques</span></code> – list of cliques (if already computed)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;DJ{&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_number_of</span><span class="p">()</span>
<span class="go">{0: 1, 1: 1, 2: 1, 3: 1, 4: 2}</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">cliques_maximal</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">E</span>
<span class="go">[[0, 4], [1, 2, 3, 4]]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_number_of</span><span class="p">(</span><span class="n">cliques</span><span class="o">=</span><span class="n">E</span><span class="p">)</span>
<span class="go">{0: 1, 1: 1, 2: 1, 3: 1, 4: 2}</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">cliques_number_of</span><span class="p">()</span>
<span class="go">{(0, 0): 2, (0, 1): 3, (0, 2): 2, (1, 0): 2, (1, 1): 3, (1, 2): 2}</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">cliques_number_of</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="go">{(0, 1): 3, (1, 2): 2}</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cliques_number_of</span><span class="p">()</span>
<span class="go">{0: 2, 1: 2, 2: 1, 3: 1}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.cliques_vertex_clique_number">
<span class="sig-name descname"><span class="pre">cliques_vertex_clique_number</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cliquer'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cliques</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.cliques_vertex_clique_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary of sizes of the largest maximal cliques containing
each vertex, keyed by vertex.</p>
<p>Returns a single value if only one input vertex.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently only implemented for undirected graphs. Use to_undirected
to convert a digraph to an undirected graph.</p>
</div>
<p>INPUT:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – either <code class="docutils literal notranslate"><span class="pre">cliquer</span></code> or <code class="docutils literal notranslate"><span class="pre">networkx</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">cliquer</span></code> – This wraps the C program Cliquer <a class="reference internal" href="../../../references/index.html#no2003" id="id20"><span>[NO2003]</span></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">networkx</span></code> – This function is based on NetworkX’s implementation
of the Bron and Kerbosch Algorithm <a class="reference internal" href="../../../references/index.html#bk1973" id="id21"><span>[BK1973]</span></a>.</p></li>
</ul>
</li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – the vertices to inspect (default is entire graph).
Ignored unless <code class="docutils literal notranslate"><span class="pre">algorithm=='networkx'</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cliques</span></code> – list of cliques (if already computed).  Ignored unless
<code class="docutils literal notranslate"><span class="pre">algorithm=='networkx'</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;DJ{&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_vertex_clique_number</span><span class="p">()</span>
<span class="go">{0: 2, 1: 4, 2: 4, 3: 4, 4: 4}</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">cliques_maximal</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">E</span>
<span class="go">[[0, 4], [1, 2, 3, 4]]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_vertex_clique_number</span><span class="p">(</span><span class="n">cliques</span><span class="o">=</span><span class="n">E</span><span class="p">,</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;networkx&quot;</span><span class="p">)</span>
<span class="go">{0: 2, 1: 4, 2: 4, 3: 4, 4: 4}</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">cliques_vertex_clique_number</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;networkx&quot;</span><span class="p">)</span>
<span class="go">{(0, 0): 2, (0, 1): 2, (0, 2): 2, (1, 0): 2, (1, 1): 2, (1, 2): 2}</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">cliques_vertex_clique_number</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="go">{(0, 1): 2, (1, 2): 2}</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cliques_vertex_clique_number</span><span class="p">()</span>
<span class="go">{0: 3, 1: 3, 2: 3, 3: 3}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.coloring">
<span class="sig-name descname"><span class="pre">coloring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hex_colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DLX'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.coloring" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the first (optimal) proper vertex-coloring found.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – Select an algorithm from the following supported
algorithms:</p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">algorithm=&quot;DLX&quot;</span></code> (default), the coloring is computed using the
dancing link algorithm.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">algorithm=&quot;MILP&quot;</span></code>, the coloring is computed using a mixed
integer linear program. The performance of this implementation is
affected by whether optional MILP solvers have been installed (see
the <a class="reference external" href="../../../numerical/sage/numerical/mip.html#module-sage.numerical.mip" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">MILP</span> <span class="pre">module</span></code></a>).</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">hex_colors</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, return a
dictionary which can easily be used for plotting.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>For more functions related to graph coloring, see the
module <a class="reference internal" href="graph_coloring.html#module-sage.graphs.graph_coloring" title="sage.graphs.graph_coloring"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.graphs.graph_coloring</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s2">&quot;Fooba&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">coloring</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;MILP&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">coloring</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;DLX&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">are_equal_colorings</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">Set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="n">A</span><span class="p">))</span> <span class="o">==</span> <span class="n">Set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="n">B</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">are_equal_colorings</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">are_equal_colorings</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">partition</span><span class="o">=</span><span class="n">P</span><span class="p">)</span>
<span class="go">Graphics object consisting of 16 graphics primitives</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">coloring</span><span class="p">(</span><span class="n">hex_colors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;MILP&quot;</span><span class="p">)</span>
<span class="go">{&#39;#0000ff&#39;: [4], &#39;#00ff00&#39;: [0, 6, 5], &#39;#ff0000&#39;: [2, 1, 3]}</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">coloring</span><span class="p">(</span><span class="n">hex_colors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;DLX&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span>
<span class="go">{&#39;#0000ff&#39;: [4], &#39;#00ff00&#39;: [1, 2, 3], &#39;#ff0000&#39;: [0, 5, 6]}</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">vertex_colors</span><span class="o">=</span><span class="n">H</span><span class="p">)</span>
<span class="go">Graphics object consisting of 16 graphics primitives</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="../../_images/graph-1.svg" class="plot-directive" src="../../_images/graph-1.svg" /></figure>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.common_neighbors_matrix">
<span class="sig-name descname"><span class="pre">common_neighbors_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nonedgesonly</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.common_neighbors_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a matrix of numbers of common neighbors between each pairs.</p>
<p>The <span class="math notranslate nohighlight">\((i , j)\)</span> entry of the matrix gives the number of common
neighbors between vertices <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>.</p>
<p>This method is only valid for simple (no loops, no multiple edges)
graphs.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nonedgesonly</span></code>– boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, assigns
<span class="math notranslate nohighlight">\(0\)</span> value to adjacent vertices.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – list (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the ordering of the
vertices defining how they should appear in the matrix. By default,
the ordering given by <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.vertices" title="sage.graphs.generic_graph.GenericGraph.vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GenericGraph.vertices()</span></code></a> is used.</p></li>
</ul>
<p>OUTPUT: matrix</p>
<p>EXAMPLES:</p>
<p>The common neighbors matrix  for a straight linear 2-tree counting
only non-adjacent vertex pairs</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G1</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G1</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G1</span><span class="o">.</span><span class="n">common_neighbors_matrix</span><span class="p">(</span><span class="n">nonedgesonly</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">[0 0 0 2 1 0]</span>
<span class="go">[0 0 0 0 2 1]</span>
<span class="go">[0 0 0 0 0 2]</span>
<span class="go">[2 0 0 0 0 0]</span>
<span class="go">[1 2 0 0 0 0]</span>
<span class="go">[0 1 2 0 0 0]</span>
</pre></div>
</div>
<p>We now show the common neighbors matrix which includes adjacent
vertices</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G1</span><span class="o">.</span><span class="n">common_neighbors_matrix</span><span class="p">(</span><span class="n">nonedgesonly</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">[0 1 1 2 1 0]</span>
<span class="go">[1 0 2 1 2 1]</span>
<span class="go">[1 2 0 2 1 2]</span>
<span class="go">[2 1 2 0 2 1]</span>
<span class="go">[1 2 1 2 0 1]</span>
<span class="go">[0 1 2 1 1 0]</span>
</pre></div>
</div>
<p>The common neighbors matrix  for a fan on 6 vertices counting only
non-adjacent vertex pairs</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">common_neighbors_matrix</span><span class="p">()</span>
<span class="go">[0 0 0 0 0 0 0]</span>
<span class="go">[0 0 0 2 1 1 1]</span>
<span class="go">[0 0 0 0 2 1 1]</span>
<span class="go">[0 2 0 0 0 2 1]</span>
<span class="go">[0 1 2 0 0 0 1]</span>
<span class="go">[0 1 1 2 0 0 1]</span>
<span class="go">[0 1 1 1 1 1 0]</span>
</pre></div>
</div>
<p>It is an error to input anything other than a simple graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span><span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">common_neighbors_matrix</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: This method is not known to work on graphs with loops.</span>
<span class="go">Perhaps this method can be updated to handle them, but in the</span>
<span class="go">meantime if you want to use it please disallow loops using</span>
<span class="go">allow_loops().</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.most_common_neighbors" title="sage.graphs.graph.Graph.most_common_neighbors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">most_common_neighbors()</span></code></a> –
returns node pairs with most shared neighbors</p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.convexity_properties">
<span class="sig-name descname"><span class="pre">convexity_properties</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.convexity_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <code class="docutils literal notranslate"><span class="pre">ConvexityProperties</span></code> object corresponding to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This object contains the methods related to convexity in graphs (convex
hull, hull number) and caches useful information so that it becomes
comparatively cheaper to compute the convex hull of many different sets
of the same graph.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>In order to know what can be done through this object, please refer
to module <a class="reference internal" href="convexity_properties.html#module-sage.graphs.convexity_properties" title="sage.graphs.convexity_properties"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.graphs.convexity_properties</span></code></a>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you want to compute many convex hulls, keep this object in memory
! When it is created, it builds a table of useful information to
compute convex hulls. As a result</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">convexity_properties</span><span class="p">()</span><span class="o">.</span><span class="n">hull</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">convexity_properties</span><span class="p">()</span><span class="o">.</span><span class="n">hull</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="go">[2, 3, 7]</span>
</pre></div>
</div>
<p>Is a terrible waste of computations, while</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">CP</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">convexity_properties</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">CP</span><span class="o">.</span><span class="n">hull</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">CP</span><span class="o">.</span><span class="n">hull</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="go">[2, 3, 7]</span>
</pre></div>
</div>
<p>Makes perfect sense.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.cores">
<span class="sig-name descname"><span class="pre">cores</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.cores" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the core number for each vertex in an ordered list.</p>
<p>(for homomorphisms cores, see the <a class="reference internal" href="#sage.graphs.graph.Graph.has_homomorphism_to" title="sage.graphs.graph.Graph.has_homomorphism_to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.has_homomorphism_to()</span></code></a>
method)</p>
<p>DEFINITIONS:</p>
<ul>
<li><p><em>K-cores</em> in graph theory were introduced by Seidman in 1983 and by
Bollobas in 1984 as a method of (destructively) simplifying graph
topology to aid in analysis and visualization. They have been more
recently defined as the following by Batagelj et al:</p>
<p><em>Given a graph `G` with vertices set `V` and edges set `E`, the
`k`-core of `G` is the graph obtained from `G` by recursively removing
the vertices with degree less than `k`, for as long as there are any.</em></p>
<p>This operation can be useful to filter or to study some properties of
the graphs. For instance, when you compute the 2-core of graph G, you
are cutting all the vertices which are in a tree part of graph.  (A
tree is a graph with no loops). See the <a class="reference external" href="https://en.wikipedia.org/wiki/K-core">Wikipedia article K-core</a>.</p>
<p><a class="reference internal" href="../../../references/index.html#psw1996" id="id22"><span>[PSW1996]</span></a> defines a <span class="math notranslate nohighlight">\(k\)</span>-core of <span class="math notranslate nohighlight">\(G\)</span> as the largest subgraph (it is
unique) of <span class="math notranslate nohighlight">\(G\)</span> with minimum degree at least <span class="math notranslate nohighlight">\(k\)</span>.</p>
</li>
<li><p>Core number of a vertex</p>
<p>The core number of a vertex <span class="math notranslate nohighlight">\(v\)</span> is the largest integer <span class="math notranslate nohighlight">\(k\)</span> such that
<span class="math notranslate nohighlight">\(v\)</span> belongs to the <span class="math notranslate nohighlight">\(k\)</span>-core of <span class="math notranslate nohighlight">\(G\)</span>.</p>
</li>
<li><p>Degeneracy</p>
<p>The <em>degeneracy</em> of a graph <span class="math notranslate nohighlight">\(G\)</span>, usually denoted <span class="math notranslate nohighlight">\(\delta^*(G)\)</span>, is the
smallest integer <span class="math notranslate nohighlight">\(k\)</span> such that the graph <span class="math notranslate nohighlight">\(G\)</span> can be reduced to the
empty graph by iteratively removing vertices of degree <span class="math notranslate nohighlight">\(\leq k\)</span>.
Equivalently, <span class="math notranslate nohighlight">\(\delta^*(G)=k\)</span> if <span class="math notranslate nohighlight">\(k\)</span> is the smallest integer such that
the <span class="math notranslate nohighlight">\(k\)</span>-core of <span class="math notranslate nohighlight">\(G\)</span> is empty.</p>
</li>
</ul>
<p>IMPLEMENTATION:</p>
<p>This implementation is based on the NetworkX implementation of the
algorithm described in <a class="reference internal" href="../../../references/index.html#bz2003" id="id23"><span>[BZ2003]</span></a>.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>);</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">None</span></code> (default), returns the core number for each vertex.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">k</span></code> is an integer, returns a pair <code class="docutils literal notranslate"><span class="pre">(ordering,</span> <span class="pre">core)</span></code>, where
<code class="docutils literal notranslate"><span class="pre">core</span></code> is the list of vertices in the <span class="math notranslate nohighlight">\(k\)</span>-core of <code class="docutils literal notranslate"><span class="pre">self</span></code>, and
<code class="docutils literal notranslate"><span class="pre">ordering</span></code> is an elimination order for the other vertices such
that each vertex is of degree strictly less than <span class="math notranslate nohighlight">\(k\)</span> when it is to
be eliminated from the graph.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">with_labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); when set to
<code class="docutils literal notranslate"><span class="pre">False</span></code>, and <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">None</span></code>, the method returns a list whose <span class="math notranslate nohighlight">\(i\)</span> th
element is the core number of the <span class="math notranslate nohighlight">\(i\)</span> th vertex. When set to <code class="docutils literal notranslate"><span class="pre">True</span></code>,
the method returns a dictionary whose keys are vertices, and whose
values are the corresponding core numbers.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p>Graph cores is also a notion related to graph homomorphisms. For
this second meaning, see <a class="reference internal" href="#sage.graphs.graph.Graph.has_homomorphism_to" title="sage.graphs.graph.Graph.has_homomorphism_to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.has_homomorphism_to()</span></code></a>.</p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">FruchtGraph</span><span class="p">())</span><span class="o">.</span><span class="n">cores</span><span class="p">()</span>
<span class="go">[3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">FruchtGraph</span><span class="p">())</span><span class="o">.</span><span class="n">cores</span><span class="p">(</span><span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{0: 3, 1: 3, 2: 3, 3: 3, 4: 3, 5: 3, 6: 3, 7: 3, 8: 3, 9: 3, 10: 3, 11: 3}</span>
<span class="gp">sage: </span><span class="n">set_random_seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">random_matrix</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="mf">.1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">nonzero_positions</span><span class="p">(),</span> <span class="n">loops</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">cores</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">cores</span><span class="p">(</span><span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">cores</span>
<span class="go">{0: 3, 1: 3, 2: 3, 3: 3, 4: 2, 5: 2, 6: 3, 7: 1, 8: 3, 9: 3, 10: 3, 11: 3, 12: 3, 13: 3, 14: 2, 15: 3, 16: 3, 17: 3, 18: 3, 19: 3}</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="n">cores</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">c</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">]</span> <span class="c1"># the vertices in the 2-core</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</span>
</pre></div>
</div>
<p>Checking the 2-core of a random lobster is indeed the empty set:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomLobster</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ordering</span><span class="p">,</span> <span class="n">core</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">cores</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">core</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.degree_constrained_subgraph">
<span class="sig-name descname"><span class="pre">degree_constrained_subgraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.degree_constrained_subgraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a degree-constrained subgraph.</p>
<p>Given a graph <span class="math notranslate nohighlight">\(G\)</span> and two functions <span class="math notranslate nohighlight">\(f, g:V(G)\rightarrow \mathbb Z\)</span>
such that <span class="math notranslate nohighlight">\(f \leq g\)</span>, a degree-constrained subgraph in <span class="math notranslate nohighlight">\(G\)</span> is
a subgraph <span class="math notranslate nohighlight">\(G' \subseteq G\)</span> such that for any vertex <span class="math notranslate nohighlight">\(v \in G\)</span>,
<span class="math notranslate nohighlight">\(f(v) \leq d_{G'}(v) \leq g(v)\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bounds</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); Two possibilities:</p>
<ul>
<li><p>A dictionary whose keys are the vertices, and values a pair of
real values <code class="docutils literal notranslate"><span class="pre">(min,max)</span></code> corresponding to the values
<span class="math notranslate nohighlight">\((f(v),g(v))\)</span>.</p></li>
<li><p>A function associating to each vertex a pair of
real values <code class="docutils literal notranslate"><span class="pre">(min,max)</span></code> corresponding to the values
<span class="math notranslate nohighlight">\((f(v),g(v))\)</span>.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>When a solution exists, this method outputs the degree-constrained
subgraph as a Graph object.</p></li>
<li><p>When no solution exists, returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>This algorithm computes the degree-constrained subgraph of minimum
weight.</p></li>
<li><p>If the graph’s edges are weighted, these are taken into account.</p></li>
<li><p>This problem can be solved in polynomial time.</p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>Is there a perfect matching in an even cycle?</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bounds</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">degree_constrained_subgraph</span><span class="p">(</span><span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.diameter">
<span class="sig-name descname"><span class="pre">diameter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">by_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.diameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the diameter of the graph.</p>
<p>The diameter is defined to be the maximum distance between two vertices.
It is infinite if the graph is not connected.</p>
<p>For more information and examples on how to use input variables, see
<a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.shortest_paths" title="sage.graphs.generic_graph.GenericGraph.shortest_paths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shortest_paths()</span></code></a> and
<a class="reference internal" href="#sage.graphs.graph.Graph.eccentricity" title="sage.graphs.graph.Graph.eccentricity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eccentricity()</span></code></a></p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">by_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, edge
weights are taken into account; if False, all edges have weight 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); one of the following
algorithms:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'BFS'</span></code>: the computation is done through a BFS centered on each
vertex successively. Works only if <code class="docutils literal notranslate"><span class="pre">by_weight==False</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Floyd-Warshall-Cython'</span></code>: a Cython implementation of the
Floyd-Warshall algorithm. Works only if <code class="docutils literal notranslate"><span class="pre">by_weight==False</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span>
<span class="pre">is</span> <span class="pre">None</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Floyd-Warshall-Python'</span></code>: a Python implementation of the
Floyd-Warshall algorithm. Works also with weighted graphs, even with
negative weights (but no negative cycle is allowed). However, <code class="docutils literal notranslate"><span class="pre">v</span></code>
must be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Dijkstra_NetworkX'</span></code>: the Dijkstra algorithm, implemented in
NetworkX. It works with weighted graphs, but no negative weight is
allowed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'DHV'</span></code> - diameter computation is done using the algorithm
proposed in <a class="reference internal" href="../../../references/index.html#dragan2018" id="id24"><span>[Dragan2018]</span></a>. Works only for non-negative edge weights.
For more information see method
<code class="xref py py-func docutils literal notranslate"><span class="pre">sage.graphs.distances_all_pairs.diameter_DHV()</span></code> and
<a class="reference internal" href="base/boost_graph.html#sage.graphs.base.boost_graph.diameter_DHV" title="sage.graphs.base.boost_graph.diameter_DHV"><code class="xref py py-func docutils literal notranslate"><span class="pre">sage.graphs.base.boost_graph.diameter_DHV()</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'standard'</span></code>, <code class="docutils literal notranslate"><span class="pre">'2sweep'</span></code>, <code class="docutils literal notranslate"><span class="pre">'multi-sweep'</span></code>, <code class="docutils literal notranslate"><span class="pre">'iFUB'</span></code>:
these algorithms are implemented in
<a class="reference internal" href="distances_all_pairs.html#sage.graphs.distances_all_pairs.diameter" title="sage.graphs.distances_all_pairs.diameter"><code class="xref py py-func docutils literal notranslate"><span class="pre">sage.graphs.distances_all_pairs.diameter()</span></code></a>
They work only if <code class="docutils literal notranslate"><span class="pre">by_weight==False</span></code>. See the function
documentation for more information.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Dijkstra_Boost'</span></code>: the Dijkstra algorithm, implemented in Boost
(works only with positive weights).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Johnson_Boost'</span></code>: the Johnson algorithm, implemented in
Boost (works also with negative weights, if there is no negative
cycle).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> (default): Sage chooses the best algorithm: <code class="docutils literal notranslate"><span class="pre">'iFUB'</span></code> for
unweighted graphs, <code class="docutils literal notranslate"><span class="pre">'Dijkstra_Boost'</span></code> if all weights are positive,
<code class="docutils literal notranslate"><span class="pre">'Johnson_Boost'</span></code> otherwise.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
takes as input an edge <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></code> and outputs its weight. If not
<code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is automatically set to <code class="docutils literal notranslate"><span class="pre">True</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>
and <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, we use the edge label <code class="docutils literal notranslate"><span class="pre">l</span></code> as a
weight, if <code class="docutils literal notranslate"><span class="pre">l</span></code> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, else <code class="docutils literal notranslate"><span class="pre">1</span></code> as a weight.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, we check
that the <code class="docutils literal notranslate"><span class="pre">weight_function</span></code> outputs a number for each edge</p></li>
</ul>
<p>EXAMPLES:</p>
<p>The more symmetric a graph is, the smaller (diameter - radius) is:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">BarbellGraph</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">radius</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">diameter</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">OctahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">radius</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">diameter</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.ear_decomposition">
<span class="sig-name descname"><span class="pre">ear_decomposition</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.ear_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an Ear decomposition of the graph.</p>
<p>An ear of an undirected graph <span class="math notranslate nohighlight">\(G\)</span> is a path <span class="math notranslate nohighlight">\(P\)</span> where the two endpoints
of the path may coincide (i.e., form a cycle), but where otherwise no
repetition of edges or vertices is allowed, so every internal vertex of
<span class="math notranslate nohighlight">\(P\)</span> has degree two in <span class="math notranslate nohighlight">\(P\)</span>.</p>
<p>An ear decomposition of an undirected graph <span class="math notranslate nohighlight">\(G\)</span> is a partition of its
set of edges into a sequence of ears, such that the one or two endpoints
of each ear belong to earlier ears in the sequence and such that the
internal vertices of each ear do not belong to any earlier ear.</p>
<p>For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Ear_decomposition">Wikipedia article Ear_decomposition</a>.</p>
<p>This method implements the linear time algorithm presented in
<a class="reference internal" href="../../../references/index.html#sch2013" id="id25"><span>[Sch2013]</span></a>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>A nested list representing the cycles and chains of the ear
decomposition of the graph.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>Ear decomposition of an outer planar graph of order 13:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;LlCG{O@?GBOMW?&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">ear_decomposition</span><span class="p">()</span>
<span class="go">[[0, 3, 2, 1, 0],</span>
<span class="go"> [0, 7, 4, 3],</span>
<span class="go"> [0, 11, 9, 8, 7],</span>
<span class="go"> [1, 12, 2],</span>
<span class="go"> [3, 6, 5, 4],</span>
<span class="go"> [4, 6],</span>
<span class="go"> [7, 10, 8],</span>
<span class="go"> [7, 11],</span>
<span class="go"> [8, 11]]</span>
</pre></div>
</div>
<p>Ear decomposition of a biconnected graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">ear_decomposition</span><span class="p">()</span>
<span class="go">[[0, 3, 2, 1, 0]]</span>
</pre></div>
</div>
<p>Ear decomposition of a connected but not biconnected graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_cycle</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_cycle</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">ear_decomposition</span><span class="p">()</span>
<span class="go">[[0, 2, 1, 0], [3, 6, 5, 4, 3]]</span>
</pre></div>
</div>
<p>The ear decomposition of a multigraph with loops is the same as the ear
decomposition of the underlying simple graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">BullGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">allow_multiple_edges</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">allow_loops</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">u</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">random_vertex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span>
<span class="go">Bull graph: Looped multi-graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">to_simple</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">ear_decomposition</span><span class="p">()</span> <span class="o">==</span> <span class="n">h</span><span class="o">.</span><span class="n">ear_decomposition</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.eccentricity">
<span class="sig-name descname"><span class="pre">eccentricity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">by_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.eccentricity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the eccentricity of vertex (or vertices) <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<p>The eccentricity of a vertex is the maximum distance to any other
vertex.</p>
<p>For more information and examples on how to use input variables, see
<a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.shortest_path_all_pairs" title="sage.graphs.generic_graph.GenericGraph.shortest_path_all_pairs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shortest_path_all_pairs()</span></code></a>,
<a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.shortest_path_lengths" title="sage.graphs.generic_graph.GenericGraph.shortest_path_lengths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shortest_path_lengths()</span></code></a> and
<a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.shortest_paths" title="sage.graphs.generic_graph.GenericGraph.shortest_paths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shortest_paths()</span></code></a></p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">v</span></code> - either a single vertex or a list of vertices. If it is not
specified, then it is taken to be all vertices.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">by_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, edge
weights are taken into account; if False, all edges have weight 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); one of the following
algorithms:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'BFS'</span></code> - the computation is done through a BFS centered on each
vertex successively. Works only if <code class="docutils literal notranslate"><span class="pre">by_weight==False</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'DHV'</span></code> - the computation is done using the algorithm proposed in
<a class="reference internal" href="../../../references/index.html#dragan2018" id="id26"><span>[Dragan2018]</span></a>. Works only if <code class="docutils literal notranslate"><span class="pre">self</span></code> has non-negative edge weights
and <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">is</span> <span class="pre">None</span></code> or <code class="docutils literal notranslate"><span class="pre">v</span></code> should contain all vertices of <code class="docutils literal notranslate"><span class="pre">self</span></code>.
For more information see method
<a class="reference internal" href="distances_all_pairs.html#sage.graphs.distances_all_pairs.eccentricity" title="sage.graphs.distances_all_pairs.eccentricity"><code class="xref py py-func docutils literal notranslate"><span class="pre">sage.graphs.distances_all_pairs.eccentricity()</span></code></a> and
<a class="reference internal" href="base/boost_graph.html#sage.graphs.base.boost_graph.eccentricity_DHV" title="sage.graphs.base.boost_graph.eccentricity_DHV"><code class="xref py py-func docutils literal notranslate"><span class="pre">sage.graphs.base.boost_graph.eccentricity_DHV()</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Floyd-Warshall-Cython'</span></code> - a Cython implementation of the
Floyd-Warshall algorithm. Works only if <code class="docutils literal notranslate"><span class="pre">by_weight==False</span></code> and
<code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">is</span> <span class="pre">None</span></code> or <code class="docutils literal notranslate"><span class="pre">v</span></code> should contain all vertices of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Floyd-Warshall-Python'</span></code> - a Python implementation of the
Floyd-Warshall algorithm. Works also with weighted graphs, even with
negative weights (but no negative cycle is allowed). However, <code class="docutils literal notranslate"><span class="pre">v</span></code>
must be <code class="docutils literal notranslate"><span class="pre">None</span></code> or <code class="docutils literal notranslate"><span class="pre">v</span></code> should contain all vertices of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Dijkstra_NetworkX'</span></code> - the Dijkstra algorithm, implemented in
NetworkX. It works with weighted graphs, but no negative weight is
allowed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Dijkstra_Boost'</span></code> - the Dijkstra algorithm, implemented in Boost
(works only with positive weights).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Johnson_Boost'</span></code> - the Johnson algorithm, implemented in
Boost (works also with negative weights, if there is no negative
cycle). Works only if <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">is</span> <span class="pre">None</span></code> or <code class="docutils literal notranslate"><span class="pre">v</span></code> should contain all
vertices of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'From_Dictionary'</span></code> - uses the (already computed) distances, that
are provided by input variable <code class="docutils literal notranslate"><span class="pre">dist_dict</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> (default): Sage chooses the best algorithm:
<code class="docutils literal notranslate"><span class="pre">'From_Dictionary'</span></code> if <code class="docutils literal notranslate"><span class="pre">dist_dict</span></code> is not None, <code class="docutils literal notranslate"><span class="pre">'BFS'</span></code> for
unweighted graphs, <code class="docutils literal notranslate"><span class="pre">'Dijkstra_Boost'</span></code> if all weights are
positive, <code class="docutils literal notranslate"><span class="pre">'Johnson_Boost'</span></code> otherwise.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
takes as input an edge <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></code> and outputs its weight. If not
<code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is automatically set to <code class="docutils literal notranslate"><span class="pre">True</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>
and <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, we use the edge label <code class="docutils literal notranslate"><span class="pre">l</span></code> as a
weight, if <code class="docutils literal notranslate"><span class="pre">l</span></code> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, else <code class="docutils literal notranslate"><span class="pre">1</span></code> as a weight.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, we check
that the <code class="docutils literal notranslate"><span class="pre">weight_function</span></code> outputs a number for each edge</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dist_dict</span></code> – a dictionary (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a dict of dicts of
distances (used only if <code class="docutils literal notranslate"><span class="pre">algorithm=='From_Dictionary'</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">with_labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return a
list or a dictionary keyed by vertices.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">KrackhardtKiteGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">eccentricity</span><span class="p">()</span>
<span class="go">[4, 4, 4, 4, 4, 3, 3, 2, 3, 4]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">eccentricity</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">eccentricity</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">])</span>
<span class="go">[2, 3, 4]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">eccentricity</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="mi">8</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">:</span> <span class="p">[],</span> <span class="mi">1</span> <span class="p">:</span> <span class="p">[],</span> <span class="mi">2</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">eccentricity</span><span class="p">()</span>
<span class="go">[+Infinity, +Infinity, +Infinity]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">eccentricity</span><span class="p">(</span><span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{0: 0}</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[],</span> <span class="mi">1</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">eccentricity</span><span class="p">(</span><span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{0: +Infinity, 1: +Infinity}</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">eccentricity</span><span class="p">(</span><span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;BFS&#39;</span><span class="p">)</span>
<span class="go">[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">eccentricity</span><span class="p">(</span><span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;Floyd-Warshall-Cython&#39;</span><span class="p">)</span>
<span class="go">[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">eccentricity</span><span class="p">(</span><span class="n">by_weight</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;Dijkstra_NetworkX&#39;</span><span class="p">)</span>
<span class="go">[2, 1, 2]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">eccentricity</span><span class="p">(</span><span class="n">by_weight</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;Dijkstra_Boost&#39;</span><span class="p">)</span>
<span class="go">[2, 1, 2]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">eccentricity</span><span class="p">(</span><span class="n">by_weight</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;Johnson_Boost&#39;</span><span class="p">)</span>
<span class="go">[2, 1, 2]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">eccentricity</span><span class="p">(</span><span class="n">by_weight</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;Floyd-Warshall-Python&#39;</span><span class="p">)</span>
<span class="go">[2, 1, 2]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">eccentricity</span><span class="p">(</span><span class="n">dist_dict</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">shortest_path_all_pairs</span><span class="p">(</span><span class="n">by_weight</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[2, 1, 2]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">eccentricity</span><span class="p">(</span><span class="n">by_weight</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;DHV&#39;</span><span class="p">)</span>
<span class="go">[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">eccentricity</span><span class="p">(</span><span class="n">by_weight</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;DHV&#39;</span><span class="p">)</span>
<span class="go">[2.0, 1.0, 2.0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.edge_isoperimetric_number">
<span class="sig-name descname"><span class="pre">edge_isoperimetric_number</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.edge_isoperimetric_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the edge-isoperimetric number of the graph.</p>
<p>The edge-isoperimetric number of a graph <span class="math notranslate nohighlight">\(G = (V,E)\)</span> is also sometimes
called the <em>isoperimetric number</em>. It is defined as the minimum of
<span class="math notranslate nohighlight">\(|\partial S| / |S|\)</span> where <span class="math notranslate nohighlight">\(\partial S\)</span> is the edge boundary of <span class="math notranslate nohighlight">\(S\)</span> (number
of edges with one end in <span class="math notranslate nohighlight">\(S\)</span> and one end in <span class="math notranslate nohighlight">\(V \setminus S\)</span>) and the
minimum is taken over all subsets of vertices whose cardinality does not
exceed half the size <span class="math notranslate nohighlight">\(|V|\)</span> of the graph.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Alternative but similar quantities can be obtained via the methods
<a class="reference internal" href="#sage.graphs.graph.Graph.cheeger_constant" title="sage.graphs.graph.Graph.cheeger_constant"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cheeger_constant()</span></code></a> and <a class="reference internal" href="#sage.graphs.graph.Graph.vertex_isoperimetric_number" title="sage.graphs.graph.Graph.vertex_isoperimetric_number"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertex_isoperimetric_number()</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<p>The edge-isoperimetric number of a complete graph on <span class="math notranslate nohighlight">\(n\)</span> vertices is
<span class="math notranslate nohighlight">\(\lceil n/2 \rceil\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">edge_isoperimetric_number</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">10</span><span class="p">)]</span>
<span class="go">[1, 2, 2, 3, 3, 4, 4, 5]</span>
</pre></div>
</div>
<p>The edge-isoperimetric constant of a cycle on <span class="math notranslate nohighlight">\(n\)</span> vertices is
<span class="math notranslate nohighlight">\(2/\lfloor n/2 \rfloor\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">edge_isoperimetric_number</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">15</span><span class="p">)]</span>
<span class="go">[1, 2, 1, 1, 2/3, 2/3, 1/2, 1/2, 2/5, 2/5, 1/3, 1/3, 2/7]</span>
</pre></div>
</div>
<p>In general, for <span class="math notranslate nohighlight">\(d\)</span>-regular graphs the edge-isoperimetric number is
<span class="math notranslate nohighlight">\(d\)</span> times larger than the Cheeger constant of the graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomRegular</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">edge_isoperimetric_number</span><span class="p">()</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">cheeger_constant</span><span class="p">()</span> <span class="o">*</span> <span class="mi">3</span>
<span class="go">True</span>
</pre></div>
</div>
<p>And the edge-isoperimetric constant of a disconnected graph is <span class="math notranslate nohighlight">\(0\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)]])</span><span class="o">.</span><span class="n">edge_isoperimetric_number</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.effective_resistance">
<span class="sig-name descname"><span class="pre">effective_resistance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.effective_resistance" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the effective resistance between nodes <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>.</p>
<p>The resistance distance between vertices <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> of a simple
connected graph <span class="math notranslate nohighlight">\(G\)</span> is defined as the effective resistance between the
two vertices on an electrical network constructed from <span class="math notranslate nohighlight">\(G\)</span> replacing
each edge of the graph by a unit (1 ohm) resistor.</p>
<p>See the <a class="reference external" href="https://en.wikipedia.org/wiki/Resistance_distance">Wikipedia article Resistance_distance</a> for more information.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">i</span></code>, <code class="docutils literal notranslate"><span class="pre">j</span></code> – vertices of the graph</p></li>
</ul>
<p>OUTPUT: rational number denoting resistance between nodes <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span></p>
<p>EXAMPLES:</p>
<p>Effective resistances in a straight linear 2-tree on 6 vertices</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">effective_resistance</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">34/55</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">effective_resistance</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">49/55</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">effective_resistance</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="go">9/11</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">effective_resistance</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="go">15/11</span>
</pre></div>
</div>
<p>Effective resistances in a fan on 6 vertices</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">effective_resistance</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="go">6/5</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">effective_resistance</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">49/55</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.effective_resistance_matrix" title="sage.graphs.graph.Graph.effective_resistance_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">effective_resistance_matrix()</span></code></a> –
a similar method giving a matrix full of all effective
resistances between all nodes</p></li>
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.least_effective_resistance" title="sage.graphs.graph.Graph.least_effective_resistance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">least_effective_resistance()</span></code></a> –
gives node pairs with least effective resistances</p></li>
<li><p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Resistance_distance">Wikipedia article Resistance_distance</a> for more details.</p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.effective_resistance_matrix">
<span class="sig-name descname"><span class="pre">effective_resistance_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nonedgesonly</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.effective_resistance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a matrix whose (<span class="math notranslate nohighlight">\(i\)</span> , <span class="math notranslate nohighlight">\(j\)</span>) entry gives the effective resistance
between vertices <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>.</p>
<p>The resistance distance between vertices <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> of a simple
connected graph <span class="math notranslate nohighlight">\(G\)</span> is defined as the effective resistance between the
two vertices on an electrical network constructed from <span class="math notranslate nohighlight">\(G\)</span> replacing
each edge of the graph by a unit (1 ohm) resistor.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nonedgesonly</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code> assign
zero resistance to pairs of adjacent vertices.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – list (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the ordering of the
vertices defining how they should appear in the matrix. By default,
the ordering given by <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.vertices" title="sage.graphs.generic_graph.GenericGraph.vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GenericGraph.vertices()</span></code></a> is used.</p></li>
</ul>
<p>OUTPUT: matrix</p>
<p>EXAMPLES:</p>
<p>The effective resistance matrix  for a straight linear 2-tree counting
only non-adjacent vertex pairs</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">effective_resistance_matrix</span><span class="p">()</span>
<span class="go">[    0     0     0 49/55 59/55 15/11]</span>
<span class="go">[    0     0     0     0  9/11 59/55]</span>
<span class="go">[    0     0     0     0     0 49/55]</span>
<span class="go">[49/55     0     0     0     0     0]</span>
<span class="go">[59/55  9/11     0     0     0     0]</span>
<span class="go">[15/11 59/55 49/55     0     0     0]</span>
</pre></div>
</div>
<p>The same effective resistance matrix, this time including adjacent
vertices</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">effective_resistance_matrix</span><span class="p">(</span><span class="n">nonedgesonly</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[    0 34/55 34/55 49/55 59/55 15/11]</span>
<span class="go">[34/55     0 26/55 31/55  9/11 59/55]</span>
<span class="go">[34/55 26/55     0  5/11 31/55 49/55]</span>
<span class="go">[49/55 31/55  5/11     0 26/55 34/55]</span>
<span class="go">[59/55  9/11 31/55 26/55     0 34/55]</span>
<span class="go">[15/11 59/55 49/55 34/55 34/55     0]</span>
</pre></div>
</div>
<p>This example illustrates the common neighbors matrix  for a fan on 6
vertices counting only non-adjacent vertex pairs</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">effective_resistance_matrix</span><span class="p">()</span>
<span class="go">[    0     0     0     0     0     0     0]</span>
<span class="go">[    0     0     0 49/55 56/55   6/5 89/55]</span>
<span class="go">[    0     0     0     0   4/5 56/55 81/55]</span>
<span class="go">[    0 49/55     0     0     0 49/55 16/11]</span>
<span class="go">[    0 56/55   4/5     0     0     0 81/55]</span>
<span class="go">[    0   6/5 56/55 49/55     0     0 89/55]</span>
<span class="go">[    0 89/55 81/55 16/11 81/55 89/55     0]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.least_effective_resistance" title="sage.graphs.graph.Graph.least_effective_resistance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">least_effective_resistance()</span></code></a> –
gives node pairs with least effective resistances</p></li>
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.effective_resistance" title="sage.graphs.graph.Graph.effective_resistance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">effective_resistance()</span></code></a> –
computes effective resistance for a single node pair</p></li>
<li><p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Resistance_Distance">Wikipedia article Resistance_Distance</a> for more details.</p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.folded_graph">
<span class="sig-name descname"><span class="pre">folded_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.folded_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the antipodal fold of this graph.</p>
<p>Given an antipodal graph <span class="math notranslate nohighlight">\(G\)</span> let <span class="math notranslate nohighlight">\(G_d\)</span> be its distance-<span class="math notranslate nohighlight">\(d\)</span> graph.
Then the folded graph of <span class="math notranslate nohighlight">\(G\)</span> has a vertex for each maximal clique
of <span class="math notranslate nohighlight">\(G_d\)</span> and two cliques are adjacent if there is an edge in <span class="math notranslate nohighlight">\(G\)</span>
connecting the two.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.graphs.graph.is_antipodal()</span></code></p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to check if the
graph is antipodal. If <code class="docutils literal notranslate"><span class="pre">check</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> and the graph is not
antipodal, then return <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>This function returns a new graph and <code class="docutils literal notranslate"><span class="pre">self</span></code> is not touched.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The input is expected to be an antipodal graph.
You can check that a graph is antipodal using
<code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.graphs.graph.is_antipodal()</span></code>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">JohnsonGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">folded_graph</span><span class="p">();</span> <span class="n">H</span>
<span class="go">Folded Johnson graph with parameters 10,5: Graph on 126 vertices</span>
<span class="gp">sage: </span><span class="n">Gd</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">distance_graph</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">diameter</span><span class="p">())</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Gd</span><span class="o">.</span><span class="n">degree</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">is_distance_regular</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="go">([25, 16, None], [None, 1, 4])</span>
</pre></div>
</div>
<p>This method doesn’t check if the graph is antipodal:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_antipodal</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">folded_graph</span><span class="p">()</span>  <span class="c1"># some garbage</span>
<span class="go">Folded Petersen graph: Graph on 2 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">folded_graph</span><span class="p">(</span><span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<p>See <a class="reference internal" href="../../../references/index.html#bcn1989" id="id27"><span>[BCN1989]</span></a> p. 438 or <a class="reference internal" href="../../../references/index.html#sam2012" id="id28"><span>[Sam2012]</span></a> for this definition of folded graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.fractional_chromatic_index">
<span class="sig-name descname"><span class="pre">fractional_chromatic_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'PPL'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.fractional_chromatic_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the fractional chromatic index of the graph.</p>
<p>The fractional chromatic index is a relaxed version of edge-coloring. An
edge coloring of a graph being actually a covering of its edges into the
smallest possible number of matchings, the fractional chromatic index of a
graph <span class="math notranslate nohighlight">\(G\)</span> is the smallest real value <span class="math notranslate nohighlight">\(\chi_f(G)\)</span> such that there exists a
list of matchings <span class="math notranslate nohighlight">\(M_1, \ldots, M_k\)</span> of <span class="math notranslate nohighlight">\(G\)</span> and coefficients <span class="math notranslate nohighlight">\(\alpha_1,
\ldots, \alpha_k\)</span> with the property that each edge is covered by the
matchings in the following relaxed way</p>
<div class="math notranslate nohighlight">
\[\forall e \in E(G), \sum_{e \in M_i} \alpha_i \geq 1.\]</div>
<p>For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Fractional_coloring">Wikipedia article Fractional_coloring</a>.</p>
<p>ALGORITHM:</p>
<p>The fractional chromatic index is computed through Linear Programming
through its dual. The LP solved by sage is actually:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mbox{Maximize : }&amp;\sum_{e\in E(G)} r_{e}\\
\mbox{Such that : }&amp;\\
&amp;\forall M\text{ matching }\subseteq G, \sum_{e\in M}r_{v}\leq 1\\\end{split}\]</div>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">&quot;PPL&quot;</span></code>); specify a Linear Program (LP) solver
to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For more
information on LP solvers and which default solver is used, see the method
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the
class <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default solver used here is <code class="docutils literal notranslate"><span class="pre">&quot;PPL&quot;</span></code> which provides exact
results, i.e. a rational number, although this may be slower that
using other solvers. Be aware that this method may loop endlessly when
using some non exact solvers as reported in <a class="reference external" href="https://trac.sagemath.org/23658">trac ticket #23658</a> and
<a class="reference external" href="https://trac.sagemath.org/23798">trac ticket #23798</a>.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose_constraints</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to
display which constraints are being generated</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <span class="math notranslate nohighlight">\(0\)</span>); sets the level of verbosity of the
LP solver</p></li>
</ul>
<p>EXAMPLES:</p>
<p>The fractional chromatic index of a <span class="math notranslate nohighlight">\(C_5\)</span> is <span class="math notranslate nohighlight">\(5/2\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">fractional_chromatic_index</span><span class="p">()</span>
<span class="go">5/2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.fractional_chromatic_number">
<span class="sig-name descname"><span class="pre">fractional_chromatic_number</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'PPL'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_components</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_bipartite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.fractional_chromatic_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the fractional chromatic number of the graph.</p>
<p>Fractional coloring is a relaxed version of vertex coloring with several
equivalent definitions, such as the optimum value in a linear relaxation of
the integer program that gives the usual chromatic number. It is also equal
to the fractional clique number by LP-duality.</p>
<p>ALGORITHM:</p>
<p>The fractional chromatic number is computed via the usual Linear Program.
The LP solved by sage is essentially,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mbox{Minimize : }&amp;\sum_{I\in \mathcal{I}(G)} x_{I}\\
\mbox{Such that : }&amp;\\
&amp;\forall v\in V(G), \sum_{I\in \mathcal{I}(G),\, v\in I}x_{v}\geq 1\\
&amp;\forall I\in \mathcal{I}(G), x_{I} \geq 0\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathcal{I}(G)\)</span> is the set of maximal independent sets of <span class="math notranslate nohighlight">\(G\)</span> (see
Section 2.1 of <a class="reference internal" href="../../../references/index.html#cfkpr2010" id="id29"><span>[CFKPR2010]</span></a> to know why it is sufficient to consider maximal
independent sets). As optional optimisations, we construct the LP on each
biconnected component of <span class="math notranslate nohighlight">\(G\)</span> (and output the maximum value), and avoid using
the LP if G is bipartite (as then the output must be 1 or 2).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Computing the fractional chromatic number can be very slow. Since the
variables of the LP are independent sets, in general the LP has size
exponential in the order of the graph. In the current implementation a
list of all maximal independent sets is created and stored, which can be
both slow and memory-hungry.</p>
</div>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">&quot;PPL&quot;</span></code>); specify a Linear Program (LP) solver
to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For more
information on LP solvers and which default solver is used, see the method
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the
class <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default solver used here is <code class="docutils literal notranslate"><span class="pre">&quot;PPL&quot;</span></code> which provides exact
results, i.e. a rational number, although this may be slower that
using other solvers.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <span class="math notranslate nohighlight">\(0\)</span>); sets the level of verbosity of
the LP solver</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_components</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether the method is
called on each biconnected component of <span class="math notranslate nohighlight">\(G\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_bipartite</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether the graph is
checked for bipartiteness. If the graph is bipartite then we can avoid
creating and solving the LP.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>The fractional chromatic number of a <span class="math notranslate nohighlight">\(C_5\)</span> is <span class="math notranslate nohighlight">\(5/2\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">fractional_chromatic_number</span><span class="p">()</span>
<span class="go">5/2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.fractional_clique_number">
<span class="sig-name descname"><span class="pre">fractional_clique_number</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'PPL'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_components</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_bipartite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.fractional_clique_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the fractional clique number of the graph.</p>
<p>A fractional clique is a nonnegative weight function on the vertices of
a graph such that the sum of the weights over any independent set is at
most 1. The fractional clique number is the largest total weight of a
fractional clique, which is equal to the fractional chromatic number by
LP-duality.</p>
<p>ALGORITHM:</p>
<p>The fractional clique number is computed via the Linear Program for
fractional chromatic number, see <a class="reference internal" href="graph_coloring.html#sage.graphs.graph_coloring.fractional_chromatic_number" title="sage.graphs.graph_coloring.fractional_chromatic_number"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fractional_chromatic_number</span></code></a></p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">&quot;PPL&quot;</span></code>); specify a Linear Program (LP)
solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default solver used here is <code class="docutils literal notranslate"><span class="pre">&quot;PPL&quot;</span></code> which provides exact
results, i.e. a rational number, although this may be slower that
using other solvers.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <span class="math notranslate nohighlight">\(0\)</span>); sets the level of verbosity of
the LP solver</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_components</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether the
method is called on each biconnected component of <span class="math notranslate nohighlight">\(G\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_bipartite</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether the graph
is checked for bipartiteness. If the graph is bipartite then we can
avoid creating and solving the LP.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>The fractional clique number of a <span class="math notranslate nohighlight">\(C_7\)</span> is <span class="math notranslate nohighlight">\(7/3\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">fractional_clique_number</span><span class="p">()</span>
<span class="go">7/3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.geodetic_closure">
<span class="sig-name descname"><span class="pre">geodetic_closure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.geodetic_closure" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the geodetic closure of the set of vertices <span class="math notranslate nohighlight">\(S\)</span> in <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>The geodetic closure <span class="math notranslate nohighlight">\(g(S)\)</span> of a subset of vertices <span class="math notranslate nohighlight">\(S\)</span> of a graph <span class="math notranslate nohighlight">\(G\)</span> is in
<a class="reference internal" href="../../../references/index.html#hlt1993" id="id30"><span>[HLT1993]</span></a> as the set of all vertices that lie on a shortest <span class="math notranslate nohighlight">\(u-v\)</span> path for
any pair of vertices <span class="math notranslate nohighlight">\(u,v \in S\)</span>. We assume that <span class="math notranslate nohighlight">\(g(\emptyset) = \emptyset\)</span>
and that <span class="math notranslate nohighlight">\(g(\{u\}) = \{u\}\)</span> for any <span class="math notranslate nohighlight">\(u\)</span> in <span class="math notranslate nohighlight">\(G\)</span>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This operation is <strong>not</strong> a closure function. Indeed, a closure function
must satisfy the property that <span class="math notranslate nohighlight">\(f(f(X))\)</span> should be equal to <span class="math notranslate nohighlight">\(f(X)\)</span>,
which is not always the case here.  The term <code class="docutils literal notranslate"><span class="pre">closure</span></code> is used here to
follow the terminology of the domain. See for instance <a class="reference internal" href="../../../references/index.html#hlt1993" id="id31"><span>[HLT1993]</span></a>.</p>
</div>
<p>Here, we implement a simple algorithm to determine this set. Roughly, for
each vertex <span class="math notranslate nohighlight">\(u \in S\)</span>, the algorithm first performs a breadth first search
from <span class="math notranslate nohighlight">\(u\)</span> to get distances, and then identifies the vertices of <span class="math notranslate nohighlight">\(G\)</span> lying on
a shortest path from <span class="math notranslate nohighlight">\(u\)</span> to any <span class="math notranslate nohighlight">\(v\in S\)</span> using a reversal traversal from
vertices in <span class="math notranslate nohighlight">\(S\)</span>.  This algorithm has time complexity in <span class="math notranslate nohighlight">\(O(|S|(n + m))\)</span> and
space complexity in <span class="math notranslate nohighlight">\(O(n + m)\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a Sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">S</span></code> – a subset of vertices of <span class="math notranslate nohighlight">\(G\)</span></p></li>
</ul>
<p>EXAMPLES:</p>
<p>The vertices of the Petersen graph can be obtained by a geodetic closure of
four of its vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.convexity_properties</span> <span class="kn">import</span> <span class="n">geodetic_closure</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">geodetic_closure</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
</pre></div>
</div>
<p>The vertices of a 2D grid can be obtained by a geodetic closure of
two vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">geodetic_closure</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If two vertices belong to different connected components of a graph, their
geodetic closure is trivial:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">geodetic_closure</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">[0, 2]</span>
</pre></div>
</div>
<p>The geodetic closure does not satisfy the closure function property that
<span class="math notranslate nohighlight">\(f(f(X))\)</span> should be equal to <span class="math notranslate nohighlight">\(f(X)\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DiamondGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">subdivide_edge</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">geodetic_closure</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">[0, 1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">geodetic_closure</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">geodetic_closure</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
<span class="go">[0, 1, 2, 3, 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.gomory_hu_tree">
<span class="sig-name descname"><span class="pre">gomory_hu_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.gomory_hu_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Gomory-Hu tree of self.</p>
<p>Given a tree <span class="math notranslate nohighlight">\(T\)</span> with labeled edges representing capacities, it is very
easy to determine the maximum flow between any pair of vertices :
it is the minimal label on the edges of the unique path between them.</p>
<p>Given a graph <span class="math notranslate nohighlight">\(G\)</span>, a Gomory-Hu tree <span class="math notranslate nohighlight">\(T\)</span> of <span class="math notranslate nohighlight">\(G\)</span> is a tree with the same
set of vertices, and such that the maximum flow between any two vertices
is the same in <span class="math notranslate nohighlight">\(G\)</span> as in <span class="math notranslate nohighlight">\(T\)</span>. See the <a class="reference external" href="https://en.wikipedia.org/wiki/Gomory–Hu_tree">Wikipedia article Gomory–Hu_tree</a>. Note
that, in general, a graph admits more than one Gomory-Hu tree.</p>
<p>See also 15.4 (Gomory-Hu trees) from <a class="reference internal" href="../../../references/index.html#sch2003" id="id32"><span>[Sch2003]</span></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – select the algorithm used by the <code class="xref py py-meth docutils literal notranslate"><span class="pre">edge_cut()</span></code>
method. Refer to its documentation for allowed values and default
behaviour.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A graph with labeled edges</p>
<p>EXAMPLES:</p>
<p>Taking the Petersen graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">gomory_hu_tree</span><span class="p">()</span>
</pre></div>
</div>
<p>Obviously, this graph is a tree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">is_tree</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note that if the original graph is not connected, then the Gomory-Hu
tree is in fact a forest:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">gomory_hu_tree</span><span class="p">()</span><span class="o">.</span><span class="n">is_forest</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">gomory_hu_tree</span><span class="p">()</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>On the other hand, such a tree has lost nothing of the initial graph
connectedness:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">flow</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">flow</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">Subsets</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">(),</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Just to make sure, we can check that the same is true for two vertices
in a random graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mf">.3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">gomory_hu_tree</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">flow</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">flow</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>And also the min cut:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">edge_connectivity</span><span class="p">()</span> <span class="o">==</span> <span class="nb">min</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">edge_labels</span><span class="p">())</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.graph6_string">
<span class="sig-name descname"><span class="pre">graph6_string</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.graph6_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the graph6 representation of the graph as an ASCII string.</p>
<p>This is only valid for simple (no loops, no multiple edges) graphs
on at most <span class="math notranslate nohighlight">\(2^{18}-1=262143\)</span> vertices.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As the graph6 format only handles graphs with vertex set
<span class="math notranslate nohighlight">\(\{0,...,n-1\}\)</span>, a <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.relabel" title="sage.graphs.generic_graph.GenericGraph.relabel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relabelled</span> <span class="pre">copy</span></code></a> will
be encoded, if necessary.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="digraph.html#sage.graphs.digraph.DiGraph.dig6_string" title="sage.graphs.digraph.DiGraph.dig6_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dig6_string()</span></code></a> –
a similar string format for directed graphs</p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">KrackhardtKiteGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">graph6_string</span><span class="p">()</span>
<span class="go">&#39;IvUqwK@?G&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.has_homomorphism_to">
<span class="sig-name descname"><span class="pre">has_homomorphism_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">core</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.has_homomorphism_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether there is a homomorphism between two graphs.</p>
<p>A homomorphism from a graph <span class="math notranslate nohighlight">\(G\)</span> to a graph <span class="math notranslate nohighlight">\(H\)</span> is a function
<span class="math notranslate nohighlight">\(\phi:V(G)\mapsto V(H)\)</span> such that for any edge <span class="math notranslate nohighlight">\(uv \in E(G)\)</span> the pair
<span class="math notranslate nohighlight">\(\phi(u)\phi(v)\)</span> is an edge of <span class="math notranslate nohighlight">\(H\)</span>.</p>
<p>Saying that a graph can be <span class="math notranslate nohighlight">\(k\)</span>-colored is equivalent to saying that it
has a homomorphism to <span class="math notranslate nohighlight">\(K_k\)</span>, the complete graph on <span class="math notranslate nohighlight">\(k\)</span> elements.</p>
<p>For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Graph_homomorphism">Wikipedia article Graph_homomorphism</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">H</span></code> – the graph to which <code class="docutils literal notranslate"><span class="pre">self</span></code> should be sent.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">core</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>; whether to minimize the size
of the mapping’s image (see note below). This is set to <code class="docutils literal notranslate"><span class="pre">False</span></code> by
default.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>One can compute the core of a graph (with respect to homomorphism)
with this method</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">mapping</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">has_homomorphism_to</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">core</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The size of the core is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">values</span><span class="p">()))))</span>
<span class="go">The size of the core is 2</span>
</pre></div>
</div>
</div>
<p>OUTPUT:</p>
<p>This method returns <code class="docutils literal notranslate"><span class="pre">False</span></code> when the homomorphism does not exist, and
returns the homomorphism otherwise as a dictionary associating a vertex
of <span class="math notranslate nohighlight">\(H\)</span> to a vertex of <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>EXAMPLES:</p>
<p>Is Petersen’s graph 3-colorable:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">has_homomorphism_to</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span>
<span class="go">True</span>
</pre></div>
</div>
<p>An odd cycle admits a homomorphism to a smaller odd cycle, but not to an
even cycle:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">has_homomorphism_to</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">has_homomorphism_to</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">has_homomorphism_to</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.has_perfect_matching">
<span class="sig-name descname"><span class="pre">has_perfect_matching</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Edmonds'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.has_perfect_matching" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether this graph has a perfect matching.
INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">&quot;Edmonds&quot;</span></code>)</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Edmonds&quot;</span></code> uses Edmonds’ algorithm as implemented in NetworkX to
find a matching of maximal cardinality, then check whether this
cardinality is half the number of vertices of the graph.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;LP_matching&quot;</span></code> uses a Linear Program to find a matching of
maximal cardinality, then check whether this cardinality is half the
number of vertices of the graph.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;LP&quot;</span></code> uses a Linear Program formulation of the perfect matching
problem: put a binary variable <code class="docutils literal notranslate"><span class="pre">b[e]</span></code> on each edge <span class="math notranslate nohighlight">\(e\)</span>, and for
each vertex <span class="math notranslate nohighlight">\(v\)</span>, require that the sum of the values of the edges
incident to <span class="math notranslate nohighlight">\(v\)</span> is 1.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of verbosity:
set to 0 by default, which means quiet (only useful when
<code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">==</span> <span class="pre">&quot;LP_matching&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">==</span> <span class="pre">&quot;LP&quot;</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A boolean.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">has_perfect_matching</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">WheelGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">has_perfect_matching</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">WheelGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">has_perfect_matching</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">has_perfect_matching</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;LP_matching&quot;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">WheelGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">has_perfect_matching</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;LP_matching&quot;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">WheelGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">has_perfect_matching</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;LP_matching&quot;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">has_perfect_matching</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;LP_matching&quot;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">WheelGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">has_perfect_matching</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;LP_matching&quot;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">WheelGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">has_perfect_matching</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;LP_matching&quot;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.ihara_zeta_function_inverse">
<span class="sig-name descname"><span class="pre">ihara_zeta_function_inverse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.ihara_zeta_function_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the inverse of the Ihara zeta function of the graph.</p>
<p>This is a polynomial in one variable with integer coefficients. The
Ihara zeta function itself is the inverse of this polynomial.</p>
<p>See the <a class="reference external" href="https://en.wikipedia.org/wiki/Ihara zeta function">Wikipedia article Ihara zeta function</a> for more information.</p>
<p>ALGORITHM:</p>
<p>This is computed here as the (reversed) characteristic polynomial of a
square matrix of size twice the number of edges, related to the
adjacency matrix of the line graph, see for example Proposition 9 in
<a class="reference internal" href="../../../references/index.html#ss2008" id="id33"><span>[SS2008]</span></a> and Def. 4.1 in <a class="reference internal" href="../../../references/index.html#ter2011" id="id34"><span>[Ter2011]</span></a>.</p>
<p>The graph is first replaced by its 2-core, as this does not change the
Ihara zeta function.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">factor</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">ihara_zeta_function_inverse</span><span class="p">())</span>
<span class="go">(2*t - 1) * (t + 1)^2 * (t - 1)^3 * (2*t^2 + t + 1)^3</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">factor</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">ihara_zeta_function_inverse</span><span class="p">())</span>
<span class="go">(-1) * (3*t - 1) * (t + 1)^5 * (t - 1)^6 * (3*t^2 + t + 1)^4</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">factor</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">ihara_zeta_function_inverse</span><span class="p">())</span>
<span class="go">(-1) * (2*t - 1) * (t + 1)^5 * (t - 1)^6 * (2*t^2 + 2*t + 1)^4</span>
<span class="go">* (2*t^2 - t + 1)^5</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomTree</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">ihara_zeta_function_inverse</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<p><a class="reference internal" href="../../../references/index.html#hst2001" id="id35"><span>[HST2001]</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.independent_set">
<span class="sig-name descname"><span class="pre">independent_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Cliquer'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduction_rules</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.independent_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a maximum independent set.</p>
<p>An independent set of a graph is a set of pairwise non-adjacent
vertices. A maximum independent set is an independent set of maximum
cardinality.  It induces an empty subgraph.</p>
<p>Equivalently, an independent set is defined as the complement of a
vertex cover.</p>
<p>For more information, see the
<a class="reference external" href="https://en.wikipedia.org/wiki/Independent_set_(graph_theory)">Wikipedia article Independent_set_(graph_theory)</a> and the
<a class="reference external" href="https://en.wikipedia.org/wiki/Vertex_cover">Wikipedia article Vertex_cover</a>.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – the algorithm to be used</p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;Cliquer&quot;</span></code> (default), the problem is solved
using Cliquer <a class="reference internal" href="../../../references/index.html#no2003" id="id36"><span>[NO2003]</span></a>.</p>
<p>(see the <a class="reference internal" href="cliquer.html#module-sage.graphs.cliquer" title="sage.graphs.cliquer"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Cliquer</span> <span class="pre">modules</span></code></a>)</p>
</li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;MILP&quot;</span></code>, the problem is solved through a Mixed
Integer Linear Program.</p>
<p>(see <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>)</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;mcqd&quot;</span></code>, uses the MCQD solver
(<a class="reference external" href="http://www.sicmm.org/~konc/maxclique/">http://www.sicmm.org/~konc/maxclique/</a>). Note that the MCQD
package must be installed.</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">value_only</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if set to <code class="docutils literal notranslate"><span class="pre">True</span></code>,
only the size of a maximum independent set is returned. Otherwise,
a maximum independent set is returned as a list of vertices.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reduction_rules</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); specify if the reductions
rules from kernelization must be applied as pre-processing or not.
See <a class="reference internal" href="../../../references/index.html#acflss04" id="id38"><span>[ACFLSS04]</span></a> for more details. Note that depending on the instance,
it might be faster to disable reduction rules.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>While Cliquer/MCAD are usually (and by far) the most efficient
implementations, the MILP formulation sometimes proves faster on
very “symmetrical” graphs.</p>
</div>
<p>EXAMPLES:</p>
<p>Using Cliquer:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">independent_set</span><span class="p">()</span>
<span class="go">[0, 3, 6, 7]</span>
</pre></div>
</div>
<p>As a linear program:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">independent_set</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;MILP&quot;</span><span class="p">))</span>
<span class="go">4</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="../../_images/graph-2.svg" class="plot-directive" src="../../_images/graph-2.svg" /></figure>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.independent_set_of_representatives">
<span class="sig-name descname"><span class="pre">independent_set_of_representatives</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">family</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.independent_set_of_representatives" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an independent set of representatives.</p>
<p>Given a graph <span class="math notranslate nohighlight">\(G\)</span> and a family <span class="math notranslate nohighlight">\(F=\{F_i:i\in [1,...,k]\}\)</span> of subsets of
<code class="docutils literal notranslate"><span class="pre">g.vertices()</span></code>, an Independent Set of Representatives (ISR) is an
assignation of a vertex <span class="math notranslate nohighlight">\(v_i\in F_i\)</span> to each set <span class="math notranslate nohighlight">\(F_i\)</span> such that <span class="math notranslate nohighlight">\(v_i !=
v_j\)</span> if <span class="math notranslate nohighlight">\(i&lt;j\)</span> (they are representatives) and the set <span class="math notranslate nohighlight">\(\cup_{i}v_i\)</span> is an
independent set in <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>It generalizes, for example, graph coloring and graph list coloring.</p>
<p>(See <a class="reference internal" href="../../../references/index.html#abz2007" id="id39"><span>[ABZ2007]</span></a> for more information.)</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">family</span></code> – A list of lists defining the family <span class="math notranslate nohighlight">\(F\)</span> (actually, a
Family of subsets of <code class="docutils literal notranslate"><span class="pre">G.vertices()</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>A list whose <span class="math notranslate nohighlight">\(i^{\mbox{th}}\)</span> element is the representative of the
<span class="math notranslate nohighlight">\(i^{\mbox{th}}\)</span> element of the <code class="docutils literal notranslate"><span class="pre">family</span></code> list. If there is no ISR,
<code class="docutils literal notranslate"><span class="pre">None</span></code> is returned.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>For a bipartite graph missing one edge, the solution is as expected:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">delete_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">independent_set_of_representatives</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]])</span>
<span class="go">[1, 4]</span>
</pre></div>
</div>
<p>The Petersen Graph is 3-colorable, which can be expressed as an
independent set of representatives problem : take 3 disjoint copies of
the Petersen Graph, each one representing one color. Then take as a
partition of the set of vertices the family defined by the three copies
of each vertex. The ISR of such a family defines a 3-coloring:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span> <span class="o">/</span> <span class="mi">3</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="p">[[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">isr</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">independent_set_of_representatives</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">integer_floor</span><span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">isr</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">color_classes</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[],</span> <span class="p">[]]</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
<span class="gp">....: </span>  <span class="n">color_classes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">classs</span> <span class="ow">in</span> <span class="n">color_classes</span><span class="p">:</span>
<span class="gp">....: </span>  <span class="n">g</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">classs</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
<span class="go">True</span>
<span class="go">True</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_antipodal">
<span class="sig-name descname"><span class="pre">is_antipodal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_antipodal" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether this graph is antipodal.</p>
<p>A graph <span class="math notranslate nohighlight">\(G\)</span> of diameter <span class="math notranslate nohighlight">\(d\)</span> is said to be antipodal if its distance-<span class="math notranslate nohighlight">\(d\)</span>
graph is a disjoint union of cliques.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">JohnsonGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_antipodal</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">folded_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">is_antipodal</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<p>See <a class="reference internal" href="../../../references/index.html#bcn1989" id="id40"><span>[BCN1989]</span></a> p. 438 or <a class="reference internal" href="../../../references/index.html#sam2012" id="id41"><span>[Sam2012]</span></a> for this definition of antipodal
graphs.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_apex">
<span class="sig-name descname"><span class="pre">is_apex</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_apex" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the graph is apex.</p>
<p>A graph is apex if it can be made planar by the removal of a single
vertex. The deleted vertex is called <code class="docutils literal notranslate"><span class="pre">an</span> <span class="pre">apex</span></code> of the graph, and a
graph may have more than one apex. For instance, in the minimal
nonplanar graphs <span class="math notranslate nohighlight">\(K_5\)</span> or <span class="math notranslate nohighlight">\(K_{3,3}\)</span>, every vertex is an apex. The apex
graphs include graphs that are themselves planar, in which case again
every vertex is an apex. The null graph is also counted as an apex graph
even though it has no vertex to remove.  If the graph is not connected,
we say that it is apex if it has at most one non planar connected
component and that this component is apex.  See the <a class="reference external" href="https://en.wikipedia.org/wiki/Apex_graph">Wikipedia article Apex_graph</a>
for more information.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.apex_vertices" title="sage.graphs.graph.Graph.apex_vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apex_vertices()</span></code></a></p></li>
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.is_planar" title="sage.graphs.generic_graph.GenericGraph.is_planar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_planar()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p><span class="math notranslate nohighlight">\(K_5\)</span> and <span class="math notranslate nohighlight">\(K_{3,3}\)</span> are apex graphs, and each of their vertices is an
apex:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_apex</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_apex</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Petersen graph is not apex:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_apex</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A graph is apex if all its connected components are apex, but at most
one is not planar:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K5</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">M</span><span class="o">+</span><span class="n">K5</span><span class="p">)</span><span class="o">.</span><span class="n">is_apex</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">M</span><span class="o">+</span><span class="n">K5</span><span class="o">+</span><span class="n">K5</span><span class="p">)</span><span class="o">.</span><span class="n">is_apex</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_arc_transitive">
<span class="sig-name descname"><span class="pre">is_arc_transitive</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_arc_transitive" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if self is an arc-transitive graph</p>
<p>A graph is arc-transitive if its automorphism group acts transitively on
its pairs of adjacent vertices.</p>
<p>Equivalently, if there exists for any pair of edges <span class="math notranslate nohighlight">\(uv,u'v'\in E(G)\)</span> an
automorphism <span class="math notranslate nohighlight">\(\phi_1\)</span> of <span class="math notranslate nohighlight">\(G\)</span> such that <span class="math notranslate nohighlight">\(\phi_1(u)=u'\)</span> and
<span class="math notranslate nohighlight">\(\phi_1(v)=v'\)</span>, as well as another automorphism <span class="math notranslate nohighlight">\(\phi_2\)</span> of <span class="math notranslate nohighlight">\(G\)</span> such
that <span class="math notranslate nohighlight">\(\phi_2(u)=v'\)</span> and <span class="math notranslate nohighlight">\(\phi_2(v)=u'\)</span></p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/arc-transitive_graph">Wikipedia article arc-transitive_graph</a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.is_edge_transitive" title="sage.graphs.graph.Graph.is_edge_transitive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_edge_transitive()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.is_half_transitive" title="sage.graphs.graph.Graph.is_half_transitive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_half_transitive()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.is_semi_symmetric" title="sage.graphs.graph.Graph.is_semi_symmetric"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_semi_symmetric()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_arc_transitive</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">GrayGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_arc_transitive</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_asteroidal_triple_free">
<span class="sig-name descname"><span class="pre">is_asteroidal_triple_free</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_asteroidal_triple_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the input graph is asteroidal triple-free</p>
<p>An independent set of three vertices such that each pair is joined by a path
that avoids the neighborhood of the third one is called an <em>asteroidal
triple</em>. A graph is asteroidal triple-free (AT-free) if it contains no
asteroidal triples. See the <a class="reference internal" href="asteroidal_triples.html#module-sage.graphs.asteroidal_triples" title="sage.graphs.asteroidal_triples"><code class="xref py py-mod docutils literal notranslate"><span class="pre">module's</span> <span class="pre">documentation</span></code></a> for more details.</p>
<p>This method returns <code class="docutils literal notranslate"><span class="pre">True</span></code> is the graph is AT-free and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a Graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); by default, this method
returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the graph is asteroidal triple-free and <code class="docutils literal notranslate"><span class="pre">False</span></code>
otherwise. When <code class="docutils literal notranslate"><span class="pre">certificate==True</span></code>, this method returns in addition a
list of three vertices forming an asteroidal triple if such a triple is
found, and the empty list otherwise.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>The complete graph is AT-free, as well as its line graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_asteroidal_triple_free</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_asteroidal_triple_free</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(True, [])</span>
<span class="gp">sage: </span><span class="n">LG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">line_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">LG</span><span class="o">.</span><span class="n">is_asteroidal_triple_free</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">LLG</span> <span class="o">=</span> <span class="n">LG</span><span class="o">.</span><span class="n">line_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">LLG</span><span class="o">.</span><span class="n">is_asteroidal_triple_free</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The PetersenGraph is not AT-free:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.asteroidal_triples</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_asteroidal_triple_free</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_asteroidal_triple_free</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(False, [0, 2, 6])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_biconnected">
<span class="sig-name descname"><span class="pre">is_biconnected</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_biconnected" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the graph is biconnected.</p>
<p>A biconnected graph is a connected graph on two or more vertices that is
not broken into disconnected pieces by deleting any single vertex.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.is_connected" title="sage.graphs.generic_graph.GenericGraph.is_connected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_connected()</span></code></a></p></li>
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.blocks_and_cut_vertices" title="sage.graphs.generic_graph.GenericGraph.blocks_and_cut_vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">blocks_and_cut_vertices()</span></code></a></p></li>
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.blocks_and_cuts_tree" title="sage.graphs.generic_graph.GenericGraph.blocks_and_cuts_tree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">blocks_and_cuts_tree()</span></code></a></p></li>
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Biconnected_graph">Wikipedia article Biconnected_graph</a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_biconnected</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_path</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_biconnected</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_biconnected</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_block_graph">
<span class="sig-name descname"><span class="pre">is_block_graph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_block_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether this graph is a block graph.</p>
<p>A block graph is a connected graph in which every biconnected component
(block) is a clique.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Block_graph">Wikipedia article Block_graph</a> for more details on these graphs</p></li>
<li><p><a class="reference internal" href="graph_generators.html#sage.graphs.graph_generators.GraphGenerators.RandomBlockGraph" title="sage.graphs.graph_generators.GraphGenerators.RandomBlockGraph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">RandomBlockGraph()</span></code></a>
– generator of random block graphs</p></li>
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.blocks_and_cut_vertices" title="sage.graphs.generic_graph.GenericGraph.blocks_and_cut_vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">blocks_and_cut_vertices()</span></code></a></p></li>
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.blocks_and_cuts_tree" title="sage.graphs.generic_graph.GenericGraph.blocks_and_cuts_tree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">blocks_and_cuts_tree()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomBlockGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">kmax</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_block_graph</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.isgci</span> <span class="kn">import</span> <span class="n">graph_classes</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="ow">in</span> <span class="n">graph_classes</span><span class="o">.</span><span class="n">Block</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">is_block_graph</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">RandomTree</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">is_block_graph</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">is_block_graph</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">is_block_graph</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_cactus">
<span class="sig-name descname"><span class="pre">is_cactus</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_cactus" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the graph is cactus graph.</p>
<p>A graph is called <em>cactus graph</em> if it is connected and every pair of
simple cycles have at most one common vertex.</p>
<p>There are other definitions, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Cactus_graph">Wikipedia article Cactus_graph</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="mi">8</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">9</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_cactus</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">c6</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">naphthalene</span> <span class="o">=</span> <span class="n">c6</span> <span class="o">+</span> <span class="n">c6</span>
<span class="gp">sage: </span><span class="n">naphthalene</span><span class="o">.</span><span class="n">is_cactus</span><span class="p">()</span>  <span class="c1"># Not connected</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">naphthalene</span><span class="o">.</span><span class="n">merge_vertices</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">naphthalene</span><span class="o">.</span><span class="n">is_cactus</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">naphthalene</span><span class="o">.</span><span class="n">merge_vertices</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">naphthalene</span><span class="o">.</span><span class="n">is_cactus</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_cartesian_product">
<span class="sig-name descname"><span class="pre">is_cartesian_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relabeling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_cartesian_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the graph is a Cartesian product.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span>
<span class="pre">False</span></code> (default) the method only returns <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>
answers. If <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></code>, the <code class="docutils literal notranslate"><span class="pre">True</span></code> answers are replaced by
the list of the factors of the graph.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">relabeling</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">relabeling</span> <span class="pre">=</span> <span class="pre">True</span></code>
(implies <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></code>), the method also returns a dictionary
associating to each vertex its natural coordinates as a vertex of a
product graph. If <span class="math notranslate nohighlight">\(g\)</span> is not a Cartesian product, <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned
instead.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.cartesian_product" title="sage.graphs.generic_graph.GenericGraph.cartesian_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.graphs.generic_graph.GenericGraph.cartesian_product()</span></code></a></p></li>
<li><p><a class="reference internal" href="graph_decompositions/graph_products.html#module-sage.graphs.graph_decompositions.graph_products" title="sage.graphs.graph_decompositions.graph_products"><code class="xref py py-mod docutils literal notranslate"><span class="pre">graph_products</span></code></a> – a module on
graph products.</p></li>
</ul>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This algorithm may run faster whenever the graph’s vertices are integers
(see <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.relabel" title="sage.graphs.generic_graph.GenericGraph.relabel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relabel()</span></code></a>). Give it a
try if it is too slow !</p>
</div>
<p>EXAMPLES:</p>
<p>The Petersen graph is prime:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions.graph_products</span> <span class="kn">import</span> <span class="n">is_cartesian_product</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">is_cartesian_product</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A 2d grid is the product of paths:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">is_cartesian_product</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">certificate</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p1</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">p2</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Forgetting the graph’s labels, then finding them back:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">relabel</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span><span class="p">,</span><span class="n">D</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_cartesian_product</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">relabeling</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span>  <span class="c1"># random isomorphism</span>
<span class="go">{0: (20, 0), 1: (20, 1), 2: (20, 2), 3: (20, 3), 4: (20, 4),</span>
<span class="go"> 5: (15, 0), 6: (15, 1), 7: (15, 2), 8: (15, 3), 9: (15, 4),</span>
<span class="go"> 10: (10, 0), 11: (10, 1), 12: (10, 2), 13: (10, 3), 14: (10, 4),</span>
<span class="go"> 15: (5, 0), 16: (5, 1), 17: (5, 2), 18: (5, 3), 19: (5, 4),</span>
<span class="go"> 20: (0, 0), 21: (0, 1), 22: (0, 2), 23: (0, 3), 24: (0, 4)}</span>
</pre></div>
</div>
<p>And of course, we find the factors back when we build a graph from a
product:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span> <span class="o">=</span> <span class="n">is_cartesian_product</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">certificate</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">any</span><span class="p">(</span> <span class="n">x</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">())</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">g1</span><span class="p">,</span><span class="n">g2</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">any</span><span class="p">(</span> <span class="n">x</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">g1</span><span class="p">,</span><span class="n">g2</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_circumscribable">
<span class="sig-name descname"><span class="pre">is_circumscribable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ppl'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_circumscribable" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the graph is the graph of a circumscribed polyhedron.</p>
<p>A polyhedron is circumscribed if all of its facets are tangent to a
sphere. By a theorem of Rivin (<a class="reference internal" href="../../../references/index.html#hrs1993" id="id42"><span>[HRS1993]</span></a>), this can be checked by
solving a linear program that assigns weights between 0 and 1/2 on each
edge of the polyhedron, so that the weights on any face add to exactly
one and the weights on any non-facial cycle add to more than one.  If
and only if this can be done, the polyhedron can be circumscribed.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">&quot;ppl&quot;</span></code>); specify a Linear Program (LP)
solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">is_circumscribable</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">O</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">OctahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">O</span><span class="o">.</span><span class="n">is_circumscribable</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">TT</span> <span class="o">=</span> <span class="n">polytopes</span><span class="o">.</span><span class="n">truncated_tetrahedron</span><span class="p">()</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">TT</span><span class="o">.</span><span class="n">is_circumscribable</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Stellating in a face of the octahedral graph is not circumscribable:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">choice</span><span class="p">(</span><span class="n">O</span><span class="o">.</span><span class="n">faces</span><span class="p">())))</span>
<span class="gp">sage: </span><span class="n">O</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([[</span><span class="mi">6</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">f</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">O</span><span class="o">.</span><span class="n">is_circumscribable</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.is_polyhedral" title="sage.graphs.graph.Graph.is_polyhedral"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_polyhedral()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.is_inscribable" title="sage.graphs.graph.Graph.is_inscribable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_inscribable()</span></code></a></p></li>
</ul>
</div>
<div class="admonition-todo admonition" id="id43">
<p class="admonition-title">Todo</p>
<p>Allow the use of other, inexact but faster solvers.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_cograph">
<span class="sig-name descname"><span class="pre">is_cograph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_cograph" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the graph is cograph.</p>
<p>A cograph is defined recursively: the single-vertex graph is
cograph, complement of cograph is cograph, and disjoint union
of two cographs is cograph. There are many other
characterizations, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Cograph">Wikipedia article Cograph</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">HouseXGraph</span><span class="p">()</span><span class="o">.</span><span class="n">is_cograph</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">HouseGraph</span><span class="p">()</span><span class="o">.</span><span class="n">is_cograph</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="id45">
<p class="admonition-title">Todo</p>
<p>Implement faster recognition algorithm, as for instance
the linear time recognition algorithm using LexBFS proposed
in <a class="reference internal" href="../../../references/index.html#bre2008" id="id44"><span>[Bre2008]</span></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_comparability">
<span class="sig-name descname"><span class="pre">is_comparability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'greedy'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_comparability" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether the graph is a comparability graph</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – choose the implementation used to do the test.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;greedy&quot;</span></code> – a greedy algorithm (see the documentation of the
<a class="reference internal" href="comparability.html#module-sage.graphs.comparability" title="sage.graphs.comparability"><code class="xref py py-mod docutils literal notranslate"><span class="pre">comparability</span> <span class="pre">module</span></code></a>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;MILP&quot;</span></code> – a Mixed Integer Linear Program formulation of the
problem. Beware, for this implementation is unable to return negative
certificates ! When <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></code>, negative certificates are
always equal to <code class="docutils literal notranslate"><span class="pre">None</span></code>. True certificates are valid, though.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> (boolean) – whether to return a
certificate. <em>Yes</em>-answers the certificate is a transitive orientation of
<span class="math notranslate nohighlight">\(G\)</span>, and a <em>no</em> certificates is an odd cycle of sequentially forcing
edges.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> (boolean) – whether to check that the
yes-certificates are indeed transitive. As it is very quick
compared to the rest of the operation, it is enabled by default.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); Specify a Linear Program (LP) solver to
be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For more information
on LP solvers and which default solver is used, see the method
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve()</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of verbosity. Set
to 0 by default, which means quiet.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.comparability</span> <span class="kn">import</span> <span class="n">is_comparability</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">is_comparability</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">is_comparability</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(True, Digraph on 5 vertices)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_directed">
<span class="sig-name descname"><span class="pre">is_directed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_directed" title="Permalink to this definition">¶</a></dt>
<dd><p>Since graph is undirected, returns False.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">is_directed</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_distance_regular">
<span class="sig-name descname"><span class="pre">is_distance_regular</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_distance_regular" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the graph is distance-regular</p>
<p>A graph <span class="math notranslate nohighlight">\(G\)</span> is distance-regular if for any integers <span class="math notranslate nohighlight">\(j,k\)</span> the value of
<span class="math notranslate nohighlight">\(|\{x:d_G(x,u)=j,x\in V(G)\} \cap \{y:d_G(y,v)=j,y\in V(G)\}|\)</span> is constant
for any two vertices <span class="math notranslate nohighlight">\(u,v\in V(G)\)</span> at distance <span class="math notranslate nohighlight">\(i\)</span> from each other. In
particular <span class="math notranslate nohighlight">\(G\)</span> is regular, of degree <span class="math notranslate nohighlight">\(b_0\)</span> (see below), as one can take
<span class="math notranslate nohighlight">\(u=v\)</span>.</p>
<p>Equivalently a graph is distance-regular if there exist integers <span class="math notranslate nohighlight">\(b_i,c_i\)</span>
such that for any two vertices <span class="math notranslate nohighlight">\(u,v\)</span> at distance <span class="math notranslate nohighlight">\(i\)</span> we have</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(b_i = |\{x:d_G(x,u)=i+1,x\in V(G)\}\cap N_G(v)\}|, \ 0\leq i\leq d-1\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(c_i = |\{x:d_G(x,u)=i-1,x\in V(G)\}\cap N_G(v)\}|, \ 1\leq i\leq d,\)</span></p></li>
</ul>
<p>where <span class="math notranslate nohighlight">\(d\)</span> is the diameter of the graph.  For more information on
distance-regular graphs, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Distance-regular_graph">Wikipedia article Distance-regular_graph</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">parameters</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the
function returns the pair <code class="docutils literal notranslate"><span class="pre">(b,</span> <span class="pre">c)</span></code> of lists of integers instead of
a boolean answer (see the definition above)</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.is_regular" title="sage.graphs.generic_graph.GenericGraph.is_regular"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_regular()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.is_strongly_regular" title="sage.graphs.graph.Graph.is_strongly_regular"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_strongly_regular()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_distance_regular</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_distance_regular</span><span class="p">(</span><span class="n">parameters</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">([3, 2, None], [None, 1, 1])</span>
</pre></div>
</div>
<p>Cube graphs, which are not strongly regular, are a bit more interesting:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">is_distance_regular</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">OddGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">is_distance_regular</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Disconnected graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="n">is_distance_regular</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_dominating">
<span class="sig-name descname"><span class="pre">is_dominating</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">focus</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_dominating" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether <code class="docutils literal notranslate"><span class="pre">dom</span></code> is a dominating set of <code class="docutils literal notranslate"><span class="pre">G</span></code>.</p>
<p>We say that a set <span class="math notranslate nohighlight">\(D\)</span> of vertices of a graph <span class="math notranslate nohighlight">\(G\)</span> dominates a set <span class="math notranslate nohighlight">\(S\)</span> if
every vertex of <span class="math notranslate nohighlight">\(S\)</span> either belongs to <span class="math notranslate nohighlight">\(D\)</span> or is adjacent to a vertex of <span class="math notranslate nohighlight">\(D\)</span>.
Also, <span class="math notranslate nohighlight">\(D\)</span> is a dominating set of <span class="math notranslate nohighlight">\(G\)</span> if it dominates <span class="math notranslate nohighlight">\(V(G)\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dom</span></code> – iterable of vertices of <code class="docutils literal notranslate"><span class="pre">G</span></code>; the vertices of the supposed
dominating set.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">focus</span></code> – iterable of vertices of <code class="docutils literal notranslate"><span class="pre">G</span></code> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); if
specified, this method checks instead if <code class="docutils literal notranslate"><span class="pre">dom</span></code> dominates the vertices in
<code class="docutils literal notranslate"><span class="pre">focus</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_dominating</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_dominating</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_edge_transitive">
<span class="sig-name descname"><span class="pre">is_edge_transitive</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_edge_transitive" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if self is an edge transitive graph.</p>
<p>A graph is edge-transitive if its automorphism group acts transitively
on its edge set.</p>
<p>Equivalently, if there exists for any pair of edges <span class="math notranslate nohighlight">\(uv,u'v'\in E(G)\)</span> an
automorphism <span class="math notranslate nohighlight">\(\phi\)</span> of <span class="math notranslate nohighlight">\(G\)</span> such that <span class="math notranslate nohighlight">\(\phi(uv)=u'v'\)</span> (note this does not
necessarily mean that <span class="math notranslate nohighlight">\(\phi(u)=u'\)</span> and <span class="math notranslate nohighlight">\(\phi(v)=v'\)</span>).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Edge-transitive_graph">Wikipedia article Edge-transitive_graph</a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.is_arc_transitive" title="sage.graphs.graph.Graph.is_arc_transitive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_arc_transitive()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.is_half_transitive" title="sage.graphs.graph.Graph.is_half_transitive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_half_transitive()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.is_semi_symmetric" title="sage.graphs.graph.Graph.is_semi_symmetric"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_semi_symmetric()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_edge_transitive</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">is_edge_transitive</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">GrayGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_edge_transitive</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_edge_transitive</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_even_hole_free">
<span class="sig-name descname"><span class="pre">is_even_hole_free</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_even_hole_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether <code class="docutils literal notranslate"><span class="pre">self</span></code> contains an induced even hole.</p>
<p>A Hole is a cycle of length at least 4 (included). It is said to be even
(resp. odd) if its length is even (resp. odd).</p>
<p>Even-hole-free graphs always contain a bisimplicial vertex, which
ensures that their chromatic number is at most twice their clique number
<a class="reference internal" href="../../../references/index.html#achrs2008" id="id46"><span>[ACHRS2008]</span></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); when <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span>
<span class="pre">False</span></code>, this method only returns <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>. If
<code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></code>, the subgraph found is returned instead of
<code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>Is the Petersen Graph even-hole-free</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_even_hole_free</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>As any chordal graph is hole-free, interval graphs behave the same way:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomIntervalGraph</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_even_hole_free</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>It is clear, though, that a random Bipartite Graph which is not a forest
has an even hole:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomBipartite</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">.5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_even_hole_free</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_forest</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We can check the certificate returned is indeed an even cycle:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_forest</span><span class="p">():</span>
<span class="gp">....: </span>   <span class="n">cycle</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_even_hole_free</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">....: </span>   <span class="k">if</span> <span class="n">cycle</span><span class="o">.</span><span class="n">order</span><span class="p">()</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">....: </span>       <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error !&quot;</span><span class="p">)</span>
<span class="gp">....: </span>   <span class="k">if</span> <span class="ow">not</span> <span class="n">cycle</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span>
<span class="gp">....: </span>          <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="n">cycle</span><span class="o">.</span><span class="n">order</span><span class="p">())):</span>
<span class="gp">....: </span>       <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error !&quot;</span><span class="p">)</span>
<span class="go">...</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Everything is Fine !&quot;</span><span class="p">)</span>
<span class="go">Everything is Fine !</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_forest">
<span class="sig-name descname"><span class="pre">is_forest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'vertex'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_forest" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests if the graph is a forest, i.e. a disjoint union of trees.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return a
certificate. The method only returns boolean answers when
<code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">False</span></code> (default). When it is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, it
either answers <code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">None)</span></code> when the graph is a forest or
<code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">cycle)</span></code> when it contains a cycle.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output</span></code> – either <code class="docutils literal notranslate"><span class="pre">'vertex'</span></code> (default) or <code class="docutils literal notranslate"><span class="pre">'edge'</span></code>; whether the
certificate is given as a list of vertices (<code class="docutils literal notranslate"><span class="pre">output</span> <span class="pre">=</span> <span class="pre">'vertex'</span></code>) or
a list of edges (<code class="docutils literal notranslate"><span class="pre">output</span> <span class="pre">=</span> <span class="pre">'edge'</span></code>).</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">seven_acre_wood</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">trees</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">Graph</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">seven_acre_wood</span><span class="o">.</span><span class="n">is_forest</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>With certificates:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomTree</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_forest</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(True, None)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">g</span> <span class="o">+</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span> <span class="o">+</span> <span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">is_forest</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(False, [68, 66, 69, 67, 65])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_half_transitive">
<span class="sig-name descname"><span class="pre">is_half_transitive</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_half_transitive" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if self is a half-transitive graph.</p>
<p>A graph is half-transitive if it is both vertex and edge transitive
but not arc-transitive.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/half-transitive_graph">Wikipedia article half-transitive_graph</a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.is_edge_transitive" title="sage.graphs.graph.Graph.is_edge_transitive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_edge_transitive()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.is_arc_transitive" title="sage.graphs.graph.Graph.is_arc_transitive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_arc_transitive()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.is_semi_symmetric" title="sage.graphs.graph.Graph.is_semi_symmetric"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_semi_symmetric()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>The Petersen Graph is not half-transitive:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_half_transitive</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The smallest half-transitive graph is the Holt Graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">HoltGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">is_half_transitive</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_inscribable">
<span class="sig-name descname"><span class="pre">is_inscribable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ppl'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_inscribable" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the graph is the graph of an inscribed polyhedron.</p>
<p>A polyhedron is inscribed if all of its vertices are on a sphere.
This is dual to the notion of circumscribed polyhedron: A Polyhedron is
inscribed if and only if its polar dual is circumscribed and hence a
graph is inscribable if and only if its planar dual is circumscribable.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">&quot;ppl&quot;</span></code>); specify a Linear Program (LP)
solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">HerschelGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">is_inscribable</span><span class="p">()</span>               <span class="c1"># long time (&gt; 1 sec)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">planar_dual</span><span class="p">()</span><span class="o">.</span><span class="n">is_inscribable</span><span class="p">()</span> <span class="c1"># long time (&gt; 1 sec)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">is_inscribable</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Cutting off a vertex from the cube yields an uninscribable graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">vertex_iterator</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">triangle</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span> <span class="o">+</span> <span class="n">v</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">C</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">Combinations</span><span class="p">(</span><span class="n">triangle</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">triangle</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">delete_vertex</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">is_inscribable</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Breaking a face of the cube yields an uninscribable graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">face</span> <span class="o">=</span> <span class="n">choice</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">faces</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">add_edge</span><span class="p">([</span><span class="n">face</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">face</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">is_inscribable</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.is_polyhedral" title="sage.graphs.graph.Graph.is_polyhedral"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_polyhedral()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.is_circumscribable" title="sage.graphs.graph.Graph.is_circumscribable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_circumscribable()</span></code></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_line_graph">
<span class="sig-name descname"><span class="pre">is_line_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_line_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the graph <span class="math notranslate nohighlight">\(g\)</span> is a line graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> (boolean) – whether to return a certificate along with
the boolean result. Here is what happens when <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></code>:</p>
<ul>
<li><p>If the graph is not a line graph, the method returns a pair <code class="docutils literal notranslate"><span class="pre">(b,</span>
<span class="pre">subgraph)</span></code> where <code class="docutils literal notranslate"><span class="pre">b</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> and <code class="docutils literal notranslate"><span class="pre">subgraph</span></code> is a subgraph
isomorphic to one of the 9 forbidden induced subgraphs of a line graph.</p></li>
<li><p>If the graph is a line graph, the method returns a triple <code class="docutils literal notranslate"><span class="pre">(b,R,isom)</span></code>
where <code class="docutils literal notranslate"><span class="pre">b</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">R</span></code> is a graph whose line graph is the graph
given as input, and <code class="docutils literal notranslate"><span class="pre">isom</span></code> is a map associating an edge of <code class="docutils literal notranslate"><span class="pre">R</span></code> to
each vertex of the graph.</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method wastes a bit of time when the input graph is not connected.
If you have performance in mind, it is probably better to only feed it
with connected graphs only.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p>The <a class="reference internal" href="line_graph.html#module-sage.graphs.line_graph" title="sage.graphs.line_graph"><code class="xref py py-mod docutils literal notranslate"><span class="pre">line_graph</span></code></a> module.</p></li>
<li><p><a class="reference internal" href="graph_generators.html#sage.graphs.graph_generators.GraphGenerators.line_graph_forbidden_subgraphs" title="sage.graphs.graph_generators.GraphGenerators.line_graph_forbidden_subgraphs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">line_graph_forbidden_subgraphs()</span></code></a>
– the forbidden subgraphs of a line graph.</p></li>
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.line_graph" title="sage.graphs.generic_graph.GenericGraph.line_graph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">line_graph()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>A complete graph is always the line graph of a star:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">is_line_graph</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Petersen Graph not being claw-free, it is not a line
graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">is_line_graph</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>This is indeed the subgraph returned:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">is_line_graph</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">ClawGraph</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The house graph is a line graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">HouseGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_line_graph</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>But what is the graph whose line graph is the house ?:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">is_line</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">isom</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_line_graph</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">sparse6_string</span><span class="p">()</span>
<span class="go">&#39;:DaHI~&#39;</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">isom</span>
<span class="go">{0: (0, 1), 1: (0, 2), 2: (1, 3), 3: (2, 3), 4: (3, 4)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_long_antihole_free">
<span class="sig-name descname"><span class="pre">is_long_antihole_free</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_long_antihole_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether the given graph contains an induced subgraph that is
isomorphic to the complement of a cycle of length at least 5.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<p>Whether to return a certificate. When <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></code>, then
the function returns</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">Antihole)</span></code> if <code class="docutils literal notranslate"><span class="pre">g</span></code> contains an induced complement
of a cycle of length at least 5 returned as <code class="docutils literal notranslate"><span class="pre">Antihole</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">[])</span></code> if <code class="docutils literal notranslate"><span class="pre">g</span></code> does not contain an induced complement of
a cycle of length at least 5.
For this case it is not known how to provide a certificate.</p></li>
</ul>
<p>When <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">False</span></code>, the function returns just <code class="docutils literal notranslate"><span class="pre">True</span></code> or
<code class="docutils literal notranslate"><span class="pre">False</span></code> accordingly.</p>
</li>
</ul>
<p>ALGORITHM:</p>
<p>This algorithm tries to find a cycle in the graph of all induced
<span class="math notranslate nohighlight">\(\overline{P_4}\)</span> of <span class="math notranslate nohighlight">\(g\)</span>, where two copies <span class="math notranslate nohighlight">\(\overline{P}\)</span> and <span class="math notranslate nohighlight">\(\overline{P'}\)</span>
of <span class="math notranslate nohighlight">\(\overline{P_4}\)</span> are adjacent if there exists a (not necessarily induced)
copy of <span class="math notranslate nohighlight">\(\overline{P_5}=u_1u_2u_3u_4u_5\)</span> such that
<span class="math notranslate nohighlight">\(\overline{P}=u_1u_2u_3u_4\)</span> and <span class="math notranslate nohighlight">\(\overline{P'}=u_2u_3u_4u_5\)</span>.</p>
<p>This is done through a depth-first-search. For efficiency, the auxiliary
graph is constructed on-the-fly and never stored in memory.</p>
<p>The run time of this algorithm is <span class="math notranslate nohighlight">\(O(m^2)\)</span> <a class="reference internal" href="../../../references/index.html#np2007" id="id47"><span>[NP2007]</span></a> (where
<span class="math notranslate nohighlight">\(m\)</span> is the number of edges of the graph).</p>
<p>EXAMPLES:</p>
<p>The Petersen Graph contains an antihole:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_long_antihole_free</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The complement of a cycle is an antihole:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">r</span><span class="p">,</span><span class="n">a</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_long_antihole_free</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">r</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_long_hole_free">
<span class="sig-name descname"><span class="pre">is_long_hole_free</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_long_hole_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether <code class="docutils literal notranslate"><span class="pre">g</span></code> contains an induced cycle of length at least 5.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<p>Whether to return a certificate. When <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></code>, then
the function returns</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">[])</span></code> if <code class="docutils literal notranslate"><span class="pre">g</span></code> does not contain such a cycle.
For this case, it is not known how to provide a certificate.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">Hole)</span></code> if <code class="docutils literal notranslate"><span class="pre">g</span></code> contains an induced cycle of length at
least 5. <code class="docutils literal notranslate"><span class="pre">Hole</span></code> returns this cycle.</p></li>
</ul>
<p>If <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">False</span></code>, the function returns just <code class="docutils literal notranslate"><span class="pre">True</span></code> or
<code class="docutils literal notranslate"><span class="pre">False</span></code> accordingly.</p>
</li>
</ul>
<p>ALGORITHM:</p>
<p>This algorithm tries to find a cycle in the graph of all induced <span class="math notranslate nohighlight">\(P_4\)</span> of
<span class="math notranslate nohighlight">\(g\)</span>, where two copies <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(P'\)</span> of <span class="math notranslate nohighlight">\(P_4\)</span> are adjacent if there exists a
(not necessarily induced) copy of <span class="math notranslate nohighlight">\(P_5=u_1u_2u_3u_4u_5\)</span> such that
<span class="math notranslate nohighlight">\(P=u_1u_2u_3u_4\)</span> and <span class="math notranslate nohighlight">\(P'=u_2u_3u_4u_5\)</span>.</p>
<p>This is done through a depth-first-search. For efficiency, the auxiliary
graph is constructed on-the-fly and never stored in memory.</p>
<p>The run time of this algorithm is <span class="math notranslate nohighlight">\(O(m^2)\)</span> <a class="reference internal" href="../../../references/index.html#np2007" id="id48"><span>[NP2007]</span></a> ( where
<span class="math notranslate nohighlight">\(m\)</span> is the number of edges of the graph ) .</p>
<p>EXAMPLES:</p>
<p>The Petersen Graph contains a hole:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_long_hole_free</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The following graph contains a hole, which we want to display:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">FlowerSnark</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">r</span><span class="p">,</span><span class="n">h</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_long_hole_free</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">r</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">order</span><span class="p">()))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_odd_hole_free">
<span class="sig-name descname"><span class="pre">is_odd_hole_free</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_odd_hole_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether <code class="docutils literal notranslate"><span class="pre">self</span></code> contains an induced odd hole.</p>
<p>A Hole is a cycle of length at least 4 (included). It is said to be even
(resp. odd) if its length is even (resp. odd).</p>
<p>It is interesting to notice that while it is polynomial to check whether
a graph has an odd hole or an odd antihole <a class="reference internal" href="../../../references/index.html#cclsv2005" id="id49"><span>[CCLSV2005]</span></a>, it is not known
whether testing for one of these two cases independently is polynomial
too.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); when <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span>
<span class="pre">False</span></code>, this method only returns <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>. If
<code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></code>, the subgraph found is returned instead of
<code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>Is the Petersen Graph odd-hole-free</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_odd_hole_free</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Which was to be expected, as its girth is 5</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">girth</span><span class="p">()</span>
<span class="go">5</span>
</pre></div>
</div>
<p>We can check the certificate returned is indeed a 5-cycle:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cycle</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_odd_hole_free</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">cycle</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>As any chordal graph is hole-free, no interval graph has an odd hole:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomIntervalGraph</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_odd_hole_free</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_overfull">
<span class="sig-name descname"><span class="pre">is_overfull</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_overfull" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether the current graph is overfull.</p>
<p>A graph <span class="math notranslate nohighlight">\(G\)</span> on <span class="math notranslate nohighlight">\(n\)</span> vertices and <span class="math notranslate nohighlight">\(m\)</span> edges is said to be overfull if:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(n\)</span> is odd</p></li>
<li><p>It satisfies <span class="math notranslate nohighlight">\(2m &gt; (n-1)\Delta(G)\)</span>, where <span class="math notranslate nohighlight">\(\Delta(G)\)</span> denotes the
maximum degree among all vertices in <span class="math notranslate nohighlight">\(G\)</span>.</p></li>
</ul>
<p>An overfull graph must have a chromatic index of <span class="math notranslate nohighlight">\(\Delta(G)+1\)</span>.</p>
<p>EXAMPLES:</p>
<p>A complete graph of order <span class="math notranslate nohighlight">\(n &gt; 1\)</span> is overfull if and only if <span class="math notranslate nohighlight">\(n\)</span> is
odd:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The claw graph is not overfull:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_coloring</span> <span class="kn">import</span> <span class="n">edge_coloring</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">ClawGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span>
<span class="go">Claw graph: Graph on 4 vertices</span>
<span class="gp">sage: </span><span class="n">edge_coloring</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">value_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The Holt graph is an example of a overfull graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">HoltGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Checking that all complete graphs <span class="math notranslate nohighlight">\(K_n\)</span> for even <span class="math notranslate nohighlight">\(0 \leq n \leq 100\)</span>
are not overfull:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">check_overfull_Kn_even</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">....: </span>    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">():</span>
<span class="gp">....: </span>            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A complete graph of even order cannot be overfull.&quot;</span><span class="p">)</span>
<span class="gp">....: </span>            <span class="k">return</span>
<span class="gp">....: </span>        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Complete graphs of even order up to </span><span class="si">%s</span><span class="s2"> are not overfull.&quot;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
<span class="go">...</span>
<span class="gp">sage: </span><span class="n">check_overfull_Kn_even</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>  <span class="c1"># long time</span>
<span class="go">Complete graphs of even order up to 100 are not overfull.</span>
</pre></div>
</div>
<p>The null graph, i.e. the graph with no vertices, is not overfull:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Checking that all complete graphs <span class="math notranslate nohighlight">\(K_n\)</span> for odd <span class="math notranslate nohighlight">\(1 &lt; n \leq 100\)</span>
are overfull:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">check_overfull_Kn_odd</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">....: </span>    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="ow">not</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">():</span>
<span class="gp">....: </span>            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A complete graph of odd order &gt; 1 must be overfull.&quot;</span><span class="p">)</span>
<span class="gp">....: </span>            <span class="k">return</span>
<span class="gp">....: </span>        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Complete graphs of odd order &gt; 1 up to </span><span class="si">%s</span><span class="s2"> are overfull.&quot;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
<span class="go">...</span>
<span class="gp">sage: </span><span class="n">check_overfull_Kn_odd</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>  <span class="c1"># long time</span>
<span class="go">Complete graphs of odd order &gt; 1 up to 100 are overfull.</span>
</pre></div>
</div>
<p>The Petersen Graph, though, is not overfull while
its chromatic index is <span class="math notranslate nohighlight">\(\Delta+1\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_coloring</span> <span class="kn">import</span> <span class="n">edge_coloring</span>
<span class="gp">sage: </span><span class="nb">max</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">degree</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span>  <span class="n">edge_coloring</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">value_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_partial_cube">
<span class="sig-name descname"><span class="pre">is_partial_cube</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_partial_cube" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the given graph is a partial cube.</p>
<p>A partial cube is a graph that can be isometrically embedded into a
hypercube, i.e., its vertices can be labelled with (0,1)-vectors of some
fixed length such that the distance between any two vertices in the graph
equals the Hamming distance of their labels.</p>
<p>Originally written by D. Eppstein for the PADS library
(<a class="reference external" href="http://www.ics.uci.edu/~eppstein/PADS/">http://www.ics.uci.edu/~eppstein/PADS/</a>), see also
<a class="reference internal" href="../../../references/index.html#epp2008" id="id50"><span>[Epp2008]</span></a>.  The algorithm runs in <span class="math notranslate nohighlight">\(O(n^2)\)</span> time, where <span class="math notranslate nohighlight">\(n\)</span>
is the number of vertices. See the documentation of
<a class="reference internal" href="partial_cube.html#module-sage.graphs.partial_cube" title="sage.graphs.partial_cube"><code class="xref py py-mod docutils literal notranslate"><span class="pre">partial_cube</span></code></a> for an overview of the algorithm.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); this function returns
<code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code> according to the graph, when <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span>
<span class="pre">False</span></code>. When <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></code> and the graph is a partial cube, the
function returns <code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">mapping)</span></code>, where <code class="docutils literal notranslate"><span class="pre">mapping</span></code> is an isometric
mapping of the vertices of the graph to the vertices of a hypercube
((0, 1)-strings of a fixed length). When <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></code> and the
graph is not a partial cube, <code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">None)</span></code> is returned.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>The Petersen graph is not a partial cube:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_partial_cube</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>All prisms are partial cubes:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_partial_cube</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_path">
<span class="sig-name descname"><span class="pre">is_path</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether <code class="docutils literal notranslate"><span class="pre">self</span></code> is a path.</p>
<p>A connected graph of order <span class="math notranslate nohighlight">\(n \geq 2\)</span> is a path if it is a tree
(see <a class="reference internal" href="#sage.graphs.graph.Graph.is_tree" title="sage.graphs.graph.Graph.is_tree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_tree()</span></code></a>) with <span class="math notranslate nohighlight">\(n-2\)</span> vertices of degree 2 and two of
degree 1. By convention, a graph of order 1 without loops is a path,
but the empty graph is not a path.</p>
<p>EXAMPLES:</p>
<blockquote>
<div><p>sage: G = graphs.PathGraph(5)
sage: G.is_path()
True
sage: H = graphs.CycleGraph(5)
sage: H.is_path()
False
sage: D = graphs.PathGraph(5).disjoint_union(graphs.CycleGraph(5))
sage: D.is_path()
False
sage: E = graphs.EmptyGraph()
sage: E.is_path()
False
sage: O = Graph([[1], []])
sage: O.is_path()
True
sage: O.allow_loops(True)
sage: O.add_edge(1, 1)
sage: O.is_path()
False</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_perfect">
<span class="sig-name descname"><span class="pre">is_perfect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_perfect" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether the graph is perfect.</p>
<p>A graph <span class="math notranslate nohighlight">\(G\)</span> is said to be perfect if <span class="math notranslate nohighlight">\(\chi(H)=\omega(H)\)</span> hold for any
induced subgraph <span class="math notranslate nohighlight">\(H\subseteq_i G\)</span> (and so for <span class="math notranslate nohighlight">\(G\)</span> itself, too), where
<span class="math notranslate nohighlight">\(\chi(H)\)</span> represents the chromatic number of <span class="math notranslate nohighlight">\(H\)</span>, and <span class="math notranslate nohighlight">\(\omega(H)\)</span> its
clique number. The Strong Perfect Graph Theorem <a class="reference internal" href="../../../references/index.html#crst2006" id="id51"><span>[CRST2006]</span></a> gives
another characterization of perfect graphs:</p>
<p>A graph is perfect if and only if it contains no odd hole (cycle on an
odd number <span class="math notranslate nohighlight">\(k\)</span> of vertices, <span class="math notranslate nohighlight">\(k&gt;3\)</span>) nor any odd antihole (complement of a
hole) as an induced subgraph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return a
certificate.</p></li>
</ul>
<p>OUTPUT:</p>
<p>When <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">False</span></code>, this function returns a boolean
value. When <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></code>, it returns a subgraph of <code class="docutils literal notranslate"><span class="pre">self</span></code>
isomorphic to an odd hole or an odd antihole if any, and <code class="docutils literal notranslate"><span class="pre">None</span></code>
otherwise.</p>
<p>EXAMPLES:</p>
<p>A Bipartite Graph is always perfect</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomBipartite</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mf">.5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_perfect</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>So is the line graph of a bipartite graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomBipartite</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mf">0.7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">line_graph</span><span class="p">()</span><span class="o">.</span><span class="n">is_perfect</span><span class="p">()</span> <span class="c1"># long time</span>
<span class="go">True</span>
</pre></div>
</div>
<p>As well as the Cartesian product of two complete graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_perfect</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Interval Graphs, which are chordal graphs, too</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span>  <span class="n">graphs</span><span class="o">.</span><span class="n">RandomIntervalGraph</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_perfect</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The PetersenGraph, which is triangle-free and has chromatic number 3 is
obviously not perfect:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_perfect</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We can obtain an induced 5-cycle as a certificate:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_perfect</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Subgraph of (Petersen graph): Graph on 5 vertices</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_permutation">
<span class="sig-name descname"><span class="pre">is_permutation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'greedy'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_permutation" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether the graph is a permutation graph.</p>
<p>For more information on permutation graphs, refer to the documentation of
the <a class="reference internal" href="comparability.html#module-sage.graphs.comparability" title="sage.graphs.comparability"><code class="xref py py-mod docutils literal notranslate"><span class="pre">comparability</span> <span class="pre">module</span></code></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – choose the implementation used for the subcalls to
<a class="reference internal" href="#sage.graphs.graph.Graph.is_comparability" title="sage.graphs.graph.Graph.is_comparability"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_comparability()</span></code></a>.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;greedy&quot;</span></code> – a greedy algorithm (see the documentation of the
<a class="reference internal" href="comparability.html#module-sage.graphs.comparability" title="sage.graphs.comparability"><code class="xref py py-mod docutils literal notranslate"><span class="pre">comparability</span> <span class="pre">module</span></code></a>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;MILP&quot;</span></code> – a Mixed Integer Linear Program formulation of the
problem. Beware, for this implementation is unable to return negative
certificates ! When <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></code>, negative certificates are
always equal to <code class="docutils literal notranslate"><span class="pre">None</span></code>. True certificates are valid, though.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> (boolean) – whether to return a certificate for the
answer given. For <code class="docutils literal notranslate"><span class="pre">True</span></code> answers the certificate is a permutation, for
<code class="docutils literal notranslate"><span class="pre">False</span></code> answers it is a no-certificate for the test of comparability or
co-comparability.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> (boolean) – whether to check that the permutations returned
indeed create the expected Permutation graph. Pretty cheap compared to the
rest, hence a good investment. It is enabled by default.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); Specify a Linear Program (LP) solver to
be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For more information
on LP solvers and which default solver is used, see the method
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve()</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of verbosity. Set
to 0 by default, which means quiet.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As the <code class="docutils literal notranslate"><span class="pre">True</span></code> certificate is a <a class="reference external" href="../../../combinat/sage/combinat/permutation.html#sage.combinat.permutation.Permutation" title="(in Sage 9.5 Reference Manual: Combinatorics v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Permutation</span></code></a> object, the
segment intersection model of the permutation graph can be visualized
through a call to <a class="reference external" href="../../../combinat/sage/combinat/permutation.html#sage.combinat.permutation.Permutation.show" title="(in Sage 9.5 Reference Manual: Combinatorics v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Permutation.show</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<p>A permutation realizing the bull graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.comparability</span> <span class="kn">import</span> <span class="n">is_permutation</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">BullGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">_</span> <span class="p">,</span> <span class="n">certif</span> <span class="o">=</span> <span class="n">is_permutation</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PermutationGraph</span><span class="p">(</span><span class="o">*</span><span class="n">certif</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Plotting the realization as an intersection graph of segments:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">true</span><span class="p">,</span> <span class="n">perm</span> <span class="o">=</span> <span class="n">is_permutation</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p1</span> <span class="o">=</span> <span class="n">Permutation</span><span class="p">([</span><span class="n">nn</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">perm</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">p2</span> <span class="o">=</span> <span class="n">Permutation</span><span class="p">([</span><span class="n">nn</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">perm</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">p2</span> <span class="o">*</span> <span class="n">p1</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">representation</span> <span class="o">=</span> <span class="s2">&quot;braid&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_polyhedral">
<span class="sig-name descname"><span class="pre">is_polyhedral</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_polyhedral" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the graph is the graph of the polyhedron.</p>
<p>By a theorem of Steinitz (Satz 43, p. 77 of <a class="reference internal" href="../../../references/index.html#st1922" id="id52"><span>[St1922]</span></a>), graphs of
three-dimensional polyhedra are exactly the simple 3-vertex-connected
planar graphs.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">is_polyhedral</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">K33</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K33</span><span class="o">.</span><span class="n">is_polyhedral</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span><span class="o">.</span><span class="n">is_polyhedral</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="k">if</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">is_polyhedral</span><span class="p">()]</span>
<span class="go">[4]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.vertex_connectivity" title="sage.graphs.generic_graph.GenericGraph.vertex_connectivity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertex_connectivity()</span></code></a></p></li>
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.is_planar" title="sage.graphs.generic_graph.GenericGraph.is_planar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_planar()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.is_circumscribable" title="sage.graphs.graph.Graph.is_circumscribable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_circumscribable()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.is_inscribable" title="sage.graphs.graph.Graph.is_inscribable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_inscribable()</span></code></a></p></li>
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Polyhedral_graph">Wikipedia article Polyhedral_graph</a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_prime">
<span class="sig-name descname"><span class="pre">is_prime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'habib'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_prime" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the current graph is prime.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'tedder'</span></code>) specifies the algorithm to
use among:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'tedder'</span></code> – Use the linear algorithm of <a class="reference internal" href="../../../references/index.html#tchp2008" id="id53"><span>[TCHP2008]</span></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'habib'</span></code> – Use the $O(n^3)$ algorithm of <a class="reference internal" href="../../../references/index.html#hm1979" id="id54"><span>[HM1979]</span></a>. This is
probably slower, but is much simpler and so possibly less error
prone.</p></li>
</ul>
</li>
</ul>
<p>A graph is prime if all its modules are trivial (i.e. empty, all of the
graph or singletons) – see <a class="reference internal" href="#sage.graphs.graph.Graph.modular_decomposition" title="sage.graphs.graph.Graph.modular_decomposition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">modular_decomposition()</span></code></a>.</p>
<p>EXAMPLES:</p>
<p>The Petersen Graph and the Bull Graph are both prime:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">is_prime</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">BullGraph</span><span class="p">()</span><span class="o">.</span><span class="n">is_prime</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Though quite obviously, the disjoint union of them is not:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span> <span class="o">+</span> <span class="n">graphs</span><span class="o">.</span><span class="n">BullGraph</span><span class="p">())</span><span class="o">.</span><span class="n">is_prime</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_redundant">
<span class="sig-name descname"><span class="pre">is_redundant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">focus</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_redundant" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether <code class="docutils literal notranslate"><span class="pre">dom</span></code> has redundant vertices.</p>
<p>For a graph <span class="math notranslate nohighlight">\(G\)</span> and sets <span class="math notranslate nohighlight">\(D\)</span> and <span class="math notranslate nohighlight">\(S\)</span> of vertices, we say that a vertex <span class="math notranslate nohighlight">\(v
\in D\)</span> is <em>redundant</em> in <span class="math notranslate nohighlight">\(S\)</span> if <span class="math notranslate nohighlight">\(v\)</span> has no private neighbor with respect to
<span class="math notranslate nohighlight">\(D\)</span> in <span class="math notranslate nohighlight">\(S\)</span>.  In other words, there is no vertex in <span class="math notranslate nohighlight">\(S\)</span> that is dominated by
<span class="math notranslate nohighlight">\(v\)</span> but not by <span class="math notranslate nohighlight">\(D \setminus \{v\}\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dom</span></code> – iterable of vertices of <code class="docutils literal notranslate"><span class="pre">G</span></code>; where we look for redundant
vertices.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">focus</span></code> – iterable of vertices of <code class="docutils literal notranslate"><span class="pre">G</span></code> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); if
specified, this method checks instead whether <code class="docutils literal notranslate"><span class="pre">dom</span></code> has a redundant
vertex in <code class="docutils literal notranslate"><span class="pre">focus</span></code>.</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The assumption is made that <code class="docutils literal notranslate"><span class="pre">focus</span></code> (if provided) does not contain
repeated vertices.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_redundant</span><span class="p">([</span><span class="s1">&#39;000&#39;</span><span class="p">,</span> <span class="s1">&#39;101&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;011&#39;</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_redundant</span><span class="p">([</span><span class="s1">&#39;000&#39;</span><span class="p">,</span> <span class="s1">&#39;101&#39;</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_semi_symmetric">
<span class="sig-name descname"><span class="pre">is_semi_symmetric</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_semi_symmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if self is semi-symmetric.</p>
<p>A graph is semi-symmetric if it is regular, edge-transitive but not
vertex-transitive.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Semi-symmetric_graph">Wikipedia article Semi-symmetric_graph</a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.is_edge_transitive" title="sage.graphs.graph.Graph.is_edge_transitive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_edge_transitive()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.is_arc_transitive" title="sage.graphs.graph.Graph.is_arc_transitive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_arc_transitive()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.is_half_transitive" title="sage.graphs.graph.Graph.is_half_transitive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_half_transitive()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>The Petersen graph is not semi-symmetric:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_semi_symmetric</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The Gray graph is the smallest possible cubic semi-symmetric graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">GrayGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_semi_symmetric</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Another well known semi-symmetric graph is the Ljubljana graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">LjubljanaGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">is_semi_symmetric</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_split">
<span class="sig-name descname"><span class="pre">is_split</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_split" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the graph is a Split graph, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>A Graph <span class="math notranslate nohighlight">\(G\)</span> is said to be a split graph if its vertices <span class="math notranslate nohighlight">\(V(G)\)</span> can be
partitioned into two sets <span class="math notranslate nohighlight">\(K\)</span> and <span class="math notranslate nohighlight">\(I\)</span> such that the vertices of <span class="math notranslate nohighlight">\(K\)</span>
induce a complete graph, and those of <span class="math notranslate nohighlight">\(I\)</span> are an independent set.</p>
<p>There is a simple test to check whether a graph is a split graph (see,
for instance, the book “Graph Classes, a survey” <a class="reference internal" href="../../../references/index.html#bls1999" id="id55"><span>[BLS1999]</span></a> page
203) :</p>
<p>Given the degree sequence <span class="math notranslate nohighlight">\(d_1 \geq ... \geq d_n\)</span> of <span class="math notranslate nohighlight">\(G\)</span>, a graph is a
split graph if and only if :</p>
<div class="math notranslate nohighlight">
\[\sum_{i=1}^\omega d_i = \omega (\omega - 1) + \sum_{i=\omega + 1}^nd_i\]</div>
<p>where <span class="math notranslate nohighlight">\(\omega = max \{i:d_i\geq i-1\}\)</span>.</p>
<p>EXAMPLES:</p>
<p>Split graphs are, in particular, chordal graphs. Hence, The Petersen
graph can not be split:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">is_split</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We can easily build some “random” split graph by creating a complete
graph, and adding vertices only connected to some random vertices of the
clique:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sets</span> <span class="o">=</span> <span class="n">Subsets</span><span class="p">(</span><span class="n">Set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">25</span><span class="p">):</span>
<span class="gp">....: </span>   <span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sets</span><span class="o">.</span><span class="n">random_element</span><span class="p">()])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_split</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Another characterisation of split graph states that a graph is a split
graph if and only if does not contain the 4-cycle, 5-cycle or <span class="math notranslate nohighlight">\(2K_2\)</span> as
an induced subgraph. Hence for the above graph we have:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">forbidden_subgraphs</span> <span class="o">=</span> <span class="p">[</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="nb">sum</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">subgraph_search_count</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">induced</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">H</span> <span class="ow">in</span> <span class="n">forbidden_subgraphs</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_strongly_regular">
<span class="sig-name descname"><span class="pre">is_strongly_regular</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_strongly_regular" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the graph is strongly regular.</p>
<p>A simple graph <span class="math notranslate nohighlight">\(G\)</span> is said to be strongly regular with parameters
<span class="math notranslate nohighlight">\((n, k, \lambda, \mu)\)</span> if and only if:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(G\)</span> has <span class="math notranslate nohighlight">\(n\)</span> vertices</p></li>
<li><p><span class="math notranslate nohighlight">\(G\)</span> is <span class="math notranslate nohighlight">\(k\)</span>-regular</p></li>
<li><p>Any two adjacent vertices of <span class="math notranslate nohighlight">\(G\)</span> have <span class="math notranslate nohighlight">\(\lambda\)</span> common neighbors</p></li>
<li><p>Any two non-adjacent vertices of <span class="math notranslate nohighlight">\(G\)</span> have <span class="math notranslate nohighlight">\(\mu\)</span> common neighbors</p></li>
</ul>
<p>By convention, the complete graphs, the graphs with no edges and the empty
graph are not strongly regular.</p>
<p>See the <a class="reference external" href="https://en.wikipedia.org/wiki/Strongly regular graph">Wikipedia article Strongly regular graph</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">parameters</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
quadruple <span class="math notranslate nohighlight">\((n, k, \lambda, \mu)\)</span>. If <code class="docutils literal notranslate"><span class="pre">parameters</span> <span class="pre">=</span> <span class="pre">False</span></code> (default),
this method only returns <code class="docutils literal notranslate"><span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">False</span></code> answers.
If <code class="docutils literal notranslate"><span class="pre">parameters</span> <span class="pre">=</span> <span class="pre">True</span></code>, the <code class="docutils literal notranslate"><span class="pre">True</span></code> answers are replaced by quadruples
<span class="math notranslate nohighlight">\((n, k, \lambda, \mu)\)</span>. See definition above.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>Petersen’s graph is strongly regular:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(10, 3, 0, 1)</span>
</pre></div>
</div>
<p>And Clebsch’s graph is too:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">ClebschGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(16, 5, 0, 2)</span>
</pre></div>
</div>
<p>But Chvatal’s graph is not:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Complete graphs are not strongly regular. (<a class="reference external" href="https://trac.sagemath.org/14297">trac ticket #14297</a>)</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Completements of complete graphs are not strongly regular:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The empty graph is not strongly regular:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">EmptyGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>If the input graph has loops or multiedges an exception is raised:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span><span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: This method is not known to work on graphs with</span>
<span class="go">loops. Perhaps this method can be updated to handle them, but in the</span>
<span class="go">meantime if you want to use it please disallow loops using</span>
<span class="go">allow_loops().</span>

<span class="gp">sage: </span><span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: This method is not known to work on graphs with</span>
<span class="go">multiedges. Perhaps this method can be updated to handle them, but in</span>
<span class="go">the meantime if you want to use it please disallow multiedges using</span>
<span class="go">allow_multiple_edges().</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_tree">
<span class="sig-name descname"><span class="pre">is_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'vertex'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests if the graph is a tree</p>
<p>The empty graph is defined to be not a tree.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return a
certificate. The method only returns boolean answers when
<code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">False</span></code> (default). When it is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, it
either answers <code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">None)</span></code> when the graph is a tree or <code class="docutils literal notranslate"><span class="pre">(False,</span>
<span class="pre">cycle)</span></code> when it contains a cycle. It returns <code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">None)</span></code> when
the graph is empty or not connected.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output</span></code> – either <code class="docutils literal notranslate"><span class="pre">'vertex'</span></code> (default) or <code class="docutils literal notranslate"><span class="pre">'edge'</span></code>; whether the
certificate is given as a list of vertices (<code class="docutils literal notranslate"><span class="pre">output</span> <span class="pre">=</span> <span class="pre">'vertex'</span></code>) or
a list of edges (<code class="docutils literal notranslate"><span class="pre">output</span> <span class="pre">=</span> <span class="pre">'edge'</span></code>).</p></li>
</ul>
<p>When the certificate cycle is given as a list of edges, the edges are
given as <span class="math notranslate nohighlight">\((v_i, v_{i+1}, l)\)</span> where <span class="math notranslate nohighlight">\(v_1, v_2, \dots, v_n\)</span> are the
vertices of the cycles (in their cyclic order).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">is_tree</span><span class="p">()</span> <span class="k">for</span> <span class="n">T</span> <span class="ow">in</span> <span class="n">graphs</span><span class="o">.</span><span class="n">trees</span><span class="p">(</span><span class="mi">15</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>With certificates:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomTree</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_tree</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(True, None)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">isit</span><span class="p">,</span> <span class="n">cycle</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_tree</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">isit</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">cycle</span>
<span class="go">True</span>
</pre></div>
</div>
<p>One can also ask for the certificate as a list of edges:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_tree</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)</span>
<span class="go">(False, [(3, 2, None), (2, 1, None), (1, 0, None), (0, 3, None)])</span>
</pre></div>
</div>
<p>This is useful for graphs with multiple edges:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)],</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_tree</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(False, [1, 2])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_tree</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)</span>
<span class="go">(False, [(1, 2, &#39;a&#39;), (2, 1, &#39;b&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_triangle_free">
<span class="sig-name descname"><span class="pre">is_triangle_free</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dense_graph'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_triangle_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether <code class="docutils literal notranslate"><span class="pre">self</span></code> is triangle-free</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'dense_graph'</span></code>) specifies the algorithm
to use among:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'matrix'</span></code> – tests if the trace of the adjacency matrix is
positive.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'bitset'</span></code> – encodes adjacencies into bitsets and uses fast
bitset operations to test if the input graph contains a
triangle. This method is generally faster than standard matrix
multiplication.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'dense_graph'</span></code> – use the implementation of
<a class="reference internal" href="base/static_dense_graph.html#module-sage.graphs.base.static_dense_graph" title="sage.graphs.base.static_dense_graph"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.graphs.base.static_dense_graph</span></code></a></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return a
triangle if one is found. This parameter is ignored when <code class="docutils literal notranslate"><span class="pre">algorithm</span></code>
is <code class="docutils literal notranslate"><span class="pre">'matrix'</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>The Petersen Graph is triangle-free:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_triangle_free</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>or a complete Bipartite Graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_triangle_free</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;matrix&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_triangle_free</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;bitset&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_triangle_free</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;dense_graph&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>a tripartite graph, though, contains many triangles:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_triangle_free</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;matrix&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_triangle_free</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;bitset&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_triangle_free</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;dense_graph&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Asking for a certificate:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K4</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K4</span><span class="o">.</span><span class="n">is_triangle_free</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;dense_graph&#39;</span><span class="p">,</span> <span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(False, [0, 1, 2])</span>
<span class="gp">sage: </span><span class="n">K4</span><span class="o">.</span><span class="n">is_triangle_free</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;bitset&#39;</span><span class="p">,</span> <span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(False, [0, 1, 2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_triconnected">
<span class="sig-name descname"><span class="pre">is_triconnected</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_triconnected" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the graph is triconnected.</p>
<p>A triconnected graph is a connected graph on 3 or more vertices that is not
broken into disconnected pieces by deleting any pair of vertices.</p>
<p>EXAMPLES:</p>
<p>The Petersen graph is triconnected:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_triconnected</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>But a 2D grid is not:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_triconnected</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>By convention, a cycle of order 3 is triconnected:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_triconnected</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>But cycles of order 4 and more are not:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">is_triconnected</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">)]</span>
<span class="go">[False, False, False, False]</span>
</pre></div>
</div>
<p>Comparing different methods on random graphs that are not always
triconnected:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomBarabasiAlbert</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_triconnected</span><span class="p">()</span> <span class="o">==</span> <span class="n">G</span><span class="o">.</span><span class="n">vertex_connectivity</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.is_connected" title="sage.graphs.generic_graph.GenericGraph.is_connected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_connected()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.is_biconnected" title="sage.graphs.graph.Graph.is_biconnected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_biconnected()</span></code></a></p></li>
<li><p><a class="reference internal" href="connectivity.html#sage.graphs.connectivity.spqr_tree" title="sage.graphs.connectivity.spqr_tree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spqr_tree()</span></code></a></p></li>
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/SPQR_tree">Wikipedia article SPQR_tree</a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.is_weakly_chordal">
<span class="sig-name descname"><span class="pre">is_weakly_chordal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_weakly_chordal" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether the given graph is weakly chordal, i.e., the graph and its
complement have no induced cycle of length at least 5.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – Boolean value (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) whether to
return a certificate. If <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">False</span></code>, return <code class="docutils literal notranslate"><span class="pre">True</span></code> or
<code class="docutils literal notranslate"><span class="pre">False</span></code> according to the graph. If <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></code>, return</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">forbidden_subgraph)</span></code> when the graph contains a
forbidden subgraph H, this graph is returned.</p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">[])</span></code> when the graph is weakly chordal.</dt><dd><p>For this case, it is not known how to provide a certificate.</p>
</dd>
</dl>
</li>
</ul>
</li>
</ul>
<p>ALGORITHM:</p>
<p>This algorithm checks whether the graph <code class="docutils literal notranslate"><span class="pre">g</span></code> or its complement
contain an induced cycle of length at least 5.</p>
<p>Using is_long_hole_free() and is_long_antihole_free() yields a run time
of <span class="math notranslate nohighlight">\(O(m^2)\)</span> (where <span class="math notranslate nohighlight">\(m\)</span> is the number of edges of the graph).</p>
<p>EXAMPLES:</p>
<p>The Petersen Graph is not weakly chordal and contains a hole:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">r</span><span class="p">,</span><span class="n">s</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_weakly_chordal</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">r</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.join">
<span class="sig-name descname"><span class="pre">join</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pairs'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">immutable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the join of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">labels</span></code> – (defaults to ‘pairs’); if set to ‘pairs’, each element
<span class="math notranslate nohighlight">\(v\)</span> in the first graph will be named <span class="math notranslate nohighlight">\((0, v)\)</span> and each element <span class="math notranslate nohighlight">\(u\)</span> in
<code class="docutils literal notranslate"><span class="pre">other</span></code> will be named <span class="math notranslate nohighlight">\((1, u)\)</span> in the result. If set to ‘integers’,
the elements of the result will be relabeled with consecutive
integers.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">immutable</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); whether to create a
mutable/immutable join. <code class="docutils literal notranslate"><span class="pre">immutable=None</span></code> (default) means that the
graphs and their join will behave the same way.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.union" title="sage.graphs.generic_graph.GenericGraph.union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">union()</span></code></a></p></li>
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.disjoint_union" title="sage.graphs.generic_graph.GenericGraph.disjoint_union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">disjoint_union()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">H</span><span class="p">);</span> <span class="n">J</span>
<span class="go">Cycle graph join : Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1)]</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="s1">&#39;integers&#39;</span><span class="p">);</span> <span class="n">J</span>
<span class="go">Cycle graph join : Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4]</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None), (0, 2, None), (0, 3, None), (0, 4, None), (1, 2, None), (1, 3, None), (1, 4, None), (2, 3, None), (2, 4, None)]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">name</span><span class="p">(</span><span class="s2">&quot;Graph on 3 vertices&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">name</span><span class="p">(</span><span class="s2">&quot;Graph on 2 vertices&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">H</span><span class="p">);</span> <span class="n">J</span>
<span class="go">Graph on 3 vertices join Graph on 2 vertices: Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1)]</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="s1">&#39;integers&#39;</span><span class="p">);</span> <span class="n">J</span>
<span class="go">Graph on 3 vertices join Graph on 2 vertices: Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 3, None), (0, 4, None), (1, 3, None), (1, 4, None), (2, 3, None), (2, 4, None)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.kirchhoff_symanzik_polynomial">
<span class="sig-name descname"><span class="pre">kirchhoff_symanzik_polynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'t'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.kirchhoff_symanzik_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Kirchhoff-Symanzik polynomial of a graph.</p>
<p>This is a polynomial in variables <span class="math notranslate nohighlight">\(t_e\)</span> (each of them representing an
edge of the graph <span class="math notranslate nohighlight">\(G\)</span>) defined as a sum over all spanning trees:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\Psi_G(t) = \sum_{\substack{T\subseteq V \\ \text{a spanning tree}}} \prod_{e \not\in E(T)} t_e\end{split}\]</div>
<p>This is also called the first Symanzik polynomial or the Kirchhoff
polynomial.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code> – name of the variables (default: <code class="docutils literal notranslate"><span class="pre">'t'</span></code>)</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>a polynomial with integer coefficients</p></li>
</ul>
<p>ALGORITHM:</p>
<blockquote>
<div><p>This is computed here using a determinant, as explained in Section
3.1 of <a class="reference internal" href="../../../references/index.html#mar2009a" id="id56"><span>[Mar2009a]</span></a>.</p>
<p>As an intermediate step, one computes a cycle basis <span class="math notranslate nohighlight">\(\mathcal C\)</span> of
<span class="math notranslate nohighlight">\(G\)</span> and a rectangular <span class="math notranslate nohighlight">\(|\mathcal C| \times |E(G)|\)</span> matrix with
entries in <span class="math notranslate nohighlight">\(\{-1,0,1\}\)</span>, which describes which edge belong to which
cycle of <span class="math notranslate nohighlight">\(\mathcal C\)</span> and their respective orientations.</p>
<p>More precisely, after fixing an arbitrary orientation for each edge
<span class="math notranslate nohighlight">\(e\in E(G)\)</span> and each cycle <span class="math notranslate nohighlight">\(C\in\mathcal C\)</span>, one gets a sign for
every incident pair (edge, cycle) which is <span class="math notranslate nohighlight">\(1\)</span> if the orientation
coincide and <span class="math notranslate nohighlight">\(-1\)</span> otherwise.</p>
</div></blockquote>
<p>EXAMPLES:</p>
<p>For the cycle of length 5:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">kirchhoff_symanzik_polynomial</span><span class="p">()</span>
<span class="go">t0 + t1 + t2 + t3 + t4</span>
</pre></div>
</div>
<p>One can use another letter for variables:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">kirchhoff_symanzik_polynomial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
<span class="go">u0 + u1 + u2 + u3 + u4</span>
</pre></div>
</div>
<p>For the ‘coffee bean’ graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">)],</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">kirchhoff_symanzik_polynomial</span><span class="p">()</span>
<span class="go">t0*t1 + t0*t2 + t1*t2</span>
</pre></div>
</div>
<p>For the ‘parachute’ graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">)],</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">kirchhoff_symanzik_polynomial</span><span class="p">()</span>
<span class="go">t0*t1 + t0*t2 + t1*t2 + t1*t3 + t2*t3</span>
</pre></div>
</div>
<p>For the complete graph with 4 vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">kirchhoff_symanzik_polynomial</span><span class="p">()</span>
<span class="go">t0*t1*t3 + t0*t2*t3 + t1*t2*t3 + t0*t1*t4 + t0*t2*t4 + t1*t2*t4</span>
<span class="go">+ t1*t3*t4 + t2*t3*t4 + t0*t1*t5 + t0*t2*t5 + t1*t2*t5 + t0*t3*t5</span>
<span class="go">+ t2*t3*t5 + t0*t4*t5 + t1*t4*t5 + t3*t4*t5</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<p><a class="reference internal" href="../../../references/index.html#bro2011" id="id57"><span>[Bro2011]</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.least_effective_resistance">
<span class="sig-name descname"><span class="pre">least_effective_resistance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nonedgesonly</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.least_effective_resistance" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of pairs of nodes with the least effective resistance.</p>
<p>The resistance distance between vertices <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> of a simple
connected graph <span class="math notranslate nohighlight">\(G\)</span> is defined as the effective resistance between the
two vertices on an electrical network constructed from <span class="math notranslate nohighlight">\(G\)</span> replacing
each edge of the graph by a unit (1 ohm) resistor.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nonedgesonly</span></code> – Boolean (default: <span class="math notranslate nohighlight">\(True\)</span>); if true, assign zero
resistance to pairs of adjacent vertices</p></li>
</ul>
<p>OUTPUT: list</p>
<p>EXAMPLES:</p>
<p>Pairs of non-adjacent nodes with least effective resistance in a
straight linear 2-tree on 6 vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">least_effective_resistance</span><span class="p">()</span>
<span class="go">[(1, 4)]</span>
</pre></div>
</div>
<p>Pairs of (adjacent or non-adjacent) nodes with least effective
resistance in a straight linear 2-tree on 6 vertices</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">least_effective_resistance</span><span class="p">(</span><span class="n">nonedgesonly</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">[(2, 3)]</span>
</pre></div>
</div>
<p>Pairs of non-adjacent nodes with least effective resistance in a fan on
6 vertices counting only non-adjacent vertex pairs</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">least_effective_resistance</span><span class="p">()</span>
<span class="go">[(2, 4)]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.effective_resistance_matrix" title="sage.graphs.graph.Graph.effective_resistance_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">effective_resistance_matrix()</span></code></a> –
a similar method giving a matrix full of all effective
resistances</p></li>
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.effective_resistance" title="sage.graphs.graph.Graph.effective_resistance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">effective_resistance()</span></code></a> –
compuetes effective resistance for a single node pair</p></li>
<li><p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Resistance_distance">Wikipedia article Resistance_distance</a> for more details.</p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.lex_M">
<span class="sig-name descname"><span class="pre">lex_M</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">triangulation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_vertex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.lex_M" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an ordering of the vertices according the LexM graph traversal.</p>
<p>LexM is a lexicographic ordering scheme that is a special type of
breadth-first-search. LexM can also produce a triangulation of the
given graph. This functionality is implemented in this method. For
more details on the algorithms used see Sections 4 (<code class="docutils literal notranslate"><span class="pre">'lex_M_slow'</span></code>)
and 5.3 (<code class="docutils literal notranslate"><span class="pre">'lex_M_fast'</span></code>) of <a class="reference internal" href="../../../references/index.html#rtl76" id="id58"><span>[RTL76]</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method works only for undirected graphs.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">triangulation</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return a
list of edges that need to be added in order to triangulate the graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the labels
assigned to each vertex</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to
consider</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); one of the following
algorithms:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'lex_M_slow'</span></code>: slower implementation of LexM traversal</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'lex_M_fast'</span></code>: faster implementation of LexM traversal (works only
when <code class="docutils literal notranslate"><span class="pre">labels</span></code> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>: Sage chooses the best algorithm: <code class="docutils literal notranslate"><span class="pre">'lex_M_slow'</span></code> if
<code class="docutils literal notranslate"><span class="pre">labels</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">'lex_M_fast'</span></code> otherwise.</p></li>
</ul>
</li>
</ul>
<p>OUTPUT:</p>
<p>Depending on the values of the parameters <code class="docutils literal notranslate"><span class="pre">triangulation</span></code> and <code class="docutils literal notranslate"><span class="pre">labels</span></code>
the method will return one or more of the following (in that order):</p>
<ul class="simple">
<li><p>an ordering of vertices of the graph according to LexM ordering scheme</p></li>
<li><p>the labels assigned to each vertex</p></li>
<li><p>a list of edges that when added to the graph will triangulate it</p></li>
</ul>
<p>EXAMPLES:</p>
<p>LexM produces an ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">ord</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">lex_M</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;lex_M_fast&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="nb">ord</span><span class="p">)</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">set</span><span class="p">(</span><span class="nb">ord</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">ord</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">lex_M</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;lex_M_slow&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="nb">ord</span><span class="p">)</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">set</span><span class="p">(</span><span class="nb">ord</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Both algorithms produce a valid LexM ordering <span class="math notranslate nohighlight">\(\alpha\)</span> (i.e the neighbors of
<span class="math notranslate nohighlight">\(\alpha(i)\)</span> in <span class="math notranslate nohighlight">\(G[\{\alpha(i), ..., \alpha(n)\}]\)</span> induce a clique):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.traversals</span> <span class="kn">import</span> <span class="n">is_valid_lex_M_order</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">ord</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">lex_M</span><span class="p">(</span><span class="n">triangulation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;lex_M_slow&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">is_valid_lex_M_order</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="nb">ord</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">ord</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">lex_M</span><span class="p">(</span><span class="n">triangulation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;lex_M_fast&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">is_valid_lex_M_order</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="nb">ord</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>LexM produces a triangulation of given graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">lex_M</span><span class="p">(</span><span class="n">triangulation</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;list_of_edges&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">is_chordal</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>LexM ordering of the 3-sun graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">lex_M</span><span class="p">()</span>
<span class="go">[6, 4, 5, 3, 2, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.lovasz_theta">
<span class="sig-name descname"><span class="pre">lovasz_theta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.lovasz_theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the value of Lovász theta-function of graph</p>
<p>For a graph <span class="math notranslate nohighlight">\(G\)</span> this function is denoted by <span class="math notranslate nohighlight">\(\theta(G)\)</span>, and it can be
computed in polynomial time. Mathematically, its most important property is
the following:</p>
<div class="math notranslate nohighlight">
\[\alpha(G)\leq\theta(G)\leq\chi(\overline{G})\]</div>
<p>with <span class="math notranslate nohighlight">\(\alpha(G)\)</span> and <span class="math notranslate nohighlight">\(\chi(\overline{G})\)</span> being, respectively, the maximum
size of an <a class="reference internal" href="#sage.graphs.graph.Graph.independent_set" title="sage.graphs.graph.Graph.independent_set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">independent</span> <span class="pre">set</span></code></a>
set of <span class="math notranslate nohighlight">\(G\)</span> and the <a class="reference internal" href="#sage.graphs.graph.Graph.chromatic_number" title="sage.graphs.graph.Graph.chromatic_number"><code class="xref py py-meth docutils literal notranslate"><span class="pre">chromatic</span> <span class="pre">number</span></code></a> of the <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.complement" title="sage.graphs.generic_graph.GenericGraph.complement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">complement</span></code></a> <span class="math notranslate nohighlight">\(\overline{G}\)</span> of <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Lovász_number">Wikipedia article Lovász_number</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Implemented for undirected graphs only. Use <code class="docutils literal notranslate"><span class="pre">to_undirected</span></code>
to convert a digraph to an undirected graph.</p></li>
<li><p>This function requires the optional package <code class="docutils literal notranslate"><span class="pre">csdp</span></code>, which you can
install with <code class="docutils literal notranslate"><span class="pre">sage</span> <span class="pre">-i</span> <span class="pre">csdp</span></code>.</p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">lovasz_theta</span><span class="p">()</span>                             <span class="c1"># optional csdp</span>
<span class="go">4.0</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">lovasz_theta</span><span class="p">()</span>          <span class="c1"># optional csdp</span>
<span class="go">2.236068</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.magnitude_function">
<span class="sig-name descname"><span class="pre">magnitude_function</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.magnitude_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the magnitude function of the graph as a rational function.</p>
<p>This is defined as the sum of all coefficients in the inverse of the
matrix <span class="math notranslate nohighlight">\(Z\)</span> whose coefficient <span class="math notranslate nohighlight">\(Z_{i,j}\)</span> indexed by a pair of vertices
<span class="math notranslate nohighlight">\((i,j)\)</span> is <span class="math notranslate nohighlight">\(q^d(i,j)\)</span> where <span class="math notranslate nohighlight">\(d\)</span> is the distance function in the graph.</p>
<p>By convention, if the distance from <span class="math notranslate nohighlight">\(i\)</span> to <span class="math notranslate nohighlight">\(j\)</span> is infinite (for two
vertices not path connected) then <span class="math notranslate nohighlight">\(Z_{i,j}=0\)</span>.</p>
<p>The value of the magnitude function at <span class="math notranslate nohighlight">\(q=0\)</span> is the cardinality of the
graph. The magnitude function of a disjoint union is the sum of the
magnitudes functions of the connected components. The magnitude function
of a Cartesian product is the product of the magnitudes functions of the
factors.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">1</span><span class="p">:[],</span> <span class="mi">2</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">magnitude_function</span><span class="p">()</span>
<span class="go">2</span>

<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">magnitude_function</span><span class="p">()</span>
<span class="go">4/(q^2 + 2*q + 1)</span>

<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">magnitude_function</span><span class="p">();</span> <span class="n">m</span>
<span class="go">5/(2*q^2 + 2*q + 1)</span>
</pre></div>
</div>
<p>One can expand the magnitude as a power series in <span class="math notranslate nohighlight">\(q\)</span> as follows:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">q</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[[</span><span class="s1">&#39;q&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">gen</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="go">5 - 10*q + 10*q^2 - 20*q^4 + 40*q^5 - 40*q^6 + ...</span>
</pre></div>
</div>
<p>One can also use the substitution <span class="math notranslate nohighlight">\(q = exp(-t)\)</span> to obtain the magnitude
function as a function of <span class="math notranslate nohighlight">\(t\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">magnitude_function</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>                                                  <span class="c1"># optional - sage.symbolic</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span><span class="p">))</span>                                                    <span class="c1"># optional - sage.symbolic</span>
<span class="go">6/(2*e^(-t) + 2*e^(-2*t) + e^(-3*t) + 1)</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<dl class="citation">
<dt class="label" id="lein"><span class="brackets">Lein</span></dt>
<dd><p>Tom Leinster, <em>The magnitude of metric spaces</em>.
Doc. Math. 18 (2013), 857-905.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.matching">
<span class="sig-name descname"><span class="pre">matching</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value_only</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_edge_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Edmonds'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.matching" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a maximum weighted matching of the graph represented by the list
of its edges.</p>
<p>For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Matching_(graph_theory)">Wikipedia article Matching_(graph_theory)</a>.</p>
<p>Given a graph <span class="math notranslate nohighlight">\(G\)</span> such that each edge <span class="math notranslate nohighlight">\(e\)</span> has a weight <span class="math notranslate nohighlight">\(w_e\)</span>, a maximum
matching is a subset <span class="math notranslate nohighlight">\(S\)</span> of the edges of <span class="math notranslate nohighlight">\(G\)</span> of maximum weight such that
no two edges of <span class="math notranslate nohighlight">\(S\)</span> are incident with each other.</p>
<p>As an optimization problem, it can be expressed as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mbox{Maximize : }&amp;\sum_{e\in G.edges()} w_e b_e\\
\mbox{Such that : }&amp;\forall v \in G,
\sum_{(u,v)\in G.edges()} b_{(u,v)}\leq 1\\
&amp;\forall x\in G, b_x\mbox{ is a binary variable}\end{split}\]</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">value_only</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); when set to <code class="docutils literal notranslate"><span class="pre">True</span></code>,
only the cardinal (or the weight) of the matching is returned</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">&quot;Edmonds&quot;</span></code>)</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Edmonds&quot;</span></code> selects Edmonds’ algorithm as implemented in NetworkX</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;LP&quot;</span></code> uses a Linear Program formulation of the matching problem</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">use_edge_labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<ul>
<li><p>when set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, computes a weighted matching where each edge
is weighted by its label (if an edge has no label, <span class="math notranslate nohighlight">\(1\)</span> is assumed)</p></li>
<li><p>when set to <code class="docutils literal notranslate"><span class="pre">False</span></code>, each edge has weight <span class="math notranslate nohighlight">\(1\)</span></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of verbosity:
set to 0 by default, which means quiet (only useful when <code class="docutils literal notranslate"><span class="pre">algorithm</span>
<span class="pre">==</span> <span class="pre">&quot;LP&quot;</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>When <code class="docutils literal notranslate"><span class="pre">value_only=False</span></code> (default), this method returns the list of
edges of a maximum matching of <span class="math notranslate nohighlight">\(G\)</span>.</p></li>
<li><p>When <code class="docutils literal notranslate"><span class="pre">value_only=True</span></code>, this method returns the sum of the
weights (default: <code class="docutils literal notranslate"><span class="pre">1</span></code>) of the edges of a maximum matching of <span class="math notranslate nohighlight">\(G\)</span>.
The type of the output may vary according to the type of the edge
labels and the algorithm used.</p></li>
</ul>
<p>ALGORITHM:</p>
<p>The problem is solved using Edmond’s algorithm implemented in NetworkX,
or using Linear Programming depending on the value of <code class="docutils literal notranslate"><span class="pre">algorithm</span></code>.</p>
<p>EXAMPLES:</p>
<p>Maximum matching in a Pappus Graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PappusGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">matching</span><span class="p">(</span><span class="n">value_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">9</span>
</pre></div>
</div>
<p>Same test with the Linear Program formulation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PappusGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">matching</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;LP&quot;</span><span class="p">,</span> <span class="n">value_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">9</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="../../_images/graph-3.svg" class="plot-directive" src="../../_images/graph-3.svg" /></figure>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.matching_polynomial">
<span class="sig-name descname"><span class="pre">matching_polynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">complement</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.matching_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the matching polynomial of the graph <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(p(G, k)\)</span> denotes the number of <span class="math notranslate nohighlight">\(k\)</span>-matchings (matchings with <span class="math notranslate nohighlight">\(k\)</span> edges)
in <span class="math notranslate nohighlight">\(G\)</span>, then the matching polynomial is defined as <a class="reference internal" href="../../../references/index.html#god1993" id="id59"><span>[God1993]</span></a>:</p>
<div class="math notranslate nohighlight">
\[\mu(x)=\sum_{k \geq 0} (-1)^k p(G,k) x^{n-2k}\]</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">complement</span></code> - (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) whether to use Godsil’s duality
theorem to compute the matching polynomial from that of the graphs
complement (see ALGORITHM).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code> - optional string for the variable name in the polynomial</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">complement</span></code> option uses matching polynomials of complete graphs,
which are cached. So if you are crazy enough to try computing the
matching polynomial on a graph with millions of vertices, you might not
want to use this option, since it will end up caching millions of
polynomials of degree in the millions.</p>
</div>
<p>ALGORITHM:</p>
<p>The algorithm used is a recursive one, based on the following observation
<a class="reference internal" href="../../../references/index.html#god1993" id="id60"><span>[God1993]</span></a>:</p>
<ul>
<li><p>If <span class="math notranslate nohighlight">\(e\)</span> is an edge of <span class="math notranslate nohighlight">\(G\)</span>, <span class="math notranslate nohighlight">\(G'\)</span> is the result of deleting the edge <span class="math notranslate nohighlight">\(e\)</span>, and
<span class="math notranslate nohighlight">\(G''\)</span> is the result of deleting each vertex in <span class="math notranslate nohighlight">\(e\)</span>, then the matching
polynomial of <span class="math notranslate nohighlight">\(G\)</span> is equal to that of <span class="math notranslate nohighlight">\(G'\)</span> minus that of <span class="math notranslate nohighlight">\(G''\)</span>.</p>
<p>(the algorithm actually computes the <em>signless</em> matching polynomial, for
which the recursion is the same when one replaces the subtraction by an
addition. It is then converted into the matching polynomial and returned)</p>
</li>
</ul>
<p>Depending on the value of <code class="docutils literal notranslate"><span class="pre">complement</span></code>, Godsil’s duality theorem
<a class="reference internal" href="../../../references/index.html#god1993" id="id61"><span>[God1993]</span></a> can also be used to compute <span class="math notranslate nohighlight">\(\mu(x)\)</span> :</p>
<div class="math notranslate nohighlight">
\[\mu(\overline{G}, x) = \sum_{k \geq 0} p(G,k) \mu( K_{n-2k}, x)\]</div>
<p>Where <span class="math notranslate nohighlight">\(\overline{G}\)</span> is the complement of <span class="math notranslate nohighlight">\(G\)</span>, and <span class="math notranslate nohighlight">\(K_n\)</span> the complete graph
on <span class="math notranslate nohighlight">\(n\)</span> vertices.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">matching_polynomial</span><span class="p">()</span>
<span class="go">x^10 - 15*x^8 + 75*x^6 - 145*x^4 + 90*x^2 - 6</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">complement</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">x^10 - 15*x^8 + 75*x^6 - 145*x^4 + 90*x^2 - 6</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;tom&#39;</span><span class="p">)</span>
<span class="go">tom^10 - 15*tom^8 + 75*tom^6 - 145*tom^4 + 90*tom^2 - 6</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mf">.3</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">prod</span><span class="p">([</span><span class="n">h</span><span class="o">.</span><span class="n">matching_polynomial</span><span class="p">()</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">L</span><span class="p">])</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">matching_polynomial</span><span class="p">()</span>  <span class="c1"># long time (up to 10s on sage.math, 2011)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">):</span>  <span class="c1"># long time (10s on sage.math, 2011)</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">graphs</span><span class="o">.</span><span class="n">trees</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">matching_polynomial</span><span class="p">()</span> <span class="o">!=</span> <span class="n">t</span><span class="o">.</span><span class="n">characteristic_polynomial</span><span class="p">():</span>
<span class="gp">....: </span>            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;bug for a tree A of size </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="gp">....: </span>        <span class="n">c</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">complement</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">!=</span> <span class="n">c</span><span class="o">.</span><span class="n">matching_polynomial</span><span class="p">():</span>
<span class="gp">....: </span>            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;bug for a tree B of size </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.matchpoly</span> <span class="kn">import</span> <span class="n">matching_polynomial</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">x^2 - 1</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">x^3 - 3*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">x^4 - 6*x^2 + 3</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">x^5 - 10*x^3 + 15*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="go">x^6 - 15*x^4 + 45*x^2 - 15</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="go">x^7 - 21*x^5 + 105*x^3 - 105*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>
<span class="go">x^8 - 28*x^6 + 210*x^4 - 420*x^2 + 105</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">9</span><span class="p">))</span>
<span class="go">x^9 - 36*x^7 + 378*x^5 - 1260*x^3 + 945*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">x^10 - 45*x^8 + 630*x^6 - 3150*x^4 + 4725*x^2 - 945</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">11</span><span class="p">))</span>
<span class="go">x^11 - 55*x^9 + 990*x^7 - 6930*x^5 + 17325*x^3 - 10395*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">12</span><span class="p">))</span>
<span class="go">x^12 - 66*x^10 + 1485*x^8 - 13860*x^6 + 51975*x^4 - 62370*x^2 + 10395</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">13</span><span class="p">))</span>
<span class="go">x^13 - 78*x^11 + 2145*x^9 - 25740*x^7 + 135135*x^5 - 270270*x^3 + 135135*x</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">x^3 - 3*x</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">x^3 - 2*x</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">x^3 - x</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[],</span> <span class="mi">1</span><span class="p">:[],</span> <span class="mi">2</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">x^3</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">x^2 - 1</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">x^3 - 3*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">x^4 - 6*x^2 + 3</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">x^5 - 10*x^3 + 15*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">x^6 - 15*x^4 + 45*x^2 - 15</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">x^7 - 21*x^5 + 105*x^3 - 105*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">x^8 - 28*x^6 + 210*x^4 - 420*x^2 + 105</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">9</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">x^9 - 36*x^7 + 378*x^5 - 1260*x^3 + 945*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">x^10 - 45*x^8 + 630*x^6 - 3150*x^4 + 4725*x^2 - 945</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">11</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">x^11 - 55*x^9 + 990*x^7 - 6930*x^5 + 17325*x^3 - 10395*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">x^12 - 66*x^10 + 1485*x^8 - 13860*x^6 + 51975*x^4 - 62370*x^2 + 10395</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">13</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">x^13 - 78*x^11 + 2145*x^9 - 25740*x^7 + 135135*x^5 - 270270*x^3 + 135135*x</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.maximum_average_degree">
<span class="sig-name descname"><span class="pre">maximum_average_degree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.maximum_average_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Maximum Average Degree (MAD) of the current graph.</p>
<p>The Maximum Average Degree (MAD) of a graph is defined as the average
degree of its densest subgraph. More formally, <code class="docutils literal notranslate"><span class="pre">Mad(G)</span> <span class="pre">=</span>
<span class="pre">\max_{H\subseteq</span> <span class="pre">G}</span> <span class="pre">Ad(H)</span></code>, where <span class="math notranslate nohighlight">\(Ad(G)\)</span> denotes the average degree of
<span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>This can be computed in polynomial time.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">value_only</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>);</p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">value_only=True</span></code>, only the numerical value of the <span class="math notranslate nohighlight">\(MAD\)</span> is
returned.</p></li>
<li><p>Else, the subgraph of <span class="math notranslate nohighlight">\(G\)</span> realizing the <span class="math notranslate nohighlight">\(MAD\)</span> is returned.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Linear Program (LP)
solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a>
of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>In any graph, the <span class="math notranslate nohighlight">\(Mad\)</span> is always larger than the average degree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mf">.3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">mad_g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">maximum_average_degree</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">average_degree</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">mad_g</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Unlike the average degree, the <span class="math notranslate nohighlight">\(Mad\)</span> of the disjoint union of two graphs
is the maximum of the <span class="math notranslate nohighlight">\(Mad\)</span> of each graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mf">.3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">mad_h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">maximum_average_degree</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">g</span><span class="o">+</span><span class="n">h</span><span class="p">)</span><span class="o">.</span><span class="n">maximum_average_degree</span><span class="p">()</span> <span class="o">==</span> <span class="nb">max</span><span class="p">(</span><span class="n">mad_g</span><span class="p">,</span> <span class="n">mad_h</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The subgraph of a regular graph realizing the maximum average degree is
always the whole graph</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">mad_g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">maximum_average_degree</span><span class="p">(</span><span class="n">value_only</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">mad_g</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This also works for complete bipartite graphs</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">mad_g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">maximum_average_degree</span><span class="p">(</span><span class="n">value_only</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">mad_g</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.maximum_cardinality_search">
<span class="sig-name descname"><span class="pre">maximum_cardinality_search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_vertex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.maximum_cardinality_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an ordering of the vertices according a maximum cardinality search.</p>
<p>Maximum cardinality search (MCS) is a graph traversal introduced in
<a class="reference internal" href="../../../references/index.html#ty1984" id="id62"><span>[TY1984]</span></a>. It starts by assigning an arbitrary vertex (or the specified
<code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code>) of <span class="math notranslate nohighlight">\(G\)</span> the last position in the ordering <span class="math notranslate nohighlight">\(\alpha\)</span>. Every
vertex keeps a weight equal to the number of its already processed neighbors
(i.e., already added to <span class="math notranslate nohighlight">\(\alpha\)</span>), and a vertex of largest such number is
chosen at each step <span class="math notranslate nohighlight">\(i\)</span> to be placed in position <span class="math notranslate nohighlight">\(n - i\)</span> in <span class="math notranslate nohighlight">\(\alpha\)</span>. This
ordering can be computed in time <span class="math notranslate nohighlight">\(O(n + m)\)</span>.</p>
<p>When the graph is chordal, the ordering returned by MCS is a <em>perfect
elimination ordering</em>, like <a class="reference internal" href="traversals.html#sage.graphs.traversals.lex_BFS" title="sage.graphs.traversals.lex_BFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_BFS()</span></code></a>. So
this ordering can be used to recognize chordal graphs. See <a class="reference internal" href="../../../references/index.html#he2006" id="id63"><span>[He2006]</span></a> for
more details.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The current implementation is for connected graphs only.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a Sage Graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reverse</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
vertices in discovery order, or the reverse</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tree</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to also return the
discovery directed tree (each vertex being linked to the one that saw
it for the first time)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to consider</p></li>
</ul>
<p>OUTPUT:</p>
<p>By default, return the ordering <span class="math notranslate nohighlight">\(\alpha\)</span> as a list. When <code class="docutils literal notranslate"><span class="pre">tree</span></code> is
<code class="docutils literal notranslate"><span class="pre">True</span></code>, the method returns a tuple <span class="math notranslate nohighlight">\((\alpha, T)\)</span>, where <span class="math notranslate nohighlight">\(T\)</span> is a directed
tree with the same set of vertices as <span class="math notranslate nohighlight">\(G\)</span> to <span class="math notranslate nohighlight">\(v\)</span>
if <span class="math notranslate nohighlight">\(u\)</span> was the first vertex to saw <span class="math notranslate nohighlight">\(v\)</span>.</p>
<p>EXAMPLES:</p>
<p>When specified, the <code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> is placed at the end of the ordering,
unless parameter <code class="docutils literal notranslate"><span class="pre">reverse</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, in which case it is placed at the
beginning:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[3, 2, 1, 0]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[0, 3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[0, 1, 3, 2]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[3, 2, 1, 0]</span>
</pre></div>
</div>
<p>Returning the discovery tree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search</span><span class="p">(</span><span class="n">tree</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">initial_vertex</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">order</span><span class="p">(),</span> <span class="n">T</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">(4, 3)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(1, 0), (2, 1), (3, 2)]</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search</span><span class="p">(</span><span class="n">tree</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">initial_vertex</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(0, 1), (1, 2), (2, 3)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.maximum_cardinality_search_M">
<span class="sig-name descname"><span class="pre">maximum_cardinality_search_M</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_vertex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.maximum_cardinality_search_M" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ordering and the edges of the triangulation produced by MCS-M.</p>
<p>Maximum cardinality search M (MCS-M) is an extension of MCS
(<a class="reference internal" href="traversals.html#sage.graphs.traversals.maximum_cardinality_search" title="sage.graphs.traversals.maximum_cardinality_search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximum_cardinality_search()</span></code></a>) in the same way
that Lex-M (<a class="reference internal" href="traversals.html#sage.graphs.traversals.lex_M" title="sage.graphs.traversals.lex_M"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_M()</span></code></a>) is an extension of
Lex-BFS (<a class="reference internal" href="traversals.html#sage.graphs.traversals.lex_BFS" title="sage.graphs.traversals.lex_BFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_BFS()</span></code></a>). That is, in MCS-M when
<span class="math notranslate nohighlight">\(u\)</span> receives number <span class="math notranslate nohighlight">\(i\)</span> at step <span class="math notranslate nohighlight">\(n - i + 1\)</span>, it increments the weight of all
unnumbered vertices <span class="math notranslate nohighlight">\(v\)</span> for which there exists a path between <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span>
consisting only of unnumbered vertices with weight strictly less than
<span class="math notranslate nohighlight">\(w^-(u)\)</span> and <span class="math notranslate nohighlight">\(w^-(v)\)</span>, where <span class="math notranslate nohighlight">\(w^-\)</span> is the number of times a vertex has been
reached during previous iterations. See <a class="reference internal" href="../../../references/index.html#bbhp2004" id="id64"><span>[BBHP2004]</span></a> for the details of this
<span class="math notranslate nohighlight">\(O(nm)\)</span> time algorithm.</p>
<p>If <span class="math notranslate nohighlight">\(G\)</span> is not connected, the orderings of each of its connected components
are added consecutively. Furthermore, if <span class="math notranslate nohighlight">\(G\)</span> has <span class="math notranslate nohighlight">\(k\)</span> connected components
<span class="math notranslate nohighlight">\(C_i\)</span> for <span class="math notranslate nohighlight">\(0 \leq i &lt; k\)</span>, <span class="math notranslate nohighlight">\(X\)</span> contains at least one vertex of <span class="math notranslate nohighlight">\(C_i\)</span> for each
<span class="math notranslate nohighlight">\(i \geq 1\)</span>. Hence, <span class="math notranslate nohighlight">\(|X| \geq k - 1\)</span>. In particular, some isolated vertices
(i.e., of degree 0) can appear in <span class="math notranslate nohighlight">\(X\)</span> as for such a vertex <span class="math notranslate nohighlight">\(x\)</span>, we have that
<span class="math notranslate nohighlight">\(G \setminus N(x) = G\)</span> is not connected.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a Sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to consider</p></li>
</ul>
<p>OUTPUT: a tuple <span class="math notranslate nohighlight">\((\alpha, F, X)\)</span>, where</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\alpha\)</span> is the resulting ordering of the vertices. If an initial vertex
is specified, it gets the last position in the ordering <span class="math notranslate nohighlight">\(\alpha\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(F\)</span> is the list of edges of a minimal triangulation of <span class="math notranslate nohighlight">\(G\)</span> according
<span class="math notranslate nohighlight">\(\alpha\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(X\)</span> is a list of vertices such that for each <span class="math notranslate nohighlight">\(x \in X\)</span>, the
neighborhood of <span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(G\)</span> is a separator (i.e., <span class="math notranslate nohighlight">\(G \setminus N(x)\)</span> is not
connected). Note that we may have <span class="math notranslate nohighlight">\(N(x) = \emptyset\)</span> if <span class="math notranslate nohighlight">\(G\)</span> is not
connected and <span class="math notranslate nohighlight">\(x\)</span> has degree 0.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>Chordal graphs have a perfect elimination ordering, and so the set <span class="math notranslate nohighlight">\(F\)</span> of
edges of the triangulation is empty:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomChordalGraph</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">alpha</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">();</span> <span class="n">F</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>The cycle of order 4 is not chordal and so the triangulation has one edge:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">alpha</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">();</span> <span class="nb">len</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>The number of edges needed to triangulate of a cycle graph or order <span class="math notranslate nohighlight">\(n\)</span> is
<span class="math notranslate nohighlight">\(n - 3\)</span>, independently of the initial vertex:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">F</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">3</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="n">C</span><span class="o">.</span><span class="n">random_vertex</span><span class="p">())</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">F</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">3</span>
<span class="go">True</span>
</pre></div>
</div>
<p>When an initial vertex is specified, it gets the last position in the
ordering:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">([3, 2, 1, 0], [], [2, 3])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">([3, 2, 0, 1], [], [2, 3])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">([0, 1, 3, 2], [], [0, 1])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">([0, 1, 2, 3], [], [0, 1])</span>
</pre></div>
</div>
<p>When <span class="math notranslate nohighlight">\(G\)</span> is not connected, the orderings of each of its connected components
are added consecutively, the vertices of the component containing the
initial vertex occupying the last positions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[5, 4, 6, 7, 2, 3, 1, 0]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">7</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[2, 1, 3, 0, 5, 6, 4, 7]</span>
</pre></div>
</div>
<p>Furthermore, if <span class="math notranslate nohighlight">\(G\)</span> has <span class="math notranslate nohighlight">\(k\)</span> connected components, <span class="math notranslate nohighlight">\(X\)</span> contains at least one
vertex per connected component, except for the first one, and so at least <span class="math notranslate nohighlight">\(k
- 1\)</span> vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;something goes wrong&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mf">.2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">cc</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">connected_components</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In the example of <a class="reference internal" href="../../../references/index.html#bps2010" id="id65"><span>[BPS2010]</span></a>, the triangulation has 3 edges:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">],</span>
<span class="gp">....: </span>           <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">],</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;g&#39;</span><span class="p">],</span>
<span class="gp">....: </span>           <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">],</span> <span class="s1">&#39;g&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">],</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">],</span>
<span class="gp">....: </span>           <span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">],</span> <span class="s1">&#39;j&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.minimal_dominating_sets">
<span class="sig-name descname"><span class="pre">minimal_dominating_sets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_dominate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">work_on_copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.minimal_dominating_sets" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over the minimal dominating sets of a graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a graph.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">to_dominate</span></code> – vertex iterable or <code class="docutils literal notranslate"><span class="pre">None</span></code> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>);
the set of vertices to be dominated.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">work_on_copy</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether or not to work on
a copy of the input graph; if set to <code class="docutils literal notranslate"><span class="pre">False</span></code>, the input graph will be
modified (relabeled).</p></li>
</ul>
<p>OUTPUT:</p>
<p>An iterator over the inclusion-minimal sets of vertices of <code class="docutils literal notranslate"><span class="pre">G</span></code>.
If <code class="docutils literal notranslate"><span class="pre">to_dominate</span></code> is provided, return an iterator over the
inclusion-minimal sets of vertices that dominate the vertices of
<code class="docutils literal notranslate"><span class="pre">to_dominate</span></code>.</p>
<p>ALGORITHM: The algorithm described in <a class="reference internal" href="../../../references/index.html#bdhpr2019" id="id66"><span>[BDHPR2019]</span></a>.</p>
<p>AUTHOR: Jean-Florent Raymond (2019-03-04) – initial version.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">ButterflyGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ll</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">minimal_dominating_sets</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">pp</span> <span class="o">=</span> <span class="p">[{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="mi">4</span><span class="p">}]</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">ll</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">pp</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ll</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">ll</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pp</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">ll</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">minimal_dominating_sets</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">pp</span> <span class="o">=</span> <span class="p">[{</span><span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="mi">4</span><span class="p">}]</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">ll</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">pp</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ll</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">ll</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pp</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">ll</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">minimal_dominating_sets</span><span class="p">([</span><span class="mi">4</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">pp</span> <span class="o">=</span> <span class="p">[{</span><span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">}]</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">ll</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">pp</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ll</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">ll</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pp</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ll</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">minimal_dominating_sets</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">pp</span> <span class="o">=</span> <span class="p">[{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">},</span>
<span class="gp">....: </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>
<span class="gp">....: </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">},</span>
<span class="gp">....: </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">},</span>
<span class="gp">....: </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">},</span>
<span class="gp">....: </span><span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">},</span>
<span class="gp">....: </span><span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span>
<span class="gp">....: </span><span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">},</span>
<span class="gp">....: </span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">},</span>
<span class="gp">....: </span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">},</span>
<span class="gp">....: </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">},</span>
<span class="gp">....: </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">},</span>
<span class="gp">....: </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">},</span>
<span class="gp">....: </span><span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">},</span>
<span class="gp">....: </span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">},</span>
<span class="gp">....: </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span>
<span class="gp">....: </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">},</span>
<span class="gp">....: </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">},</span>
<span class="gp">....: </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">},</span>
<span class="gp">....: </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">},</span>
<span class="gp">....: </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">},</span>
<span class="gp">....: </span><span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">},</span>
<span class="gp">....: </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">},</span>
<span class="gp">....: </span><span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">},</span>
<span class="gp">....: </span><span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">},</span>
<span class="gp">....: </span><span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">},</span>
<span class="gp">....: </span><span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">}]</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">ll</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">pp</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ll</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">ll</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pp</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.minimum_outdegree_orientation">
<span class="sig-name descname"><span class="pre">minimum_outdegree_orientation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">use_edge_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.minimum_outdegree_orientation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an orientation of <code class="docutils literal notranslate"><span class="pre">self</span></code> with the smallest possible maximum
outdegree.</p>
<p>Given a Graph <span class="math notranslate nohighlight">\(G\)</span>, it is polynomial to compute an orientation <span class="math notranslate nohighlight">\(D\)</span> of the
edges of <span class="math notranslate nohighlight">\(G\)</span> such that the maximum out-degree in <span class="math notranslate nohighlight">\(D\)</span> is minimized. This
problem, though, is NP-complete in the weighted case <a class="reference internal" href="../../../references/index.html#amoz2006" id="id67"><span>[AMOZ2006]</span></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">use_edge_labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<ul>
<li><p>When set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, uses edge labels as weights to compute the
orientation and assumes a weight of <span class="math notranslate nohighlight">\(1\)</span> when there is no value
available for a given edge.</p></li>
<li><p>When set to <code class="docutils literal notranslate"><span class="pre">False</span></code> (default), gives a weight of 1 to all the
edges.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>Given a complete bipartite graph <span class="math notranslate nohighlight">\(K_{n,m}\)</span>, the maximum out-degree of an
optimal orientation is <span class="math notranslate nohighlight">\(\left\lceil \frac {nm} {n+m}\right\rceil\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">minimum_outdegree_orientation</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">max</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">out_degree</span><span class="p">())</span> <span class="o">==</span> <span class="n">integer_ceil</span><span class="p">((</span><span class="mi">4</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="mi">4</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.minor">
<span class="sig-name descname"><span class="pre">minor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.minor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertices of a minor isomorphic to <span class="math notranslate nohighlight">\(H\)</span> in the current graph.</p>
<p>We say that a graph <span class="math notranslate nohighlight">\(G\)</span> has a <span class="math notranslate nohighlight">\(H\)</span>-minor (or that it has a graph
isomorphic to <span class="math notranslate nohighlight">\(H\)</span> as a minor), if for all <span class="math notranslate nohighlight">\(h\in H\)</span>, there exist disjoint
sets <span class="math notranslate nohighlight">\(S_h \subseteq V(G)\)</span> such that once the vertices of each <span class="math notranslate nohighlight">\(S_h\)</span> have
been merged to create a new graph <span class="math notranslate nohighlight">\(G'\)</span>, this new graph contains <span class="math notranslate nohighlight">\(H\)</span> as a
subgraph.</p>
<p>For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Minor_(graph_theory)">Wikipedia article Minor_(graph_theory)</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">H</span></code> – The minor to find for in the current graph.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A dictionary associating to each vertex of <span class="math notranslate nohighlight">\(H\)</span> the set of vertices in
the current graph representing it.</p>
<p>ALGORITHM:</p>
<p>Mixed Integer Linear Programming</p>
<p>COMPLEXITY:</p>
<p>Theoretically, when <span class="math notranslate nohighlight">\(H\)</span> is fixed, testing for the existence of a
<span class="math notranslate nohighlight">\(H\)</span>-minor is polynomial. The known algorithms are highly exponential in
<span class="math notranslate nohighlight">\(H\)</span>, though.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function can be expected to be <em>very</em> slow, especially where
the minor does not exist.</p>
</div>
<p>EXAMPLES:</p>
<p>Trying to find a minor isomorphic to <span class="math notranslate nohighlight">\(K_4\)</span> in the <span class="math notranslate nohighlight">\(4\times 4\)</span> grid:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">GridGraph</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">minor</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">gg</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">max_level</span> <span class="o">=</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">_</span> <span class="o">=</span> <span class="p">[</span><span class="n">gg</span><span class="o">.</span><span class="n">merge_vertices</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">L</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">gg</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We can also try to prove this way that the Petersen graph is not planar,
as it has a <span class="math notranslate nohighlight">\(K_5\)</span> minor:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">K5_minor</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">minor</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>                    <span class="c1"># long time</span>
</pre></div>
</div>
<p>And even a <span class="math notranslate nohighlight">\(K_{3,3}\)</span> minor:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K33_minor</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">minor</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>        <span class="c1"># long time</span>
</pre></div>
</div>
<p>(It is much faster to use the linear-time test of planarity in this
situation, though.)</p>
<p>As there is no cycle in a tree, looking for a <span class="math notranslate nohighlight">\(K_3\)</span> minor is useless.
This function will raise an exception in this case:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mf">.5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">edges</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_tree</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">minor</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: This graph has no minor isomorphic to H !</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.modular_decomposition">
<span class="sig-name descname"><span class="pre">modular_decomposition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'habib'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">style</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'tuple'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.modular_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the modular decomposition of the current graph.</p>
<p>A module of an undirected graph is a subset of vertices such that every
vertex outside the module is either connected to all members of the
module or to none of them. Every graph that has a nontrivial module can
be partitioned into modules, and the increasingly fine partitions into
modules form a tree. The <code class="docutils literal notranslate"><span class="pre">modular_decomposition</span></code> function returns
that tree.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">'habib'</span></code>); specifies the
algorithm to use among:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'tedder'</span></code> – linear time algorithm of <a class="reference internal" href="../../../references/index.html#tchp2008" id="id68"><span>[TCHP2008]</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'habib'</span></code> – <span class="math notranslate nohighlight">\(O(n^3)\)</span> algorithm of <a class="reference internal" href="../../../references/index.html#hm1979" id="id69"><span>[HM1979]</span></a>. This algorithm is
much simpler and so possibly less prone to errors.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">style</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">'tuple'</span></code>); specifies the output
format:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'tuple'</span></code> – as nested tuples.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'tree'</span></code> – as <a class="reference external" href="../../../combinat/sage/combinat/rooted_tree.html#sage.combinat.rooted_tree.LabelledRootedTree" title="(in Sage 9.5 Reference Manual: Combinatorics v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">LabelledRootedTree</span></code></a>.</p></li>
</ul>
</li>
</ul>
<p>OUTPUT:</p>
<p>A pair of two values (recursively encoding the decomposition) :</p>
<ul class="simple">
<li><p>The type of the current module :</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;PARALLEL&quot;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;PRIME&quot;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;SERIES&quot;</span></code></p></li>
</ul>
</li>
<li><p>The list of submodules (as list of pairs <code class="docutils literal notranslate"><span class="pre">(type,</span> <span class="pre">list)</span></code>,
recursively…) or the vertex’s name if the module is a singleton.</p></li>
</ul>
<p>Crash course on modular decomposition:</p>
<p>A module <span class="math notranslate nohighlight">\(M\)</span> of a graph <span class="math notranslate nohighlight">\(G\)</span> is a proper subset of its vertices such
that for all <span class="math notranslate nohighlight">\(u \in V(G)-M, v,w\in M\)</span> the relation <span class="math notranslate nohighlight">\(u \sim v
\Leftrightarrow u \sim w\)</span> holds, where <span class="math notranslate nohighlight">\(\sim\)</span> denotes the adjacency
relation in <span class="math notranslate nohighlight">\(G\)</span>. Equivalently, <span class="math notranslate nohighlight">\(M \subset V(G)\)</span> is a module if all its
vertices have the same adjacency relations with each vertex outside of
the module (vertex by vertex).</p>
<p>Hence, for a set like a module, it is very easy to encode the
information of the adjacencies between the vertices inside and outside
the module – we can actually add a new vertex <span class="math notranslate nohighlight">\(v_M\)</span> to our graph
representing our module <span class="math notranslate nohighlight">\(M\)</span>, and let <span class="math notranslate nohighlight">\(v_M\)</span> be adjacent to <span class="math notranslate nohighlight">\(u\in V(G)-M\)</span>
if and only if some <span class="math notranslate nohighlight">\(v\in M\)</span> (and hence all the vertices contained in
the module) is adjacent to <span class="math notranslate nohighlight">\(u\)</span>. We can now independently (and
recursively) study the structure of our module <span class="math notranslate nohighlight">\(M\)</span> and the new graph
<span class="math notranslate nohighlight">\(G-M+\{v_M\}\)</span>, without any loss of information.</p>
<p>Here are two very simple modules :</p>
<ul class="simple">
<li><p>A connected component <span class="math notranslate nohighlight">\(C\)</span> (or the union of some –but not all– of
them) of a disconnected graph <span class="math notranslate nohighlight">\(G\)</span>, for instance, is a module, as no
vertex of <span class="math notranslate nohighlight">\(C\)</span> has a neighbor outside of it.</p></li>
<li><p>An anticomponent <span class="math notranslate nohighlight">\(C\)</span> (or the union of some –but not all– of them) of
an non-anticonnected graph <span class="math notranslate nohighlight">\(G\)</span>, for the same reason (it is just the
complement of the previous graph !).</p></li>
</ul>
<p>These modules being of special interest, the disjoint union of graphs is
called a Parallel composition, and the complement of a disjoint union is
called a Series composition. A graph whose only modules are singletons
is called Prime.</p>
<p>For more information on modular decomposition, in particular for an
explanation of the terms “Parallel,” “Prime” and “Series,” see the
<a class="reference external" href="https://en.wikipedia.org/wiki/Modular_decomposition">Wikipedia article Modular_decomposition</a>.</p>
<p>You may also be interested in the survey from Michel Habib and
Christophe Paul entitled “A survey on Algorithmic aspects of modular
decomposition” <a class="reference internal" href="../../../references/index.html#hp2010" id="id70"><span>[HP2010]</span></a>.</p>
<p>EXAMPLES:</p>
<p>The Bull Graph is prime:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">BullGraph</span><span class="p">()</span><span class="o">.</span><span class="n">modular_decomposition</span><span class="p">()</span>
<span class="go">(PRIME, [1, 2, 0, 3, 4])</span>
</pre></div>
</div>
<p>The Petersen Graph too:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">modular_decomposition</span><span class="p">()</span>
<span class="go">(PRIME, [1, 4, 5, 0, 2, 6, 3, 7, 8, 9])</span>
</pre></div>
</div>
<p>This a clique on 5 vertices with 2 pendant edges, though, has a more
interesting decomposition:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">modular_decomposition</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;habib&#39;</span><span class="p">)</span>
<span class="go">(SERIES, [(PARALLEL, [(SERIES, [1, 2, 3, 4]), 5, 6]), 0])</span>
</pre></div>
</div>
<p>We get an equivalent tree when we use the algorithm of <a class="reference internal" href="../../../references/index.html#tchp2008" id="id71"><span>[TCHP2008]</span></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">modular_decomposition</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;tedder&#39;</span><span class="p">)</span>
<span class="go">(SERIES, [(PARALLEL, [(SERIES, [4, 3, 2, 1]), 5, 6]), 0])</span>
</pre></div>
</div>
<p>We can choose output to be a
<a class="reference external" href="../../../combinat/sage/combinat/rooted_tree.html#sage.combinat.rooted_tree.LabelledRootedTree" title="(in Sage 9.5 Reference Manual: Combinatorics v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">LabelledRootedTree</span></code></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">modular_decomposition</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s1">&#39;tree&#39;</span><span class="p">)</span>
<span class="go">SERIES[0[], PARALLEL[5[], 6[], SERIES[1[], 2[], 3[], 4[]]]]</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">modular_decomposition</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s1">&#39;tree&#39;</span><span class="p">))</span>
<span class="go">  __SERIES</span>
<span class="go"> /      /</span>
<span class="go">0   ___PARALLEL</span>
<span class="go">   / /     /</span>
<span class="go">  5 6   __SERIES</span>
<span class="go">       / / / /</span>
<span class="go">      1 2 3 4</span>
</pre></div>
</div>
<p>ALGORITHM:</p>
<p>When <code class="docutils literal notranslate"><span class="pre">algorithm='tedder'</span></code> this function uses python implementation of
algorithm published by Marc Tedder, Derek Corneil, Michel Habib and
Christophe Paul <a class="reference internal" href="../../../references/index.html#tchp2008" id="id72"><span>[TCHP2008]</span></a>. When <code class="docutils literal notranslate"><span class="pre">algorithm='habib'</span></code> this function
uses the algorithm of M. Habib and M. Maurer <a class="reference internal" href="../../../references/index.html#hm1979" id="id73"><span>[HM1979]</span></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.is_prime" title="sage.graphs.graph.Graph.is_prime"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_prime()</span></code></a> – Tests whether a graph is prime.</p></li>
<li><p><a class="reference external" href="../../../combinat/sage/combinat/rooted_tree.html#sage.combinat.rooted_tree.LabelledRootedTree" title="(in Sage 9.5 Reference Manual: Combinatorics v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">LabelledRootedTree</span></code></a>.</p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.most_common_neighbors">
<span class="sig-name descname"><span class="pre">most_common_neighbors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nonedgesonly</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.most_common_neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vertex pairs with maximal number of common neighbors.</p>
<p>This method is only valid for simple (no loops, no multiple edges)
graphs with order <span class="math notranslate nohighlight">\(\geq 2\)</span></p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nonedgesonly</span></code>– boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, assigns
<span class="math notranslate nohighlight">\(0\)</span> value to adjacent vertices.</p></li>
</ul>
<p>OUTPUT: list of tuples of edge pairs</p>
<p>EXAMPLES:</p>
<p>The maximum common neighbor (non-adjacent) pairs for a straight
linear 2-tree</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G1</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G1</span><span class="o">.</span><span class="n">most_common_neighbors</span><span class="p">()</span>
<span class="go">[(0, 3), (1, 4), (2, 5)]</span>
</pre></div>
</div>
<p>If we include non-adjacent pairs</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G1</span><span class="o">.</span><span class="n">most_common_neighbors</span><span class="p">(</span><span class="n">nonedgesonly</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">[(0, 3), (1, 2), (1, 4), (2, 3), (2, 5), (3, 4)]</span>
</pre></div>
</div>
<p>The common neighbors matrix  for a fan on 6 vertices counting only
non-adjacent vertex pairs</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">most_common_neighbors</span><span class="p">()</span>
<span class="go">[(1, 3), (2, 4), (3, 5)]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.common_neighbors_matrix" title="sage.graphs.graph.Graph.common_neighbors_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">common_neighbors_matrix()</span></code></a> –
a similar method giving a matrix of number of common neighbors</p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.orientations">
<span class="sig-name descname"><span class="pre">orientations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_structure</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.orientations" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over orientations of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>An <em>orientation</em> of an undirected graph is a directed graph such that
every edge is assigned a direction.  Hence there are <span class="math notranslate nohighlight">\(2^s\)</span> oriented
digraphs for a simple graph with <span class="math notranslate nohighlight">\(s\)</span> edges.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">data_structure</span></code> – one of <code class="docutils literal notranslate"><span class="pre">&quot;sparse&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;static_sparse&quot;</span></code>, or
<code class="docutils literal notranslate"><span class="pre">&quot;dense&quot;</span></code>; see the documentation of <a class="reference internal" href="#sage.graphs.graph.Graph" title="sage.graphs.graph.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a> or
<a class="reference internal" href="digraph.html#sage.graphs.digraph.DiGraph" title="sage.graphs.digraph.DiGraph"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraph</span></code></a>; default is the data structure of <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sparse</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); <code class="docutils literal notranslate"><span class="pre">sparse=True</span></code> is an alias
for <code class="docutils literal notranslate"><span class="pre">data_structure=&quot;sparse&quot;</span></code>, and <code class="docutils literal notranslate"><span class="pre">sparse=False</span></code> is an alias for
<code class="docutils literal notranslate"><span class="pre">data_structure=&quot;dense&quot;</span></code>. By default (<code class="docutils literal notranslate"><span class="pre">None</span></code>), guess the most
suitable data structure.</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This always considers multiple edges of graphs as distinguishable,
and hence, may have repeated digraphs.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)]],</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;vertices_and_edges&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">orientations</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(1, 2, &#39;a&#39;), (1, 3, &#39;b&#39;)]</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(1, 2, &#39;a&#39;), (3, 1, &#39;b&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.pathwidth">
<span class="sig-name descname"><span class="pre">pathwidth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'BAB'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_prefix_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_prefix_number</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.pathwidth" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the pathwidth of <code class="docutils literal notranslate"><span class="pre">self</span></code> (and provides a decomposition)</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the width to be considered. When
<code class="docutils literal notranslate"><span class="pre">k</span></code> is an integer, the method checks that the graph has pathwidth
<span class="math notranslate nohighlight">\(\leq k\)</span>. If <code class="docutils literal notranslate"><span class="pre">k</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), the method computes the optimal
pathwidth.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
path-decomposition itself</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">&quot;BAB&quot;</span></code>); algorithm to use among:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;BAB&quot;</span></code> – Use a branch-and-bound algorithm. This algorithm has no
size restriction but could take a very long time on large graphs. It can
also be used to test is the input graph has pathwidth <span class="math notranslate nohighlight">\(\leq k\)</span>, in which
cas it will return the first found solution with width <span class="math notranslate nohighlight">\(\leq k\)</span> is
<code class="docutils literal notranslate"><span class="pre">certificate==True</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">exponential</span></code> – Use an exponential time and space algorithm. This
algorithm only works of graphs on less than 32 vertices.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MILP</span></code> – Use a mixed integer linear programming formulation. This
algorithm has no size restriction but could take a very long time.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to display
information on the computations</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_prefix_length</span></code> – integer (default: 20); limits the length of the
stored prefixes to prevent storing too many prefixes. This parameter is
used only when <code class="docutils literal notranslate"><span class="pre">algorithm==&quot;BAB&quot;</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_prefix_number</span></code> – integer (default: 10**6); upper bound on the
number of stored prefixes used to prevent using too much memory. This
parameter is used only when <code class="docutils literal notranslate"><span class="pre">algorithm==&quot;BAB&quot;</span></code>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>Return the pathwidth of <code class="docutils literal notranslate"><span class="pre">self</span></code>. When <code class="docutils literal notranslate"><span class="pre">k</span></code> is specified, it returns
<code class="docutils literal notranslate"><span class="pre">False</span></code> when no path-decomposition of width <span class="math notranslate nohighlight">\(\leq k\)</span> exists or <code class="docutils literal notranslate"><span class="pre">True</span></code>
otherwise. When <code class="docutils literal notranslate"><span class="pre">certificate=True</span></code>, the path-decomposition is also
returned.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.treewidth" title="sage.graphs.graph.Graph.treewidth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.treewidth()</span></code></a> – computes the treewidth of a graph</p></li>
<li><p><a class="reference internal" href="graph_decompositions/vertex_separation.html#sage.graphs.graph_decompositions.vertex_separation.vertex_separation" title="sage.graphs.graph_decompositions.vertex_separation.vertex_separation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertex_separation()</span></code></a>
– computes the vertex separation of a (di)graph</p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>The pathwidth of a cycle is equal to 2:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">pathwidth</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pw</span><span class="p">,</span> <span class="n">decomp</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">pathwidth</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">decomp</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="go">[{0, 1, 5}, {1, 2, 5}, {2, 3, 4}, {2, 4, 5}]</span>
</pre></div>
</div>
<p>The pathwidth of a Petersen graph is 5:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">pathwidth</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">pathwidth</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">pathwidth</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">pathwidth</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(True, Graph on 5 vertices)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.perfect_matchings">
<span class="sig-name descname"><span class="pre">perfect_matchings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.perfect_matchings" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over all perfect matchings of the graph.</p>
<p>ALGORITHM:</p>
<p>Choose a vertex <span class="math notranslate nohighlight">\(v\)</span>, then recurse through all edges incident to <span class="math notranslate nohighlight">\(v\)</span>,
removing one edge at a time whenever an edge is added to a matching.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); when <code class="docutils literal notranslate"><span class="pre">True</span></code>, the edges
in each perfect matching are triples (containing the label as the
third element), otherwise the edges are pairs.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.graphs.graph.Graph.matching" title="sage.graphs.graph.Graph.matching"><code class="xref py py-meth docutils literal notranslate"><span class="pre">matching()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">GridGraph</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">perfect_matchings</span><span class="p">():</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
<span class="go">[((0, 0), (0, 1)), ((0, 2), (1, 2)), ((1, 0), (1, 1))]</span>
<span class="go">[((0, 0), (1, 0)), ((0, 1), (0, 2)), ((1, 1), (1, 2))]</span>
<span class="go">[((0, 0), (1, 0)), ((0, 1), (1, 1)), ((0, 2), (1, 2))]</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">perfect_matchings</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
<span class="go">[(0, 1, None), (2, 3, None)]</span>
<span class="go">[(0, 2, None), (1, 3, None)]</span>
<span class="go">[(0, 3, None), (1, 2, None)]</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">perfect_matchings</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[[(-2, 1, &#39;x&#39;), (-1, 2, &#39;y&#39;)], [(-2, 2, &#39;b&#39;), (-1, 1, &#39;a&#39;)]]</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">mpc</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">matching_polynomial</span><span class="p">()</span><span class="o">.</span><span class="n">coefficients</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">perfect_matchings</span><span class="p">()))</span> <span class="o">==</span> <span class="n">mpc</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">immutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">perfect_matchings</span><span class="p">()]</span>
<span class="go">[[(0, 1), (2, 3), (4, 9), (5, 7), (6, 8)],</span>
<span class="go"> [(0, 1), (2, 7), (3, 4), (5, 8), (6, 9)],</span>
<span class="go"> [(0, 4), (1, 2), (3, 8), (5, 7), (6, 9)],</span>
<span class="go"> [(0, 4), (1, 6), (2, 3), (5, 8), (7, 9)],</span>
<span class="go"> [(0, 5), (1, 2), (3, 4), (6, 8), (7, 9)],</span>
<span class="go"> [(0, 5), (1, 6), (2, 7), (3, 8), (4, 9)]]</span>

<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">perfect_matchings</span><span class="p">())</span>
<span class="go">[[]]</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">perfect_matchings</span><span class="p">())</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.periphery">
<span class="sig-name descname"><span class="pre">periphery</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">by_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.periphery" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the set of vertices in the periphery of the graph.</p>
<p>The periphery is the set of vertices whose eccentricity is equal to the
diameter of the graph, i.e., achieving the maximum eccentricity.</p>
<p>For more information and examples on how to use input variables,
see <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.shortest_paths" title="sage.graphs.generic_graph.GenericGraph.shortest_paths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shortest_paths()</span></code></a> and
<a class="reference internal" href="#sage.graphs.graph.Graph.eccentricity" title="sage.graphs.graph.Graph.eccentricity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eccentricity()</span></code></a></p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">by_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, edge
weights are taken into account; if False, all edges have weight 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); see method
<a class="reference internal" href="#sage.graphs.graph.Graph.eccentricity" title="sage.graphs.graph.Graph.eccentricity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eccentricity()</span></code></a> for the list of available algorithms</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
takes as input an edge <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></code> and outputs its weight. If not
<code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is automatically set to <code class="docutils literal notranslate"><span class="pre">True</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>
and <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, we use the edge label <code class="docutils literal notranslate"><span class="pre">l</span></code> as a
weight, if <code class="docutils literal notranslate"><span class="pre">l</span></code> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, else <code class="docutils literal notranslate"><span class="pre">1</span></code> as a weight.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, we check
that the <code class="docutils literal notranslate"><span class="pre">weight_function</span></code> outputs a number for each edge</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DiamondGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">periphery</span><span class="p">()</span>
<span class="go">[0, 3]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">periphery</span><span class="p">())</span> <span class="o">==</span> <span class="n">P</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">StarGraph</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">periphery</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">periphery</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">periphery</span><span class="p">()</span>
<span class="go">[0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.private_neighbors">
<span class="sig-name descname"><span class="pre">private_neighbors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dom</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.private_neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the private neighbors of a vertex with respect to other vertices.</p>
<p>A private neighbor of a vertex <span class="math notranslate nohighlight">\(v\)</span> with respect to a vertex subset <span class="math notranslate nohighlight">\(D\)</span>
is a closed neighbor of <span class="math notranslate nohighlight">\(v\)</span> that is not dominated by a vertex of <span class="math notranslate nohighlight">\(D
\setminus \{v\}\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertex</span></code> – a vertex of <code class="docutils literal notranslate"><span class="pre">G</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dom</span></code> – iterable of vertices of <code class="docutils literal notranslate"><span class="pre">G</span></code>; the vertices possibly stealing
private neighbors from <code class="docutils literal notranslate"><span class="pre">vertex</span></code>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>Return the closed neighbors of <code class="docutils literal notranslate"><span class="pre">vertex</span></code> that are not closed neighbors
of any other vertex of <code class="docutils literal notranslate"><span class="pre">dom</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">private_neighbors</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]))</span>
<span class="go">[1, 0]</span>

<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">private_neighbors</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]))</span>
<span class="go">[1, 0]</span>

<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">private_neighbors</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.radius">
<span class="sig-name descname"><span class="pre">radius</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">by_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DHV'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.radius" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the radius of the graph.</p>
<p>The radius is defined to be the minimum eccentricity of any vertex,
where the eccentricity is the maximum distance to any other
vertex. For more information and examples on how to use input variables,
see <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.shortest_paths" title="sage.graphs.generic_graph.GenericGraph.shortest_paths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shortest_paths()</span></code></a> and
<a class="reference internal" href="#sage.graphs.graph.Graph.eccentricity" title="sage.graphs.graph.Graph.eccentricity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eccentricity()</span></code></a></p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">by_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, edge
weights are taken into account; if False, all edges have weight 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">'DHV'</span></code>).</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'DHV'</span></code> - Radius computation is done using the algorithm proposed
in <a class="reference internal" href="../../../references/index.html#dragan2018" id="id74"><span>[Dragan2018]</span></a>. Works for graph with non-negative edge weights.
For more information see method
<a class="reference internal" href="distances_all_pairs.html#sage.graphs.distances_all_pairs.radius_DHV" title="sage.graphs.distances_all_pairs.radius_DHV"><code class="xref py py-func docutils literal notranslate"><span class="pre">sage.graphs.distances_all_pairs.radius_DHV()</span></code></a> and
<a class="reference internal" href="base/boost_graph.html#sage.graphs.base.boost_graph.radius_DHV" title="sage.graphs.base.boost_graph.radius_DHV"><code class="xref py py-func docutils literal notranslate"><span class="pre">sage.graphs.base.boost_graph.radius_DHV()</span></code></a>.</p></li>
<li><p>see method <a class="reference internal" href="#sage.graphs.graph.Graph.eccentricity" title="sage.graphs.graph.Graph.eccentricity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eccentricity()</span></code></a> for the list of remaining algorithms</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
takes as input an edge <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></code> and outputs its weight. If not
<code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is automatically set to <code class="docutils literal notranslate"><span class="pre">True</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>
and <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, we use the edge label <code class="docutils literal notranslate"><span class="pre">l</span></code> as a
weight, if <code class="docutils literal notranslate"><span class="pre">l</span></code> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, else <code class="docutils literal notranslate"><span class="pre">1</span></code> as a weight.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, we check
that the <code class="docutils literal notranslate"><span class="pre">weight_function</span></code> outputs a number for each edge</p></li>
</ul>
<p>EXAMPLES:</p>
<p>The more symmetric a graph is, the smaller (diameter - radius) is:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">BarbellGraph</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">radius</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">diameter</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">OctahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">radius</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">diameter</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.random_orientation">
<span class="sig-name descname"><span class="pre">random_orientation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.random_orientation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a random orientation of a graph <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>An <em>orientation</em> of an undirected graph is a directed graph such that every
edge is assigned a direction. Hence there are <span class="math notranslate nohighlight">\(2^m\)</span> oriented digraphs for a
simple graph with <span class="math notranslate nohighlight">\(m\)</span> edges.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a Graph.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.orientations</span> <span class="kn">import</span> <span class="n">random_orientation</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">random_orientation</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">order</span><span class="p">()</span> <span class="o">==</span> <span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">(),</span> <span class="n">D</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">G</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">(True, True)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.orientations" title="sage.graphs.graph.Graph.orientations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">orientations()</span></code></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.random_spanning_tree">
<span class="sig-name descname"><span class="pre">random_spanning_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_as_graph</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">by_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.random_spanning_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a random spanning tree of the graph.</p>
<p>This uses the Aldous-Broder algorithm (<a class="reference internal" href="../../../references/index.html#bro1989" id="id75"><span>[Bro1989]</span></a>, <a class="reference internal" href="../../../references/index.html#ald1990" id="id76"><span>[Ald1990]</span></a>) to generate
a random spanning tree with the uniform distribution, as follows.</p>
<p>Start from any vertex. Perform a random walk by choosing at every step one
neighbor uniformly at random. Every time a new vertex <span class="math notranslate nohighlight">\(j\)</span> is met, add the
edge <span class="math notranslate nohighlight">\((i, j)\)</span> to the spanning tree, where <span class="math notranslate nohighlight">\(i\)</span> is the previous vertex in the
random walk.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> or a weight function is given, the selection
of the neighbor is done proportionaly to the edge weights.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – an undirected graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output_as_graph</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return a
list of edges or a graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">by_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, the edges in
the graph are weighted, otherwise all edges have weight 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that takes
as input an edge <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></code> and outputs its weight. If not <code class="docutils literal notranslate"><span class="pre">None</span></code>,
<code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is automatically set to <code class="docutils literal notranslate"><span class="pre">True</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code> and
<code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, we use the edge label <code class="docutils literal notranslate"><span class="pre">l</span></code> , if <code class="docutils literal notranslate"><span class="pre">l</span></code> is not
<code class="docutils literal notranslate"><span class="pre">None</span></code>, else <code class="docutils literal notranslate"><span class="pre">1</span></code> as a weight. The <code class="docutils literal notranslate"><span class="pre">weight_function</span></code> can be used to
transform the label into a weight (note that, if the weight returned is
not convertible to a float, an error is raised)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether to check that
the <code class="docutils literal notranslate"><span class="pre">weight_function</span></code> outputs a number for each edge.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.spanning_trees_count" title="sage.graphs.generic_graph.GenericGraph.spanning_trees_count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spanning_trees_count()</span></code></a>
and <a class="reference internal" href="#sage.graphs.graph.Graph.spanning_trees" title="sage.graphs.graph.Graph.spanning_trees"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spanning_trees()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">TietzeGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">random_spanning_tree</span><span class="p">(</span><span class="n">output_as_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Graph on 12 vertices</span>
<span class="gp">sage: </span><span class="n">rg</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">random_spanning_tree</span><span class="p">();</span> <span class="n">rg</span> <span class="c1"># random</span>
<span class="go">[(0, 9),</span>
<span class="go">(9, 11),</span>
<span class="go">(0, 8),</span>
<span class="go">(8, 7),</span>
<span class="go">(7, 6),</span>
<span class="go">(7, 2),</span>
<span class="go">(2, 1),</span>
<span class="go">(1, 5),</span>
<span class="go">(9, 10),</span>
<span class="go">(5, 4),</span>
<span class="go">(2, 3)]</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">rg</span><span class="p">)</span><span class="o">.</span><span class="n">is_tree</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A visual example for the grid graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pos</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">get_pos</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">random_spanning_tree</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">set_pos</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">vertex_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>We can also use edge weights to change the probability of returning a
spanning tree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">S</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="n">E</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">random_spanning_tree</span><span class="p">(</span><span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">....: </span>        <span class="n">S</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Graph</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">graph6_string</span><span class="p">())</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">S</span>
<span class="gp">sage: </span><span class="n">K3</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">K3</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">K3</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">foo</span><span class="p">(</span><span class="n">K3</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;BW&#39;</span><span class="p">,</span> <span class="s1">&#39;Bg&#39;</span><span class="p">,</span> <span class="s1">&#39;Bo&#39;</span><span class="p">}</span>  <span class="c1"># random</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">K4</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">K4</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">K4</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">foo</span><span class="p">(</span><span class="n">K4</span><span class="p">,</span> <span class="mi">100</span><span class="p">)))</span>  <span class="c1"># random</span>
<span class="go">16</span>
</pre></div>
</div>
<p>Check that the spanning tree returned when using weights is a tree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomBarabasiAlbert</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">G</span><span class="o">.</span><span class="n">set_edge_label</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">random_spanning_tree</span><span class="p">(</span><span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">output_as_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">is_tree</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.rank_decomposition">
<span class="sig-name descname"><span class="pre">rank_decomposition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.rank_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an optimal rank-decomposition of the given graph.</p>
<p>This function is available as a method of the <a class="reference internal" href="#module-sage.graphs.graph" title="sage.graphs.graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a> class. See <a class="reference internal" href="#sage.graphs.graph.Graph.rank_decomposition" title="sage.graphs.graph.Graph.rank_decomposition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rank_decomposition</span></code></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to display progress
information while computing the decomposition</p></li>
</ul>
<p>OUTPUT:</p>
<p>A pair <code class="docutils literal notranslate"><span class="pre">(rankwidth,</span> <span class="pre">decomposition_tree)</span></code>, where <code class="docutils literal notranslate"><span class="pre">rankwidth</span></code> is a
numerical value and <code class="docutils literal notranslate"><span class="pre">decomposition_tree</span></code> is a ternary tree describing the
decomposition (cf. the module’s documentation).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions.rankwidth</span> <span class="kn">import</span> <span class="n">rank_decomposition</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">rank_decomposition</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">(3, Graph on 19 vertices)</span>
</pre></div>
</div>
<p>On more than 32 vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mf">.5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">rank_decomposition</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">RuntimeError: the rank decomposition cannot be computed on graphs of &gt;= 32 vertices</span>
</pre></div>
</div>
<p>The empty graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">rank_decomposition</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">(0, Graph on 0 vertices)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.seidel_adjacency_matrix">
<span class="sig-name descname"><span class="pre">seidel_adjacency_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.seidel_adjacency_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Seidel adjacency matrix of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Returns <span class="math notranslate nohighlight">\(J-I-2A\)</span>, for <span class="math notranslate nohighlight">\(A\)</span> the (ordinary) <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.adjacency_matrix" title="sage.graphs.generic_graph.GenericGraph.adjacency_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">adjacency</span> <span class="pre">matrix</span></code></a> of <code class="docutils literal notranslate"><span class="pre">self</span></code>,
<span class="math notranslate nohighlight">\(I\)</span> the identity matrix, and <span class="math notranslate nohighlight">\(J\)</span> the all-1 matrix.  It is closely
related to <a class="reference internal" href="#sage.graphs.graph.Graph.twograph" title="sage.graphs.graph.Graph.twograph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">twograph()</span></code></a>.</p>
<p>The matrix returned is over the integers. If a different ring is
desired, use either the <a class="reference external" href="../../../matrices/sage/matrix/matrix0.html#sage.matrix.matrix0.Matrix.change_ring" title="(in Sage 9.5 Reference Manual: Matrices and Spaces of Matrices v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.matrix.matrix0.Matrix.change_ring()</span></code></a>
method or the <a class="reference external" href="../../../matrices/sage/matrix/constructor.html#sage.matrix.constructor.matrix" title="(in Sage 9.5 Reference Manual: Matrices and Spaces of Matrices v9.5)"><code class="xref py py-func docutils literal notranslate"><span class="pre">matrix()</span></code></a> function.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – list of vertices (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the ordering of
the vertices defining how they should appear in the matrix. By
default, the ordering given by
<a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.vertices" title="sage.graphs.generic_graph.GenericGraph.vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertices()</span></code></a> is used.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">seidel_adjacency_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">minpoly</span><span class="p">()</span>
<span class="go">x^2 - 5</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.seidel_switching">
<span class="sig-name descname"><span class="pre">seidel_switching</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.seidel_switching" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Seidel switching of <code class="docutils literal notranslate"><span class="pre">self</span></code> w.r.t. subset of vertices <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p>
<p>Returns the graph obtained by Seidel switching of <code class="docutils literal notranslate"><span class="pre">self</span></code> with respect
to the subset of vertices <code class="docutils literal notranslate"><span class="pre">s</span></code>. This is the graph given by Seidel
adjacency matrix <span class="math notranslate nohighlight">\(DSD\)</span>, for <span class="math notranslate nohighlight">\(S\)</span> the Seidel adjacency matrix of <code class="docutils literal notranslate"><span class="pre">self</span></code>,
and <span class="math notranslate nohighlight">\(D\)</span> the diagonal matrix with -1s at positions corresponding to
<code class="docutils literal notranslate"><span class="pre">s</span></code>, and 1s elsewhere.</p>
<p>INPUT:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code> – a list of vertices of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">inplace</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether to do the
modification inplace, or to return a copy of the graph after
switching.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">seidel_switching</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">seidel_adjacency_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">minpoly</span><span class="p">()</span>
<span class="go">x^2 - 5</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.spanning_trees">
<span class="sig-name descname"><span class="pre">spanning_trees</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.spanning_trees" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over all spanning trees of the graph <span class="math notranslate nohighlight">\(g\)</span>.</p>
<p>A disconnected graph has no spanning tree.</p>
<p>Uses the Read-Tarjan backtracking algorithm <a class="reference internal" href="../../../references/index.html#rt1975a" id="id77"><span>[RT1975a]</span></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return edges labels
in the spanning trees or not</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)],</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">spanning_trees</span><span class="p">()))</span>
<span class="go">8</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">spanning_trees_count</span><span class="p">()</span>
<span class="go">8</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">)],</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">spanning_trees</span><span class="p">()))</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">spanning_trees_count</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.spanning_trees_count" title="sage.graphs.generic_graph.GenericGraph.spanning_trees_count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spanning_trees_count()</span></code></a>
– counts the number of spanning trees</p></li>
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.random_spanning_tree" title="sage.graphs.graph.Graph.random_spanning_tree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">random_spanning_tree()</span></code></a>
– returns a random spanning tree</p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.sparse6_string">
<span class="sig-name descname"><span class="pre">sparse6_string</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.sparse6_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sparse6 representation of the graph as an ASCII string.</p>
<p>Only valid for undirected graphs on 0 to 262143 vertices, but loops
and multiple edges are permitted.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As the sparse6 format only handles graphs whose vertex set is
<span class="math notranslate nohighlight">\(\{0,...,n-1\}\)</span>, a <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.relabel" title="sage.graphs.generic_graph.GenericGraph.relabel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relabelled</span> <span class="pre">copy</span></code></a> of your graph will
be encoded if necessary.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">BullGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">sparse6_string</span><span class="p">()</span>
<span class="go">&#39;:Da@en&#39;</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">data_structure</span><span class="o">=</span><span class="s2">&quot;sparse&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;:?&#39;</span><span class="p">,</span> <span class="n">data_structure</span><span class="o">=</span><span class="s2">&quot;sparse&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">G</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.spqr_tree">
<span class="sig-name descname"><span class="pre">spqr_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Hopcroft_Tarjan'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.spqr_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an SPQR-tree representing the triconnected components of the graph.</p>
<p>An SPQR-tree is a tree data structure used to represent the triconnected
components of a biconnected (multi)graph and the 2-vertex cuts separating
them. A node of a SPQR-tree, and the graph associated with it, can be one of
the following four types:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;S&quot;</span></code> – the associated graph is a cycle with at least three vertices.
<code class="docutils literal notranslate"><span class="pre">&quot;S&quot;</span></code> stands for <code class="docutils literal notranslate"><span class="pre">series</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;P&quot;</span></code> – the associated graph is a dipole graph, a multigraph with two
vertices and three or more edges. <code class="docutils literal notranslate"><span class="pre">&quot;P&quot;</span></code> stands for <code class="docutils literal notranslate"><span class="pre">parallel</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Q&quot;</span></code> – the associated graph has a single real edge. This trivial case
is necessary to handle the graph that has only one edge.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;R&quot;</span></code> – the associated graph is a 3-connected graph that is not a cycle
or dipole. <code class="docutils literal notranslate"><span class="pre">&quot;R&quot;</span></code> stands for <code class="docutils literal notranslate"><span class="pre">rigid</span></code>.</p></li>
</ul>
<p>This method decomposes a biconnected graph into cycles, cocycles, and
3-connected blocks summed over cocycles, and arranges them as a SPQR-tree.
More precisely, it splits the graph at each of its 2-vertex cuts, giving a
unique decomposition into 3-connected blocks, cycles and cocycles. The
cocycles are dipole graphs with one edge per real edge between the included
vertices and one additional (virtual) edge per connected component resulting
from deletion of the vertices in the cut. See the <a class="reference external" href="https://en.wikipedia.org/wiki/SPQR_tree">Wikipedia article SPQR_tree</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – the input graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">&quot;Hopcroft_Tarjan&quot;</span></code>); the algorithm to
use among:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Hopcroft_Tarjan&quot;</span></code> (default) – use the algorithm proposed by
Hopcroft and Tarjan in <a class="reference internal" href="../../../references/index.html#hopcroft1973" id="id78"><span>[Hopcroft1973]</span></a> and later corrected by Gutwenger
and Mutzel in <a class="reference internal" href="../../../references/index.html#gut2001" id="id79"><span>[Gut2001]</span></a>. See
<a class="reference internal" href="connectivity.html#sage.graphs.connectivity.TriconnectivitySPQR" title="sage.graphs.connectivity.TriconnectivitySPQR"><code class="xref py py-class docutils literal notranslate"><span class="pre">TriconnectivitySPQR</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;cleave&quot;</span></code> – using method <a class="reference internal" href="connectivity.html#sage.graphs.connectivity.cleave" title="sage.graphs.connectivity.cleave"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cleave()</span></code></a></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer Linear
Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one
is used. For more information on MILP solvers and which default solver is
used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of verbosity. Set
to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP solvers
over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>OUTPUT: <code class="docutils literal notranslate"><span class="pre">SPQR-tree</span></code> a tree whose vertices are labeled with the block’s type
and the subgraph of three-blocks in the decomposition.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.connectivity</span> <span class="kn">import</span> <span class="n">spqr_tree</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">G</span><span class="o">.</span><span class="n">add_clique</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(),</span> <span class="n">G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">()])</span>
<span class="gp">sage: </span><span class="n">Tree</span> <span class="o">=</span> <span class="n">spqr_tree</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Tree</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">K4</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">K4</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">Tree</span> <span class="k">if</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;R&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.connectivity</span> <span class="kn">import</span> <span class="n">spqr_tree_to_graph</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">spqr_tree_to_graph</span><span class="p">(</span><span class="n">Tree</span><span class="p">))</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">G</span><span class="o">.</span><span class="n">add_path</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(),</span> <span class="n">G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(),</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Tree</span> <span class="o">=</span> <span class="n">spqr_tree</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Tree</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">C4</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">C4</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">Tree</span> <span class="k">if</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;S&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">spqr_tree_to_graph</span><span class="p">(</span><span class="n">Tree</span><span class="p">))</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_multiple_edges</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">Tree</span> <span class="o">=</span> <span class="n">spqr_tree</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Tree</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">13</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">C4</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">Tree</span> <span class="k">if</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;S&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">spqr_tree_to_graph</span><span class="p">(</span><span class="n">Tree</span><span class="p">))</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Tree</span> <span class="o">=</span> <span class="n">spqr_tree</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Tree</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">spqr_tree_to_graph</span><span class="p">(</span><span class="n">Tree</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Tree</span> <span class="o">=</span> <span class="n">spqr_tree</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Tree</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">spqr_tree_to_graph</span><span class="p">(</span><span class="n">Tree</span><span class="p">))</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;LlCG{O@?GBoMw?&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">spqr_tree</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Hopcroft_Tarjan&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">spqr_tree_to_graph</span><span class="p">(</span><span class="n">T</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">T2</span> <span class="o">=</span> <span class="n">spqr_tree</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;cleave&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">spqr_tree_to_graph</span><span class="p">(</span><span class="n">T2</span><span class="p">))</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">spqr_tree</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;cleave&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[(&#39;Q&#39;, Multi-graph on 2 vertices)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">spqr_tree_to_graph</span><span class="p">(</span><span class="n">T</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">spqr_tree</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Hopcroft_Tarjan&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[(&#39;Q&#39;, Multi-graph on 2 vertices)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">spqr_tree</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;cleave&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[(&#39;P&#39;, Multi-graph on 2 vertices)]</span>

<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">spqr_tree</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Hopcroft_Tarjan&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Counter</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">T</span><span class="p">)</span>
<span class="go">Counter({&#39;R&#39;: 1})</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">spqr_tree</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;cleave&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Counter</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">T</span><span class="p">)</span>
<span class="go">Counter({&#39;R&#39;: 1})</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)):</span>
<span class="gp">....: </span>    <span class="n">G</span><span class="o">.</span><span class="n">add_path</span><span class="p">([</span><span class="n">u</span><span class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(),</span> <span class="n">G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(),</span> <span class="n">v</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">spqr_tree</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Hopcroft_Tarjan&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;P&#39;, 15), (&#39;R&#39;, 1), (&#39;S&#39;, 15)]</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">spqr_tree</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;cleave&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;P&#39;, 15), (&#39;R&#39;, 1), (&#39;S&#39;, 15)]</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)):</span>
<span class="gp">....: </span>    <span class="n">G</span><span class="o">.</span><span class="n">add_path</span><span class="p">([</span><span class="n">u</span><span class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(),</span> <span class="n">G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(),</span> <span class="n">v</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">spqr_tree</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Hopcroft_Tarjan&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;P&#39;, 60), (&#39;R&#39;, 1), (&#39;S&#39;, 75)]</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">spqr_tree</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;cleave&quot;</span><span class="p">)</span>       <span class="c1"># long time</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>  <span class="c1"># long time</span>
<span class="go">[(&#39;P&#39;, 60), (&#39;R&#39;, 1), (&#39;S&#39;, 75)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.strong_orientation">
<span class="sig-name descname"><span class="pre">strong_orientation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.strong_orientation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a strongly connected orientation of the current graph.</p>
<p>An orientation of an undirected graph is a digraph obtained by giving an
unique direction to each of its edges. An orientation is said to be
strong if there is a directed path between each pair of vertices.  See
also the <a class="reference external" href="https://en.wikipedia.org/wiki/Strongly_connected_component">Wikipedia article Strongly_connected_component</a>.</p>
<p>If the graph is 2-edge-connected, a strongly connected orientation
can be found in linear time. If the given graph is not 2-connected,
the orientation returned will ensure that each 2-connected component
has a strongly connected orientation.</p>
<p>OUTPUT:</p>
<p>A digraph representing an orientation of the current graph.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>This method assumes the graph is connected.</p></li>
<li><p>This algorithm works in O(m).</p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>For a 2-regular graph, a strong orientation gives to each vertex an
out-degree equal to 1:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">strong_orientation</span><span class="p">()</span><span class="o">.</span><span class="n">out_degree</span><span class="p">()</span>
<span class="go">[1, 1, 1, 1, 1]</span>
</pre></div>
</div>
<p>The Petersen Graph is 2-edge connected. It then has a strongly connected
orientation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">strong_orientation</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">strongly_connected_components</span><span class="p">())</span>
<span class="go">1</span>
</pre></div>
</div>
<p>The same goes for the CubeGraph in any dimension</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">strong_orientation</span><span class="p">()</span><span class="o">.</span><span class="n">strongly_connected_components</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A multigraph also has a strong orientation</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">strong_orientation</span><span class="p">()</span>
<span class="go">Multi-digraph on 2 vertices</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.strong_orientations_iterator">
<span class="sig-name descname"><span class="pre">strong_orientations_iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.strong_orientations_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator over all strong orientations of a graph <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>A strong orientation of a graph is an orientation of its edges such that
the obtained digraph is strongly connected (i.e. there exist a directed path
between each pair of vertices).</p>
<p>ALGORITHM:</p>
<p>It is an adaptation of the algorithm published in <a class="reference internal" href="../../../references/index.html#cgmrv16" id="id80"><span>[CGMRV16]</span></a>.
It runs in <span class="math notranslate nohighlight">\(O(mn)\)</span> amortized time, where <span class="math notranslate nohighlight">\(m\)</span> is the number of edges and
<span class="math notranslate nohighlight">\(n\)</span> is the number of vertices. The amortized time can be improved to <span class="math notranslate nohighlight">\(O(m)\)</span>
with a more involved method.
In this function, first the graph is preprocessed and a spanning tree is
generated. Then every orientation of the non-tree edges of the graph can be
extended to at least one new strong orientation by orienting properly
the edges of the spanning tree (this property is proved in <a class="reference internal" href="../../../references/index.html#cgmrv16" id="id81"><span>[CGMRV16]</span></a>).
Therefore, this function generates all partial orientations of the non-tree
edges and then launches a helper function corresponding to the generation
algorithm described in <a class="reference internal" href="../../../references/index.html#cgmrv16" id="id82"><span>[CGMRV16]</span></a>.
In order to avoid trivial symmetries, the orientation of an arbitrary edge
is fixed before the start of the enumeration process.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – an undirected graph.</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>an iterator which will produce all strong orientations of this graph.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Works only for simple graphs (no multiple edges).
To avoid symmetries an orientation of an arbitrary edge is fixed.</p>
</div>
<p>EXAMPLES:</p>
<p>A cycle has one possible (non-symmetric) strong orientation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">strong_orientations_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">it</span><span class="p">))</span>
<span class="go">1</span>
</pre></div>
</div>
<p>A tree cannot be strongly oriented:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomTree</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">strong_orientations_iterator</span><span class="p">()))</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Neither can be a disconnected graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">strong_orientations_iterator</span><span class="p">()))</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.to_directed">
<span class="sig-name descname"><span class="pre">to_directed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_structure</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.to_directed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a directed version of the graph.</p>
<p>A single edge becomes two edges, one in each direction.</p>
<p>INPUT:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">data_structure</span></code> – one of <code class="docutils literal notranslate"><span class="pre">&quot;sparse&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;static_sparse&quot;</span></code>, or
<code class="docutils literal notranslate"><span class="pre">&quot;dense&quot;</span></code>. See the documentation of <a class="reference internal" href="#sage.graphs.graph.Graph" title="sage.graphs.graph.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a> or
<a class="reference internal" href="digraph.html#sage.graphs.digraph.DiGraph" title="sage.graphs.digraph.DiGraph"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraph</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sparse</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); <code class="docutils literal notranslate"><span class="pre">sparse=True</span></code> is an
alias for <code class="docutils literal notranslate"><span class="pre">data_structure=&quot;sparse&quot;</span></code>, and <code class="docutils literal notranslate"><span class="pre">sparse=False</span></code> is an
alias for <code class="docutils literal notranslate"><span class="pre">data_structure=&quot;dense&quot;</span></code>.</p></li>
</ul>
</div></blockquote>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
<span class="go">Petersen graph: Digraph on 10 vertices</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.to_undirected">
<span class="sig-name descname"><span class="pre">to_undirected</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.to_undirected" title="Permalink to this definition">¶</a></dt>
<dd><p>Since the graph is already undirected, simply returns a copy of itself.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">to_undirected</span><span class="p">()</span>
<span class="go">Petersen graph: Graph on 10 vertices</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.topological_minor">
<span class="sig-name descname"><span class="pre">topological_minor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">paths</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.topological_minor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a topological <span class="math notranslate nohighlight">\(H\)</span>-minor from <code class="docutils literal notranslate"><span class="pre">self</span></code> if one exists.</p>
<p>We say that a graph <span class="math notranslate nohighlight">\(G\)</span> has a topological <span class="math notranslate nohighlight">\(H\)</span>-minor (or that it has a
graph isomorphic to <span class="math notranslate nohighlight">\(H\)</span> as a topological minor), if <span class="math notranslate nohighlight">\(G\)</span> contains a
subdivision of a graph isomorphic to <span class="math notranslate nohighlight">\(H\)</span> (i.e.  obtained from <span class="math notranslate nohighlight">\(H\)</span>
through arbitrary subdivision of its edges) as a subgraph.</p>
<p>For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Minor_(graph_theory)">Wikipedia article Minor_(graph_theory)</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">H</span></code> – The topological minor to find in the current graph.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>The topological <span class="math notranslate nohighlight">\(H\)</span>-minor found is returned as a subgraph <span class="math notranslate nohighlight">\(M\)</span> of
<code class="docutils literal notranslate"><span class="pre">self</span></code>, such that the vertex <span class="math notranslate nohighlight">\(v\)</span> of <span class="math notranslate nohighlight">\(M\)</span> that represents a vertex <span class="math notranslate nohighlight">\(h\in
H\)</span> has <code class="docutils literal notranslate"><span class="pre">h</span></code> as a label (see <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.get_vertex" title="sage.graphs.generic_graph.GenericGraph.get_vertex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_vertex</span></code></a> and
<a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.set_vertex" title="sage.graphs.generic_graph.GenericGraph.set_vertex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_vertex</span></code></a>),
and such that every edge of <span class="math notranslate nohighlight">\(M\)</span> has as a label the edge of <span class="math notranslate nohighlight">\(H\)</span> it
(partially) represents.</p>
<p>If no topological minor is found, this method returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>ALGORITHM:</p>
<p>Mixed Integer Linear Programming.</p>
<p>COMPLEXITY:</p>
<p>Theoretically, when <span class="math notranslate nohighlight">\(H\)</span> is fixed, testing for the existence of a
topological <span class="math notranslate nohighlight">\(H\)</span>-minor is polynomial. The known algorithms are highly
exponential in <span class="math notranslate nohighlight">\(H\)</span>, though.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function can be expected to be <em>very</em> slow, especially where
the topological minor does not exist.</p>
<p>(CPLEX seems to be <em>much</em> more efficient than GLPK on this kind of
problem)</p>
</div>
<p>EXAMPLES:</p>
<p>Petersen’s graph has a topological <span class="math notranslate nohighlight">\(K_4\)</span>-minor:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">topological_minor</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">Subgraph of (Petersen graph): Graph on ...</span>
</pre></div>
</div>
<p>And a topological <span class="math notranslate nohighlight">\(K_{3,3}\)</span>-minor:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">topological_minor</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="go">Subgraph of (Petersen graph): Graph on ...</span>
</pre></div>
</div>
<p>And of course, a tree has no topological <span class="math notranslate nohighlight">\(C_3\)</span>-minor:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mf">.3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">edges</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">topological_minor</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.treelength">
<span class="sig-name descname"><span class="pre">treelength</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.treelength" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the treelength of <span class="math notranslate nohighlight">\(G\)</span> (and provide a decomposition).</p>
<p>The <em>length</em> of a tree decomposition, as proposed in <a class="reference internal" href="../../../references/index.html#dg2006" id="id83"><span>[DG2006]</span></a>, is the
maximum <em>diameter</em> in <span class="math notranslate nohighlight">\(G\)</span> of its bags, where the diameter of a bag <span class="math notranslate nohighlight">\(X_i\)</span> is
the largest distance in <span class="math notranslate nohighlight">\(G\)</span> between the vertices in <span class="math notranslate nohighlight">\(X_i\)</span> (i.e., <span class="math notranslate nohighlight">\(\max_{u, v
\in X_i} dist_G(u, v)\)</span>). The <em>treelength</em> <span class="math notranslate nohighlight">\(tl(G)\)</span> of a graph <span class="math notranslate nohighlight">\(G\)</span> is the
minimum length among all possible tree decompositions of <span class="math notranslate nohighlight">\(G\)</span>.
See the documentation of the
<a class="reference internal" href="graph_decompositions/tree_decomposition.html#module-sage.graphs.graph_decompositions.tree_decomposition" title="sage.graphs.graph_decompositions.tree_decomposition"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tree_decomposition</span></code></a> module for more
details.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a sage Graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); indicates the length to be
considered. When <span class="math notranslate nohighlight">\(k\)</span> is an integer, the method checks that the graph has
treelength <span class="math notranslate nohighlight">\(\leq k\)</span>. If <span class="math notranslate nohighlight">\(k\)</span> is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), the method computes the
optimal treelength.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to also return
the tree-decomposition itself</p></li>
</ul>
<p>OUTPUT:</p>
<p><code class="docutils literal notranslate"><span class="pre">G.treelength()</span></code> returns the treelength of <span class="math notranslate nohighlight">\(G\)</span>. When <span class="math notranslate nohighlight">\(k\)</span> is specified, it
returns <code class="docutils literal notranslate"><span class="pre">False</span></code> when no tree-decomposition of length <span class="math notranslate nohighlight">\(\leq k\)</span> exists or
<code class="docutils literal notranslate"><span class="pre">True</span></code> otherwise. When <code class="docutils literal notranslate"><span class="pre">certificate=True</span></code>, the tree-decomposition is
also returned.</p>
<p>ALGORITHM:</p>
<p>This method virtually explores the graph of all pairs <code class="docutils literal notranslate"><span class="pre">(vertex_cut,</span>
<span class="pre">connected_component)</span></code>, where <code class="docutils literal notranslate"><span class="pre">vertex_cut</span></code> is a vertex cut of the graph of
length <span class="math notranslate nohighlight">\(\leq k\)</span>, and <code class="docutils literal notranslate"><span class="pre">connected_component</span></code> is a connected component of the
graph induced by <code class="docutils literal notranslate"><span class="pre">G</span> <span class="pre">-</span> <span class="pre">vertex_cut</span></code>.</p>
<p>We deduce that the pair <code class="docutils literal notranslate"><span class="pre">(vertex_cut,</span> <span class="pre">connected_component)</span></code> is feasible
with treelength <span class="math notranslate nohighlight">\(k\)</span> if <code class="docutils literal notranslate"><span class="pre">connected_component</span></code> is empty, or if a vertex
<code class="docutils literal notranslate"><span class="pre">v</span></code> from <code class="docutils literal notranslate"><span class="pre">vertex_cut</span></code> can be replaced with a vertex from
<code class="docutils literal notranslate"><span class="pre">connected_component</span></code>, such that the pair <code class="docutils literal notranslate"><span class="pre">(vertex_cut</span> <span class="pre">+</span> <span class="pre">v,</span>
<span class="pre">connected_component</span> <span class="pre">-</span> <span class="pre">v)</span></code> is feasible.</p>
<p>In practice, this method decomposes the graph by its clique minimal
separators into atoms, computes the treelength of each of atom and returns
the maximum value over all the atoms. Indeed, we have that <span class="math notranslate nohighlight">\(tl(G) = \max_{X
\in A} tl(G[X])\)</span> where <span class="math notranslate nohighlight">\(A\)</span> is the set of atoms of the decomposition by
clique separators of <span class="math notranslate nohighlight">\(G\)</span>. When <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">==</span> <span class="pre">True</span></code>, the
tree-decompositions of the atoms are connected to each others by adding
edges with respect to the clique separators.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.graphs.graph.Graph.treewidth" title="sage.graphs.graph.Graph.treewidth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">treewidth()</span></code></a> computes the treewidth of a graph.</p></li>
<li><p><a class="reference internal" href="graph_decompositions/vertex_separation.html#sage.graphs.graph_decompositions.vertex_separation.path_decomposition" title="sage.graphs.graph_decompositions.vertex_separation.path_decomposition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">path_decomposition()</span></code></a>
computes the pathwidth of a graph.</p></li>
<li><p>module <a class="reference internal" href="graph_decompositions/vertex_separation.html#module-sage.graphs.graph_decompositions.vertex_separation" title="sage.graphs.graph_decompositions.vertex_separation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vertex_separation</span></code></a>.</p></li>
<li><p><a class="reference internal" href="graph_decompositions/clique_separators.html#sage.graphs.graph_decompositions.clique_separators.atoms_and_clique_separators" title="sage.graphs.graph_decompositions.clique_separators.atoms_and_clique_separators"><code class="xref py py-meth docutils literal notranslate"><span class="pre">atoms_and_clique_separators()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>The PetersenGraph has treelength 2:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">treelength</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Disconnected graphs have infinite treelength:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">treelength</span><span class="p">()</span>
<span class="go">+Infinity</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">treelength</span><span class="p">(</span><span class="n">k</span><span class="o">=+</span><span class="n">Infinity</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">treelength</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">treelength</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: the tree decomposition of a disconnected graph is not defined</span>
</pre></div>
</div>
<p>Chordal graphs have treelength 1:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomChordalGraph</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">while</span> <span class="ow">not</span> <span class="n">G</span><span class="o">.</span><span class="n">is_connected</span><span class="p">():</span>
<span class="gp">....: </span>    <span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomChordalGraph</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">treelength</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Cycles have treelength <span class="math notranslate nohighlight">\(\lceil n/3 \rceil\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">treelength</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">)]</span>
<span class="go">[1, 2, 2, 2, 3, 3, 3, 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.treewidth">
<span class="sig-name descname"><span class="pre">treewidth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.treewidth" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the treewidth of <span class="math notranslate nohighlight">\(g\)</span> (and provide a decomposition).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">g</span></code> – a sage Graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); indicates the width to be
considered. When <code class="docutils literal notranslate"><span class="pre">k</span></code> is an integer, the method checks that the graph has
treewidth <span class="math notranslate nohighlight">\(\leq k\)</span>. If <code class="docutils literal notranslate"><span class="pre">k</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), the method computes
the optimal tree-width.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">kmin</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); when specified, search for a
tree-decomposition of width at least <code class="docutils literal notranslate"><span class="pre">kmin</span></code>. This parameter is useful
when the graph can be decomposed into atoms.  This parameter is ignored
when <code class="docutils literal notranslate"><span class="pre">k</span></code> is not <code class="docutils literal notranslate"><span class="pre">None</span></code> or when <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">==</span> <span class="pre">'tdlib'</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
tree-decomposition itself.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – whether to use <code class="docutils literal notranslate"><span class="pre">&quot;sage&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;tdlib&quot;</span></code> (requires the
installation of the ‘tdlib’ package). The default behaviour is to use
‘tdlib’ if it is available, and Sage’s own algorithm when it is not.</p></li>
</ul>
<p>OUTPUT:</p>
<p><code class="docutils literal notranslate"><span class="pre">g.treewidth()</span></code> returns the treewidth of <code class="docutils literal notranslate"><span class="pre">g</span></code>. When <code class="docutils literal notranslate"><span class="pre">k</span></code> is specified,
it returns <code class="docutils literal notranslate"><span class="pre">False</span></code> when no tree-decomposition of width <span class="math notranslate nohighlight">\(\leq k\)</span> exists or
<code class="docutils literal notranslate"><span class="pre">True</span></code> otherwise. When <code class="docutils literal notranslate"><span class="pre">certificate=True</span></code>, the tree-decomposition is
also returned.</p>
<p>ALGORITHM:</p>
<p>This function virtually explores the graph of all pairs <code class="docutils literal notranslate"><span class="pre">(vertex_cut,cc)</span></code>,
where <code class="docutils literal notranslate"><span class="pre">vertex_cut</span></code> is a vertex cut of the graph of cardinality <span class="math notranslate nohighlight">\(\leq k+1\)</span>,
and <code class="docutils literal notranslate"><span class="pre">connected_component</span></code> is a connected component of the graph induced by
<code class="docutils literal notranslate"><span class="pre">G-vertex_cut</span></code>.</p>
<p>We deduce that the pair <code class="docutils literal notranslate"><span class="pre">(vertex_cut,cc)</span></code> is feasible with tree-width <span class="math notranslate nohighlight">\(k\)</span>
if <code class="docutils literal notranslate"><span class="pre">cc</span></code> is empty, or if a vertex <code class="docutils literal notranslate"><span class="pre">v</span></code> from <code class="docutils literal notranslate"><span class="pre">vertex_cut</span></code> can be replaced
with a vertex from <code class="docutils literal notranslate"><span class="pre">cc</span></code>, such that the pair <code class="docutils literal notranslate"><span class="pre">(vertex_cut+v,cc-v)</span></code> is
feasible.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The implementation would be much faster if <code class="docutils literal notranslate"><span class="pre">cc</span></code>, the argument of the
recursive function, was a bitset. It would also be very nice to not copy
the graph in order to compute connected components, for this is really a
waste of time.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="graph_decompositions/vertex_separation.html#sage.graphs.graph_decompositions.vertex_separation.path_decomposition" title="sage.graphs.graph_decompositions.vertex_separation.path_decomposition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">path_decomposition()</span></code></a>
computes the pathwidth of a graph. See also the
<a class="reference internal" href="graph_decompositions/vertex_separation.html#module-sage.graphs.graph_decompositions.vertex_separation" title="sage.graphs.graph_decompositions.vertex_separation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vertex_separation</span></code></a> module.</p>
</div>
<p>EXAMPLES:</p>
<p>The PetersenGraph has treewidth 4:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">treewidth</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">treewidth</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Tree decomposition: Graph on 6 vertices</span>
</pre></div>
</div>
<p>The treewidth of a 2d grid is its smallest side:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">treewidth</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">treewidth</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>When parameter <code class="docutils literal notranslate"><span class="pre">kmin</span></code> is specified, the method search for a
tree-decomposition of width at least <code class="docutils literal notranslate"><span class="pre">kmin</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">treewidth</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">treewidth</span><span class="p">(</span><span class="n">kmin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;sage&#39;</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">treewidth</span><span class="p">(</span><span class="n">kmin</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">(),</span> <span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;sage&#39;</span><span class="p">)</span>
<span class="go">Tree decomposition: Graph on 1 vertex</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.tutte_polynomial">
<span class="sig-name descname"><span class="pre">tutte_polynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_selector</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cache</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.tutte_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Tutte polynomial of the graph <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">edge_selector</span></code> (optional; method) this argument allows the user
to specify his own heuristic for selecting edges used in the deletion
contraction recurrence</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cache</span></code> – (optional; dict) a dictionary to cache the Tutte
polynomials generated in the recursive process.  One will be
created automatically if not provided.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>The Tutte polynomial of any tree of order <span class="math notranslate nohighlight">\(n\)</span> is <span class="math notranslate nohighlight">\(x^{n-1}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">tutte_polynomial</span><span class="p">()</span> <span class="o">==</span> <span class="n">x</span><span class="o">**</span><span class="mi">9</span> <span class="k">for</span> <span class="n">T</span> <span class="ow">in</span> <span class="n">graphs</span><span class="o">.</span><span class="n">trees</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Tutte polynomial of the Petersen graph is:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">tutte_polynomial</span><span class="p">()</span>
<span class="go">x^9 + 6*x^8 + 21*x^7 + 56*x^6 + 12*x^5*y + y^6 + 114*x^5 + 70*x^4*y</span>
<span class="go">+ 30*x^3*y^2 + 15*x^2*y^3 + 10*x*y^4 + 9*y^5 + 170*x^4 + 170*x^3*y</span>
<span class="go">+ 105*x^2*y^2 + 65*x*y^3 + 35*y^4 + 180*x^3 + 240*x^2*y + 171*x*y^2</span>
<span class="go">+ 75*y^3 + 120*x^2 + 168*x*y + 84*y^2 + 36*x + 36*y</span>
</pre></div>
</div>
<p>The Tutte polynomial of a connected graph <span class="math notranslate nohighlight">\(G\)</span> evaluated at (1,1) is the number of
spanning trees of <span class="math notranslate nohighlight">\(G\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mf">0.6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">while</span> <span class="ow">not</span> <span class="n">G</span><span class="o">.</span><span class="n">is_connected</span><span class="p">():</span>
<span class="gp">....: </span>    <span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mf">0.6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">tutte_polynomial</span><span class="p">()(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">G</span><span class="o">.</span><span class="n">spanning_trees_count</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Given that <span class="math notranslate nohighlight">\(T(x,y)\)</span> is the Tutte polynomial of a graph <span class="math notranslate nohighlight">\(G\)</span> with
<span class="math notranslate nohighlight">\(n\)</span> vertices and <span class="math notranslate nohighlight">\(c\)</span> connected components, then <span class="math notranslate nohighlight">\((-1)^{n-c} x^k
T(1-x,0)\)</span> is the chromatic polynomial of <span class="math notranslate nohighlight">\(G\)</span>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">OctahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">tutte_polynomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">^</span><span class="mi">5</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">T</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">(x - 2) * (x - 1) * x * (x^3 - 9*x^2 + 29*x - 32)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">(x - 2) * (x - 1) * x * (x^3 - 9*x^2 + 29*x - 32)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.two_factor_petersen">
<span class="sig-name descname"><span class="pre">two_factor_petersen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solver</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.two_factor_petersen" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a decomposition of the graph into 2-factors.</p>
<p>Petersen’s 2-factor decomposition theorem asserts that any <span class="math notranslate nohighlight">\(2r\)</span>-regular
graph <span class="math notranslate nohighlight">\(G\)</span> can be decomposed into 2-factors.  Equivalently, it means that
the edges of any <span class="math notranslate nohighlight">\(2r\)</span>-regular graphs can be partitionned in <span class="math notranslate nohighlight">\(r\)</span> sets
<span class="math notranslate nohighlight">\(C_1,\dots,C_r\)</span> such that for all <span class="math notranslate nohighlight">\(i\)</span>, the set <span class="math notranslate nohighlight">\(C_i\)</span> is a disjoint union
of cycles (a 2-regular graph).</p>
<p>As any graph of maximal degree <span class="math notranslate nohighlight">\(\Delta\)</span> can be completed into a regular
graph of degree <span class="math notranslate nohighlight">\(2\lceil\frac\Delta 2\rceil\)</span>, this result also means
that the edges of any graph of degree <span class="math notranslate nohighlight">\(\Delta\)</span> can be partitionned in
<span class="math notranslate nohighlight">\(r=2\lceil\frac\Delta 2\rceil\)</span> sets <span class="math notranslate nohighlight">\(C_1,\dots,C_r\)</span> such that for all
<span class="math notranslate nohighlight">\(i\)</span>, the set <span class="math notranslate nohighlight">\(C_i\)</span> is a graph of maximal degree <span class="math notranslate nohighlight">\(2\)</span> (a disjoint union of
paths and cycles).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>The Complete Graph on <span class="math notranslate nohighlight">\(7\)</span> vertices is a <span class="math notranslate nohighlight">\(6\)</span>-regular graph, so it can be
edge-partitionned into <span class="math notranslate nohighlight">\(2\)</span>-regular graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">classes</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">two_factor_petersen</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">classes</span><span class="p">:</span>
<span class="gp">....: </span>    <span class="n">gg</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="n">gg</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">gg</span><span class="o">.</span><span class="n">degree</span><span class="p">())</span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="go">True</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Set</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">classes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">classes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">classes</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CirculantGraph</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">cl</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">two_factor_petersen</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">edge_colors</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;black&#39;</span><span class="p">:</span><span class="n">cl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;red&#39;</span><span class="p">:</span><span class="n">cl</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
<span class="go">Graphics object consisting of 73 graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.twograph">
<span class="sig-name descname"><span class="pre">twograph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.twograph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the two-graph of <code class="docutils literal notranslate"><span class="pre">self</span></code></p>
<p>Returns the <a class="reference external" href="../../../combinat/sage/combinat/designs/twographs.html#sage.combinat.designs.twographs.TwoGraph" title="(in Sage 9.5 Reference Manual: Combinatorics v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">two-graph</span></code></a>
with the triples
<span class="math notranslate nohighlight">\(T=\{t \in \binom {V}{3} : \left| \binom {t}{2} \cap E \right| \text{odd} \}\)</span>
where <span class="math notranslate nohighlight">\(V\)</span> and <span class="math notranslate nohighlight">\(E\)</span> are vertices and edges of <code class="docutils literal notranslate"><span class="pre">self</span></code>, respectively.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">twograph</span><span class="p">()</span>
<span class="go">Incidence structure with 10 points and 60 blocks</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">chang_graphs</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T8</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">line_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">T8</span><span class="o">.</span><span class="n">seidel_switching</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="kc">None</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="kc">None</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="kc">None</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="kc">None</span><span class="p">)],</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T8</span><span class="o">.</span><span class="n">twograph</span><span class="p">()</span> <span class="o">==</span> <span class="n">C</span><span class="o">.</span><span class="n">twograph</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">T8</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference external" href="../../../combinat/sage/combinat/designs/twographs.html#sage.combinat.designs.twographs.TwoGraph.descendant" title="(in Sage 9.5 Reference Manual: Combinatorics v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">descendant()</span></code></a> –
computes the descendant graph of the two-graph of self at a vertex</p></li>
<li><p><a class="reference external" href="../../../combinat/sage/combinat/designs/twographs.html#sage.combinat.designs.twographs.twograph_descendant" title="(in Sage 9.5 Reference Manual: Combinatorics v9.5)"><code class="xref py py-func docutils literal notranslate"><span class="pre">twograph_descendant()</span></code></a>
– ditto, but much faster.</p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.vertex_cover">
<span class="sig-name descname"><span class="pre">vertex_cover</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Cliquer'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduction_rules</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.vertex_cover" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a minimum vertex cover of self represented by a set of vertices.</p>
<p>A minimum vertex cover of a graph is a set <span class="math notranslate nohighlight">\(S\)</span> of vertices such that
each edge is incident to at least one element of <span class="math notranslate nohighlight">\(S\)</span>, and such that <span class="math notranslate nohighlight">\(S\)</span>
is of minimum cardinality. For more information, see the
<a class="reference external" href="https://en.wikipedia.org/wiki/Vertex_cover">Wikipedia article Vertex_cover</a>.</p>
<p>Equivalently, a vertex cover is defined as the complement of an
independent set.</p>
<p>As an optimization problem, it can be expressed as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mbox{Minimize : }&amp;\sum_{v\in G} b_v\\
\mbox{Such that : }&amp;\forall (u,v) \in G.edges(), b_u+b_v\geq 1\\
&amp;\forall x\in G, b_x\mbox{ is a binary variable}\end{split}\]</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">&quot;Cliquer&quot;</span></code>). Indicating which
algorithm to use. It can be one of those values.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Cliquer&quot;</span></code> will compute a minimum vertex cover using the Cliquer
package.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;MILP&quot;</span></code> will compute a minimum vertex cover through a mixed
integer linear program.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;mcqd&quot;</span></code> will use the MCQD solver
(<a class="reference external" href="http://www.sicmm.org/~konc/maxclique/">http://www.sicmm.org/~konc/maxclique/</a>). Note that the MCQD
package must be installed.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">value_only</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if set to <code class="docutils literal notranslate"><span class="pre">True</span></code>,
only the size of a minimum vertex cover is returned. Otherwise,
a minimum vertex cover is returned as a list of vertices.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reduction_rules</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); specify if the reductions
rules from kernelization must be applied as pre-processing or not.
See <a class="reference internal" href="../../../references/index.html#acflss04" id="id85"><span>[ACFLSS04]</span></a> for more details. Note that depending on the instance,
it might be faster to disable reduction rules.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Mixed Integer
Linear Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default one is used. For more information on MILP solvers and which
default solver is used, see the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – float; parameter for use with MILP
solvers over an inexact base ring; see
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Sage 9.5 Reference Manual: Numerical Optimization v9.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>On the Pappus graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PappusGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">vertex_cover</span><span class="p">(</span><span class="n">value_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">9</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="../../_images/graph-4.svg" class="plot-directive" src="../../_images/graph-4.svg" /></figure>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.vertex_isoperimetric_number">
<span class="sig-name descname"><span class="pre">vertex_isoperimetric_number</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.vertex_isoperimetric_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex-isoperimetric number of the graph.</p>
<p>The vertex-isoperimetric number of a graph <span class="math notranslate nohighlight">\(G = (V,E)\)</span> is also sometimes
called the <em>magnifying constant</em>. It is defined as the minimum of <span class="math notranslate nohighlight">\(|N(S)| /
|S|\)</span> where <span class="math notranslate nohighlight">\(|N(S)|\)</span> is the vertex boundary of <span class="math notranslate nohighlight">\(S\)</span> and the minimum is taken
over the subsets <span class="math notranslate nohighlight">\(S\)</span> of vertices of size at most half of the vertices.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Alternative but similar quantities can be obtained via the methods
<a class="reference internal" href="#sage.graphs.graph.Graph.cheeger_constant" title="sage.graphs.graph.Graph.cheeger_constant"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cheeger_constant()</span></code></a> and <a class="reference internal" href="#sage.graphs.graph.Graph.edge_isoperimetric_number" title="sage.graphs.graph.Graph.edge_isoperimetric_number"><code class="xref py py-meth docutils literal notranslate"><span class="pre">edge_isoperimetric_number()</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<p>The vertex-isoperimetric number of a complete graph on <span class="math notranslate nohighlight">\(n\)</span> vertices is
<span class="math notranslate nohighlight">\(\lceil n/2 \rceil/\lfloor n/2 \rfloor\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">vertex_isoperimetric_number</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">15</span><span class="p">)]</span>
<span class="go">[1, 2, 1, 3/2, 1, 4/3, 1, 5/4, 1, 6/5, 1, 7/6, 1]</span>
</pre></div>
</div>
<p>The vertex-isoperimetric number of a cycle on <span class="math notranslate nohighlight">\(n\)</span> vertices is
<span class="math notranslate nohighlight">\(2/\lfloor n/2 \rfloor\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">vertex_isoperimetric_number</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">15</span><span class="p">)]</span>
<span class="go">[1, 2, 1, 1, 2/3, 2/3, 1/2, 1/2, 2/5, 2/5, 1/3, 1/3, 2/7]</span>
</pre></div>
</div>
<p>And the vertex-isoperimetric number of a disconnected graph is <span class="math notranslate nohighlight">\(0\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)]])</span><span class="o">.</span><span class="n">vertex_isoperimetric_number</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<p>The vertex-isoperimetric number is independent of edge multiplicity:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">vertex_isoperimetric_number</span><span class="p">()</span>
<span class="go">2/3</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_multiple_edges</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">vertex_isoperimetric_number</span><span class="p">()</span>
<span class="go">2/3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.graphs.graph.Graph.write_to_eps">
<span class="sig-name descname"><span class="pre">write_to_eps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.write_to_eps" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a plot of the graph to <code class="docutils literal notranslate"><span class="pre">filename</span></code> in <code class="docutils literal notranslate"><span class="pre">eps</span></code> format.</p>
<p>INPUT:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">filename</span></code> – a string</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">**options</span></code> – same layout options as <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.layout" title="sage.graphs.generic_graph.GenericGraph.layout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">layout()</span></code></a></p></li>
</ul>
</div></blockquote>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">write_to_eps</span><span class="p">(</span><span class="n">tmp_filename</span><span class="p">(</span><span class="n">ext</span><span class="o">=</span><span class="s1">&#39;.eps&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>It is relatively simple to include this file in a LaTeX document.
<code class="docutils literal notranslate"><span class="pre">\usepackage{graphics}</span></code> must appear in the preamble, and
<code class="docutils literal notranslate"><span class="pre">\includegraphics{filename}</span></code> will include the file. To compile the
document to <code class="docutils literal notranslate"><span class="pre">pdf</span></code> with <code class="docutils literal notranslate"><span class="pre">pdflatex</span></code> or <code class="docutils literal notranslate"><span class="pre">xelatex</span></code> the file needs
first to be converted to <code class="docutils literal notranslate"><span class="pre">pdf</span></code>, for example with <code class="docutils literal notranslate"><span class="pre">ps2pdf</span> <span class="pre">filename.eps</span>
<span class="pre">filename.pdf</span></code>.</p>
</dd></dl>

</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Undirected graphs</a><ul>
<li><a class="reference internal" href="#graph-format">Graph Format</a><ul>
<li><a class="reference internal" href="#supported-formats">Supported formats</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generators">Generators</a></li>
<li><a class="reference internal" href="#labels">Labels</a></li>
<li><a class="reference internal" href="#database">Database</a></li>
<li><a class="reference internal" href="#visualization">Visualization</a></li>
<li><a class="reference internal" href="#mutability">Mutability</a></li>
<li><a class="reference internal" href="#methods">Methods</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="generic_graph.html"
                        title="previous chapter">Generic graphs (common to directed/undirected)</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="digraph.html"
                        title="next chapter">Directed graphs</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/sage/graphs/graph.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="digraph.html" title="Directed graphs"
             >next</a> |</li>
        <li class="right" >
          <a href="generic_graph.html" title="Generic graphs (common to directed/undirected)"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Sage 9.5 Reference Manual: Graph Theory</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">Undirected graphs</a></li> 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2022, The Sage Development Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.2.0.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* The sidebar toggle adapts its height to the bodywrapper height. */
    const resizeObserver = new ResizeObserver(entries => {
        tog.height(bod.height());
    });
    resizeObserver.observe(bod[0]);

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>