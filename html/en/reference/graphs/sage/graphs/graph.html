<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Undirected graphs &mdash; Sage Reference Manual v7.1: Graph Theory</title>
    
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '7.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v7.1: Graph Theory" href="../../index.html" />
    <link rel="next" title="Directed graphs" href="digraph.html" />
    <link rel="prev" title="Generic graphs (common to directed/undirected)" href="generic_graph.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="digraph.html" title="Directed graphs"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="generic_graph.html" title="Generic graphs (common to directed/undirected)"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Graph Theory</a> &raquo;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="undirected-graphs">
<span id="sage-graphs-graph"></span><h1>Undirected graphs<a class="headerlink" href="#undirected-graphs" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.graphs.graph"></span><p>This module implements functions and operations involving undirected
graphs.</p>
<p><strong>Algorithmically hard stuff</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.chromatic_number" title="sage.graphs.graph.Graph.chromatic_number"><tt class="xref py py-meth docutils literal"><span class="pre">chromatic_number()</span></tt></a></td>
<td>Returns the minimal number of colors needed to color the vertices of the graph <span class="math">\(G\)</span>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.chromatic_polynomial" title="sage.graphs.graph.Graph.chromatic_polynomial"><tt class="xref py py-meth docutils literal"><span class="pre">chromatic_polynomial()</span></tt></a></td>
<td>Computes the chromatic polynomial of the graph G.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.chromatic_quasisymmetric_function" title="sage.graphs.graph.Graph.chromatic_quasisymmetric_function"><tt class="xref py py-meth docutils literal"><span class="pre">chromatic_quasisymmetric_function()</span></tt></a></td>
<td>Return the chromatic quasisymmetric function of <tt class="docutils literal"><span class="pre">self</span></tt>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.chromatic_symmetric_function" title="sage.graphs.graph.Graph.chromatic_symmetric_function"><tt class="xref py py-meth docutils literal"><span class="pre">chromatic_symmetric_function()</span></tt></a></td>
<td>Return the chromatic symmetric function of <tt class="docutils literal"><span class="pre">self</span></tt>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.coloring" title="sage.graphs.graph.Graph.coloring"><tt class="xref py py-meth docutils literal"><span class="pre">coloring()</span></tt></a></td>
<td>Returns the first (optimal) proper vertex-coloring found.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.convexity_properties" title="sage.graphs.graph.Graph.convexity_properties"><tt class="xref py py-meth docutils literal"><span class="pre">convexity_properties()</span></tt></a></td>
<td>Returns a <tt class="docutils literal"><span class="pre">ConvexityProperties</span></tt> object corresponding to <tt class="docutils literal"><span class="pre">self</span></tt>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.has_homomorphism_to" title="sage.graphs.graph.Graph.has_homomorphism_to"><tt class="xref py py-meth docutils literal"><span class="pre">has_homomorphism_to()</span></tt></a></td>
<td>Checks whether there is a homomorphism between two graphs.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.independent_set" title="sage.graphs.graph.Graph.independent_set"><tt class="xref py py-meth docutils literal"><span class="pre">independent_set()</span></tt></a></td>
<td>Returns a maximum independent set.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.independent_set_of_representatives" title="sage.graphs.graph.Graph.independent_set_of_representatives"><tt class="xref py py-meth docutils literal"><span class="pre">independent_set_of_representatives()</span></tt></a></td>
<td>Returns an independent set of representatives.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_perfect" title="sage.graphs.graph.Graph.is_perfect"><tt class="xref py py-meth docutils literal"><span class="pre">is_perfect()</span></tt></a></td>
<td>Tests whether the graph is perfect.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.matching_polynomial" title="sage.graphs.graph.Graph.matching_polynomial"><tt class="xref py py-meth docutils literal"><span class="pre">matching_polynomial()</span></tt></a></td>
<td>Computes the matching polynomial of the graph <span class="math">\(G\)</span>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.minor" title="sage.graphs.graph.Graph.minor"><tt class="xref py py-meth docutils literal"><span class="pre">minor()</span></tt></a></td>
<td>Returns the vertices of a minor isomorphic to <span class="math">\(H\)</span> in the current graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.rank_decomposition" title="sage.graphs.graph.Graph.rank_decomposition"><tt class="xref py py-meth docutils literal"><span class="pre">rank_decomposition()</span></tt></a></td>
<td>Computes an optimal rank-decomposition of the given graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.topological_minor" title="sage.graphs.graph.Graph.topological_minor"><tt class="xref py py-meth docutils literal"><span class="pre">topological_minor()</span></tt></a></td>
<td>Returns a topological <span class="math">\(H\)</span>-minor from <tt class="docutils literal"><span class="pre">self</span></tt> if one exists.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.treewidth" title="sage.graphs.graph.Graph.treewidth"><tt class="xref py py-meth docutils literal"><span class="pre">treewidth()</span></tt></a></td>
<td>Computes the tree-width of <span class="math">\(G\)</span> (and provides a decomposition)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.tutte_polynomial" title="sage.graphs.graph.Graph.tutte_polynomial"><tt class="xref py py-meth docutils literal"><span class="pre">tutte_polynomial()</span></tt></a></td>
<td>Return the Tutte polynomial of the graph <span class="math">\(G\)</span>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.vertex_cover" title="sage.graphs.graph.Graph.vertex_cover"><tt class="xref py py-meth docutils literal"><span class="pre">vertex_cover()</span></tt></a></td>
<td>Returns a minimum vertex cover of self represented by a set of vertices.</td>
</tr>
</tbody>
</table>
<p><strong>Basic methods</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.bipartite_color" title="sage.graphs.graph.Graph.bipartite_color"><tt class="xref py py-meth docutils literal"><span class="pre">bipartite_color()</span></tt></a></td>
<td>Returns a dictionary with vertices as the keys and the color class as the values. Fails with an error if the graph is not bipartite.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.bipartite_sets" title="sage.graphs.graph.Graph.bipartite_sets"><tt class="xref py py-meth docutils literal"><span class="pre">bipartite_sets()</span></tt></a></td>
<td>Returns <span class="math">\((X,Y)\)</span> where <span class="math">\(X\)</span> and <span class="math">\(Y\)</span> are the nodes in each bipartite set of graph <span class="math">\(G\)</span>. Fails with an error if graph is not bipartite.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.graph6_string" title="sage.graphs.graph.Graph.graph6_string"><tt class="xref py py-meth docutils literal"><span class="pre">graph6_string()</span></tt></a></td>
<td>Returns the graph6 representation of the graph as an ASCII string. Only valid for simple (no loops, multiple edges) graphs on 0 to 262143 vertices.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_directed" title="sage.graphs.graph.Graph.is_directed"><tt class="xref py py-meth docutils literal"><span class="pre">is_directed()</span></tt></a></td>
<td>Since graph is undirected, returns False.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.join" title="sage.graphs.graph.Graph.join"><tt class="xref py py-meth docutils literal"><span class="pre">join()</span></tt></a></td>
<td>Returns the join of <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">other</span></tt>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.sparse6_string" title="sage.graphs.graph.Graph.sparse6_string"><tt class="xref py py-meth docutils literal"><span class="pre">sparse6_string()</span></tt></a></td>
<td>Returns the sparse6 representation of the graph as an ASCII string. Only valid for undirected graphs on 0 to 262143 vertices, but loops and multiple edges are permitted.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.to_directed" title="sage.graphs.graph.Graph.to_directed"><tt class="xref py py-meth docutils literal"><span class="pre">to_directed()</span></tt></a></td>
<td>Returns a directed version of the graph. A single edge becomes two edges, one in each direction.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.to_undirected" title="sage.graphs.graph.Graph.to_undirected"><tt class="xref py py-meth docutils literal"><span class="pre">to_undirected()</span></tt></a></td>
<td>Since the graph is already undirected, simply returns a copy of itself.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.write_to_eps" title="sage.graphs.graph.Graph.write_to_eps"><tt class="xref py py-meth docutils literal"><span class="pre">write_to_eps()</span></tt></a></td>
<td>Writes a plot of the graph to <tt class="docutils literal"><span class="pre">filename</span></tt> in <tt class="docutils literal"><span class="pre">eps</span></tt> format.</td>
</tr>
</tbody>
</table>
<p><strong>Clique-related methods</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.clique_complex" title="sage.graphs.graph.Graph.clique_complex"><tt class="xref py py-meth docutils literal"><span class="pre">clique_complex()</span></tt></a></td>
<td>Returns the clique complex of self. This is the largest simplicial complex on the vertices of self whose 1-skeleton is self.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.clique_maximum" title="sage.graphs.graph.Graph.clique_maximum"><tt class="xref py py-meth docutils literal"><span class="pre">clique_maximum()</span></tt></a></td>
<td>Returns the vertex set of a maximal order complete subgraph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.clique_number" title="sage.graphs.graph.Graph.clique_number"><tt class="xref py py-meth docutils literal"><span class="pre">clique_number()</span></tt></a></td>
<td>Returns the order of the largest clique of the graph (the clique number).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.clique_polynomial" title="sage.graphs.graph.Graph.clique_polynomial"><tt class="xref py py-meth docutils literal"><span class="pre">clique_polynomial()</span></tt></a></td>
<td>Returns the clique polynomial of self.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.cliques_containing_vertex" title="sage.graphs.graph.Graph.cliques_containing_vertex"><tt class="xref py py-meth docutils literal"><span class="pre">cliques_containing_vertex()</span></tt></a></td>
<td>Returns the cliques containing each vertex, represented as a dictionary of lists of lists, keyed by vertex. (Returns a single list if only one input vertex).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.cliques_get_clique_bipartite" title="sage.graphs.graph.Graph.cliques_get_clique_bipartite"><tt class="xref py py-meth docutils literal"><span class="pre">cliques_get_clique_bipartite()</span></tt></a></td>
<td>Returns a bipartite graph constructed such that maximal cliques are the right vertices and the left vertices are retained from the given graph. Right and left vertices are connected if the bottom vertex belongs to the clique represented by a top vertex.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.cliques_get_max_clique_graph" title="sage.graphs.graph.Graph.cliques_get_max_clique_graph"><tt class="xref py py-meth docutils literal"><span class="pre">cliques_get_max_clique_graph()</span></tt></a></td>
<td>Returns a graph constructed with maximal cliques as vertices, and edges between maximal cliques with common members in the original graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.cliques_maximal" title="sage.graphs.graph.Graph.cliques_maximal"><tt class="xref py py-meth docutils literal"><span class="pre">cliques_maximal()</span></tt></a></td>
<td>Returns the list of all maximal cliques, with each clique represented by a list of vertices. A clique is an induced complete subgraph, and a maximal clique is one not contained in a larger one.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.cliques_maximum" title="sage.graphs.graph.Graph.cliques_maximum"><tt class="xref py py-meth docutils literal"><span class="pre">cliques_maximum()</span></tt></a></td>
<td>Returns the vertex sets of <em>ALL</em> the maximum complete subgraphs.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.cliques_number_of" title="sage.graphs.graph.Graph.cliques_number_of"><tt class="xref py py-meth docutils literal"><span class="pre">cliques_number_of()</span></tt></a></td>
<td>Returns a dictionary of the number of maximal cliques containing each vertex, keyed by vertex. (Returns a single value if only one input vertex).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.cliques_vertex_clique_number" title="sage.graphs.graph.Graph.cliques_vertex_clique_number"><tt class="xref py py-meth docutils literal"><span class="pre">cliques_vertex_clique_number()</span></tt></a></td>
<td>Returns a dictionary of sizes of the largest maximal cliques containing each vertex, keyed by vertex. (Returns a single value if only one input vertex).</td>
</tr>
</tbody>
</table>
<p><strong>Connectivity, orientations, trees</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.bounded_outdegree_orientation" title="sage.graphs.graph.Graph.bounded_outdegree_orientation"><tt class="xref py py-meth docutils literal"><span class="pre">bounded_outdegree_orientation()</span></tt></a></td>
<td>Computes an orientation of <tt class="docutils literal"><span class="pre">self</span></tt> such that every vertex <span class="math">\(v\)</span> has out-degree less than <span class="math">\(b(v)\)</span></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.bridges" title="sage.graphs.graph.Graph.bridges"><tt class="xref py py-meth docutils literal"><span class="pre">bridges()</span></tt></a></td>
<td>Returns a list of the bridges (or cut edges).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.degree_constrained_subgraph" title="sage.graphs.graph.Graph.degree_constrained_subgraph"><tt class="xref py py-meth docutils literal"><span class="pre">degree_constrained_subgraph()</span></tt></a></td>
<td>Returns a degree-constrained subgraph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.gomory_hu_tree" title="sage.graphs.graph.Graph.gomory_hu_tree"><tt class="xref py py-meth docutils literal"><span class="pre">gomory_hu_tree()</span></tt></a></td>
<td>Returns a Gomory-Hu tree of self.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.minimum_outdegree_orientation" title="sage.graphs.graph.Graph.minimum_outdegree_orientation"><tt class="xref py py-meth docutils literal"><span class="pre">minimum_outdegree_orientation()</span></tt></a></td>
<td>Returns an orientation of <tt class="docutils literal"><span class="pre">self</span></tt> with the smallest possible maximum outdegree.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.random_spanning_tree" title="sage.graphs.graph.Graph.random_spanning_tree"><tt class="xref py py-meth docutils literal"><span class="pre">random_spanning_tree()</span></tt></a></td>
<td>Return a random spanning tree of the graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.spanning_trees" title="sage.graphs.graph.Graph.spanning_trees"><tt class="xref py py-meth docutils literal"><span class="pre">spanning_trees()</span></tt></a></td>
<td>Returns a list of all spanning trees.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.strong_orientation" title="sage.graphs.graph.Graph.strong_orientation"><tt class="xref py py-meth docutils literal"><span class="pre">strong_orientation()</span></tt></a></td>
<td>Returns a strongly connected orientation of the current graph.</td>
</tr>
</tbody>
</table>
<p><strong>Deprecated</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.to_partition" title="sage.graphs.graph.Graph.to_partition"><tt class="xref py py-meth docutils literal"><span class="pre">to_partition()</span></tt></a></td>
<td>Return the partition of connected components of <tt class="docutils literal"><span class="pre">self</span></tt>.</td>
</tr>
</tbody>
</table>
<p><strong>Distances</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.centrality_degree" title="sage.graphs.graph.Graph.centrality_degree"><tt class="xref py py-meth docutils literal"><span class="pre">centrality_degree()</span></tt></a></td>
<td>Returns the degree centrality of a vertex.</td>
</tr>
</tbody>
</table>
<p><strong>Graph properties</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_arc_transitive" title="sage.graphs.graph.Graph.is_arc_transitive"><tt class="xref py py-meth docutils literal"><span class="pre">is_arc_transitive()</span></tt></a></td>
<td>Returns true if self is an arc-transitive graph</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_asteroidal_triple_free" title="sage.graphs.graph.Graph.is_asteroidal_triple_free"><tt class="xref py py-meth docutils literal"><span class="pre">is_asteroidal_triple_free()</span></tt></a></td>
<td>Test if the input graph is asteroidal triple-free</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_bipartite" title="sage.graphs.graph.Graph.is_bipartite"><tt class="xref py py-meth docutils literal"><span class="pre">is_bipartite()</span></tt></a></td>
<td>Returns <tt class="docutils literal"><span class="pre">True</span></tt> if graph <span class="math">\(G\)</span> is bipartite, <tt class="docutils literal"><span class="pre">False</span></tt> if not.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_cartesian_product" title="sage.graphs.graph.Graph.is_cartesian_product"><tt class="xref py py-meth docutils literal"><span class="pre">is_cartesian_product()</span></tt></a></td>
<td>Tests whether the graph is a Cartesian product.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_distance_regular" title="sage.graphs.graph.Graph.is_distance_regular"><tt class="xref py py-meth docutils literal"><span class="pre">is_distance_regular()</span></tt></a></td>
<td>Tests if the graph is distance-regular</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_edge_transitive" title="sage.graphs.graph.Graph.is_edge_transitive"><tt class="xref py py-meth docutils literal"><span class="pre">is_edge_transitive()</span></tt></a></td>
<td>Returns true if self is an edge transitive graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_even_hole_free" title="sage.graphs.graph.Graph.is_even_hole_free"><tt class="xref py py-meth docutils literal"><span class="pre">is_even_hole_free()</span></tt></a></td>
<td>Tests whether <tt class="docutils literal"><span class="pre">self</span></tt> contains an induced even hole.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_forest" title="sage.graphs.graph.Graph.is_forest"><tt class="xref py py-meth docutils literal"><span class="pre">is_forest()</span></tt></a></td>
<td>Tests if the graph is a forest, i.e. a disjoint union of trees.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_half_transitive" title="sage.graphs.graph.Graph.is_half_transitive"><tt class="xref py py-meth docutils literal"><span class="pre">is_half_transitive()</span></tt></a></td>
<td>Returns true if self is a half-transitive graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_line_graph" title="sage.graphs.graph.Graph.is_line_graph"><tt class="xref py py-meth docutils literal"><span class="pre">is_line_graph()</span></tt></a></td>
<td>Tests wether the graph is a line graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_long_antihole_free" title="sage.graphs.graph.Graph.is_long_antihole_free"><tt class="xref py py-meth docutils literal"><span class="pre">is_long_antihole_free()</span></tt></a></td>
<td>Tests whether the given graph contains an induced subgraph that is isomorphic to the complement of a cycle of length at least 5.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_long_hole_free" title="sage.graphs.graph.Graph.is_long_hole_free"><tt class="xref py py-meth docutils literal"><span class="pre">is_long_hole_free()</span></tt></a></td>
<td>Tests whether <tt class="docutils literal"><span class="pre">g</span></tt> contains an induced cycle of length at least 5.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_odd_hole_free" title="sage.graphs.graph.Graph.is_odd_hole_free"><tt class="xref py py-meth docutils literal"><span class="pre">is_odd_hole_free()</span></tt></a></td>
<td>Tests whether <tt class="docutils literal"><span class="pre">self</span></tt> contains an induced odd hole.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_overfull" title="sage.graphs.graph.Graph.is_overfull"><tt class="xref py py-meth docutils literal"><span class="pre">is_overfull()</span></tt></a></td>
<td>Tests whether the current graph is overfull.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_partial_cube" title="sage.graphs.graph.Graph.is_partial_cube"><tt class="xref py py-meth docutils literal"><span class="pre">is_partial_cube()</span></tt></a></td>
<td>Test whether the given graph is a partial cube.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_prime" title="sage.graphs.graph.Graph.is_prime"><tt class="xref py py-meth docutils literal"><span class="pre">is_prime()</span></tt></a></td>
<td>Tests whether the current graph is prime.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_semi_symmetric" title="sage.graphs.graph.Graph.is_semi_symmetric"><tt class="xref py py-meth docutils literal"><span class="pre">is_semi_symmetric()</span></tt></a></td>
<td>Returns true if self is semi-symmetric.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_split" title="sage.graphs.graph.Graph.is_split"><tt class="xref py py-meth docutils literal"><span class="pre">is_split()</span></tt></a></td>
<td>Returns <tt class="docutils literal"><span class="pre">True</span></tt> if the graph is a Split graph, <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_strongly_regular" title="sage.graphs.graph.Graph.is_strongly_regular"><tt class="xref py py-meth docutils literal"><span class="pre">is_strongly_regular()</span></tt></a></td>
<td>Tests whether <tt class="docutils literal"><span class="pre">self</span></tt> is strongly regular.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_tree" title="sage.graphs.graph.Graph.is_tree"><tt class="xref py py-meth docutils literal"><span class="pre">is_tree()</span></tt></a></td>
<td>Tests if the graph is a tree</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_triangle_free" title="sage.graphs.graph.Graph.is_triangle_free"><tt class="xref py py-meth docutils literal"><span class="pre">is_triangle_free()</span></tt></a></td>
<td>Returns whether <tt class="docutils literal"><span class="pre">self</span></tt> is triangle-free</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_weakly_chordal" title="sage.graphs.graph.Graph.is_weakly_chordal"><tt class="xref py py-meth docutils literal"><span class="pre">is_weakly_chordal()</span></tt></a></td>
<td>Tests whether the given graph is weakly chordal, i.e., the graph and its complement have no induced cycle of length at least 5.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.odd_girth" title="sage.graphs.graph.Graph.odd_girth"><tt class="xref py py-meth docutils literal"><span class="pre">odd_girth()</span></tt></a></td>
<td>Returns the odd girth of self.</td>
</tr>
</tbody>
</table>
<p><strong>Leftovers</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.cores" title="sage.graphs.graph.Graph.cores"><tt class="xref py py-meth docutils literal"><span class="pre">cores()</span></tt></a></td>
<td>Returns the core number for each vertex in an ordered list.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.fractional_chromatic_index" title="sage.graphs.graph.Graph.fractional_chromatic_index"><tt class="xref py py-meth docutils literal"><span class="pre">fractional_chromatic_index()</span></tt></a></td>
<td>Computes the fractional chromatic index of <tt class="docutils literal"><span class="pre">self</span></tt></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.ihara_zeta_function_inverse" title="sage.graphs.graph.Graph.ihara_zeta_function_inverse"><tt class="xref py py-meth docutils literal"><span class="pre">ihara_zeta_function_inverse()</span></tt></a></td>
<td>Compute the inverse of the Ihara zeta function of the graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.kirchhoff_symanzik_polynomial" title="sage.graphs.graph.Graph.kirchhoff_symanzik_polynomial"><tt class="xref py py-meth docutils literal"><span class="pre">kirchhoff_symanzik_polynomial()</span></tt></a></td>
<td>Return the Kirchhoff-Symanzik polynomial of a graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.lovasz_theta" title="sage.graphs.graph.Graph.lovasz_theta"><tt class="xref py py-meth docutils literal"><span class="pre">lovasz_theta()</span></tt></a></td>
<td>Return the value of Lovász theta-function of graph</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.matching" title="sage.graphs.graph.Graph.matching"><tt class="xref py py-meth docutils literal"><span class="pre">matching()</span></tt></a></td>
<td>Returns a maximum weighted matching of the graph represented by the list of its edges. For more information, see the <a class="reference external" href="http://en.wikipedia.org/wiki/Matching_%28graph_theory%29">Wikipedia article on matchings</a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.maximum_average_degree" title="sage.graphs.graph.Graph.maximum_average_degree"><tt class="xref py py-meth docutils literal"><span class="pre">maximum_average_degree()</span></tt></a></td>
<td>Returns the Maximum Average Degree (MAD) of the current graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.modular_decomposition" title="sage.graphs.graph.Graph.modular_decomposition"><tt class="xref py py-meth docutils literal"><span class="pre">modular_decomposition()</span></tt></a></td>
<td>Returns the modular decomposition of the current graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.perfect_matchings" title="sage.graphs.graph.Graph.perfect_matchings"><tt class="xref py py-meth docutils literal"><span class="pre">perfect_matchings()</span></tt></a></td>
<td>Return an interator over all perfect matchings of the graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.seidel_adjacency_matrix" title="sage.graphs.graph.Graph.seidel_adjacency_matrix"><tt class="xref py py-meth docutils literal"><span class="pre">seidel_adjacency_matrix()</span></tt></a></td>
<td>Returns the Seidel adjacency matrix of <tt class="docutils literal"><span class="pre">self</span></tt>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.seidel_switching" title="sage.graphs.graph.Graph.seidel_switching"><tt class="xref py py-meth docutils literal"><span class="pre">seidel_switching()</span></tt></a></td>
<td>Returns the Seidel switching of <tt class="docutils literal"><span class="pre">self</span></tt> w.r.t. subset of vertices <tt class="docutils literal"><span class="pre">s</span></tt>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.two_factor_petersen" title="sage.graphs.graph.Graph.two_factor_petersen"><tt class="xref py py-meth docutils literal"><span class="pre">two_factor_petersen()</span></tt></a></td>
<td>Returns a decomposition of the graph into 2-factors.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.twograph" title="sage.graphs.graph.Graph.twograph"><tt class="xref py py-meth docutils literal"><span class="pre">twograph()</span></tt></a></td>
<td>Returns the two-graph of <tt class="docutils literal"><span class="pre">self</span></tt></td>
</tr>
</tbody>
</table>
<p>AUTHORS:</p>
<ul>
<li><p class="first">Robert L. Miller (2006-10-22): initial version</p>
</li>
<li><p class="first">William Stein (2006-12-05): Editing</p>
</li>
<li><p class="first">Robert L. Miller (2007-01-13): refactoring, adjusting for
NetworkX-0.33, fixed plotting bugs (2007-01-23): basic tutorial,
edge labels, loops, multiple edges and arcs (2007-02-07): graph6
and sparse6 formats, matrix input</p>
</li>
<li><p class="first">Emily Kirkmann (2007-02-11): added graph_border option to plot
and show</p>
</li>
<li><p class="first">Robert L. Miller (2007-02-12): vertex color-maps, graph
boundaries, graph6 helper functions in Cython</p>
</li>
<li><p class="first">Robert L. Miller Sage Days 3 (2007-02-17-21): 3d plotting in
Tachyon</p>
</li>
<li><p class="first">Robert L. Miller (2007-02-25): display a partition</p>
</li>
<li><p class="first">Robert L. Miller (2007-02-28): associate arbitrary objects to
vertices, edge and arc label display (in 2d), edge coloring</p>
</li>
<li><p class="first">Robert L. Miller (2007-03-21): Automorphism group, isomorphism
check, canonical label</p>
</li>
<li><p class="first">Robert L. Miller (2007-06-07-09): NetworkX function wrapping</p>
</li>
<li><p class="first">Michael W. Hansen (2007-06-09): Topological sort generation</p>
</li>
<li><p class="first">Emily Kirkman, Robert L. Miller Sage Days 4: Finished wrapping
NetworkX</p>
</li>
<li><p class="first">Emily Kirkman (2007-07-21): Genus (including circular planar,
all embeddings and all planar embeddings), all paths, interior
paths</p>
</li>
<li><p class="first">Bobby Moretti (2007-08-12): fixed up plotting of graphs with
edge colors differentiated by label</p>
</li>
<li><p class="first">Jason Grout (2007-09-25): Added functions, bug fixes, and
general enhancements</p>
</li>
<li><p class="first">Robert L. Miller (Sage Days 7): Edge labeled graph isomorphism</p>
</li>
<li><p class="first">Tom Boothby (Sage Days 7): Miscellaneous awesomeness</p>
</li>
<li><p class="first">Tom Boothby (2008-01-09): Added graphviz output</p>
</li>
<li><p class="first">David Joyner (2009-2): Fixed docstring bug related to GAP.</p>
</li>
<li><p class="first">Stephen Hartke (2009-07-26): Fixed bug in blocks_and_cut_vertices()
that caused an incorrect result when the vertex 0 was a cut vertex.</p>
</li>
<li><p class="first">Stephen Hartke (2009-08-22): Fixed bug in blocks_and_cut_vertices()
where the list of cut_vertices is not treated as a set.</p>
</li>
<li><p class="first">Anders Jonsson (2009-10-10): Counting of spanning trees and out-trees added.</p>
</li>
<li><dl class="first docutils">
<dt>Nathann Cohen (2009-09) <span class="classifier-delimiter">:</span> <span class="classifier">Cliquer, Connectivity, Flows</span></dt>
<dd><p class="first last">and everything that uses Linear Programming
and class numerical.MIP</p>
</dd>
</dl>
</li>
<li><p class="first">Nicolas M. Thiery (2010-02): graph layout code refactoring, dot2tex/graphviz interface</p>
</li>
<li><p class="first">David Coudert (2012-04) : Reduction rules in vertex_cover.</p>
</li>
<li><dl class="first docutils">
<dt>Birk Eisermann (2012-06): added recognition of weakly chordal graphs and</dt>
<dd><p class="first last">long-hole-free / long-antihole-free graphs</p>
</dd>
</dl>
</li>
<li><p class="first">Alexandre P. Zuge (2013-07): added join operation.</p>
</li>
<li><p class="first">Amritanshu Prasad (2014-08): added clique polynomial</p>
</li>
</ul>
<div class="section" id="graph-format">
<h2>Graph Format<a class="headerlink" href="#graph-format" title="Permalink to this headline">¶</a></h2>
<div class="section" id="supported-formats">
<h3>Supported formats<a class="headerlink" href="#supported-formats" title="Permalink to this headline">¶</a></h3>
<p>Sage Graphs can be created from a wide range of inputs. A few
examples are covered here.</p>
<ul>
<li><p class="first">NetworkX dictionary format:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">9</span><span class="p">],</span> \
<span class="go">      5: [7, 8], 6: [8,9], 7: [9]}</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">d</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Graph on 10 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>    <span class="c1"># or G.show()</span>
</pre></div>
</div>
</li>
<li><p class="first">A NetworkX graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">networkx</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">complete_bipartite_graph</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">[7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 12, 12, 12, 12, 12, 12, 12]</span>
</pre></div>
</div>
</li>
<li><p class="first">graph6 or sparse6 format:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;:I`AKGsaOs`cI]Gb~&#39;</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Looped multi-graph on 10 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>    <span class="c1"># or G.show()</span>
</pre></div>
</div>
<p>Note that the <tt class="docutils literal"><span class="pre">\</span></tt> character is an escape character in Python, and
also a character used by graph6 strings:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;Ihe</span><span class="se">\n</span><span class="s1">@GUA&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">RuntimeError</span>: <span class="n">The string (Ihe) seems corrupt: for n = 10, the string is too short.</span>
</pre></div>
</div>
<p>In Python, the escaped character <tt class="docutils literal"><span class="pre">\</span></tt> is represented by <tt class="docutils literal"><span class="pre">\\</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;Ihe</span><span class="se">\\</span><span class="s1">n@GUA&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>    <span class="c1"># or G.show()</span>
</pre></div>
</div>
</li>
<li><p class="first">adjacency matrix: In an adjacency matrix, each column and each
row represent a vertex. If a 1 shows up in row <span class="math">\(i\)</span>, column
<span class="math">\(j\)</span>, there is an edge <span class="math">\((i,j)\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> \
<span class="go">(0,1,0,1,0,0,0,1,0,0), (0,0,1,0,1,0,0,0,1,0),(1,0,0,1,0,0,0,0,0,1), \</span>
<span class="go">(1,0,0,0,0,0,0,1,1,0), (0,1,0,0,0,0,0,0,1,1),(0,0,1,0,0,1,0,0,0,1), \</span>
<span class="go">(0,0,0,1,0,1,1,0,0,0), (0,0,0,0,1,0,1,1,0,0)])</span>
<span class="gp">sage: </span><span class="n">M</span>
<span class="go">[0 1 0 0 1 1 0 0 0 0]</span>
<span class="go">[1 0 1 0 0 0 1 0 0 0]</span>
<span class="go">[0 1 0 1 0 0 0 1 0 0]</span>
<span class="go">[0 0 1 0 1 0 0 0 1 0]</span>
<span class="go">[1 0 0 1 0 0 0 0 0 1]</span>
<span class="go">[1 0 0 0 0 0 0 1 1 0]</span>
<span class="go">[0 1 0 0 0 0 0 0 1 1]</span>
<span class="go">[0 0 1 0 0 1 0 0 0 1]</span>
<span class="go">[0 0 0 1 0 1 1 0 0 0]</span>
<span class="go">[0 0 0 0 1 0 1 1 0 0]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">M</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Graph on 10 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>    <span class="c1"># or G.show()</span>
</pre></div>
</div>
</li>
<li><p class="first">incidence matrix: In an incidence matrix, each row represents a
vertex and each column represents an edge.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:             ( 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 0, 0, 0),</span>
<span class="go">....:             ( 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 0, 0),</span>
<span class="go">....:             ( 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 0),</span>
<span class="go">....:             ( 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1),</span>
<span class="go">....:             ( 0, 0, 0, 0, 0,-1, 0, 0, 0, 1, 1, 0, 0, 0, 0),</span>
<span class="go">....:             ( 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 1, 0, 0, 0),</span>
<span class="go">....:             ( 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 1, 0, 0),</span>
<span class="go">....:             ( 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 1, 0),</span>
<span class="go">....:             ( 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 1)])</span>
<span class="gp">sage: </span><span class="n">M</span>
<span class="go">[-1  0  0  0  1  0  0  0  0  0 -1  0  0  0  0]</span>
<span class="go">[ 1 -1  0  0  0  0  0  0  0  0  0 -1  0  0  0]</span>
<span class="go">[ 0  1 -1  0  0  0  0  0  0  0  0  0 -1  0  0]</span>
<span class="go">[ 0  0  1 -1  0  0  0  0  0  0  0  0  0 -1  0]</span>
<span class="go">[ 0  0  0  1 -1  0  0  0  0  0  0  0  0  0 -1]</span>
<span class="go">[ 0  0  0  0  0 -1  0  0  0  1  1  0  0  0  0]</span>
<span class="go">[ 0  0  0  0  0  0  0  1 -1  0  0  1  0  0  0]</span>
<span class="go">[ 0  0  0  0  0  1 -1  0  0  0  0  0  1  0  0]</span>
<span class="go">[ 0  0  0  0  0  0  0  0  1 -1  0  0  0  1  0]</span>
<span class="go">[ 0  0  0  0  0  0  1 -1  0  0  0  0  0  0  1]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">M</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Graph on 10 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>    <span class="c1"># or G.show()</span>
<span class="gp">sage: </span><span class="n">DiGraph</span><span class="p">(</span><span class="n">matrix</span><span class="p">(</span><span class="mi">2</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span> <span class="n">format</span><span class="o">=</span><span class="s2">&quot;incidence_matrix&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">There must be two nonzero entries (-1 &amp; 1) per column.</span>
</pre></div>
</div>
</li>
<li><p class="first">a list of edges:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span>
<span class="go">Graph on 5 vertices</span>
</pre></div>
</div>
</li>
<li><p class="first">an igraph Graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">igraph</span>                                <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">igraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)]))</span> <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">g</span>                                            <span class="c1"># optional - python_igraph</span>
<span class="go">Graph on 4 vertices</span>
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="generators">
<h2>Generators<a class="headerlink" href="#generators" title="Permalink to this headline">¶</a></h2>
<p>Use <tt class="docutils literal"><span class="pre">graphs(n)</span></tt> to iterate through all non-isomorphic graphs of given size:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">graphs</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
<span class="go">....:     print g.spectrum()</span>
<span class="go">[0, 0, 0, 0]</span>
<span class="go">[1, 0, 0, -1]</span>
<span class="go">[1.4142135623..., 0, 0, -1.4142135623...]</span>
<span class="go">[2, 0, -1, -1]</span>
<span class="go">[1.7320508075..., 0, 0, -1.7320508075...]</span>
<span class="go">[1, 1, -1, -1]</span>
<span class="go">[1.6180339887..., 0.6180339887..., -0.6180339887..., -1.6180339887...]</span>
<span class="go">[2.1700864866..., 0.3111078174..., -1, -1.4811943040...]</span>
<span class="go">[2, 0, 0, -2]</span>
<span class="go">[2.5615528128..., 0, -1, -1.5615528128...]</span>
<span class="go">[3, -1, -1, -1]</span>
</pre></div>
</div>
<p>Similarly <tt class="docutils literal"><span class="pre">graphs()</span></tt> will iterate through all graphs. The complete
graph of 4 vertices is of course the smallest graph with chromatic number
bigger than three:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">graphs</span><span class="p">():</span>
<span class="go">....:     if g.chromatic_number() &gt; 3:</span>
<span class="go">....:         break</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>For some commonly used graphs to play with, type</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="p">[</span><span class="n">tab</span><span class="p">]</span>          <span class="c1"># not tested</span>
</pre></div>
</div>
<p>and hit {tab}. Most of these graphs come with their own custom
plot, so you can see how people usually visualize these graphs.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>    <span class="c1"># or G.show()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">degree_histogram</span><span class="p">()</span>
<span class="go">[0, 0, 0, 10]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span>
<span class="go">[0 1 0 0 1 1 0 0 0 0]</span>
<span class="go">[1 0 1 0 0 0 1 0 0 0]</span>
<span class="go">[0 1 0 1 0 0 0 1 0 0]</span>
<span class="go">[0 0 1 0 1 0 0 0 1 0]</span>
<span class="go">[1 0 0 1 0 0 0 0 0 1]</span>
<span class="go">[1 0 0 0 0 0 0 1 1 0]</span>
<span class="go">[0 1 0 0 0 0 0 0 1 1]</span>
<span class="go">[0 0 1 0 0 1 0 0 0 1]</span>
<span class="go">[0 0 0 1 0 1 1 0 0 0]</span>
<span class="go">[0 0 0 0 1 0 1 1 0 0]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>    <span class="c1"># or S.show()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">density</span><span class="p">()</span>
<span class="go">1/2</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">GraphQuery</span><span class="p">(</span><span class="n">display_cols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;graph6&#39;</span><span class="p">],</span> <span class="n">num_vertices</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">diameter</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">get_graphs_list</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">graphs_list</span><span class="o">.</span><span class="n">show_graphs</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="labels">
<span id="graph-labels"></span><h2>Labels<a class="headerlink" href="#labels" title="Permalink to this headline">¶</a></h2>
<p>Each vertex can have any hashable object as a label. These are
things like strings, numbers, and tuples. Each edge is given a
default label of <tt class="docutils literal"><span class="pre">None</span></tt>, but if specified, edges can
have any label at all. Edges between vertices <span class="math">\(u\)</span> and
<span class="math">\(v\)</span> are represented typically as <tt class="docutils literal"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></tt>, where
<tt class="docutils literal"><span class="pre">l</span></tt> is the label for the edge.</p>
<p>Note that vertex labels themselves cannot be mutable items:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span> <span class="mi">0</span> <span class="p">:</span> <span class="p">{</span> <span class="n">M</span> <span class="p">:</span> <span class="bp">None</span> <span class="p">}</span> <span class="p">})</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">mutable matrices are unhashable</span>
</pre></div>
</div>
<p>However, if one wants to define a dictionary, with the same keys
and arbitrary objects for entries, one can make that association:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span> <span class="p">:</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">(),</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">graphs</span><span class="o">.</span><span class="n">FlowerSnark</span><span class="p">(),</span> \
<span class="go">      2 : graphs.MoebiusKantorGraph(), 3 : graphs.PetersenGraph() }</span>
<span class="gp">sage: </span><span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">Moebius-Kantor Graph: Graph on 16 vertices</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">TetrahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">set_vertices</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">get_vertex</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Flower Snark: Graph on 20 vertices</span>
</pre></div>
</div>
</div>
<div class="section" id="database">
<h2>Database<a class="headerlink" href="#database" title="Permalink to this headline">¶</a></h2>
<p>There is a database available for searching for graphs that satisfy
a certain set of parameters, including number of vertices and
edges, density, maximum and minimum degree, diameter, radius, and
connectivity. To see a list of all search parameter keywords broken
down by their designated table names, type</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graph_db_info</span><span class="p">()</span>
<span class="go">{...}</span>
</pre></div>
</div>
<p>For more details on data types or keyword input, enter</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>sage: GraphQuery?    # not tested
</pre></div>
</div>
<p>The results of a query can be viewed with the show method, or can be
viewed individually by iterating through the results:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">GraphQuery</span><span class="p">(</span><span class="n">display_cols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;graph6&#39;</span><span class="p">],</span><span class="n">num_vertices</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">diameter</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="go">Graph6</span>
<span class="go">--------------------</span>
<span class="go">F?`po</span>
<span class="go">F?gqg</span>
<span class="go">F@?]O</span>
<span class="go">F@OKg</span>
<span class="go">F@R@o</span>
<span class="go">FA_pW</span>
<span class="go">FEOhW</span>
<span class="go">FGC{o</span>
<span class="go">FIAHo</span>
</pre></div>
</div>
<p>Show each graph as you iterate through the results:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">Q</span><span class="p">:</span>
<span class="go">....:     show(g)</span>
</pre></div>
</div>
</div>
<div class="section" id="visualization">
<h2>Visualization<a class="headerlink" href="#visualization" title="Permalink to this headline">¶</a></h2>
<p>To see a graph <span class="math">\(G\)</span> you are working with, there
are three main options. You can view the graph in two dimensions via
matplotlib with <tt class="docutils literal"><span class="pre">show()</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="o">.</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>And you can view it in three dimensions via jmol with <tt class="docutils literal"><span class="pre">show3d()</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show3d</span><span class="p">()</span>
</pre></div>
</div>
<p>Or it can be rendered with <span class="math">\(\LaTeX\)</span>.  This requires the right
additions to a standard <span class="math">\(\mbox{\rm\TeX}\)</span> installation.  Then standard
Sage commands, such as <tt class="docutils literal"><span class="pre">view(G)</span></tt> will display the graph, or
<tt class="docutils literal"><span class="pre">latex(G)</span></tt> will produce a string suitable for inclusion in a
<span class="math">\(\LaTeX\)</span> document.  More details on this are at
the <a class="reference internal" href="graph_latex.html#module-sage.graphs.graph_latex" title="sage.graphs.graph_latex"><tt class="xref py py-mod docutils literal"><span class="pre">sage.graphs.graph_latex</span></tt></a> module.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_latex</span> <span class="kn">import</span> <span class="n">check_tkz_graph</span>
<span class="gp">sage: </span><span class="n">check_tkz_graph</span><span class="p">()</span>  <span class="c1"># random - depends on TeX installation</span>
<span class="gp">sage: </span><span class="n">latex</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">\begin{tikzpicture}</span>
<span class="gp">...</span>
<span class="go">\end{tikzpicture}</span>
</pre></div>
</div>
</div>
<div class="section" id="mutability">
<h2>Mutability<a class="headerlink" href="#mutability" title="Permalink to this headline">¶</a></h2>
<p>Graphs are mutable, and thus unusable as dictionary keys, unless
<tt class="docutils literal"><span class="pre">data_structure=&quot;static_sparse&quot;</span></tt> is used:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">{</span><span class="n">G</span><span class="p">:</span><span class="mi">1</span><span class="p">}[</span><span class="n">G</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">This graph is mutable, and thus not hashable. Create an immutable copy by `g.copy(immutable=True)`</span>
<span class="gp">sage: </span><span class="n">G_immutable</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">immutable</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G_immutable</span> <span class="o">==</span> <span class="n">G</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">{</span><span class="n">G_immutable</span><span class="p">:</span><span class="mi">1</span><span class="p">}[</span><span class="n">G_immutable</span><span class="p">]</span>
<span class="go">1</span>
</pre></div>
</div>
</div>
<div class="section" id="methods">
<h2>Methods<a class="headerlink" href="#methods" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="sage.graphs.graph.Graph">
<em class="property">class </em><tt class="descclassname">sage.graphs.graph.</tt><tt class="descname">Graph</tt><big>(</big><em>data=None</em>, <em>pos=None</em>, <em>loops=None</em>, <em>format=None</em>, <em>weighted=None</em>, <em>implementation='c_graph'</em>, <em>data_structure='sparse'</em>, <em>vertex_labels=True</em>, <em>name=None</em>, <em>multiedges=None</em>, <em>convert_empty_dict_labels_to_None=None</em>, <em>sparse=True</em>, <em>immutable=False</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph" title="sage.graphs.generic_graph.GenericGraph"><tt class="xref py py-class docutils literal"><span class="pre">sage.graphs.generic_graph.GenericGraph</span></tt></a></p>
<p>Undirected graph.</p>
<p>A graph is a set of vertices connected by edges. See also the
<a class="reference external" href="https://en.wikipedia.org/wiki/Graph_(mathematics)">Wikipedia article on graphs</a>. For a
collection of pre-defined graphs, see the
<a class="reference internal" href="graph_generators.html#module-sage.graphs.graph_generators" title="sage.graphs.graph_generators"><tt class="xref py py-mod docutils literal"><span class="pre">graph_generators</span></tt></a> module.</p>
<p>A <a class="reference internal" href="#sage.graphs.graph.Graph" title="sage.graphs.graph.Graph"><tt class="xref py py-class docutils literal"><span class="pre">Graph</span></tt></a> object has many methods whose list can be obtained by
typing <tt class="docutils literal"><span class="pre">g.&lt;tab&gt;</span></tt> (i.e. hit the &#8216;tab&#8217; key) or by reading the documentation
of <a class="reference internal" href="#module-sage.graphs.graph" title="sage.graphs.graph"><tt class="xref py py-mod docutils literal"><span class="pre">graph</span></tt></a>, <a class="reference internal" href="generic_graph.html#module-sage.graphs.generic_graph" title="sage.graphs.generic_graph"><tt class="xref py py-mod docutils literal"><span class="pre">generic_graph</span></tt></a>, and
<a class="reference internal" href="digraph.html#module-sage.graphs.digraph" title="sage.graphs.digraph"><tt class="xref py py-mod docutils literal"><span class="pre">digraph</span></tt></a>.</p>
<p>INPUT:</p>
<p>By default, a <a class="reference internal" href="#sage.graphs.graph.Graph" title="sage.graphs.graph.Graph"><tt class="xref py py-class docutils literal"><span class="pre">Graph</span></tt></a> object is simple (i.e. no <em>loops</em> nor <em>multiple
edges</em>) and unweighted. This can be easily tuned with the appropriate flags
(see below).</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">data</span></tt> &#8211; can be any of the following (see the <tt class="docutils literal"><span class="pre">format</span></tt> argument):</li>
</ul>
<blockquote>
<div><ol class="arabic">
<li><p class="first"><tt class="docutils literal"><span class="pre">Graph()</span></tt> &#8211; build a graph on 0 vertices.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Graph(5)</span></tt> &#8211; return an edgeless graph on the 5 vertices 0,...,4.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Graph([list_of_vertices,list_of_edges])</span></tt> &#8211; returns a graph with
given vertices/edges.</p>
<p>To bypass auto-detection, prefer the more explicit
<tt class="docutils literal"><span class="pre">Graph([V,E],format='vertices_and_edges')</span></tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Graph(list_of_edges)</span></tt> &#8211; return a graph with a given list of edges
(see documentation of
<a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.add_edges" title="sage.graphs.generic_graph.GenericGraph.add_edges"><tt class="xref py py-meth docutils literal"><span class="pre">add_edges()</span></tt></a>).</p>
<p>To bypass auto-detection, prefer the more explicit <tt class="docutils literal"><span class="pre">Graph(L,</span>
<span class="pre">format='list_of_edges')</span></tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Graph({1:[2,3,4],3:[4]})</span></tt> &#8211; return a graph by associating to each
vertex the list of its neighbors.</p>
<p>To bypass auto-detection, prefer the more explicit <tt class="docutils literal"><span class="pre">Graph(D,</span>
<span class="pre">format='dict_of_lists')</span></tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Graph({1:</span> <span class="pre">{2:</span> <span class="pre">'a',</span> <span class="pre">3:'b'}</span> <span class="pre">,3:{2:'c'}})</span></tt> &#8211; return a graph by
associating a list of neighbors to each vertex and providing its edge
label.</p>
<p>To bypass auto-detection, prefer the more explicit <tt class="docutils literal"><span class="pre">Graph(D,</span>
<span class="pre">format='dict_of_dicts')</span></tt>.</p>
<p>For graphs with multiple edges, you can provide a list of labels
instead, e.g.: <tt class="docutils literal"><span class="pre">Graph({1:</span> <span class="pre">{2:</span> <span class="pre">['a1',</span> <span class="pre">'a2'],</span> <span class="pre">3:['b']}</span> <span class="pre">,3:{2:['c']}})</span></tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Graph(a_symmetric_matrix)</span></tt> &#8211; return a graph with given (weighted)
adjacency matrix (see documentation of
<a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.adjacency_matrix" title="sage.graphs.generic_graph.GenericGraph.adjacency_matrix"><tt class="xref py py-meth docutils literal"><span class="pre">adjacency_matrix()</span></tt></a>).</p>
<p>To bypass auto-detection, prefer the more explicit <tt class="docutils literal"><span class="pre">Graph(M,</span>
<span class="pre">format='adjacency_matrix')</span></tt>. To take weights into account, use
<tt class="docutils literal"><span class="pre">format='weighted_adjacency_matrix'</span></tt> instead.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Graph(a_nonsymmetric_matrix)</span></tt> &#8211; return a graph with given incidence
matrix (see documentation of
<a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.incidence_matrix" title="sage.graphs.generic_graph.GenericGraph.incidence_matrix"><tt class="xref py py-meth docutils literal"><span class="pre">incidence_matrix()</span></tt></a>).</p>
<p>To bypass auto-detection, prefer the more explicit <tt class="docutils literal"><span class="pre">Graph(M,</span>
<span class="pre">format='incidence_matrix')</span></tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Graph([V,</span> <span class="pre">f])</span></tt> &#8211; return a graph from a vertex set <tt class="docutils literal"><span class="pre">V</span></tt> and a
<em>symmetric</em> function <tt class="docutils literal"><span class="pre">f</span></tt>. The graph contains an edge <span class="math">\(u,v\)</span> whenever
<tt class="docutils literal"><span class="pre">f(u,v)</span></tt> is <tt class="docutils literal"><span class="pre">True</span></tt>.. Example: <tt class="docutils literal"><span class="pre">Graph([</span> <span class="pre">[1..10],</span> <span class="pre">lambda</span> <span class="pre">x,y:</span>
<span class="pre">abs(x-y).is_square()])</span></tt></p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Graph(':I`ES&#64;obGkqegW~')</span></tt> &#8211; return a graph from a graph6 or sparse6
string (see documentation of <a class="reference internal" href="#sage.graphs.graph.Graph.graph6_string" title="sage.graphs.graph.Graph.graph6_string"><tt class="xref py py-meth docutils literal"><span class="pre">graph6_string()</span></tt></a> or
<a class="reference internal" href="#sage.graphs.graph.Graph.sparse6_string" title="sage.graphs.graph.Graph.sparse6_string"><tt class="xref py py-meth docutils literal"><span class="pre">sparse6_string()</span></tt></a>).</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Graph(a_seidel_matrix,</span> <span class="pre">format='seidel_adjacency_matrix')</span></tt> &#8211; return
a graph with a given Seidel adjacency matrix (see documentation of
<a class="reference internal" href="#sage.graphs.graph.Graph.seidel_adjacency_matrix" title="sage.graphs.graph.Graph.seidel_adjacency_matrix"><tt class="xref py py-meth docutils literal"><span class="pre">seidel_adjacency_matrix()</span></tt></a>).</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Graph(another_graph)</span></tt> &#8211; return a graph from a Sage (di)graph,
<a class="reference external" href="https://pygraphviz.github.io/">pygraphviz</a> graph, <a class="reference external" href="https://networkx.github.io/">NetworkX</a> graph, or <a class="reference external" href="http://igraph.org/python/">igraph</a> graph.</p>
</li>
</ol>
</div></blockquote>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">pos</span></tt> - a positioning dictionary (cf. documentation of
<a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.layout" title="sage.graphs.generic_graph.GenericGraph.layout"><tt class="xref py py-meth docutils literal"><span class="pre">layout()</span></tt></a>). For example, to
draw 4 vertices on a square:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
 <span class="mi">1</span><span class="p">:</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
 <span class="mi">2</span><span class="p">:</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
 <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]}</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">name</span></tt> - (must be an explicitly named parameter,
i.e., <tt class="docutils literal"><span class="pre">name=&quot;complete&quot;)</span></tt> gives the graph a name</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">loops</span></tt> - boolean, whether to allow loops (ignored
if data is an instance of the <tt class="docutils literal"><span class="pre">Graph</span></tt> class)</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">multiedges</span></tt> - boolean, whether to allow multiple
edges (ignored if data is an instance of the <tt class="docutils literal"><span class="pre">Graph</span></tt> class).</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">weighted</span></tt> - whether graph thinks of itself as weighted or not. See
<a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.weighted" title="sage.graphs.generic_graph.GenericGraph.weighted"><tt class="xref py py-meth docutils literal"><span class="pre">weighted()</span></tt></a>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">format</span></tt> - if set to <tt class="docutils literal"><span class="pre">None</span></tt> (default), <a class="reference internal" href="#sage.graphs.graph.Graph" title="sage.graphs.graph.Graph"><tt class="xref py py-class docutils literal"><span class="pre">Graph</span></tt></a> tries to guess
input&#8217;s format. To avoid this possibly time-consuming step, one of the
following values can be specified (see description above): <tt class="docutils literal"><span class="pre">&quot;int&quot;</span></tt>,
<tt class="docutils literal"><span class="pre">&quot;graph6&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;sparse6&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;rule&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;list_of_edges&quot;</span></tt>,
<tt class="docutils literal"><span class="pre">&quot;dict_of_lists&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;dict_of_dicts&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;adjacency_matrix&quot;</span></tt>,
<tt class="docutils literal"><span class="pre">&quot;weighted_adjacency_matrix&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;seidel_adjacency_matrix&quot;</span></tt>,
<tt class="docutils literal"><span class="pre">&quot;incidence_matrix&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;NX&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;igraph&quot;</span></tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">sparse</span></tt> (boolean) &#8211; <tt class="docutils literal"><span class="pre">sparse=True</span></tt> is an alias for
<tt class="docutils literal"><span class="pre">data_structure=&quot;sparse&quot;</span></tt>, and <tt class="docutils literal"><span class="pre">sparse=False</span></tt> is an alias for
<tt class="docutils literal"><span class="pre">data_structure=&quot;dense&quot;</span></tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">data_structure</span></tt> &#8211; one of the following (for more information, see
<a class="reference internal" href="base/overview.html#module-sage.graphs.base.overview" title="sage.graphs.base.overview"><tt class="xref py py-mod docutils literal"><span class="pre">overview</span></tt></a>)</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">&quot;dense&quot;</span></tt> &#8211; selects the <a class="reference internal" href="base/dense_graph.html#module-sage.graphs.base.dense_graph" title="sage.graphs.base.dense_graph"><tt class="xref py py-mod docutils literal"><span class="pre">dense_graph</span></tt></a>
backend.</li>
<li><tt class="docutils literal"><span class="pre">&quot;sparse&quot;</span></tt> &#8211; selects the <a class="reference internal" href="base/sparse_graph.html#module-sage.graphs.base.sparse_graph" title="sage.graphs.base.sparse_graph"><tt class="xref py py-mod docutils literal"><span class="pre">sparse_graph</span></tt></a>
backend.</li>
<li><tt class="docutils literal"><span class="pre">&quot;static_sparse&quot;</span></tt> &#8211; selects the
<a class="reference internal" href="base/static_sparse_backend.html#module-sage.graphs.base.static_sparse_backend" title="sage.graphs.base.static_sparse_backend"><tt class="xref py py-mod docutils literal"><span class="pre">static_sparse_backend</span></tt></a> (this backend is faster
than the sparse backend and smaller in memory, and it is immutable, so
that the resulting graphs can be used as dictionary keys).</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">immutable</span></tt> (boolean) &#8211; whether to create a immutable graph. Note that
<tt class="docutils literal"><span class="pre">immutable=True</span></tt> is actually a shortcut for
<tt class="docutils literal"><span class="pre">data_structure='static_sparse'</span></tt>. Set to <tt class="docutils literal"><span class="pre">False</span></tt> by default.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">vertex_labels</span></tt> - Whether to allow any object as a vertex (slower), or
only the integers <span class="math">\(0,...,n-1\)</span>, where <span class="math">\(n\)</span> is the number of vertices.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">convert_empty_dict_labels_to_None</span></tt> - this arguments sets
the default edge labels used by NetworkX (empty dictionaries)
to be replaced by None, the default Sage edge label. It is
set to <tt class="docutils literal"><span class="pre">True</span></tt> iff a NetworkX graph is on the input.</p>
</li>
</ul>
<p>EXAMPLES:</p>
<p>We illustrate the first seven input formats (the other two
involve packages that are currently not standard in Sage):</p>
<ol class="arabic">
<li><p class="first">An integer giving the number of vertices:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="n">g</span>
<span class="go">Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
</li>
<li><p class="first">A dictionary of dictionaries:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:{</span><span class="mi">1</span><span class="p">:</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="s1">&#39;z&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">:</span><span class="s1">&#39;a&#39;</span><span class="p">},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">5</span><span class="p">:</span><span class="s1">&#39;out&#39;</span><span class="p">}});</span> <span class="n">g</span>
<span class="go">Graph on 5 vertices</span>
</pre></div>
</div>
<p>The labels (&#8216;x&#8217;, &#8216;z&#8217;, &#8216;a&#8217;, &#8216;out&#8217;) are labels for edges. For
example, &#8216;out&#8217; is the label for the edge on 2 and 5. Labels can be
used as weights, if all the labels share some common parent.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">f</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">SymmetricGroup</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">({</span><span class="n">b</span><span class="p">:{</span><span class="n">d</span><span class="p">:</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="n">e</span><span class="p">:</span><span class="s1">&#39;p&#39;</span><span class="p">},</span> <span class="n">c</span><span class="p">:{</span><span class="n">d</span><span class="p">:</span><span class="s1">&#39;p&#39;</span><span class="p">,</span><span class="n">e</span><span class="p">:</span><span class="s1">&#39;c&#39;</span><span class="p">}})</span>
<span class="go">Graph on 4 vertices</span>
</pre></div>
</div>
</li>
<li><p class="first">A dictionary of lists:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">]});</span> <span class="n">g</span>
<span class="go">Graph on 5 vertices</span>
</pre></div>
</div>
</li>
<li><p class="first">A list of vertices and a function describing adjacencies. Note
that the list of vertices and the function must be enclosed in a
list (i.e., [list of vertices, function]).</p>
<p>Construct the Paley graph over GF(13).</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">=</span><span class="n">Graph</span><span class="p">([</span><span class="n">GF</span><span class="p">(</span><span class="mi">13</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">:</span> <span class="n">i</span><span class="o">!=</span><span class="n">j</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">is_square</span><span class="p">()])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span>
<span class="go">[0 1 0 1 1 0 0 0 0 1 1 0 1]</span>
<span class="go">[1 0 1 0 1 1 0 0 0 0 1 1 0]</span>
<span class="go">[0 1 0 1 0 1 1 0 0 0 0 1 1]</span>
<span class="go">[1 0 1 0 1 0 1 1 0 0 0 0 1]</span>
<span class="go">[1 1 0 1 0 1 0 1 1 0 0 0 0]</span>
<span class="go">[0 1 1 0 1 0 1 0 1 1 0 0 0]</span>
<span class="go">[0 0 1 1 0 1 0 1 0 1 1 0 0]</span>
<span class="go">[0 0 0 1 1 0 1 0 1 0 1 1 0]</span>
<span class="go">[0 0 0 0 1 1 0 1 0 1 0 1 1]</span>
<span class="go">[1 0 0 0 0 1 1 0 1 0 1 0 1]</span>
<span class="go">[1 1 0 0 0 0 1 1 0 1 0 1 0]</span>
<span class="go">[0 1 1 0 0 0 0 1 1 0 1 0 1]</span>
<span class="go">[1 0 1 1 0 0 0 0 1 1 0 1 0]</span>
</pre></div>
</div>
<p>Construct the line graph of a complete graph.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">line_graph</span><span class="o">=</span><span class="n">Graph</span><span class="p">([</span><span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="n">false</span><span class="p">),</span> \
<span class="go">       lambda i,j: len(set(i).intersection(set(j)))&gt;0], \</span>
<span class="go">       loops=False)</span>
<span class="gp">sage: </span><span class="n">line_graph</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]</span>
<span class="gp">sage: </span><span class="n">line_graph</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span>
<span class="go">[0 1 1 1 1 0]</span>
<span class="go">[1 0 1 1 0 1]</span>
<span class="go">[1 1 0 0 1 1]</span>
<span class="go">[1 1 0 0 1 1]</span>
<span class="go">[1 0 1 1 0 1]</span>
<span class="go">[0 1 1 1 1 0]</span>
</pre></div>
</div>
</li>
<li><p class="first">A graph6 or sparse6 string: Sage automatically recognizes
whether a string is in graph6 or sparse6 format:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;:I`AKGsaOs`cI]Gb~&#39;</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Looped multi-graph on 10 vertices</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;G?????&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s2">&quot;G&#39;?G?C&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">RuntimeError</span>: <span class="n">The string seems corrupt: valid characters are</span>
<span class="go">?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;G??????&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">RuntimeError</span>: <span class="n">The string (G??????) seems corrupt: for n = 8, the string is too long.</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s2">&quot;:I&#39;AKGsaOs`cI]Gb~&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">RuntimeError</span>: <span class="n">The string seems corrupt: valid characters are</span>
<span class="go">?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~</span>
</pre></div>
</div>
<p>There are also list functions to take care of lists of graphs:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;:IgMoqoCUOqeb</span><span class="se">\n</span><span class="s1">:I`AKGsaOs`cI]Gb~</span><span class="se">\n</span><span class="s1">:I`EDOAEQ?PccSsge\N</span><span class="se">\n</span><span class="s1">&#39;</span>
<span class="gp">sage: </span><span class="n">graphs_list</span><span class="o">.</span><span class="n">from_sparse6</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[Looped multi-graph on 10 vertices, Looped multi-graph on 10 vertices, Looped multi-graph on 10 vertices]</span>
</pre></div>
</div>
</li>
<li><p class="first">A Sage matrix:
Note: If format is not specified, then Sage assumes a symmetric square
matrix is an adjacency matrix, otherwise an incidence matrix.</p>
<ul>
<li><p class="first">an adjacency matrix:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">am</span><span class="p">();</span> <span class="n">M</span>
<span class="go">[0 1 0 0 1 1 0 0 0 0]</span>
<span class="go">[1 0 1 0 0 0 1 0 0 0]</span>
<span class="go">[0 1 0 1 0 0 0 1 0 0]</span>
<span class="go">[0 0 1 0 1 0 0 0 1 0]</span>
<span class="go">[1 0 0 1 0 0 0 0 0 1]</span>
<span class="go">[1 0 0 0 0 0 0 1 1 0]</span>
<span class="go">[0 1 0 0 0 0 0 0 1 1]</span>
<span class="go">[0 0 1 0 0 1 0 0 0 1]</span>
<span class="go">[0 0 0 1 0 1 1 0 0 0]</span>
<span class="go">[0 0 0 0 1 0 1 1 0 0]</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="go">Graph on 10 vertices</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]]),</span><span class="n">loops</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Looped multi-graph on 2 vertices</span>

<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]]);</span> <span class="n">M</span>
<span class="go">[   0    1   -1]</span>
<span class="go">[   1    0 -1/2]</span>
<span class="go">[  -1 -1/2    0]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Graph on 3 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">weighted</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</li>
<li><p class="first">an incidence matrix:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]);</span> <span class="n">M</span>
<span class="go">[-1  0  0  0  1]</span>
<span class="go">[ 1 -1  0  0  0]</span>
<span class="go">[ 0  1 -1  0  0]</span>
<span class="go">[ 0  0  1 -1  0]</span>
<span class="go">[ 0  0  0  1 -1]</span>
<span class="go">[ 0  0  0  0  0]</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="go">Graph on 6 vertices</span>

<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">]]))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">There must be one or two nonzero entries per column in an incidence matrix. Got entries [1, 1, 1] in column 0</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">]]))</span>
<span class="go">Graph on 3 vertices</span>

<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]);</span> <span class="n">M</span>
<span class="go">[ 0  1 -1]</span>
<span class="go">[ 1  0 -1]</span>
<span class="go">[-1 -1  0]</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Graph on 3 vertices</span>

<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]);</span> <span class="n">M</span>
<span class="go">[ 0  1  1]</span>
<span class="go">[ 1  0  1]</span>
<span class="go">[-1 -1  0]</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">There must be one or two nonzero entries per column in an incidence matrix. Got entries [1, 1] in column 2</span>
</pre></div>
</div>
</li>
</ul>
<blockquote>
<div><p>Check that <a class="reference external" href="http://trac.sagemath.org/9714">trac ticket #9714</a> is fixed:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">MA</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">GA</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">MA</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s1">&#39;adjacency_matrix&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">MI</span> <span class="o">=</span> <span class="n">GA</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">(</span><span class="n">oriented</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">MI</span>
<span class="go">[2 1 1 0 0 0]</span>
<span class="go">[0 1 1 2 2 0]</span>
<span class="go">[0 0 0 0 0 2]</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">MI</span><span class="p">)</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<span class="go">[(0, 0), (0, 1), (0, 1), (1, 1), (1, 1), (2, 2)]</span>

<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]);</span> <span class="n">M</span>
<span class="go">[ 1]</span>
<span class="go">[-1]</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">M</span><span class="p">)</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None)]</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">A Seidel adjacency matrix:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.matrices.hadamard_matrix</span> <span class="kn">import</span> \
<span class="go">....:  regular_symmetric_hadamard_matrix_with_constant_diagonal as rshcd</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">=</span><span class="n">rshcd</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span> <span class="n">matrix</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">format</span><span class="o">=</span><span class="s2">&quot;seidel_adjacency_matrix&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(16, 6, 2, 2)</span>
</pre></div>
</div>
</li>
<li><p class="first">a list of edges, or labelled edges:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span>
<span class="go">Graph on 5 vertices</span>

<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s2">&quot;Peace&quot;</span><span class="p">),(</span><span class="mi">7</span><span class="p">,</span><span class="o">-</span><span class="mi">9</span><span class="p">,</span><span class="s2">&quot;and&quot;</span><span class="p">),(</span><span class="mi">77</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Love&quot;</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span>
<span class="go">Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">)],</span> <span class="n">loops</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">multiedges</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">loops</span><span class="p">()</span>
<span class="go">[(3, 3, &#39;2&#39;)]</span>
</pre></div>
</div>
</li>
<li><p class="first">A NetworkX MultiGraph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">networkx</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">MultiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">Graph on 5 vertices</span>
</pre></div>
</div>
</li>
<li><p class="first">A NetworkX graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">networkx</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">DiGraph</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">Digraph on 5 vertices</span>
</pre></div>
</div>
</li>
<li><p class="first">An igraph Graph (see also
<a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.igraph_graph" title="sage.graphs.generic_graph.GenericGraph.igraph_graph"><tt class="xref py py-meth docutils literal"><span class="pre">igraph_graph()</span></tt></a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">igraph</span>                   <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">igraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span> <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>                        <span class="c1"># optional - python_igraph</span>
<span class="go">Graph on 3 vertices</span>
</pre></div>
</div>
<p>If <tt class="docutils literal"><span class="pre">vertex_labels</span></tt> is <tt class="docutils literal"><span class="pre">True</span></tt>, the names of the vertices are given by
the vertex attribute <tt class="docutils literal"><span class="pre">'name'</span></tt>, if available:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">igraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span> <span class="n">vertex_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">]})</span>  <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>                                                   <span class="c1"># optional - python_igraph</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">igraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span> <span class="n">vertex_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">]})</span> <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>                                                   <span class="c1"># optional - python_igraph</span>
<span class="go">[0, 1, 2]</span>
</pre></div>
</div>
<p>If the igraph Graph has edge attributes, they are used as edge labels:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">igraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span> <span class="n">edge_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;weight&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]})</span> <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>                                                               <span class="c1"># optional - python_igraph</span>
<span class="go">[(0, 1, {&#39;name&#39;: &#39;a&#39;, &#39;weight&#39;: 1}), (0, 2, {&#39;name&#39;: &#39;b&#39;, &#39;weight&#39;: 3})]</span>
</pre></div>
</div>
</li>
</ol>
<p>When defining an undirected graph from a function <tt class="docutils literal"><span class="pre">f</span></tt>, it is <em>very</em>
important that <tt class="docutils literal"><span class="pre">f</span></tt> be symmetric. If it is not, anything can happen:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f_sym</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">f_nonsym</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">G_sym</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">f_sym</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G_sym</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G_nonsym</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">f_nonsym</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G_nonsym</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">G_nonsym</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">G_sym</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>By default, graphs are mutable and can thus not be used as a dictionary
key:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">{</span><span class="n">G</span><span class="p">:</span><span class="mi">1</span><span class="p">}[</span><span class="n">G</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">This graph is mutable, and thus not hashable. Create an immutable copy by `g.copy(immutable=True)`</span>
</pre></div>
</div>
<p>When providing the optional arguments <tt class="docutils literal"><span class="pre">data_structure=&quot;static_sparse&quot;</span></tt>
or <tt class="docutils literal"><span class="pre">immutable=True</span></tt> (both mean the same), then an immutable graph
results.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G_imm</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">immutable</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H_imm</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">data_structure</span><span class="o">=</span><span class="s1">&#39;static_sparse&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G_imm</span> <span class="o">==</span> <span class="n">H_imm</span> <span class="o">==</span> <span class="n">G</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">{</span><span class="n">G_imm</span><span class="p">:</span><span class="mi">1</span><span class="p">}[</span><span class="n">H_imm</span><span class="p">]</span>
<span class="go">1</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="n">format</span><span class="o">=</span><span class="s2">&quot;HeyHeyHey&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Unknown input format &#39;HeyHeyHey&#39;</span>

<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">igraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">directed</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span> <span class="c1"># optional - python_igraph</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">An *undirected* igraph graph was expected. To build an directed graph, call the DiGraph constructor.</span>

<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">format</span><span class="o">=</span><span class="s2">&quot;seidel_adjacency_matrix&quot;</span><span class="p">)</span>
<span class="go">Graph on 2 vertices</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">format</span><span class="o">=</span><span class="s2">&quot;seidel_adjacency_matrix&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Graph&#39;s Seidel adjacency matrix must be symmetric</span>

<span class="gp">sage: </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">format</span><span class="o">=</span><span class="s2">&quot;seidel_adjacency_matrix&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Graph&#39;s Seidel adjacency matrix must have 0s on the main diagonal</span>
</pre></div>
</div>
<p>From a a list of vertices and a list of edges:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)]]);</span> <span class="n">G</span>
<span class="go">Graph on 3 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(1, 2, None)]</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.graphs.graph.Graph.bipartite_color">
<tt class="descname">bipartite_color</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.bipartite_color" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary with vertices as the keys and the color class
as the values. Fails with an error if the graph is not bipartite.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">bipartite_color</span><span class="p">()</span>
<span class="go">{0: 1, 1: 0, 2: 1, 3: 0}</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">bipartite_color</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">RuntimeError</span>: <span class="n">Graph is not bipartite.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.bipartite_sets">
<tt class="descname">bipartite_sets</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.bipartite_sets" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <span class="math">\((X,Y)\)</span> where <span class="math">\(X\)</span> and <span class="math">\(Y\)</span> are the nodes in each bipartite set of
graph <span class="math">\(G\)</span>. Fails with an error if graph is not bipartite.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">bipartite_sets</span><span class="p">()</span>
<span class="go">({0, 2}, {1, 3})</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">bipartite_sets</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">RuntimeError</span>: <span class="n">Graph is not bipartite.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.bounded_outdegree_orientation">
<tt class="descname">bounded_outdegree_orientation</tt><big>(</big><em>bound</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.bounded_outdegree_orientation" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes an orientation of <tt class="docutils literal"><span class="pre">self</span></tt> such that every vertex <span class="math">\(v\)</span>
has out-degree less than <span class="math">\(b(v)\)</span></p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">bound</span></tt> &#8211; Maximum bound on the out-degree. Can be of
three different types :</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>An integer <span class="math">\(k\)</span>. In this case, computes an orientation
whose maximum out-degree is less than <span class="math">\(k\)</span>.</li>
<li>A dictionary associating to each vertex its associated
maximum out-degree.</li>
<li>A function associating to each vertex its associated
maximum out-degree.</li>
</ul>
</div></blockquote>
<p>OUTPUT:</p>
<p>A DiGraph representing the orientation if it exists. A
<tt class="docutils literal"><span class="pre">ValueError</span></tt> exception is raised otherwise.</p>
<p>ALGORITHM:</p>
<p>The problem is solved through a maximum flow :</p>
<p>Given a graph <span class="math">\(G\)</span>, we create a <tt class="docutils literal"><span class="pre">DiGraph</span></tt> <span class="math">\(D\)</span> defined on
<span class="math">\(E(G)\cup V(G)\cup \{s,t\}\)</span>. We then link <span class="math">\(s\)</span> to all of <span class="math">\(V(G)\)</span>
(these edges having a capacity equal to the bound associated
to each element of <span class="math">\(V(G)\)</span>), and all the elements of <span class="math">\(E(G)\)</span> to
<span class="math">\(t\)</span> . We then link each <span class="math">\(v \in V(G)\)</span> to each of its incident
edges in <span class="math">\(G\)</span>. A maximum integer flow of value <span class="math">\(|E(G)|\)</span>
corresponds to an admissible orientation of <span class="math">\(G\)</span>. Otherwise,
none exists.</p>
<p>EXAMPLES:</p>
<p>There is always an orientation of a graph <span class="math">\(G\)</span> such that a
vertex <span class="math">\(v\)</span> has out-degree at most <span class="math">\(\lceil \frac {d(v)} 2
\rceil\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="o">.</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v</span> <span class="p">:</span> <span class="n">ceil</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">bounded_outdegree_orientation</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">D</span><span class="o">.</span><span class="n">out_degree</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">g</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Chvatal&#8217;s graph, being 4-regular, can be oriented in such a
way that its maximum out-degree is 2:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">bounded_outdegree_orientation</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">max</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">out_degree</span><span class="p">())</span>
<span class="go">2</span>
</pre></div>
</div>
<p>For any graph <span class="math">\(G\)</span>, it is possible to compute an orientation
such that the maximum out-degree is at most the maximum
average degree of <span class="math">\(G\)</span> divided by 2. Anything less, though, is
impossible.</p>
<blockquote>
<div>sage: g = graphs.RandomGNP(40, .4)
sage: mad = g.maximum_average_degree()</div></blockquote>
<p>Hence this is possible</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">bounded_outdegree_orientation</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">mad</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>While this is not:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>     <span class="n">g</span><span class="o">.</span><span class="n">bounded_outdegree_orientation</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">mad</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">... </span>     <span class="k">print</span> <span class="s2">&quot;Error&quot;</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
<span class="gp">... </span>      <span class="k">pass</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>As previously for random graphs, but more intensively:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">30</span><span class="p">):</span>      <span class="c1"># long time (up to 6s on sage.math, 2012)</span>
<span class="gp">... </span>      <span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="o">.</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">... </span>      <span class="n">b</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v</span> <span class="p">:</span> <span class="n">ceil</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">... </span>      <span class="n">D</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">bounded_outdegree_orientation</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">... </span>      <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
<span class="gp">... </span>           <span class="nb">all</span><span class="p">(</span> <span class="n">D</span><span class="o">.</span><span class="n">out_degree</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">g</span> <span class="p">)</span> <span class="ow">or</span>
<span class="gp">... </span>           <span class="n">D</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">g</span><span class="o">.</span><span class="n">size</span><span class="p">()):</span>
<span class="gp">... </span>          <span class="k">print</span> <span class="s2">&quot;Something wrong happened&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.bridges">
<tt class="descname">bridges</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.bridges" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of the bridges (or cut edges).</p>
<p>A bridge is an edge so that deleting it disconnects the graph.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method assumes the graph is connected.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">bridges</span><span class="p">()</span>
<span class="go">[(1, 10, None)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.centrality_degree">
<tt class="descname">centrality_degree</tt><big>(</big><em>v=None</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.centrality_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the degree centrality of a vertex.</p>
<p>The degree centrality of a vertex <span class="math">\(v\)</span> is its degree, divided by
<span class="math">\(|V(G)|-1\)</span>. For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Centrality">Wikipedia article Centrality</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">v</span></tt> - a vertex. Set to <tt class="docutils literal"><span class="pre">None</span></tt> (default) to get a dictionary
associating each vertex with its centrality degree.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.centrality_closeness" title="sage.graphs.generic_graph.GenericGraph.centrality_closeness"><tt class="xref py py-meth docutils literal"><span class="pre">centrality_closeness()</span></tt></a></li>
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.centrality_betweenness" title="sage.graphs.generic_graph.GenericGraph.centrality_betweenness"><tt class="xref py py-meth docutils literal"><span class="pre">centrality_betweenness()</span></tt></a></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">())</span><span class="o">.</span><span class="n">centrality_degree</span><span class="p">()</span>
<span class="go">{0: 4/11, 1: 4/11, 2: 4/11, 3: 4/11,  4: 4/11,  5: 4/11,</span>
<span class="go"> 6: 4/11, 7: 4/11, 8: 4/11, 9: 4/11, 10: 4/11, 11: 4/11}</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DiamondGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">centrality_degree</span><span class="p">()</span>
<span class="go">{0: 2/3, 1: 1, 2: 1, 3: 2/3}</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">centrality_degree</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">centrality_degree</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The centrality degree is not defined on graphs with only one vertex</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.chromatic_number">
<tt class="descname">chromatic_number</tt><big>(</big><em>algorithm='DLX'</em>, <em>verbose=0</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.chromatic_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the minimal number of colors needed to color the vertices
of the graph <span class="math">\(G\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">algorithm</span></tt> &#8211; Select an algorithm from the following supported
algorithms:<ul>
<li>If <tt class="docutils literal"><span class="pre">algorithm=&quot;DLX&quot;</span></tt> (default), the chromatic number is
computed using the dancing link algorithm. It is
inefficient speedwise to compute the chromatic number through
the dancing link algorithm because this algorithm computes
<em>all</em> the possible colorings to check that one exists.</li>
<li>If <tt class="docutils literal"><span class="pre">algorithm=&quot;CP&quot;</span></tt>, the chromatic number is computed
using the coefficients of the chromatic polynomial. Again, this
method is inefficient in terms of speed and it only useful for
small graphs.</li>
<li>If <tt class="docutils literal"><span class="pre">algorithm=&quot;MILP&quot;</span></tt>, the chromatic number is computed using a
mixed integer linear program. The performance of this implementation
is affected by whether optional MILP solvers have been installed
(see the <a class="reference external" href="../../../numerical/sage/numerical/mip.html#module-sage.numerical.mip" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-mod docutils literal"><span class="pre">MILP</span> <span class="pre">module</span></tt></a>, or Sage&#8217;s tutorial
on Linear Programming).</li>
</ul>
</li>
<li><tt class="docutils literal"><span class="pre">verbose</span></tt> &#8211; integer (default: <tt class="docutils literal"><span class="pre">0</span></tt>). Sets the level of verbosity
for the MILP algorithm. Its default value is 0, which means <em>quiet</em>.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">For more functions related to graph coloring, see the
module <a class="reference internal" href="graph_coloring.html#module-sage.graphs.graph_coloring" title="sage.graphs.graph_coloring"><tt class="xref py py-mod docutils literal"><span class="pre">sage.graphs.graph_coloring</span></tt></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;DLX&quot;</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;MILP&quot;</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;CP&quot;</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>A bipartite graph has (by definition) chromatic number 2:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">RandomBipartite</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mf">0.7</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
<p>A complete multipartite graph with k parts has chromatic number k:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteMultipartiteGraph</span><span class="p">([</span><span class="mi">5</span><span class="p">]</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">()</span> <span class="o">==</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The complete graph has the largest chromatic number from all the graphs
of order n. Namely its chromatic number is n:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">()</span> <span class="o">==</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Kneser graph with parameters (n,2) for n &gt; 3 has chromatic number n-2:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">KneserGraph</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">()</span> <span class="o">==</span> <span class="n">i</span><span class="o">-</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A snark has chromatic index 4 hence its line graph has chromatic number 4:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">FlowerSnark</span><span class="p">()</span><span class="o">.</span><span class="n">line_graph</span><span class="p">()</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The &#39;algorithm&#39; keyword must be set to either &#39;DLX&#39;, &#39;MILP&#39; or &#39;CP&#39;.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.chromatic_polynomial">
<tt class="descname">chromatic_polynomial</tt><big>(</big><em>G</em>, <em>return_tree_basis=False</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.chromatic_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the chromatic polynomial of the graph G.</p>
<p>The algorithm used is a recursive one, based on the following observations
of Read:</p>
<blockquote>
<div><ul class="simple">
<li>The chromatic polynomial of a tree on n vertices is x(x-1)^(n-1).</li>
<li>If e is an edge of G, G&#8217; is the result of deleting the edge e, and G&#8217;&#8217;
is the result of contracting e, then the chromatic polynomial of G is
equal to that of G&#8217; minus that of G&#8217;&#8216;.</li>
</ul>
</div></blockquote>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span>
<span class="go">x^4 - 4*x^3 + 6*x^2 - 3*x</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span>
<span class="go">x^3 - 3*x^2 + 2*x</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span>
<span class="go">x^8 - 12*x^7 + 66*x^6 - 214*x^5 + 441*x^4 - 572*x^3 + 423*x^2 - 133*x</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span>
<span class="go">x^10 - 15*x^9 + 105*x^8 - 455*x^7 + 1353*x^6 - 2861*x^5 + 4275*x^4 - 4305*x^3 + 2606*x^2 - 704*x</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span>
<span class="go">x^6 - 9*x^5 + 36*x^4 - 75*x^3 + 78*x^2 - 31*x</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">(x - 1) * x</span>
<span class="go">(x - 2) * (x - 1) * x</span>
<span class="go">(x - 3) * (x - 2) * (x - 1) * x</span>
<span class="go">(x - 4) * (x - 3) * (x - 2) * (x - 1) * x</span>
<span class="go">(x - 5) * (x - 4) * (x - 3) * (x - 2) * (x - 1) * x</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">(x - 2) * (x - 1) * x * (x^2 - 2*x + 2)</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">OctahedralGraph</span><span class="p">()</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">(x - 2) * (x - 1) * x * (x^3 - 9*x^2 + 29*x - 32)</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">WheelGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">(x - 2) * (x - 1) * x * (x^2 - 5*x + 7)</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">WheelGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">(x - 3) * (x - 2) * (x - 1) * x * (x^2 - 4*x + 5)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">LCFGraph</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">],</span> <span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span>  <span class="c1"># long time (6s on sage.math, 2011)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># long time</span>
<span class="go">0</span>
</pre></div>
</div>
<p>By definition, the chromatic number of a graph G is the least integer k such that
the chromatic polynomial of G is strictly positive at k:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">min</span><span class="p">((</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">if</span> <span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mf">0.7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">min</span><span class="p">((</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">if</span> <span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.chromatic_quasisymmetric_function">
<tt class="descname">chromatic_quasisymmetric_function</tt><big>(</big><em>t=None</em>, <em>R=None</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.chromatic_quasisymmetric_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chromatic quasisymmetric function of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>Let <span class="math">\(G\)</span> be a graph whose vertex set is totally ordered. The
chromatic quasisymmetric function <span class="math">\(X_G(t)\)</span> was first
described in <a class="reference internal" href="#sw12" id="id1">[SW12]</a>. We use the equivalent definition
given in <a class="reference internal" href="#bc15" id="id2">[BC15]</a>:</p>
<div class="math">
\[X_G(t) = \sum_{\sigma=(\sigma_1,\ldots,\sigma_n)}
t^{\operatorname{asc}(\sigma)}
M_{|\sigma_1|,\ldots,|\sigma_n|},\]</div>
<p>where we sum over all ordered set partitions of the vertex
set of <span class="math">\(G\)</span> such that each block <span class="math">\(\sigma_i\)</span> is an independent
(i.e., stable) set of <span class="math">\(G\)</span>, and where
<span class="math">\(\operatorname{asc}(\sigma)\)</span> denotes the number of edges
<span class="math">\(\{u, v\}\)</span> of <span class="math">\(G\)</span> such that <span class="math">\(u &lt; v\)</span> and <span class="math">\(v\)</span> appears in a
later part of <span class="math">\(\sigma\)</span> than <span class="math">\(u\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">t</span></tt> &#8211; (optional) the parameter <span class="math">\(t\)</span>; uses the variable <span class="math">\(t\)</span>
in <span class="math">\(\ZZ[t]\)</span> by default</li>
<li><tt class="docutils literal"><span class="pre">R</span></tt> &#8211; (optional) the base ring for the quasisymmetric
functions; uses the parent of <span class="math">\(t\)</span> by default</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">chromatic_quasisymmetric_function</span><span class="p">()</span>
<span class="go">(2*t^2+2*t+2)*M[1, 1, 1] + M[1, 2] + t^2*M[2, 1]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">XG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_quasisymmetric_function</span><span class="p">();</span> <span class="n">XG</span>
<span class="go">(t^3+11*t^2+11*t+1)*M[1, 1, 1, 1] + (3*t^2+3*t)*M[1, 1, 2]</span>
<span class="go"> + (3*t^2+3*t)*M[1, 2, 1] + (3*t^2+3*t)*M[2, 1, 1]</span>
<span class="go"> + (t^2+t)*M[2, 2]</span>
<span class="gp">sage: </span><span class="n">XG</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="go">(t^3+11*t^2+11*t+1)*m[1, 1, 1, 1] + (3*t^2+3*t)*m[2, 1, 1]</span>
<span class="go"> + (t^2+t)*m[2, 2]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">chromatic_quasisymmetric_function</span><span class="p">()</span>
<span class="go">(t^6+3*t^5+5*t^4+6*t^3+5*t^2+3*t+1)*M[1, 1, 1, 1]</span>
</pre></div>
</div>
<p>Not all chromatic quasisymmetric functions are symmetric:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">chromatic_quasisymmetric_function</span><span class="p">()</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We check that at <span class="math">\(t = 1\)</span>, we recover the usual chromatic
symmetric function:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">XG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_quasisymmetric_function</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span> <span class="n">XG</span>
<span class="go">120*M[1, 1, 1, 1, 1] + 30*M[1, 1, 1, 2] + 30*M[1, 1, 2, 1]</span>
<span class="go"> + 30*M[1, 2, 1, 1] + 10*M[1, 2, 2] + 30*M[2, 1, 1, 1]</span>
<span class="go"> + 10*M[2, 1, 2] + 10*M[2, 2, 1]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="n">XG</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">())</span>
<span class="go">p[1, 1, 1, 1, 1] - 5*p[2, 1, 1, 1] + 5*p[2, 2, 1]</span>
<span class="go"> + 5*p[3, 1, 1] - 5*p[3, 2] - 5*p[4, 1] + 4*p[5]</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">ClawGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">XG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_quasisymmetric_function</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span> <span class="n">XG</span>
<span class="go">24*M[1, 1, 1, 1] + 6*M[1, 1, 2] + 6*M[1, 2, 1] + M[1, 3]</span>
<span class="go"> + 6*M[2, 1, 1] + M[3, 1]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="n">XG</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">())</span>
<span class="go">p[1, 1, 1, 1] - 3*p[2, 1, 1] + 3*p[3, 1] - p[4]</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="sw12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[SW12]</a></td><td>John Shareshian and Michelle Wachs.
<em>Chromatic quasisymmetric functions and Hessenberg varieties</em>.
Configuration Spaces. CRM Series. Scuola Normale Superiore.
(2012) pp. 433-460.
<a class="reference external" href="http://www.math.miami.edu/~wachs/papers/chrom.pdf">http://www.math.miami.edu/~wachs/papers/chrom.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="bc15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[BC15]</a></td><td>Patrick Brosnan and Timothy Y. Chow.
<em>Unit interval orders and the dot action on the cohomology
of regular semisimple Hessenberg varieties</em>.
(2015) <a class="reference external" href="http://arxiv.org/abs/1511.00773v1">Arxiv 1511.00773v1</a>.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.chromatic_symmetric_function">
<tt class="descname">chromatic_symmetric_function</tt><big>(</big><em>R=None</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.chromatic_symmetric_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chromatic symmetric function of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>Let <span class="math">\(G\)</span> be a graph. The chromatic symmetric function <span class="math">\(X_G\)</span> was
described in <a class="reference internal" href="#stanley95" id="id3">[Stanley95]</a>, specifically Theorem 2.5 states that</p>
<div class="math">
\[X_G = \sum_{F \subseteq E(G)} (-1)^{|F|} p_{\lambda(F)},\]</div>
<p>where <span class="math">\(\lambda(F)\)</span> is the partition of the sizes of the connected
components of the subgraph induced by the edges <span class="math">\(F\)</span> and <span class="math">\(p_{\mu}\)</span>
is the powersum symmetric function.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">R</span></tt> &#8211; (optional) the base ring for the symmetric functions;
this uses <span class="math">\(\ZZ\)</span> by default</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">XG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_symmetric_function</span><span class="p">();</span> <span class="n">XG</span>
<span class="go">p[1, 1, 1, 1, 1] - 5*p[2, 1, 1, 1] + 5*p[2, 2, 1]</span>
<span class="go"> + 5*p[3, 1, 1] - 5*p[3, 2] - 5*p[4, 1] + 4*p[5]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">XG</span><span class="p">)</span>
<span class="go">30*s[1, 1, 1, 1, 1] + 10*s[2, 1, 1, 1] + 10*s[2, 2, 1]</span>
</pre></div>
</div>
<p>Not all graphs have a positive Schur expansion:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">ClawGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">XG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_symmetric_function</span><span class="p">();</span> <span class="n">XG</span>
<span class="go">p[1, 1, 1, 1] - 3*p[2, 1, 1] + 3*p[3, 1] - p[4]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">XG</span><span class="p">)</span>
<span class="go">8*s[1, 1, 1, 1] + 5*s[2, 1, 1] - s[2, 2] + s[3, 1]</span>
</pre></div>
</div>
<p>We show that given a triangle <span class="math">\(\{e_1, e_2, e_3\}\)</span>, we have
<span class="math">\(X_G = X_{G - e_1} + X_{G - e_2} - X_{G - e_1 - e_2}\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">XG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_symmetric_function</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G1</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G1</span><span class="o">.</span><span class="n">delete_edge</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">XG1</span> <span class="o">=</span> <span class="n">G1</span><span class="o">.</span><span class="n">chromatic_symmetric_function</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G2</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G2</span><span class="o">.</span><span class="n">delete_edge</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">XG2</span> <span class="o">=</span> <span class="n">G2</span><span class="o">.</span><span class="n">chromatic_symmetric_function</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G3</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">G1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G3</span><span class="o">.</span><span class="n">delete_edge</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">XG3</span> <span class="o">=</span> <span class="n">G3</span><span class="o">.</span><span class="n">chromatic_symmetric_function</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">XG</span> <span class="o">==</span> <span class="n">XG1</span> <span class="o">+</span> <span class="n">XG2</span> <span class="o">-</span> <span class="n">XG3</span>
<span class="go">True</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="stanley95" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[Stanley95]</a></td><td>R. P. Stanley, <em>A symmetric function generalization
of the chromatic polynomial of a graph</em>, Adv. Math., <strong>*111*</strong>
no.1 (1995), 166-194.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.clique_complex">
<tt class="descname">clique_complex</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.clique_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the clique complex of self. This is the largest simplicial complex on
the vertices of self whose 1-skeleton is self.</p>
<p>This is only makes sense for undirected simple graphs.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span><span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">clique_complex</span><span class="p">()</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 4) and facets {(4,), (0, 1, 2)}</span>

<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">clique_complex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3, 4) and facets {(0, 1, 4), (0, 1, 2, 3)}</span>
<span class="gp">sage: </span><span class="n">i</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">i</span><span class="o">==</span><span class="n">h</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">==</span><span class="n">i</span><span class="o">.</span><span class="n">clique_complex</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.clique_maximum">
<tt class="descname">clique_maximum</tt><big>(</big><em>algorithm='Cliquer'</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.clique_maximum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the vertex set of a maximal order complete subgraph.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">algorithm</span></tt> &#8211; the algorithm to be used :</p>
<ul>
<li><p class="first">If <tt class="docutils literal"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;Cliquer&quot;</span></tt> (default) - This wraps the C program
Cliquer <a class="reference internal" href="cliquer.html#nisost2003" id="id4">[NisOst2003]</a>.</p>
</li>
<li><p class="first">If <tt class="docutils literal"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;MILP&quot;</span></tt>, the problem is solved through a Mixed
Integer Linear Program.</p>
<p>(see <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">MixedIntegerLinearProgram</span></tt></a>)</p>
</li>
<li><p class="first">If <tt class="docutils literal"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;mcqd&quot;</span></tt> - Uses the MCQD solver
(<a class="reference external" href="http://www.sicmm.org/~konc/maxclique/">http://www.sicmm.org/~konc/maxclique/</a>). Note that the MCQD
package must be installed.</p>
</li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently only implemented for undirected graphs. Use to_undirected
to convert a digraph to an undirected graph.</p>
</div>
<p>ALGORITHM:</p>
<p>This function is based on Cliquer <a class="reference internal" href="cliquer.html#nisost2003" id="id5">[NisOst2003]</a>.</p>
<p>EXAMPLES:</p>
<p>Using Cliquer (default):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">clique_maximum</span><span class="p">()</span>
<span class="go">[7, 9]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;DJ{&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">clique_maximum</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4]</span>
</pre></div>
</div>
<p>Through a Linear Program:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">clique_maximum</span><span class="p">(</span><span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;MILP&quot;</span><span class="p">))</span>
<span class="go">4</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Wrong algorithm:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">clique_maximum</span><span class="p">(</span><span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;BFS&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">Only &#39;MILP&#39;, &#39;Cliquer&#39; and &#39;mcqd&#39; are supported.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.clique_number">
<tt class="descname">clique_number</tt><big>(</big><em>algorithm='Cliquer'</em>, <em>cliques=None</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.clique_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the order of the largest clique of the graph (the clique
number).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently only implemented for undirected graphs. Use <tt class="docutils literal"><span class="pre">to_undirected</span></tt>
to convert a digraph to an undirected graph.</p>
</div>
<p>INPUT:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">algorithm</span></tt> &#8211; the algorithm to be used :</p>
<ul>
<li><p class="first">If <tt class="docutils literal"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;Cliquer&quot;</span></tt> - This wraps the C program Cliquer
<a class="reference internal" href="cliquer.html#nisost2003" id="id6">[NisOst2003]</a>.</p>
</li>
<li><p class="first">If <tt class="docutils literal"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;networkx&quot;</span></tt> - This function is based on
NetworkX&#8217;s implementation of the Bron and Kerbosch Algorithm
<a class="reference internal" href="#broker1973" id="id7">[BroKer1973]</a>.</p>
</li>
<li><p class="first">If <tt class="docutils literal"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;MILP&quot;</span></tt>, the problem is solved through a Mixed
Integer Linear Program.</p>
<p>(see <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">MixedIntegerLinearProgram</span></tt></a>)</p>
</li>
<li><p class="first">If <tt class="docutils literal"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;mcqd&quot;</span></tt> - Uses the MCQD solver
(<a class="reference external" href="http://www.sicmm.org/~konc/maxclique/">http://www.sicmm.org/~konc/maxclique/</a>). Note that the MCQD
package must be installed.</p>
</li>
</ul>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">cliques</span></tt> - an optional list of cliques that can be input if
already computed. Ignored unless <tt class="docutils literal"><span class="pre">algorithm==&quot;networkx&quot;</span></tt>.</p>
</li>
</ul>
<p>ALGORITHM:</p>
<p>This function is based on Cliquer <a class="reference internal" href="cliquer.html#nisost2003" id="id9">[NisOst2003]</a> and <a class="reference internal" href="#broker1973" id="id10">[BroKer1973]</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;DJ{&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">clique_number</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">clique_number</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>By definition the clique number of a complete graph is its order:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">clique_number</span><span class="p">()</span> <span class="o">==</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">15</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A non-empty graph without edges has a clique number of 1:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">((</span><span class="n">i</span><span class="o">*</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">clique_number</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">15</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A complete multipartite graph with k parts has clique number k:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">((</span><span class="n">i</span><span class="o">*</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteMultipartiteGraph</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="p">[</span><span class="mi">5</span><span class="p">]))</span><span class="o">.</span><span class="n">clique_number</span><span class="p">()</span> <span class="o">==</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">clique_number</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;MILP&quot;</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>                                            <span class="c1"># optional - mcqd</span>
<span class="gp">... </span>      <span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">)</span>                                <span class="c1"># optional - mcqd</span>
<span class="gp">... </span>      <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">clique_number</span><span class="p">()</span> <span class="o">!=</span> <span class="n">g</span><span class="o">.</span><span class="n">clique_number</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;mcqd&quot;</span><span class="p">):</span> <span class="c1"># optional - mcqd</span>
<span class="gp">... </span>          <span class="k">print</span> <span class="s2">&quot;This is dead wrong !&quot;</span>                           <span class="c1"># optional - mcqd</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.clique_polynomial">
<tt class="descname">clique_polynomial</tt><big>(</big><em>t=None</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.clique_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the clique polynomial of self.</p>
<p>This is the polynomial where the coefficient of <span class="math">\(t^n\)</span> is the number of
cliques in the graph with <span class="math">\(n\)</span> vertices. The constant term of the
clique polynomial is always taken to be one.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">clique_polynomial</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">clique_polynomial</span><span class="p">()</span>
<span class="go">t^2 + 2*t + 1</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">clique_polynomial</span><span class="p">()</span>
<span class="go">4*t^2 + 4*t + 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.cliques_containing_vertex">
<tt class="descname">cliques_containing_vertex</tt><big>(</big><em>vertices=None</em>, <em>cliques=None</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.cliques_containing_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the cliques containing each vertex, represented as a dictionary
of lists of lists, keyed by vertex. (Returns a single list if only one
input vertex).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently only implemented for undirected graphs. Use to_undirected
to convert a digraph to an undirected graph.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">vertices</span></tt> - the vertices to inspect (default is
entire graph)</li>
<li><tt class="docutils literal"><span class="pre">cliques</span></tt> - list of cliques (if already
computed)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;DJ{&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_containing_vertex</span><span class="p">()</span>
<span class="go">{0: [[4, 0]], 1: [[4, 1, 2, 3]], 2: [[4, 1, 2, 3]], 3: [[4, 1, 2, 3]], 4: [[4, 0], [4, 1, 2, 3]]}</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">cliques_maximal</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">E</span>
<span class="go">[[0, 4], [1, 2, 3, 4]]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_containing_vertex</span><span class="p">(</span><span class="n">cliques</span><span class="o">=</span><span class="n">E</span><span class="p">)</span>
<span class="go">{0: [[0, 4]], 1: [[1, 2, 3, 4]], 2: [[1, 2, 3, 4]], 3: [[1, 2, 3, 4]], 4: [[0, 4], [1, 2, 3, 4]]}</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">cliques_containing_vertex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">()):</span>
<span class="gp">... </span>   <span class="k">print</span> <span class="n">v</span><span class="p">,</span> <span class="n">X</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
<span class="go">(0, 0) [[(0, 1), (0, 0)], [(1, 0), (0, 0)]]</span>
<span class="go">(0, 1) [[(0, 1), (0, 0)], [(0, 1), (0, 2)], [(0, 1), (1, 1)]]</span>
<span class="go">(0, 2) [[(0, 1), (0, 2)], [(1, 2), (0, 2)]]</span>
<span class="go">(1, 0) [[(1, 0), (0, 0)], [(1, 0), (1, 1)]]</span>
<span class="go">(1, 1) [[(0, 1), (1, 1)], [(1, 2), (1, 1)], [(1, 0), (1, 1)]]</span>
<span class="go">(1, 2) [[(1, 2), (0, 2)], [(1, 2), (1, 1)]]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">cliques_containing_vertex</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="go">{(0, 1): [[(0, 1), (0, 0)], [(0, 1), (0, 2)], [(0, 1), (1, 1)]], (1, 2): [[(1, 2), (0, 2)], [(1, 2), (1, 1)]]}</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cliques_containing_vertex</span><span class="p">()</span>
<span class="go">{0: [[0, 1, 2], [0, 1, 3]], 1: [[0, 1, 2], [0, 1, 3]], 2: [[0, 1, 2]], 3: [[0, 1, 3]]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.cliques_get_clique_bipartite">
<tt class="descname">cliques_get_clique_bipartite</tt><big>(</big><em>**kwds</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.cliques_get_clique_bipartite" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a bipartite graph constructed such that maximal cliques are the
right vertices and the left vertices are retained from the given
graph. Right and left vertices are connected if the bottom vertex
belongs to the clique represented by a top vertex.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently only implemented for undirected graphs. Use to_undirected
to convert a digraph to an undirected graph.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">())</span><span class="o">.</span><span class="n">cliques_get_clique_bipartite</span><span class="p">()</span>
<span class="go">Bipartite graph on 36 vertices</span>
<span class="gp">sage: </span><span class="p">((</span><span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">())</span><span class="o">.</span><span class="n">cliques_get_clique_bipartite</span><span class="p">())</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">vertex_size</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">vertex_labels</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cliques_get_clique_bipartite</span><span class="p">()</span>
<span class="go">Bipartite graph on 6 vertices</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">cliques_get_clique_bipartite</span><span class="p">())</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.cliques_get_max_clique_graph">
<tt class="descname">cliques_get_max_clique_graph</tt><big>(</big><em>name=''</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.cliques_get_max_clique_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a graph constructed with maximal cliques as vertices, and
edges between maximal cliques with common members in the original
graph.</p>
<p>For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Clique_graph">Wikipedia article Clique_graph</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently only implemented for undirected graphs. Use to_undirected
to convert a digraph to an undirected graph.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">name</span></tt> - The name of the new graph.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">())</span><span class="o">.</span><span class="n">cliques_get_max_clique_graph</span><span class="p">()</span>
<span class="go">Graph on 24 vertices</span>
<span class="gp">sage: </span><span class="p">((</span><span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">())</span><span class="o">.</span><span class="n">cliques_get_max_clique_graph</span><span class="p">())</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">vertex_size</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">vertex_labels</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cliques_get_max_clique_graph</span><span class="p">()</span>
<span class="go">Graph on 2 vertices</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">cliques_get_max_clique_graph</span><span class="p">())</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.cliques_maximal">
<tt class="descname">cliques_maximal</tt><big>(</big><em>algorithm='native'</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.cliques_maximal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the list of all maximal cliques, with each clique represented
by a list of vertices. A clique is an induced complete subgraph, and a
maximal clique is one not contained in a larger one.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">algorithm</span></tt> &#8211; can be set to <tt class="docutils literal"><span class="pre">&quot;native&quot;</span></tt> (default) to use Sage&#8217;s
own implementation, or to <tt class="docutils literal"><span class="pre">&quot;NetworkX&quot;</span></tt> to use NetworkX&#8217;
implementation of the Bron and Kerbosch Algorithm <a class="reference internal" href="#broker1973" id="id11">[BroKer1973]</a>.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method sorts its output before returning it. If you prefer to
save the extra time, you can call
<a class="reference internal" href="independent_sets.html#sage.graphs.independent_sets.IndependentSets" title="sage.graphs.independent_sets.IndependentSets"><tt class="xref py py-class docutils literal"><span class="pre">sage.graphs.independent_sets.IndependentSets</span></tt></a> directly.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Sage&#8217;s implementation of the enumeration of <em>maximal</em> independent
sets is not much faster than NetworkX&#8217; (expect a 2x speedup), which
is surprising as it is written in Cython. This being said, the
algorithm from NetworkX appears to be sligthly different from this
one, and that would be a good thing to explore if one wants to
improve the implementation.</p>
</div>
<p>ALGORITHM:</p>
<p>This function is based on NetworkX&#8217;s implementation of the Bron and
Kerbosch Algorithm <a class="reference internal" href="#broker1973" id="id12">[BroKer1973]</a>.</p>
<p>REFERENCE:</p>
<table class="docutils citation" frame="void" id="broker1973" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[BroKer1973]</td><td><em>(<a class="fn-backref" href="#id7">1</a>, <a class="fn-backref" href="#id10">2</a>, <a class="fn-backref" href="#id11">3</a>, <a class="fn-backref" href="#id12">4</a>, <a class="fn-backref" href="#id15">5</a>)</em> Coen Bron and Joep Kerbosch. (1973). Algorithm 457:
Finding All Cliques of an Undirected Graph. Commun. ACM. v
16. n 9.  pages 575-577. ACM Press. [Online] Available:
<a class="reference external" href="http://www.ram.org/computing/rambin/rambin.html">http://www.ram.org/computing/rambin/rambin.html</a></td></tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">()</span><span class="o">.</span><span class="n">cliques_maximal</span><span class="p">()</span>
<span class="go">[[0, 1], [0, 4], [0, 6], [0, 9], [1, 2], [1, 5], [1, 7], [2, 3],</span>
<span class="go"> [2, 6], [2, 8], [3, 4], [3, 7], [3, 9], [4, 5], [4, 8], [5, 10],</span>
<span class="go"> [5, 11], [6, 10], [6, 11], [7, 8], [7, 11], [8, 10], [9, 10], [9, 11]]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cliques_maximal</span><span class="p">()</span>
<span class="go">[[0, 1, 2], [0, 1, 3]]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_maximal</span><span class="p">()</span>
<span class="go">[[0, 1], [0, 4], [0, 5], [1, 2], [1, 6], [2, 3], [2, 7], [3, 4],</span>
<span class="go"> [3, 8], [4, 9], [5, 7], [5, 8], [6, 8], [6, 9], [7, 9]]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;DJ{&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_maximal</span><span class="p">()</span>
<span class="go">[[0, 4], [1, 2, 3, 4]]</span>
</pre></div>
</div>
<p>Comparing the two implementations:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="o">.</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s1</span> <span class="o">=</span> <span class="n">Set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">cliques_maximal</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;NetworkX&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">s2</span> <span class="o">=</span> <span class="n">Set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">cliques_maximal</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;native&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.cliques_maximum">
<tt class="descname">cliques_maximum</tt><big>(</big><em>graph</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.cliques_maximum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the vertex sets of <em>ALL</em> the maximum complete subgraphs.</p>
<p>Returns the list of all maximum cliques, with each clique represented by a
list of vertices. A clique is an induced complete subgraph, and a maximum
clique is one of maximal order.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently only implemented for undirected graphs. Use to_undirected
to convert a digraph to an undirected graph.</p>
</div>
<p>ALGORITHM:</p>
<p>This function is based on Cliquer <a class="reference internal" href="cliquer.html#nisost2003" id="id13">[NisOst2003]</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">()</span><span class="o">.</span><span class="n">cliques_maximum</span><span class="p">()</span> <span class="c1"># indirect doctest</span>
<span class="go">[[0, 1], [0, 4], [0, 6], [0, 9], [1, 2], [1, 5], [1, 7], [2, 3],</span>
<span class="go"> [2, 6], [2, 8], [3, 4], [3, 7], [3, 9], [4, 5], [4, 8], [5, 10],</span>
<span class="go"> [5, 11], [6, 10], [6, 11], [7, 8], [7, 11], [8, 10], [9, 10], [9, 11]]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cliques_maximum</span><span class="p">()</span>
<span class="go">[[0, 1, 2], [0, 1, 3]]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_maximum</span><span class="p">()</span>
<span class="go">[[0, 1], [0, 4], [0, 5], [1, 2], [1, 6], [2, 3], [2, 7], [3, 4],</span>
<span class="go"> [3, 8], [4, 9], [5, 7], [5, 8], [6, 8], [6, 9], [7, 9]]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;DJ{&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_maximum</span><span class="p">()</span>
<span class="go">[[1, 2, 3, 4]]</span>
</pre></div>
</div>
<p>TEST:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">cliques_maximum</span><span class="p">()</span>
<span class="go">[[]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.cliques_number_of">
<tt class="descname">cliques_number_of</tt><big>(</big><em>vertices=None</em>, <em>cliques=None</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.cliques_number_of" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary of the number of maximal cliques containing each
vertex, keyed by vertex. (Returns a single value if
only one input vertex).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently only implemented for undirected graphs. Use to_undirected
to convert a digraph to an undirected graph.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">vertices</span></tt> - the vertices to inspect (default is
entire graph)</li>
<li><tt class="docutils literal"><span class="pre">cliques</span></tt> - list of cliques (if already
computed)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;DJ{&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_number_of</span><span class="p">()</span>
<span class="go">{0: 1, 1: 1, 2: 1, 3: 1, 4: 2}</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">cliques_maximal</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">E</span>
<span class="go">[[0, 4], [1, 2, 3, 4]]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_number_of</span><span class="p">(</span><span class="n">cliques</span><span class="o">=</span><span class="n">E</span><span class="p">)</span>
<span class="go">{0: 1, 1: 1, 2: 1, 3: 1, 4: 2}</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">cliques_number_of</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">()):</span>
<span class="gp">... </span>   <span class="k">print</span> <span class="n">v</span><span class="p">,</span> <span class="n">X</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
<span class="go">(0, 0) 2</span>
<span class="go">(0, 1) 3</span>
<span class="go">(0, 2) 2</span>
<span class="go">(1, 0) 2</span>
<span class="go">(1, 1) 3</span>
<span class="go">(1, 2) 2</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">cliques_number_of</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="go">{(0, 1): 3, (1, 2): 2}</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cliques_number_of</span><span class="p">()</span>
<span class="go">{0: 2, 1: 2, 2: 1, 3: 1}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.cliques_vertex_clique_number">
<tt class="descname">cliques_vertex_clique_number</tt><big>(</big><em>algorithm='cliquer'</em>, <em>vertices=None</em>, <em>cliques=None</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.cliques_vertex_clique_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary of sizes of the largest maximal cliques containing
each vertex, keyed by vertex. (Returns a single value if only one
input vertex).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently only implemented for undirected graphs. Use to_undirected
to convert a digraph to an undirected graph.</p>
</div>
<p>INPUT:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">algorithm</span></tt> - either <tt class="docutils literal"><span class="pre">cliquer</span></tt> or <tt class="docutils literal"><span class="pre">networkx</span></tt><ul>
<li><tt class="docutils literal"><span class="pre">cliquer</span></tt> - This wraps the C program Cliquer <a class="reference internal" href="cliquer.html#nisost2003" id="id14">[NisOst2003]</a>.</li>
<li><tt class="docutils literal"><span class="pre">networkx</span></tt> - This function is based on NetworkX&#8217;s implementation
of the Bron and Kerbosch Algorithm <a class="reference internal" href="#broker1973" id="id15">[BroKer1973]</a>.</li>
</ul>
</li>
</ul>
</div></blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">vertices</span></tt> - the vertices to inspect (default is entire graph).
Ignored unless <tt class="docutils literal"><span class="pre">algorithm=='networkx'</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">cliques</span></tt> - list of cliques (if already computed).  Ignored unless
<tt class="docutils literal"><span class="pre">algorithm=='networkx'</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;DJ{&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_vertex_clique_number</span><span class="p">()</span>
<span class="go">{0: 2, 1: 4, 2: 4, 3: 4, 4: 4}</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">cliques_maximal</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">E</span>
<span class="go">[[0, 4], [1, 2, 3, 4]]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_vertex_clique_number</span><span class="p">(</span><span class="n">cliques</span><span class="o">=</span><span class="n">E</span><span class="p">,</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;networkx&quot;</span><span class="p">)</span>
<span class="go">{0: 2, 1: 4, 2: 4, 3: 4, 4: 4}</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">cliques_vertex_clique_number</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;networkx&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">()):</span>
<span class="gp">... </span>   <span class="k">print</span> <span class="n">v</span><span class="p">,</span> <span class="n">X</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
<span class="go">(0, 0) 2</span>
<span class="go">(0, 1) 2</span>
<span class="go">(0, 2) 2</span>
<span class="go">(1, 0) 2</span>
<span class="go">(1, 1) 2</span>
<span class="go">(1, 2) 2</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">cliques_vertex_clique_number</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="go">{(0, 1): 2, (1, 2): 2}</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cliques_vertex_clique_number</span><span class="p">()</span>
<span class="go">{0: 3, 1: 3, 2: 3, 3: 3}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.coloring">
<tt class="descname">coloring</tt><big>(</big><em>algorithm='DLX'</em>, <em>hex_colors=False</em>, <em>verbose=0</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.coloring" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the first (optimal) proper vertex-coloring found.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">algorithm</span></tt> &#8211; Select an algorithm from the following supported
algorithms:<ul>
<li>If <tt class="docutils literal"><span class="pre">algorithm=&quot;DLX&quot;</span></tt> (default), the coloring is computed using the
dancing link algorithm.</li>
<li>If <tt class="docutils literal"><span class="pre">algorithm=&quot;MILP&quot;</span></tt>, the coloring is computed using a mixed
integer linear program. The performance of this implementation is
affected by whether optional MILP solvers have been installed (see
the <a class="reference external" href="../../../numerical/sage/numerical/mip.html#module-sage.numerical.mip" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-mod docutils literal"><span class="pre">MILP</span> <span class="pre">module</span></tt></a>).</li>
</ul>
</li>
<li><tt class="docutils literal"><span class="pre">hex_colors</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>) if <tt class="docutils literal"><span class="pre">True</span></tt>, return a
dictionary which can easily be used for plotting.</li>
<li><tt class="docutils literal"><span class="pre">verbose</span></tt> &#8211; integer (default: <tt class="docutils literal"><span class="pre">0</span></tt>). Sets the level of verbosity
for the MILP algorithm. Its default value is 0, which means <em>quiet</em>.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">For more functions related to graph coloring, see the
module <a class="reference internal" href="graph_coloring.html#module-sage.graphs.graph_coloring" title="sage.graphs.graph_coloring"><tt class="xref py py-mod docutils literal"><span class="pre">sage.graphs.graph_coloring</span></tt></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s2">&quot;Fooba&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">coloring</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;MILP&quot;</span><span class="p">);</span> <span class="n">P</span>
<span class="go">[[2, 1, 3], [0, 6, 5], [4]]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">coloring</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;DLX&quot;</span><span class="p">);</span> <span class="n">P</span>
<span class="go">[[1, 2, 3], [0, 5, 6], [4]]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">partition</span><span class="o">=</span><span class="n">P</span><span class="p">)</span>
<span class="go">Graphics object consisting of 16 graphics primitives</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">coloring</span><span class="p">(</span><span class="n">hex_colors</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;MILP&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
<span class="gp">... </span>      <span class="k">print</span> <span class="n">c</span><span class="p">,</span> <span class="n">H</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
<span class="go">#0000ff [4]</span>
<span class="go">#00ff00 [0, 6, 5]</span>
<span class="go">#ff0000 [2, 1, 3]</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">coloring</span><span class="p">(</span><span class="n">hex_colors</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;DLX&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
<span class="gp">... </span>      <span class="k">print</span> <span class="n">c</span><span class="p">,</span> <span class="n">H</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
<span class="go">#0000ff [4]</span>
<span class="go">#00ff00 [1, 2, 3]</span>
<span class="go">#ff0000 [0, 5, 6]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">vertex_colors</span><span class="o">=</span><span class="n">H</span><span class="p">)</span>
<span class="go">Graphics object consisting of 16 graphics primitives</span>
</pre></div>
</div>
<div class="figure">
<img alt="../../_images/graph-1.png" src="../../_images/graph-1.png" />
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">coloring</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The &#39;algorithm&#39; keyword must be set to either &#39;DLX&#39; or &#39;MILP&#39;.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.convexity_properties">
<tt class="descname">convexity_properties</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.convexity_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <tt class="docutils literal"><span class="pre">ConvexityProperties</span></tt> object corresponding to <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>This object contains the methods related to convexity in graphs (convex
hull, hull number) and caches useful information so that it becomes
comparatively cheaper to compute the convex hull of many different sets
of the same graph.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">In order to know what can be done through this object, please refer
to module <a class="reference internal" href="convexity_properties.html#module-sage.graphs.convexity_properties" title="sage.graphs.convexity_properties"><tt class="xref py py-mod docutils literal"><span class="pre">sage.graphs.convexity_properties</span></tt></a>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>If you want to compute many convex hulls, keep this object in memory
! When it is created, it builds a table of useful information to
compute convex hulls. As a result</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">convexity_properties</span><span class="p">()</span><span class="o">.</span><span class="n">hull</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">convexity_properties</span><span class="p">()</span><span class="o">.</span><span class="n">hull</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="go">[2, 3, 7]</span>
</pre></div>
</div>
<p>Is a terrible waste of computations, while</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">CP</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">convexity_properties</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">CP</span><span class="o">.</span><span class="n">hull</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">CP</span><span class="o">.</span><span class="n">hull</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="go">[2, 3, 7]</span>
</pre></div>
</div>
<p class="last">Makes perfect sense.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.cores">
<tt class="descname">cores</tt><big>(</big><em>k=None</em>, <em>with_labels=False</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.cores" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the core number for each vertex in an ordered list.</p>
<p>(for homomorphisms cores, see the <a class="reference internal" href="#sage.graphs.graph.Graph.has_homomorphism_to" title="sage.graphs.graph.Graph.has_homomorphism_to"><tt class="xref py py-meth docutils literal"><span class="pre">Graph.has_homomorphism_to()</span></tt></a>
method)</p>
<p><strong>DEFINITIONS</strong></p>
<ul>
<li><p class="first"><em>K-cores</em> in graph theory were introduced by Seidman in 1983 and by
Bollobas in 1984 as a method of (destructively) simplifying graph
topology to aid in analysis and visualization. They have been more
recently defined as the following by Batagelj et al:</p>
<p><em>Given a graph `G` with vertices set `V` and edges set `E`, the
`k`-core of `G` is the graph obtained from `G` by recursively removing
the vertices with degree less than `k`, for as long as there are any.</em></p>
<p>This operation can be useful to filter or to study some properties of
the graphs. For instance, when you compute the 2-core of graph G, you
are cutting all the vertices which are in a tree part of graph.  (A
tree is a graph with no loops). <a class="reference internal" href="#wpkcore" id="id16">[WPkcore]</a></p>
<p><a class="reference internal" href="#psw1996" id="id17">[PSW1996]</a> defines a <span class="math">\(k\)</span>-core of <span class="math">\(G\)</span> as the largest subgraph (it is
unique) of <span class="math">\(G\)</span> with minimum degree at least <span class="math">\(k\)</span>.</p>
</li>
<li><p class="first">Core number of a vertex</p>
<p>The core number of a vertex <span class="math">\(v\)</span> is the largest integer <span class="math">\(k\)</span> such that
<span class="math">\(v\)</span> belongs to the <span class="math">\(k\)</span>-core of <span class="math">\(G\)</span>.</p>
</li>
<li><p class="first">Degeneracy</p>
<p>The <em>degeneracy</em> of a graph <span class="math">\(G\)</span>, usually denoted <span class="math">\(\delta^*(G)\)</span>, is the
smallest integer <span class="math">\(k\)</span> such that the graph <span class="math">\(G\)</span> can be reduced to the
empty graph by iteratively removing vertices of degree <span class="math">\(\leq
k\)</span>. Equivalently, <span class="math">\(\delta^*(G)=k\)</span> if <span class="math">\(k\)</span> is the smallest integer such
that the <span class="math">\(k\)</span>-core of <span class="math">\(G\)</span> is empty.</p>
</li>
</ul>
<p><strong>IMPLEMENTATION</strong></p>
<p>This implementation is based on the NetworkX implementation of
the algorithm described in <a class="reference internal" href="#bz" id="id18">[BZ]</a>.</p>
<p><strong>INPUT</strong></p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">k</span></tt> (integer)</p>
<blockquote>
<div><ul class="simple">
<li>If <tt class="docutils literal"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">None</span></tt> (default), returns the core number for each vertex.</li>
<li>If <tt class="docutils literal"><span class="pre">k</span></tt> is an integer, returns a pair <tt class="docutils literal"><span class="pre">(ordering,</span> <span class="pre">core)</span></tt>, where
<tt class="docutils literal"><span class="pre">core</span></tt> is the list of vertices in the <span class="math">\(k\)</span>-core of <tt class="docutils literal"><span class="pre">self</span></tt>, and
<tt class="docutils literal"><span class="pre">ordering</span></tt> is an elimination order for the other vertices such
that each vertex is of degree strictly less than <span class="math">\(k\)</span> when it is to
be eliminated from the graph.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">with_labels</span></tt> (boolean)</p>
<blockquote>
<div><ul>
<li><p class="first">When set to <tt class="docutils literal"><span class="pre">False</span></tt>, and <tt class="docutils literal"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">None</span></tt>, the method returns a list
whose <span class="math">\(i\)</span> th element is the core number of the <span class="math">\(i\)</span> th vertex. When
set to <tt class="docutils literal"><span class="pre">True</span></tt>, the method returns a dictionary whose keys are
vertices, and whose values are the corresponding core numbers.</p>
<p>By default, <tt class="docutils literal"><span class="pre">with_labels</span> <span class="pre">=</span> <span class="pre">False</span></tt>.</p>
</li>
</ul>
</div></blockquote>
</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li>Graph cores is also a notion related to graph homomorphisms. For
this second meaning, see <a class="reference internal" href="#sage.graphs.graph.Graph.has_homomorphism_to" title="sage.graphs.graph.Graph.has_homomorphism_to"><tt class="xref py py-meth docutils literal"><span class="pre">Graph.has_homomorphism_to()</span></tt></a>.</li>
</ul>
</div>
<p>REFERENCE:</p>
<table class="docutils citation" frame="void" id="wpkcore" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[WPkcore]</a></td><td>K-core. Wikipedia. (2007). [Online] Available:
<a class="reference external" href="https://en.wikipedia.org/wiki/K-core">Wikipedia article K-core</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="psw1996" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[PSW1996]</a></td><td>Boris Pittel, Joel Spencer and Nicholas Wormald. Sudden
Emergence of a Giant k-Core in a Random
Graph. (1996). J. Combinatorial Theory. Ser B 67. pages
111-151. [Online] Available:
<a class="reference external" href="http://cs.nyu.edu/cs/faculty/spencer/papers/k-core.pdf">http://cs.nyu.edu/cs/faculty/spencer/papers/k-core.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="bz" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id18">[BZ]</a></td><td>Vladimir Batagelj and Matjaz Zaversnik. An <span class="math">\(O(m)\)</span>
Algorithm for Cores Decomposition of
Networks. <a class="reference external" href="http://arxiv.org/abs/cs/0310049v1">Arxiv cs/0310049v1</a>.</td></tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">FruchtGraph</span><span class="p">())</span><span class="o">.</span><span class="n">cores</span><span class="p">()</span>
<span class="go">[3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">FruchtGraph</span><span class="p">())</span><span class="o">.</span><span class="n">cores</span><span class="p">(</span><span class="n">with_labels</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">{0: 3, 1: 3, 2: 3, 3: 3, 4: 3, 5: 3, 6: 3, 7: 3, 8: 3, 9: 3, 10: 3, 11: 3}</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">=</span><span class="n">random_matrix</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">density</span><span class="o">=.</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">=</span><span class="n">Graph</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">nonzero_positions</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">cores</span><span class="o">=</span><span class="n">b</span><span class="o">.</span><span class="n">cores</span><span class="p">(</span><span class="n">with_labels</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span> <span class="n">cores</span>
<span class="go">{0: 3, 1: 3, 2: 3, 3: 3, 4: 2, 5: 2, 6: 3, 7: 1, 8: 3, 9: 3, 10: 3, 11: 3, 12: 3, 13: 3, 14: 2, 15: 3, 16: 3, 17: 3, 18: 3, 19: 3}</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="n">cores</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">c</span><span class="o">&gt;=</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># the vertices in the 2-core</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</span>
</pre></div>
</div>
<p>Checking the 2-core of a random lobster is indeed the empty set:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomLobster</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ordering</span><span class="p">,</span> <span class="n">core</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">cores</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">core</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.degree_constrained_subgraph">
<tt class="descname">degree_constrained_subgraph</tt><big>(</big><em>bounds=None</em>, <em>solver=None</em>, <em>verbose=0</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.degree_constrained_subgraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a degree-constrained subgraph.</p>
<p>Given a graph <span class="math">\(G\)</span> and two functions <span class="math">\(f, g:V(G)\rightarrow \mathbb Z\)</span>
such that <span class="math">\(f \leq g\)</span>, a degree-constrained subgraph in <span class="math">\(G\)</span> is
a subgraph <span class="math">\(G' \subseteq G\)</span> such that for any vertex <span class="math">\(v \in G\)</span>,
<span class="math">\(f(v) \leq d_{G'}(v) \leq g(v)\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">bounds</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) Two possibilities:<ul>
<li>A dictionary whose keys are the vertices, and values a pair of
real values <tt class="docutils literal"><span class="pre">(min,max)</span></tt> corresponding to the values
<span class="math">\((f(v),g(v))\)</span>.</li>
<li>A function associating to each vertex a pair of
real values <tt class="docutils literal"><span class="pre">(min,max)</span></tt> corresponding to the values
<span class="math">\((f(v),g(v))\)</span>.</li>
</ul>
</li>
<li><tt class="docutils literal"><span class="pre">solver</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) Specify a Linear Program (LP)
solver to be used. If set to <tt class="docutils literal"><span class="pre">None</span></tt>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-meth docutils literal"><span class="pre">solve</span></tt></a>
of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">MixedIntegerLinearProgram</span></tt></a>.</li>
<li><tt class="docutils literal"><span class="pre">verbose</span></tt> &#8211; integer (default: <tt class="docutils literal"><span class="pre">0</span></tt>). Sets the level of
verbosity. Set to 0 by default, which means quiet.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>When a solution exists, this method outputs the degree-constained
subgraph as a Graph object.</li>
<li>When no solution exists, returns <tt class="docutils literal"><span class="pre">False</span></tt>.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>This algorithm computes the degree-constrained subgraph of minimum weight.</li>
<li>If the graph&#8217;s edges are weighted, these are taken into account.</li>
<li>This problem can be solved in polynomial time.</li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>Is there a perfect matching in an even cycle?</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bounds</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">degree_constrained_subgraph</span><span class="p">(</span><span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.fractional_chromatic_index">
<tt class="descname">fractional_chromatic_index</tt><big>(</big><em>solver=None</em>, <em>verbose_constraints=0</em>, <em>verbose=0</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.fractional_chromatic_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the fractional chromatic index of <tt class="docutils literal"><span class="pre">self</span></tt></p>
<p>The fractional chromatic index is a relaxed version of edge-coloring. An
edge coloring of a graph being actually a covering of its edges into the
smallest possible number of matchings, the fractional chromatic index of
a graph <span class="math">\(G\)</span> is the smallest real value <span class="math">\(\chi_f(G)\)</span> such that there
exists a list of matchings <span class="math">\(M_1, ..., M_k\)</span> of <span class="math">\(G\)</span> and coefficients
<span class="math">\(\alpha_1, ..., \alpha_k\)</span> with the property that each edge is covered by
the matchings in the following relaxed way</p>
<div class="math">
\[\forall e \in E(G), \sum_{e \in M_i} \alpha_i \geq 1\]</div>
<p>For more information, see the <a class="reference external" href="http://en.wikipedia.org/wiki/Fractional_coloring">Wikipedia article on fractional coloring</a>.</p>
<p>ALGORITHM:</p>
<p>The fractional chromatic index is computed through Linear Programming
through its dual. The LP solved by sage is actually:</p>
<div class="math">
\[\begin{split}\mbox{Maximize : }&amp;\sum_{e\in E(G)} r_{e}\\
\mbox{Such that : }&amp;\\
&amp;\forall M\text{ matching }\subseteq G, \sum_{e\in M}r_{v}\leq 1\\\end{split}\]</div>
<p>INPUT:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">solver</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) Specify a Linear Program (LP)
solver to be used. If set to <tt class="docutils literal"><span class="pre">None</span></tt>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-meth docutils literal"><span class="pre">solve</span></tt></a>
of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">MixedIntegerLinearProgram</span></tt></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you want exact results, i.e. a rational number, use
<tt class="docutils literal"><span class="pre">solver=&quot;PPL&quot;</span></tt>. This may be slower, though.</p>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">verbose_constraints</span></tt> &#8211; whether to display which constraints are
being generated.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">verbose</span></tt> &#8211; level of verbosity required from the LP solver</p>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This implementation can be improved by computing matchings through a
LP formulation, and not using the Python implementation of Edmonds&#8217;
algorithm (which requires to copy the graph, etc). It may be more
efficient to write the matching problem as a LP, as we would then
just have to update the weights on the edges between each call to
<tt class="docutils literal"><span class="pre">solve</span></tt> (and so avoiding the generation of all the constraints).</p>
</div>
<p>EXAMPLE:</p>
<p>The fractional chromatic index of a <span class="math">\(C_5\)</span> is <span class="math">\(5/2\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">fractional_chromatic_index</span><span class="p">()</span>
<span class="go">2.5</span>
</pre></div>
</div>
<p>With PPL:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">fractional_chromatic_index</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="s2">&quot;PPL&quot;</span><span class="p">)</span>
<span class="go">5/2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.gomory_hu_tree">
<tt class="descname">gomory_hu_tree</tt><big>(</big><em>algorithm='FF'</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.gomory_hu_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Gomory-Hu tree of self.</p>
<p>Given a tree <span class="math">\(T\)</span> with labeled edges representing capacities, it is very
easy to determine the maximum flow between any pair of vertices :
it is the minimal label on the edges of the unique path between them.</p>
<p>Given a graph <span class="math">\(G\)</span>, a Gomory-Hu tree <span class="math">\(T\)</span> of <span class="math">\(G\)</span> is a tree
with the same set of vertices, and such that the maximum flow
between any two vertices is the same in <span class="math">\(G\)</span> as in <span class="math">\(T\)</span>. See the
<a class="reference external" href="http://en.wikipedia.org/wiki/Gomory%E2%80%93Hu_tree">Wikipedia article on Gomory-Hu tree</a>.
Note that, in general, a graph admits more than one Gomory-Hu tree.</p>
<p>See also 15.4 (Gomory-Hu trees) from <a class="reference internal" href="generic_graph.html#schrijvercombopt" id="id19">[SchrijverCombOpt]</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">algorithm</span></tt> &#8211; There are currently two different
implementations of this method :<ul>
<li>If <tt class="docutils literal"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;FF&quot;</span></tt> (default), a Python
implementation of the Ford-Fulkerson algorithm is
used.</li>
<li>If <tt class="docutils literal"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;LP&quot;</span></tt>, the flow problems are solved
using Linear Programming.</li>
</ul>
</li>
</ul>
<p>OUTPUT:</p>
<p>A graph with labeled edges</p>
<p>EXAMPLE:</p>
<p>Taking the Petersen graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">gomory_hu_tree</span><span class="p">()</span>
</pre></div>
</div>
<p>Obviously, this graph is a tree:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">is_tree</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note that if the original graph is not connected, then the
Gomory-Hu tree is in fact a forest:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">gomory_hu_tree</span><span class="p">()</span><span class="o">.</span><span class="n">is_forest</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">gomory_hu_tree</span><span class="p">()</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>On the other hand, such a tree has lost nothing of the initial
graph connectedness:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">([</span> <span class="n">t</span><span class="o">.</span><span class="n">flow</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">flow</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">Subsets</span><span class="p">(</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">(),</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Just to make sure, we can check that the same is true for two vertices
in a random graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="o">.</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">gomory_hu_tree</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">flow</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">flow</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>And also the min cut:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">edge_connectivity</span><span class="p">()</span> <span class="o">==</span> <span class="nb">min</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">edge_labels</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<p><a class="reference external" href="http://trac.sagemath.org/16475">trac ticket #16475</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
<span class="go">....:     G.set_edge_label(u, v, 1)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">)]:</span>
<span class="go">....:     G.set_edge_label(u, v, 2)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">gomory_hu_tree</span><span class="p">()</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
<span class="go">....:     assert T.flow(u,v,use_edge_labels=True) == G.flow(u,v,use_edge_labels=True)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.graph6_string">
<tt class="descname">graph6_string</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.graph6_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the graph6 representation of the graph as an ASCII string.
Only valid for simple (no loops, multiple edges) graphs on 0 to
262143 vertices.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As the graph6 format only handles graphs whose vertex set is
<span class="math">\(\{0,...,n-1\}\)</span>, a <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.relabel" title="sage.graphs.generic_graph.GenericGraph.relabel"><tt class="xref py py-meth docutils literal"><span class="pre">relabelled</span> <span class="pre">copy</span></tt></a> of your graph will
be encoded if necessary.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">KrackhardtKiteGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">graph6_string</span><span class="p">()</span>
<span class="go">&#39;IvUqwK@?G&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.has_homomorphism_to">
<tt class="descname">has_homomorphism_to</tt><big>(</big><em>H</em>, <em>core=False</em>, <em>solver=None</em>, <em>verbose=0</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.has_homomorphism_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether there is a homomorphism between two graphs.</p>
<p>A homomorphism from a graph <span class="math">\(G\)</span> to a graph <span class="math">\(H\)</span> is a function
<span class="math">\(\phi:V(G)\mapsto V(H)\)</span> such that for any edge <span class="math">\(uv \in E(G)\)</span> the pair
<span class="math">\(\phi(u)\phi(v)\)</span> is an edge of <span class="math">\(H\)</span>.</p>
<p>Saying that a graph can be <span class="math">\(k\)</span>-colored is equivalent to saying that it
has a homomorphism to <span class="math">\(K_k\)</span>, the complete graph on <span class="math">\(k\)</span> elements.</p>
<p>For more information, see the <a class="reference external" href="Graph_homomorphism">Wikipedia article on graph homomorphisms</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">H</span></tt> &#8211; the graph to which <tt class="docutils literal"><span class="pre">self</span></tt> should be sent.</li>
<li><tt class="docutils literal"><span class="pre">core</span></tt> (boolean) &#8211; whether to minimize the size of the mapping&#8217;s
image (see note below). This is set to <tt class="docutils literal"><span class="pre">False</span></tt> by default.</li>
<li><tt class="docutils literal"><span class="pre">solver</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) Specify a Linear Program (LP)
solver to be used. If set to <tt class="docutils literal"><span class="pre">None</span></tt>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-meth docutils literal"><span class="pre">solve</span></tt></a>
of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">MixedIntegerLinearProgram</span></tt></a>.</li>
<li><tt class="docutils literal"><span class="pre">verbose</span></tt> &#8211; integer (default: <tt class="docutils literal"><span class="pre">0</span></tt>). Sets the level of
verbosity. Set to 0 by default, which means quiet.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>One can compute the core of a graph (with respect to homomorphism)
with this method</p>
<div class="last highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">mapping</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">has_homomorphism_to</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">core</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">print</span> <span class="s2">&quot;The size of the core is&quot;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
<span class="go">The size of the core is 2</span>
</pre></div>
</div>
</div>
<p>OUTPUT:</p>
<p>This method returns <tt class="docutils literal"><span class="pre">False</span></tt> when the homomorphism does not exist, and
returns the homomorphism otherwise as a dictionary associating a vertex
of <span class="math">\(H\)</span> to a vertex of <span class="math">\(G\)</span>.</p>
<p>EXAMPLE:</p>
<p>Is Petersen&#8217;s graph 3-colorable:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">has_homomorphism_to</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span>
<span class="go">True</span>
</pre></div>
</div>
<p>An odd cycle admits a homomorphism to a smaller odd cycle, but not to an
even cycle:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">has_homomorphism_to</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">has_homomorphism_to</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">has_homomorphism_to</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.ihara_zeta_function_inverse">
<tt class="descname">ihara_zeta_function_inverse</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.ihara_zeta_function_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the inverse of the Ihara zeta function of the graph.</p>
<p>This is a polynomial in one variable with integer coefficients. The
Ihara zeta function itself is the inverse of this polynomial.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Ihara zeta function">Wikipedia article Ihara zeta function</a>.</p>
<p>ALGORITHM:</p>
<p>This is computed here as the (reversed) characteristic
polynomial of a square matrix of size twice the number of edges,
related to the adjacency matrix of the line graph, see for example
Proposition 9 in <a class="reference internal" href="#scottstorm" id="id20">[ScottStorm]</a> and Def. 4.1 in <a class="reference internal" href="#terras" id="id21">[Terras]</a>.</p>
<p>The graph is first replaced by its 2-core, as this does not change
the Ihara zeta function.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">factor</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">ihara_zeta_function_inverse</span><span class="p">())</span>
<span class="go">(2*t - 1) * (t + 1)^2 * (t - 1)^3 * (2*t^2 + t + 1)^3</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">factor</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">ihara_zeta_function_inverse</span><span class="p">())</span>
<span class="go">(-1) * (3*t - 1) * (t + 1)^5 * (t - 1)^6 * (3*t^2 + t + 1)^4</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">factor</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">ihara_zeta_function_inverse</span><span class="p">())</span>
<span class="go">(-1) * (2*t - 1) * (t + 1)^5 * (t - 1)^6 * (2*t^2 + 2*t + 1)^4</span>
<span class="go">* (2*t^2 - t + 1)^5</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomTree</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">ihara_zeta_function_inverse</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="hst" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[HST]</td><td>Matthew D. Horton, H. M. Stark, and Audrey A. Terras,
What are zeta functions of graphs and what are they good for?
in Quantum graphs and their applications, 173-189,
Contemp. Math., Vol. 415</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="terras" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id21">[Terras]</a></td><td>Audrey Terras, Zeta functions of graphs: a stroll through
the garden, Cambridge Studies in Advanced Mathematics, Vol. 128</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="scottstorm" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id20">[ScottStorm]</a></td><td>Geoffrey Scott and Christopher Storm, The coefficients
of the Ihara zeta function, Involve (<a class="reference external" href="http://msp.org/involve/2008/1-2/involve-v1-n2-p08-p.pdf">http://msp.org/involve/2008/1-2/involve-v1-n2-p08-p.pdf</a>)</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.independent_set">
<tt class="descname">independent_set</tt><big>(</big><em>algorithm='Cliquer'</em>, <em>value_only=False</em>, <em>reduction_rules=True</em>, <em>solver=None</em>, <em>verbosity=0</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.independent_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a maximum independent set.</p>
<p>An independent set of a graph is a set of pairwise non-adjacent
vertices. A maximum independent set is an independent set of maximum
cardinality.  It induces an empty subgraph.</p>
<p>Equivalently, an independent set is defined as the complement of a
vertex cover.</p>
<p>For more information, see the
<a class="reference external" href="https://en.wikipedia.org/wiki/Independent_set_(graph_theory)">Wikipedia article Independent_set_(graph_theory)</a> and the
<a class="reference external" href="https://en.wikipedia.org/wiki/Vertex_cover">Wikipedia article Vertex_cover</a>.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">algorithm</span></tt> &#8211; the algorithm to be used</p>
<ul>
<li><p class="first">If <tt class="docutils literal"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;Cliquer&quot;</span></tt> (default), the problem is solved
using Cliquer <a class="reference internal" href="cliquer.html#nisost2003" id="id22">[NisOst2003]</a>.</p>
<p>(see the <a class="reference internal" href="cliquer.html#module-sage.graphs.cliquer" title="sage.graphs.cliquer"><tt class="xref py py-mod docutils literal"><span class="pre">Cliquer</span> <span class="pre">modules</span></tt></a>)</p>
</li>
<li><p class="first">If <tt class="docutils literal"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;MILP&quot;</span></tt>, the problem is solved through a Mixed
Integer Linear Program.</p>
<p>(see <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">MixedIntegerLinearProgram</span></tt></a>)</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>If <tt class="docutils literal"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;mcqd&quot;</span></tt> - Uses the MCQD solver
(<a class="reference external" href="http://www.sicmm.org/~konc/maxclique/">http://www.sicmm.org/~konc/maxclique/</a>). Note that the MCQD
package must be installed.</li>
</ul>
</div></blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">value_only</span></tt> &#8211; boolean (default: <tt class="docutils literal"><span class="pre">False</span></tt>). If set to <tt class="docutils literal"><span class="pre">True</span></tt>,
only the size of a maximum independent set is returned. Otherwise,
a maximum independent set is returned as a list of vertices.</li>
<li><tt class="docutils literal"><span class="pre">reduction_rules</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">True</span></tt>) Specify if the reductions
rules from kernelization must be applied as pre-processing or not.
See <a class="reference internal" href="#acflss04" id="id24">[ACFLSS04]</a> for more details. Note that depending on the
instance, it might be faster to disable reduction rules.</li>
<li><tt class="docutils literal"><span class="pre">solver</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) Specify a Linear Program (LP)
solver to be used. If set to <tt class="docutils literal"><span class="pre">None</span></tt>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-meth docutils literal"><span class="pre">solve()</span></tt></a>
of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">MixedIntegerLinearProgram</span></tt></a>.</li>
<li><tt class="docutils literal"><span class="pre">verbosity</span></tt> &#8211; non-negative integer (default: <tt class="docutils literal"><span class="pre">0</span></tt>). Set the level
of verbosity you want from the linear program solver. Since the
problem of computing an independent set is <span class="math">\(NP\)</span>-complete, its solving
may take some time depending on the graph. A value of 0 means that
there will be no message printed by the solver. This option is only
useful if <tt class="docutils literal"><span class="pre">algorithm=&quot;MILP&quot;</span></tt>.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">While Cliquer/MCAD are usually (and by far) the most efficient
implementations, the MILP formulation sometimes proves faster on
very &#8220;symmetrical&#8221; graphs.</p>
</div>
<p>EXAMPLES:</p>
<p>Using Cliquer:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">independent_set</span><span class="p">()</span>
<span class="go">[0, 3, 6, 7]</span>
</pre></div>
</div>
<p>As a linear program:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">independent_set</span><span class="p">(</span><span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;MILP&quot;</span><span class="p">))</span>
<span class="go">4</span>
</pre></div>
</div>
<div class="figure">
<img alt="../../_images/graph-2.png" src="../../_images/graph-2.png" />
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.independent_set_of_representatives">
<tt class="descname">independent_set_of_representatives</tt><big>(</big><em>family</em>, <em>solver=None</em>, <em>verbose=0</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.independent_set_of_representatives" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an independent set of representatives.</p>
<p>Given a graph <span class="math">\(G\)</span> and and a family <span class="math">\(F=\{F_i:i\in [1,...,k]\}\)</span> of
subsets of <tt class="docutils literal"><span class="pre">g.vertices()</span></tt>, an Independent Set of Representatives
(ISR) is an assignation of a vertex <span class="math">\(v_i\in F_i\)</span> to each set <span class="math">\(F_i\)</span>
such that <span class="math">\(v_i != v_j\)</span> if <span class="math">\(i&lt;j\)</span> (they are representatives) and the
set <span class="math">\(\cup_{i}v_i\)</span> is an independent set in <span class="math">\(G\)</span>.</p>
<p>It generalizes, for example, graph coloring and graph list coloring.</p>
<p>(See <a class="reference internal" href="#ahaberziv07" id="id25">[AhaBerZiv07]</a> for more information.)</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">family</span></tt> &#8211; A list of lists defining the family <span class="math">\(F\)</span>
(actually, a Family of subsets of <tt class="docutils literal"><span class="pre">G.vertices()</span></tt>).</li>
<li><tt class="docutils literal"><span class="pre">solver</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) Specify a Linear Program (LP)
solver to be used. If set to <tt class="docutils literal"><span class="pre">None</span></tt>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-meth docutils literal"><span class="pre">solve</span></tt></a>
of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">MixedIntegerLinearProgram</span></tt></a>.</li>
<li><tt class="docutils literal"><span class="pre">verbose</span></tt> &#8211; integer (default: <tt class="docutils literal"><span class="pre">0</span></tt>). Sets the level of
verbosity. Set to 0 by default, which means quiet.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>A list whose <span class="math">\(i^{\mbox{th}}\)</span> element is the representative of the
<span class="math">\(i^{\mbox{th}}\)</span> element of the <tt class="docutils literal"><span class="pre">family</span></tt> list. If there is no ISR,
<tt class="docutils literal"><span class="pre">None</span></tt> is returned.</li>
</ul>
<p>EXAMPLES:</p>
<p>For a bipartite graph missing one edge, the solution is as expected:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">delete_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">independent_set_of_representatives</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]])</span>
<span class="go">[1, 4]</span>
</pre></div>
</div>
<p>The Petersen Graph is 3-colorable, which can be expressed as an
independent set of representatives problem : take 3 disjoint copies
of the Petersen Graph, each one representing one color. Then take
as a partition of the set of vertices the family defined by the three
copies of each vertex. The ISR of such a family
defines a 3-coloring:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span><span class="o">/</span><span class="mi">3</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="p">[[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">isr</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">independent_set_of_representatives</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">floor</span><span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">isr</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">color_classes</span> <span class="o">=</span> <span class="p">[[],[],[]]</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">color_classes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">classs</span> <span class="ow">in</span> <span class="n">color_classes</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">g</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">classs</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
<span class="go">True</span>
<span class="go">True</span>
<span class="go">True</span>
</pre></div>
</div>
<p>REFERENCE:</p>
<table class="docutils citation" frame="void" id="ahaberziv07" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id25">[AhaBerZiv07]</a></td><td>R. Aharoni and E. Berger and R. Ziv
Independent systems of representatives in weighted graphs
Combinatorica vol 27, num 3, p253&#8211;267
2007</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_arc_transitive">
<tt class="descname">is_arc_transitive</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.is_arc_transitive" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if self is an arc-transitive graph</p>
<p>A graph is arc-transitive if its automorphism group acts transitively on
its pairs of adjacent vertices.</p>
<p>Equivalently, if there exists for any pair of edges <span class="math">\(uv,u'v'\in E(G)\)</span> an
automorphism <span class="math">\(\phi_1\)</span> of <span class="math">\(G\)</span> such that <span class="math">\(\phi_1(u)=u'\)</span> and
<span class="math">\(\phi_1(v)=v'\)</span>, as well as another automorphism <span class="math">\(\phi_2\)</span> of <span class="math">\(G\)</span> such
that <span class="math">\(\phi_2(u)=v'\)</span> and <span class="math">\(\phi_2(v)=u'\)</span></p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/arc-transitive_graph">the wikipedia article on arc-transitive graphs</a> for more information.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_edge_transitive" title="sage.graphs.graph.Graph.is_edge_transitive"><tt class="xref py py-meth docutils literal"><span class="pre">is_edge_transitive()</span></tt></a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_half_transitive" title="sage.graphs.graph.Graph.is_half_transitive"><tt class="xref py py-meth docutils literal"><span class="pre">is_half_transitive()</span></tt></a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_semi_symmetric" title="sage.graphs.graph.Graph.is_semi_symmetric"><tt class="xref py py-meth docutils literal"><span class="pre">is_semi_symmetric()</span></tt></a></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_arc_transitive</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">GrayGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_arc_transitive</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_asteroidal_triple_free">
<tt class="descname">is_asteroidal_triple_free</tt><big>(</big><em>G</em>, <em>certificate=False</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.is_asteroidal_triple_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the input graph is asteroidal triple-free</p>
<p>An independent set of three vertices such that each pair is joined by a path
that avoids the neighborhood of the third one is called an <em>asteroidal
triple</em>. A graph is asteroidal triple-free (AT-free) if it contains no
asteroidal triples. See the <a class="reference internal" href="asteroidal_triples.html#module-sage.graphs.asteroidal_triples" title="sage.graphs.asteroidal_triples"><tt class="xref py py-mod docutils literal"><span class="pre">module's</span> <span class="pre">documentation</span></tt></a> for more details.</p>
<p>This method returns <tt class="docutils literal"><span class="pre">True</span></tt> is the graph is AT-free and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">G</span></tt> &#8211; a Graph</li>
<li><tt class="docutils literal"><span class="pre">certificate</span></tt> &#8211; (default: False) By default, this method returns
<tt class="docutils literal"><span class="pre">True</span></tt> if the graph is asteroidal triple-free and <tt class="docutils literal"><span class="pre">False</span></tt>
otherwise. When <tt class="docutils literal"><span class="pre">certificate==True</span></tt>, this method returns in addition a
list of three vertices forming an asteroidal triple if such a triple is
found, and the empty list otherwise.</li>
</ul>
<p>EXAMPLES:</p>
<p>The complete graph is AT-free, as well as its line graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.asteroidal_triples</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">is_asteroidal_triple_free</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">is_asteroidal_triple_free</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(True, [])</span>
<span class="gp">sage: </span><span class="n">LG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">line_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">is_asteroidal_triple_free</span><span class="p">(</span><span class="n">LG</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">LLG</span> <span class="o">=</span> <span class="n">LG</span><span class="o">.</span><span class="n">line_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">is_asteroidal_triple_free</span><span class="p">(</span><span class="n">LLG</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The PetersenGraph is not AT-free:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.asteroidal_triples</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">is_asteroidal_triple_free</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">is_asteroidal_triple_free</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(False, [0, 2, 6])</span>
</pre></div>
</div>
<p>TEST:</p>
<p>Giving anything else than a Graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.asteroidal_triples</span> <span class="kn">import</span> <span class="n">is_asteroidal_triple_free</span>
<span class="gp">sage: </span><span class="n">is_asteroidal_triple_free</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">())</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The first parameter must be a Graph.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_bipartite">
<tt class="descname">is_bipartite</tt><big>(</big><em>certificate=False</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.is_bipartite" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">True</span></tt> if graph <span class="math">\(G\)</span> is bipartite, <tt class="docutils literal"><span class="pre">False</span></tt> if not.</p>
<p>Traverse the graph G with breadth-first-search and color nodes.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">certificate</span></tt> &#8211; whether to return a certificate (<tt class="docutils literal"><span class="pre">False</span></tt> by
default). If set to <tt class="docutils literal"><span class="pre">True</span></tt>, the certificate returned in a proper
2-coloring when <span class="math">\(G\)</span> is bipartite, and an odd cycle otherwise.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">is_bipartite</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">is_bipartite</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">RandomBipartite</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mf">0.7</span><span class="p">)</span><span class="o">.</span><span class="n">is_bipartite</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A random graph is very rarely bipartite:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_bipartite</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">false</span><span class="p">,</span> <span class="n">oddcycle</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_bipartite</span><span class="p">(</span><span class="n">certificate</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">oddcycle</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_cartesian_product">
<tt class="descname">is_cartesian_product</tt><big>(</big><em>g</em>, <em>certificate=False</em>, <em>relabeling=False</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.is_cartesian_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether the graph is a Cartesian product.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">certificate</span></tt> (boolean) &#8211; if <tt class="docutils literal"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">False</span></tt> (default) the
method only returns <tt class="docutils literal"><span class="pre">True</span></tt> or <tt class="docutils literal"><span class="pre">False</span></tt> answers. If <tt class="docutils literal"><span class="pre">certificate</span> <span class="pre">=</span>
<span class="pre">True</span></tt>, the <tt class="docutils literal"><span class="pre">True</span></tt> answers are replaced by the list of the factors of
the graph.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">relabeling</span></tt> (boolean) &#8211; if <tt class="docutils literal"><span class="pre">relabeling</span> <span class="pre">=</span> <span class="pre">True</span></tt> (implies
<tt class="docutils literal"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></tt>), the method also returns a dictionary associating
to each vertex its natural coordinates as a vertex of a product graph. If
<span class="math">\(g\)</span> is not a Cartesian product, <tt class="docutils literal"><span class="pre">None</span></tt> is returned instead.</p>
<p>This is set to <tt class="docutils literal"><span class="pre">False</span></tt> by default.</p>
</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.cartesian_product" title="sage.graphs.generic_graph.GenericGraph.cartesian_product"><tt class="xref py py-meth docutils literal"><span class="pre">sage.graphs.generic_graph.GenericGraph.cartesian_product()</span></tt></a></li>
<li><a class="reference internal" href="graph_decompositions/graph_products.html#module-sage.graphs.graph_decompositions.graph_products" title="sage.graphs.graph_decompositions.graph_products"><tt class="xref py py-mod docutils literal"><span class="pre">graph_products</span></tt></a> &#8211; a module on
graph products.</li>
</ul>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This algorithm may run faster whenever the graph&#8217;s vertices are integers
(see <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.relabel" title="sage.graphs.generic_graph.GenericGraph.relabel"><tt class="xref py py-meth docutils literal"><span class="pre">relabel()</span></tt></a>). Give it a
try if it is too slow !</p>
</div>
<p>EXAMPLE:</p>
<p>The Petersen graph is prime:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions.graph_products</span> <span class="kn">import</span> <span class="n">is_cartesian_product</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">is_cartesian_product</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A 2d grid is the product of paths:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">is_cartesian_product</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">certificate</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p1</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">p2</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Forgetting the graph&#8217;s labels, then finding them back:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">relabel</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_cartesian_product</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">relabeling</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="go">(True, {0: (0, 0), 1: (0, 1), 2: (0, 2), 3: (0, 3),</span>
<span class="go">        4: (0, 4), 5: (5, 0), 6: (5, 1), 7: (5, 2),</span>
<span class="go">        8: (5, 3), 9: (5, 4), 10: (10, 0), 11: (10, 1),</span>
<span class="go">        12: (10, 2), 13: (10, 3), 14: (10, 4), 15: (15, 0),</span>
<span class="go">        16: (15, 1), 17: (15, 2), 18: (15, 3), 19: (15, 4),</span>
<span class="go">        20: (20, 0), 21: (20, 1), 22: (20, 2), 23: (20, 3),</span>
<span class="go">        24: (20, 4)})</span>
</pre></div>
</div>
<p>And of course, we find the factors back when we build a graph from a
product:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span> <span class="o">=</span> <span class="n">is_cartesian_product</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">certificate</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">any</span><span class="p">(</span> <span class="n">x</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">())</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">g1</span><span class="p">,</span><span class="n">g2</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">any</span><span class="p">(</span> <span class="n">x</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">g1</span><span class="p">,</span><span class="n">g2</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Wagner&#8217;s Graph (<a class="reference external" href="http://trac.sagemath.org/13599">trac ticket #13599</a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">WagnerGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_cartesian_product</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Empty and one-element graph (<a class="reference external" href="http://trac.sagemath.org/19546">trac ticket #19546</a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">is_cartesian_product</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[]})</span><span class="o">.</span><span class="n">is_cartesian_product</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_directed">
<tt class="descname">is_directed</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.is_directed" title="Permalink to this definition">¶</a></dt>
<dd><p>Since graph is undirected, returns False.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">is_directed</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_distance_regular">
<tt class="descname">is_distance_regular</tt><big>(</big><em>G</em>, <em>parameters=False</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.is_distance_regular" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests if the graph is distance-regular</p>
<p>A graph <span class="math">\(G\)</span> is distance-regular if for any integers <span class="math">\(j,k\)</span> the value
of <span class="math">\(|\{x:d_G(x,u)=j,x\in V(G)\} \cap \{y:d_G(y,v)=j,y\in V(G)\}|\)</span> is constant
for any two vertices <span class="math">\(u,v\in V(G)\)</span> at distance <span class="math">\(i\)</span> from each other.
In particular <span class="math">\(G\)</span> is regular, of degree <span class="math">\(b_0\)</span> (see below), as one can take <span class="math">\(u=v\)</span>.</p>
<p>Equivalently a graph is distance-regular if there exist integers <span class="math">\(b_i,c_i\)</span>
such that for any two vertices <span class="math">\(u,v\)</span> at distance <span class="math">\(i\)</span> we have</p>
<ul class="simple">
<li><span class="math">\(b_i = |\{x:d_G(x,u)=i+1,x\in V(G)\}\cap N_G(v)\}|, \ 0\leq i\leq d-1\)</span></li>
<li><span class="math">\(c_i = |\{x:d_G(x,u)=i-1,x\in V(G)\}\cap N_G(v)\}|, \ 1\leq i\leq d,\)</span></li>
</ul>
<p>where <span class="math">\(d\)</span> is the diameter of the graph.  For more information on
distance-regular graphs, see its associated <a class="reference external" href="https://en.wikipedia.org/wiki/Distance-regular_graph">wikipedia
page</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">parameters</span></tt> (boolean) &#8211; if set to <tt class="docutils literal"><span class="pre">True</span></tt>, the function returns the
pair <tt class="docutils literal"><span class="pre">(b,c)</span></tt> of lists of integers instead of <tt class="docutils literal"><span class="pre">True</span></tt> (see the definition
above). Set to <tt class="docutils literal"><span class="pre">False</span></tt> by default.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.is_regular" title="sage.graphs.generic_graph.GenericGraph.is_regular"><tt class="xref py py-meth docutils literal"><span class="pre">is_regular()</span></tt></a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_strongly_regular" title="sage.graphs.graph.Graph.is_strongly_regular"><tt class="xref py py-meth docutils literal"><span class="pre">is_strongly_regular()</span></tt></a></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_distance_regular</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_distance_regular</span><span class="p">(</span><span class="n">parameters</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="go">([3, 2, None], [None, 1, 1])</span>
</pre></div>
</div>
<p>Cube graphs, which are not strongly regular, are a bit more interesting:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">is_distance_regular</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">OddGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">is_distance_regular</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Disconnected graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="n">is_distance_regular</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">is_distance_regular</span><span class="p">(</span><span class="n">parameters</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="go">([1, None], [None, 1])</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">Tutte12Cage</span><span class="p">()</span><span class="o">.</span><span class="n">is_distance_regular</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">([3, 2, 2, 2, 2, 2, None], [None, 1, 1, 1, 1, 1, 3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_edge_transitive">
<tt class="descname">is_edge_transitive</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.is_edge_transitive" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if self is an edge transitive graph.</p>
<p>A graph is edge-transitive if its automorphism group acts transitively
on its edge set.</p>
<p>Equivalently, if there exists for any pair of edges <span class="math">\(uv,u'v'\in E(G)\)</span> an
automorphism <span class="math">\(\phi\)</span> of <span class="math">\(G\)</span> such that <span class="math">\(\phi(uv)=u'v'\)</span> (note this does not
necessarily mean that <span class="math">\(\phi(u)=u'\)</span> and <span class="math">\(\phi(v)=v'\)</span>).</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Edge-transitive_graph">the wikipedia article on edge-transitive graphs</a> for more information.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_arc_transitive" title="sage.graphs.graph.Graph.is_arc_transitive"><tt class="xref py py-meth docutils literal"><span class="pre">is_arc_transitive()</span></tt></a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_half_transitive" title="sage.graphs.graph.Graph.is_half_transitive"><tt class="xref py py-meth docutils literal"><span class="pre">is_half_transitive()</span></tt></a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_semi_symmetric" title="sage.graphs.graph.Graph.is_semi_symmetric"><tt class="xref py py-meth docutils literal"><span class="pre">is_semi_symmetric()</span></tt></a></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_edge_transitive</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">is_edge_transitive</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">GrayGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_edge_transitive</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_edge_transitive</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_even_hole_free">
<tt class="descname">is_even_hole_free</tt><big>(</big><em>certificate=False</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.is_even_hole_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether <tt class="docutils literal"><span class="pre">self</span></tt> contains an induced even hole.</p>
<p>A Hole is a cycle of length at least 4 (included). It is said
to be even (resp. odd) if its length is even (resp. odd).</p>
<p>Even-hole-free graphs always contain a bisimplicial vertex,
which ensures that their chromatic number is at most twice
their clique number <a class="reference internal" href="#abchrs08" id="id26">[ABCHRS08]</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">certificate</span></tt> (boolean) &#8211; When <tt class="docutils literal"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">False</span></tt>,
this method only returns <tt class="docutils literal"><span class="pre">True</span></tt> or <tt class="docutils literal"><span class="pre">False</span></tt>. If
<tt class="docutils literal"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></tt>, the subgraph found is returned
instead of <tt class="docutils literal"><span class="pre">False</span></tt>.</li>
</ul>
<p>EXAMPLE:</p>
<p>Is the Petersen Graph even-hole-free</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_even_hole_free</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>As any chordal graph is hole-free, interval graphs behave the
same way:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomIntervalGraph</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_even_hole_free</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>It is clear, though, that a random Bipartite Graph which is
not a forest has an even hole:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomBipartite</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_even_hole_free</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_forest</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We can check the certificate returned is indeed an even
cycle:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_forest</span><span class="p">():</span>
<span class="gp">... </span>     <span class="n">cycle</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_even_hole_free</span><span class="p">(</span><span class="n">certificate</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">... </span>     <span class="k">if</span> <span class="n">cycle</span><span class="o">.</span><span class="n">order</span><span class="p">()</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">... </span>         <span class="k">print</span> <span class="s2">&quot;Error !&quot;</span>
<span class="gp">... </span>     <span class="k">if</span> <span class="ow">not</span> <span class="n">cycle</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span>
<span class="gp">... </span>            <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="n">cycle</span><span class="o">.</span><span class="n">order</span><span class="p">())):</span>
<span class="gp">... </span>         <span class="k">print</span> <span class="s2">&quot;Error !&quot;</span>
<span class="gp">...</span>
<span class="gp">sage: </span><span class="k">print</span> <span class="s2">&quot;Everything is Fine !&quot;</span>
<span class="go">Everything is Fine !</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Bug reported in <a class="reference external" href="http://trac.sagemath.org/9925">trac ticket #9925</a>, and fixed by <a class="reference external" href="http://trac.sagemath.org/9420">trac ticket #9420</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;:SiBFGaCEF_@CE`DEGH`CEFGaCDGaCDEHaDEF`CEH`ABCDEF&#39;</span><span class="p">,</span> <span class="n">loops</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">multiedges</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_even_hole_free</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_even_hole_free</span><span class="p">(</span><span class="n">certificate</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="go">Subgraph of (): Graph on 4 vertices</span>
</pre></div>
</div>
<p>Making sure there are no other counter-examples around</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="p">(</span><span class="n">Graph</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">is_forest</span><span class="p">()</span> <span class="ow">or</span>
<span class="gp">... </span>        <span class="nb">isinstance</span><span class="p">(</span><span class="n">Graph</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">is_even_hole_free</span><span class="p">(</span><span class="n">certificate</span> <span class="o">=</span> <span class="bp">True</span><span class="p">),</span><span class="n">Graph</span><span class="p">))</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">t</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">RandomBipartite</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>REFERENCE:</p>
<table class="docutils citation" frame="void" id="abchrs08" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id26">[ABCHRS08]</a></td><td>L. Addario-Berry, M. Chudnovsky, F. Havet, B. Reed, P. Seymour
Bisimplicial vertices in even-hole-free graphs
Journal of Combinatorial Theory, Series B
vol 98, n.6 pp 1119-1164, 2008</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_forest">
<tt class="descname">is_forest</tt><big>(</big><em>certificate=False</em>, <em>output='vertex'</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.is_forest" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests if the graph is a forest, i.e. a disjoint union of trees.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">certificate</span></tt> (boolean) &#8211; whether to return a certificate. The
method only returns boolean answers when <tt class="docutils literal"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">False</span></tt>
(default). When it is set to <tt class="docutils literal"><span class="pre">True</span></tt>, it either answers <tt class="docutils literal"><span class="pre">(True,</span>
<span class="pre">None)</span></tt> when the graph is a forest and <tt class="docutils literal"><span class="pre">(False,</span> <span class="pre">cycle)</span></tt> when it
contains a cycle.</li>
<li><tt class="docutils literal"><span class="pre">output</span></tt> (<tt class="docutils literal"><span class="pre">'vertex'</span></tt> (default) or <tt class="docutils literal"><span class="pre">'edge'</span></tt>) &#8211; whether the
certificate is given as a list of vertices or a list of
edges.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">seven_acre_wood</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">trees</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">Graph</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">seven_acre_wood</span><span class="o">.</span><span class="n">is_forest</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>With certificates:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomTree</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_forest</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(True, None)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">g</span> <span class="o">+</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span> <span class="o">+</span> <span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">is_forest</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(False, [63, 62, 61, 60, 64])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_half_transitive">
<tt class="descname">is_half_transitive</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.is_half_transitive" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if self is a half-transitive graph.</p>
<p>A graph is is half-transitive if it is both vertex and edge transitive
but not arc-transitive.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/half-transitive_graph">the wikipedia article on half-transitive graphs</a> for more information.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_edge_transitive" title="sage.graphs.graph.Graph.is_edge_transitive"><tt class="xref py py-meth docutils literal"><span class="pre">is_edge_transitive()</span></tt></a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_arc_transitive" title="sage.graphs.graph.Graph.is_arc_transitive"><tt class="xref py py-meth docutils literal"><span class="pre">is_arc_transitive()</span></tt></a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_semi_symmetric" title="sage.graphs.graph.Graph.is_semi_symmetric"><tt class="xref py py-meth docutils literal"><span class="pre">is_semi_symmetric()</span></tt></a></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>The Petersen Graph is not half-transitive:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_half_transitive</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The smallest half-transitive graph is the Holt Graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">HoltGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">is_half_transitive</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_line_graph">
<tt class="descname">is_line_graph</tt><big>(</big><em>g</em>, <em>certificate=False</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.is_line_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests wether the graph is a line graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">certificate</span></tt> (boolean) &#8211; whether to return a certificate along with
the boolean result. Here is what happens when <tt class="docutils literal"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></tt>:<ul>
<li>If the graph is not a line graph, the method returns a pair <tt class="docutils literal"><span class="pre">(b,</span>
<span class="pre">subgraph)</span></tt> where <tt class="docutils literal"><span class="pre">b</span></tt> is <tt class="docutils literal"><span class="pre">False</span></tt> and <tt class="docutils literal"><span class="pre">subgraph</span></tt> is a subgraph
isomorphic to one of the 9 forbidden induced subgraphs of a line graph.</li>
<li>If the graph is a line graph, the method returns a triple <tt class="docutils literal"><span class="pre">(b,R,isom)</span></tt>
where <tt class="docutils literal"><span class="pre">b</span></tt> is <tt class="docutils literal"><span class="pre">True</span></tt>, <tt class="docutils literal"><span class="pre">R</span></tt> is a graph whose line graph is the graph
given as input, and <tt class="docutils literal"><span class="pre">isom</span></tt> is a map associating an edge of <tt class="docutils literal"><span class="pre">R</span></tt> to
each vertex of the graph.</li>
</ul>
</li>
</ul>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">This method sequentially tests each of the forbidden subgraphs in order
to know whether the graph is a line graph, which is a very slow
method. It could eventually be replaced by
<a class="reference internal" href="line_graph.html#sage.graphs.line_graph.root_graph" title="sage.graphs.line_graph.root_graph"><tt class="xref py py-func docutils literal"><span class="pre">root_graph()</span></tt></a> when this method will not
require an exponential time to run on general graphs anymore (see its
documentation for more information on this problem)...  and if it can be
improved to return negative certificates !</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method wastes a bit of time when the input graph is not
connected. If you have performance in mind, it is probably better to
only feed it with connected graphs only.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li>The <a class="reference internal" href="line_graph.html#module-sage.graphs.line_graph" title="sage.graphs.line_graph"><tt class="xref py py-mod docutils literal"><span class="pre">line_graph</span></tt></a> module.</li>
<li><a class="reference internal" href="graph_generators.html#sage.graphs.graph_generators.GraphGenerators.line_graph_forbidden_subgraphs" title="sage.graphs.graph_generators.GraphGenerators.line_graph_forbidden_subgraphs"><tt class="xref py py-meth docutils literal"><span class="pre">line_graph_forbidden_subgraphs()</span></tt></a>
&#8211; the forbidden subgraphs of a line graph.</li>
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.line_graph" title="sage.graphs.generic_graph.GenericGraph.line_graph"><tt class="xref py py-meth docutils literal"><span class="pre">line_graph()</span></tt></a></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>A complete graph is always the line graph of a star:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">is_line_graph</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Petersen Graph not being claw-free, it is not a line
graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">is_line_graph</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>This is indeed the subgraph returned:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">is_line_graph</span><span class="p">(</span><span class="n">certificate</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">ClawGraph</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The house graph is a line graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">HouseGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_line_graph</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>But what is the graph whose line graph is the house ?:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">is_line</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">isom</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_line_graph</span><span class="p">(</span><span class="n">certificate</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">sparse6_string</span><span class="p">()</span>
<span class="go">&#39;:DaHI~&#39;</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">isom</span>
<span class="go">{0: (0, 1), 1: (0, 2), 2: (1, 3), 3: (2, 3), 4: (3, 4)}</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Disconnected graphs:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">gl</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">line_graph</span><span class="p">()</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">inplace</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">new_g</span> <span class="o">=</span> <span class="n">gl</span><span class="o">.</span><span class="n">is_line_graph</span><span class="p">(</span><span class="n">certificate</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">line_graph</span><span class="p">()</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">gl</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_long_antihole_free">
<tt class="descname">is_long_antihole_free</tt><big>(</big><em>g</em>, <em>certificate=False</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.is_long_antihole_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether the given graph contains an induced subgraph that is
isomorphic to the complement of a cycle of length at least 5.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">certificate</span></tt> &#8211; boolean (default: <tt class="docutils literal"><span class="pre">False</span></tt>)</p>
<p>Whether to return a certificate. When <tt class="docutils literal"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></tt>, then
the function returns</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">(False,</span> <span class="pre">Antihole)</span></tt> if <tt class="docutils literal"><span class="pre">g</span></tt> contains an induced complement
of a cycle of length at least 5 returned as <tt class="docutils literal"><span class="pre">Antihole</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">(True,</span> <span class="pre">[])</span></tt> if <tt class="docutils literal"><span class="pre">g</span></tt> does not contain an induced complement of
a cycle of length at least 5.
For this case it is not known how to provide a certificate.</li>
</ul>
<p>When <tt class="docutils literal"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">False</span></tt>, the function returns just <tt class="docutils literal"><span class="pre">True</span></tt> or
<tt class="docutils literal"><span class="pre">False</span></tt> accordingly.</p>
</li>
</ul>
<p>ALGORITHM:</p>
<p>This algorithm tries to find a cycle in the graph of all induced
<span class="math">\(\overline{P_4}\)</span> of <span class="math">\(g\)</span>, where two copies <span class="math">\(\overline{P}\)</span> and <span class="math">\(\overline{P'}\)</span>
of <span class="math">\(\overline{P_4}\)</span> are adjacent if there exists a (not necessarily induced)
copy of <span class="math">\(\overline{P_5}=u_1u_2u_3u_4u_5\)</span> such that
<span class="math">\(\overline{P}=u_1u_2u_3u_4\)</span> and <span class="math">\(\overline{P'}=u_2u_3u_4u_5\)</span>.</p>
<p>This is done through a depth-first-search. For efficiency, the auxiliary
graph is constructed on-the-fly and never stored in memory.</p>
<p>The run time of this algorithm is <span class="math">\(O(m^2)\)</span> <a class="reference internal" href="weakly_chordal.html#nikolopoulospalios07" id="id27">[NikolopoulosPalios07]</a> ( where
<span class="math">\(m\)</span> is the number of edges of the graph ) .</p>
<p>EXAMPLES:</p>
<p>The Petersen Graph contains an antihole:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_long_antihole_free</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The complement of a cycle is an antihole:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">r</span><span class="p">,</span><span class="n">a</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_long_antihole_free</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">r</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Further tests:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span><span class="mi">4</span><span class="p">:[</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">],</span><span class="mi">5</span><span class="p">:[</span><span class="mi">11</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span><span class="mi">6</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span><span class="mi">7</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span><span class="mi">8</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span><span class="mi">9</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span><span class="mi">10</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">11</span><span class="p">],</span><span class="mi">11</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">]})</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">r</span><span class="p">,</span><span class="n">a</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_long_antihole_free</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">r</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_long_hole_free">
<tt class="descname">is_long_hole_free</tt><big>(</big><em>g</em>, <em>certificate=False</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.is_long_hole_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether <tt class="docutils literal"><span class="pre">g</span></tt> contains an induced cycle of length at least 5.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">certificate</span></tt> &#8211; boolean (default: <tt class="docutils literal"><span class="pre">False</span></tt>)</p>
<p>Whether to return a certificate. When <tt class="docutils literal"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></tt>, then
the function returns</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">(True,</span> <span class="pre">[])</span></tt> if <tt class="docutils literal"><span class="pre">g</span></tt> does not contain such a cycle.
For this case, it is not known how to provide a certificate.</li>
<li><tt class="docutils literal"><span class="pre">(False,</span> <span class="pre">Hole)</span></tt> if <tt class="docutils literal"><span class="pre">g</span></tt> contains an induced cycle of length at
least 5. <tt class="docutils literal"><span class="pre">Hole</span></tt> returns this cycle.</li>
</ul>
<p>If <tt class="docutils literal"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">False</span></tt>, the function returns just <tt class="docutils literal"><span class="pre">True</span></tt> or
<tt class="docutils literal"><span class="pre">False</span></tt> accordingly.</p>
</li>
</ul>
<p>ALGORITHM:</p>
<p>This algorithm tries to find a cycle in the graph of all induced <span class="math">\(P_4\)</span> of
<span class="math">\(g\)</span>, where two copies <span class="math">\(P\)</span> and <span class="math">\(P'\)</span> of <span class="math">\(P_4\)</span> are adjacent if there exists a
(not necessarily induced) copy of <span class="math">\(P_5=u_1u_2u_3u_4u_5\)</span> such that
<span class="math">\(P=u_1u_2u_3u_4\)</span> and <span class="math">\(P'=u_2u_3u_4u_5\)</span>.</p>
<p>This is done through a depth-first-search. For efficiency, the auxiliary
graph is constructed on-the-fly and never stored in memory.</p>
<p>The run time of this algorithm is <span class="math">\(O(m^2)\)</span> <a class="reference internal" href="weakly_chordal.html#nikolopoulospalios07" id="id28">[NikolopoulosPalios07]</a> ( where
<span class="math">\(m\)</span> is the number of edges of the graph ) .</p>
<p>EXAMPLES:</p>
<p>The Petersen Graph contains a hole:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_long_hole_free</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The following graph contains a hole, which we want to display:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">FlowerSnark</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">r</span><span class="p">,</span><span class="n">h</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_long_hole_free</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">r</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">order</span><span class="p">()))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Another graph with vertices 2, ..., 8, 10:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">4</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span><span class="mi">5</span><span class="p">:[</span><span class="mi">6</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span><span class="mi">6</span><span class="p">:[</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span><span class="mi">7</span><span class="p">:[</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span><span class="mi">8</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span><span class="mi">10</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">r</span><span class="p">,</span><span class="n">hole</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_long_hole_free</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">r</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">hole</span>
<span class="go">Subgraph of (): Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">hole</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="n">hole</span><span class="o">.</span><span class="n">order</span><span class="p">()))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_odd_hole_free">
<tt class="descname">is_odd_hole_free</tt><big>(</big><em>certificate=False</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.is_odd_hole_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether <tt class="docutils literal"><span class="pre">self</span></tt> contains an induced odd hole.</p>
<p>A Hole is a cycle of length at least 4 (included). It is said
to be even (resp. odd) if its length is even (resp. odd).</p>
<p>It is interesting to notice that while it is polynomial to
check whether a graph has an odd hole or an odd antihole <a class="reference internal" href="#crst06" id="id29">[CRST06]</a>, it is
not known whether testing for one of these two cases
independently is polynomial too.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">certificate</span></tt> (boolean) &#8211; When <tt class="docutils literal"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">False</span></tt>,
this method only returns <tt class="docutils literal"><span class="pre">True</span></tt> or <tt class="docutils literal"><span class="pre">False</span></tt>. If
<tt class="docutils literal"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></tt>, the subgraph found is returned
instead of <tt class="docutils literal"><span class="pre">False</span></tt>.</li>
</ul>
<p>EXAMPLE:</p>
<p>Is the Petersen Graph odd-hole-free</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_odd_hole_free</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Which was to be expected, as its girth is 5</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">girth</span><span class="p">()</span>
<span class="go">5</span>
</pre></div>
</div>
<p>We can check the certificate returned is indeed a 5-cycle:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cycle</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_odd_hole_free</span><span class="p">(</span><span class="n">certificate</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">cycle</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>As any chordal graph is hole-free, no interval graph has an odd hole:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomIntervalGraph</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_odd_hole_free</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="crst06" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id29">[CRST06]</a></td><td>M. Chudnovsky, G. Cornuejols, X. Liu, P. Seymour, K. Vuskovic
Recognizing berge graphs
Combinatorica vol 25, n 2, pages 143&#8211;186
2005</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_overfull">
<tt class="descname">is_overfull</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.is_overfull" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether the current graph is overfull.</p>
<p>A graph <span class="math">\(G\)</span> on <span class="math">\(n\)</span> vertices and <span class="math">\(m\)</span> edges is said to
be overfull if:</p>
<ul class="simple">
<li><span class="math">\(n\)</span> is odd</li>
<li>It satisfies <span class="math">\(2m &gt; (n-1)\Delta(G)\)</span>, where
<span class="math">\(\Delta(G)\)</span> denotes the maximum degree
among all vertices in <span class="math">\(G\)</span>.</li>
</ul>
<p>An overfull graph must have a chromatic index of <span class="math">\(\Delta(G)+1\)</span>.</p>
<p>EXAMPLES:</p>
<p>A complete graph of order <span class="math">\(n &gt; 1\)</span> is overfull if and only if <span class="math">\(n\)</span> is
odd:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The claw graph is not overfull:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_coloring</span> <span class="kn">import</span> <span class="n">edge_coloring</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">ClawGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span>
<span class="go">Claw graph: Graph on 4 vertices</span>
<span class="gp">sage: </span><span class="n">edge_coloring</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">value_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The Holt graph is an example of a overfull graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">HoltGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Checking that all complete graphs <span class="math">\(K_n\)</span> for even <span class="math">\(0 \leq n \leq 100\)</span>
are not overfull:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">check_overfull_Kn_even</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>      <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>      <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
<span class="gp">... </span>          <span class="k">if</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">():</span>
<span class="gp">... </span>              <span class="k">print</span> <span class="s2">&quot;A complete graph of even order cannot be overfull.&quot;</span>
<span class="gp">... </span>              <span class="k">return</span>
<span class="gp">... </span>          <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
<span class="gp">... </span>      <span class="k">print</span> <span class="s2">&quot;Complete graphs of even order up to </span><span class="si">%s</span><span class="s2"> are not overfull.&quot;</span> <span class="o">%</span> <span class="n">n</span>
<span class="gp">...</span>
<span class="gp">sage: </span><span class="n">check_overfull_Kn_even</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>  <span class="c1"># long time</span>
<span class="go">Complete graphs of even order up to 100 are not overfull.</span>
</pre></div>
</div>
<p>The null graph, i.e. the graph with no vertices, is not overfull:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Checking that all complete graphs <span class="math">\(K_n\)</span> for odd <span class="math">\(1 &lt; n \leq 100\)</span>
are overfull:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">check_overfull_Kn_odd</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>      <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">... </span>      <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
<span class="gp">... </span>          <span class="k">if</span> <span class="ow">not</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">():</span>
<span class="gp">... </span>              <span class="k">print</span> <span class="s2">&quot;A complete graph of odd order &gt; 1 must be overfull.&quot;</span>
<span class="gp">... </span>              <span class="k">return</span>
<span class="gp">... </span>          <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
<span class="gp">... </span>      <span class="k">print</span> <span class="s2">&quot;Complete graphs of odd order &gt; 1 up to </span><span class="si">%s</span><span class="s2"> are overfull.&quot;</span> <span class="o">%</span> <span class="n">n</span>
<span class="gp">...</span>
<span class="gp">sage: </span><span class="n">check_overfull_Kn_odd</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>  <span class="c1"># long time</span>
<span class="go">Complete graphs of odd order &gt; 1 up to 100 are overfull.</span>
</pre></div>
</div>
<p>The Petersen Graph, though, is not overfull while
its chromatic index is <span class="math">\(\Delta+1\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_coloring</span> <span class="kn">import</span> <span class="n">edge_coloring</span>
<span class="gp">sage: </span><span class="nb">max</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">degree</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span>  <span class="n">edge_coloring</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">value_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_partial_cube">
<tt class="descname">is_partial_cube</tt><big>(</big><em>G</em>, <em>certificate=False</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.is_partial_cube" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the given graph is a partial cube.</p>
<p>A partial cube is a graph that can be isometrically embedded into a
hypercube, i.e., its vertices can be labelled with (0,1)-vectors of some
fixed length such that the distance between any two vertices in the graph
equals the Hamming distance of their labels.</p>
<p>Originally written by D. Eppstein for the PADS library
(<a class="reference external" href="http://www.ics.uci.edu/~eppstein/PADS/">http://www.ics.uci.edu/~eppstein/PADS/</a>), see also
<a class="reference internal" href="partial_cube.html#eppstein2008" id="id30">[Eppstein2008]</a>.  The algorithm runs in <span class="math">\(O(n^2)\)</span> time, where <span class="math">\(n\)</span>
is the number of vertices. See the documentation of
<a class="reference internal" href="partial_cube.html#module-sage.graphs.partial_cube" title="sage.graphs.partial_cube"><tt class="xref py py-mod docutils literal"><span class="pre">partial_cube</span></tt></a> for an overview of the algorithm.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">certificate</span></tt> (boolean; <tt class="docutils literal"><span class="pre">False</span></tt>) &#8211; The function returns <tt class="docutils literal"><span class="pre">True</span></tt>
or <tt class="docutils literal"><span class="pre">False</span></tt> according to the graph, when <tt class="docutils literal"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">False</span></tt>. When
<tt class="docutils literal"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></tt> and the graph is a partial cube, the function
returns <tt class="docutils literal"><span class="pre">(True,</span> <span class="pre">mapping)</span></tt>, where <tt class="docutils literal"><span class="pre">mapping</span></tt> is an isometric mapping of
the vertices of the graph to the vertices of a hypercube ((0, 1)-strings
of a fixed length). When <tt class="docutils literal"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></tt> and the graph is not a
partial cube, <tt class="docutils literal"><span class="pre">(False,</span> <span class="pre">None)</span></tt> is returned.</li>
</ul>
<p>EXAMPLES:</p>
<p>The Petersen graph is not a partial cube:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_partial_cube</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>All prisms are partial cubes:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_partial_cube</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>The returned mapping is an isometric embedding into a hypercube:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DesarguesGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_partial_cube</span><span class="p">(</span><span class="n">certificate</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="c1"># random</span>
<span class="go">{0: &#39;00000&#39;,</span>
<span class="go"> 1: &#39;00001&#39;,</span>
<span class="go"> 2: &#39;00011&#39;,</span>
<span class="go"> 3: &#39;01011&#39;,</span>
<span class="go"> 4: &#39;11011&#39;,</span>
<span class="go"> 5: &#39;11111&#39;,</span>
<span class="go"> 6: &#39;11110&#39;,</span>
<span class="go"> 7: &#39;11100&#39;,</span>
<span class="go"> 8: &#39;10100&#39;,</span>
<span class="go"> 9: &#39;00100&#39;,</span>
<span class="go"> 10: &#39;01000&#39;,</span>
<span class="go"> 11: &#39;10001&#39;,</span>
<span class="go"> 12: &#39;00111&#39;,</span>
<span class="go"> 13: &#39;01010&#39;,</span>
<span class="go"> 14: &#39;11001&#39;,</span>
<span class="go"> 15: &#39;10111&#39;,</span>
<span class="go"> 16: &#39;01110&#39;,</span>
<span class="go"> 17: &#39;11000&#39;,</span>
<span class="go"> 18: &#39;10101&#39;,</span>
<span class="go"> 19: &#39;00110&#39;}</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">u</span><span class="p">]))</span> <span class="k">if</span> <span class="n">m</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">m</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">m</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A graph without vertices is trivially a partial cube:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">is_partial_cube</span><span class="p">(</span><span class="n">certificate</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="go">(True, {})</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_perfect">
<tt class="descname">is_perfect</tt><big>(</big><em>certificate=False</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.is_perfect" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether the graph is perfect.</p>
<p>A graph <span class="math">\(G\)</span> is said to be perfect if <span class="math">\(\chi(H)=\omega(H)\)</span> hold
for any induced subgraph <span class="math">\(H\subseteq_i G\)</span> (and so for <span class="math">\(G\)</span>
itself, too), where <span class="math">\(\chi(H)\)</span> represents the chromatic number
of <span class="math">\(H\)</span>, and <span class="math">\(\omega(H)\)</span> its clique number. The Strong Perfect
Graph Theorem <a class="reference internal" href="#spgt" id="id31">[SPGT]</a> gives another characterization of
perfect graphs:</p>
<p>A graph is perfect if and only if it contains no odd hole
(cycle on an odd number <span class="math">\(k\)</span> of vertices, <span class="math">\(k&gt;3\)</span>) nor any odd
antihole (complement of a hole) as an induced subgraph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">certificate</span></tt> (boolean) &#8211; whether to return
a certificate (default : <tt class="docutils literal"><span class="pre">False</span></tt>)</li>
</ul>
<p>OUTPUT:</p>
<p>When <tt class="docutils literal"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">False</span></tt>, this function returns
a boolean value. When <tt class="docutils literal"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></tt>, it returns
a subgraph of <tt class="docutils literal"><span class="pre">self</span></tt> isomorphic to an odd hole or an odd
antihole if any, and <tt class="docutils literal"><span class="pre">None</span></tt> otherwise.</p>
<p>EXAMPLE:</p>
<p>A Bipartite Graph is always perfect</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomBipartite</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_perfect</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>So is the line graph of a bipartite graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomBipartite</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mf">0.7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">line_graph</span><span class="p">()</span><span class="o">.</span><span class="n">is_perfect</span><span class="p">()</span> <span class="c1"># long time</span>
<span class="go">True</span>
</pre></div>
</div>
<p>As well as the Cartesian product of two complete graphs:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_perfect</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Interval Graphs, which are chordal graphs, too</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span>  <span class="n">graphs</span><span class="o">.</span><span class="n">RandomIntervalGraph</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_perfect</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The PetersenGraph, which is triangle-free and
has chromatic number 3 is obviously not perfect:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_perfect</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We can obtain an induced 5-cycle as a certificate:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_perfect</span><span class="p">(</span><span class="n">certificate</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="go">Subgraph of (Petersen graph): Graph on 5 vertices</span>
</pre></div>
</div>
<p>TEST:</p>
<p>Check that <a class="reference external" href="http://trac.sagemath.org/13546">trac ticket #13546</a> has been fixed:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;:FgGE@I@GxGs&#39;</span><span class="p">,</span> <span class="n">loops</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">multiedges</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">is_perfect</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>             <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>             <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>             <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>             <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>             <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>             <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_perfect</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="spgt" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id31">[SPGT]</a></td><td>M. Chudnovsky, N. Robertson, P. Seymour, R. Thomas.
The strong perfect graph theorem
Annals of Mathematics
vol 164, number 1, pages 51&#8211;230
2006</td></tr>
</tbody>
</table>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;:Ab&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">is_perfect</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">This method is only defined for simple graphs, and yours is not one of them !</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">allow_loops</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 0, None)]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_perfect</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">This method is only defined for simple graphs, and yours is not one of them !</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_prime">
<tt class="descname">is_prime</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.is_prime" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether the current graph is prime.</p>
<p>A graph is prime if all its modules are trivial (i.e. empty, all of the
graph or singletons) &#8211; see <a class="reference internal" href="#sage.graphs.graph.Graph.modular_decomposition" title="sage.graphs.graph.Graph.modular_decomposition"><tt class="xref py py-meth docutils literal"><span class="pre">modular_decomposition()</span></tt></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In order to use this method you must install the
<tt class="docutils literal"><span class="pre">modular_decomposition</span></tt> optional package. See
<a class="reference external" href="../../../misc/sage/misc/package.html#module-sage.misc.package" title="(in Sage Reference Manual: Utilities v7.1)"><tt class="xref py py-mod docutils literal"><span class="pre">sage.misc.package</span></tt></a>.</p>
</div>
<p>EXAMPLE:</p>
<p>The Petersen Graph and the Bull Graph are both prime:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">is_prime</span><span class="p">()</span> <span class="c1"># optional - modular_decomposition</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">BullGraph</span><span class="p">()</span><span class="o">.</span><span class="n">is_prime</span><span class="p">()</span>     <span class="c1"># optional - modular_decomposition</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Though quite obviously, the disjoint union of them is not:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span> <span class="o">+</span> <span class="n">graphs</span><span class="o">.</span><span class="n">BullGraph</span><span class="p">())</span><span class="o">.</span><span class="n">is_prime</span><span class="p">()</span> <span class="c1"># optional - modular_decomposition</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_semi_symmetric">
<tt class="descname">is_semi_symmetric</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.is_semi_symmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if self is semi-symmetric.</p>
<p>A graph is semi-symmetric if it is regular, edge-transitve but not
vertex-transitive.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Semi-symmetric_graph">the wikipedia article on semi-symmetric graphs</a> for more information.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_edge_transitive" title="sage.graphs.graph.Graph.is_edge_transitive"><tt class="xref py py-meth docutils literal"><span class="pre">is_edge_transitive()</span></tt></a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_arc_transitive" title="sage.graphs.graph.Graph.is_arc_transitive"><tt class="xref py py-meth docutils literal"><span class="pre">is_arc_transitive()</span></tt></a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_half_transitive" title="sage.graphs.graph.Graph.is_half_transitive"><tt class="xref py py-meth docutils literal"><span class="pre">is_half_transitive()</span></tt></a></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>The Petersen graph is not semi-symmetric:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_semi_symmetric</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The Gray graph is the smallest possible cubic semi-symmetric graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">GrayGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_semi_symmetric</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Another well known semi-symmetric graph is the Ljubljana graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">LjubljanaGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">is_semi_symmetric</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_split">
<tt class="descname">is_split</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.is_split" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">True</span></tt> if the graph is a Split graph, <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</p>
<p>A Graph <span class="math">\(G\)</span> is said to be a split graph if its vertices <span class="math">\(V(G)\)</span>
can be partitioned into two sets <span class="math">\(K\)</span> and <span class="math">\(I\)</span> such that the
vertices of <span class="math">\(K\)</span> induce a complete graph, and those of <span class="math">\(I\)</span> are
an independent set.</p>
<p>There is a simple test to check whether a graph is a split
graph (see, for instance, the book &#8220;Graph Classes, a survey&#8221;
<a class="reference internal" href="#graphclasses" id="id32">[GraphClasses]</a> page 203) :</p>
<p>Given the degree sequence <span class="math">\(d_1 \geq ... \geq d_n\)</span> of <span class="math">\(G\)</span>, a graph
is a split graph if and only if :</p>
<div class="math">
\[\sum_{i=1}^\omega d_i = \omega (\omega - 1) + \sum_{i=\omega + 1}^nd_i\]</div>
<p>where <span class="math">\(\omega = max \{i:d_i\geq i-1\}\)</span>.</p>
<p>EXAMPLES:</p>
<p>Split graphs are, in particular, chordal graphs. Hence, The Petersen graph
can not be split:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">is_split</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We can easily build some &#8220;random&#8221; split graph by creating a
complete graph, and adding vertices only connected
to some random vertices of the clique:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sets</span> <span class="o">=</span> <span class="n">Subsets</span><span class="p">(</span><span class="n">Set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">25</span><span class="p">):</span>
<span class="gp">... </span>     <span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sets</span><span class="o">.</span><span class="n">random_element</span><span class="p">()])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_split</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Another caracterisation of split graph states that a graph is a split graph
if and only if does not contain the 4-cycle, 5-cycle or 2K_2 as an induced
subgraph. Hence for the above graph we have:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">sum</span><span class="p">([</span><span class="n">g</span><span class="o">.</span><span class="n">subgraph_search_count</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">induced</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">H</span> <span class="ow">in</span> <span class="p">[</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">)]])</span>
<span class="go">0</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="graphclasses" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id32">[GraphClasses]</a></td><td>A. Brandstadt, VB Le and JP Spinrad
Graph classes: a survey
SIAM Monographs on Discrete Mathematics and Applications},
1999</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_strongly_regular">
<tt class="descname">is_strongly_regular</tt><big>(</big><em>g</em>, <em>parameters=False</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.is_strongly_regular" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether <tt class="docutils literal"><span class="pre">self</span></tt> is strongly regular.</p>
<p>A simple graph <span class="math">\(G\)</span> is said to be strongly regular with parameters <span class="math">\((n, k, \lambda,
\mu)\)</span> if and only if:</p>
<blockquote>
<div><ul class="simple">
<li><span class="math">\(G\)</span> has <span class="math">\(n\)</span> vertices.</li>
<li><span class="math">\(G\)</span> is <span class="math">\(k\)</span>-regular.</li>
<li>Any two adjacent vertices of <span class="math">\(G\)</span> have <span class="math">\(\lambda\)</span> common neighbors.</li>
<li>Any two non-adjacent vertices of <span class="math">\(G\)</span> have <span class="math">\(\mu\)</span> common neighbors.</li>
</ul>
</div></blockquote>
<p>By convention, the complete graphs, the graphs with no edges
and the empty graph are not strongly regular.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Strongly regular graph">Wikipedia article Strongly regular graph</a></p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">parameters</span></tt> (boolean) &#8211; whether to return the quadruple <span class="math">\((n,
k,\lambda,\mu)\)</span>. If <tt class="docutils literal"><span class="pre">parameters</span> <span class="pre">=</span> <span class="pre">False</span></tt> (default), this method only
returns <tt class="docutils literal"><span class="pre">True</span></tt> and <tt class="docutils literal"><span class="pre">False</span></tt> answers. If <tt class="docutils literal"><span class="pre">parameters=True</span></tt>, the
<tt class="docutils literal"><span class="pre">True</span></tt> answers are replaced by quadruples <span class="math">\((n, k,\lambda,\mu)\)</span>. See
definition above.</li>
</ul>
<p>EXAMPLES:</p>
<p>Petersen&#8217;s graph is strongly regular:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">(</span><span class="n">parameters</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="go">(10, 3, 0, 1)</span>
</pre></div>
</div>
<p>And Clebsch&#8217;s graph is too:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">ClebschGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">(</span><span class="n">parameters</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="go">(16, 5, 0, 2)</span>
</pre></div>
</div>
<p>But Chvatal&#8217;s graph is not:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Complete graphs are not strongly regular. (<a class="reference external" href="http://trac.sagemath.org/14297">trac ticket #14297</a>)</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Completements of complete graphs are not strongly regular:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The empty graph is not strongly regular:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">EmptyGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>If the input graph has loops or multiedges an exception is raised:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">This method is not known to work on graphs with</span>
<span class="go">loops. Perhaps this method can be updated to handle them, but in the</span>
<span class="go">meantime if you want to use it please disallow loops using</span>
<span class="go">allow_loops().</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">This method is not known to work on graphs with</span>
<span class="go">multiedges. Perhaps this method can be updated to handle them, but in</span>
<span class="go">the meantime if you want to use it please disallow multiedges using</span>
<span class="go">allow_multiple_edges().</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_tree">
<tt class="descname">is_tree</tt><big>(</big><em>certificate=False</em>, <em>output='vertex'</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.is_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests if the graph is a tree</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">certificate</span></tt> (boolean) &#8211; whether to return a certificate. The
method only returns boolean answers when <tt class="docutils literal"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">False</span></tt>
(default). When it is set to <tt class="docutils literal"><span class="pre">True</span></tt>, it either answers <tt class="docutils literal"><span class="pre">(True,</span>
<span class="pre">None)</span></tt> when the graph is a tree and <tt class="docutils literal"><span class="pre">(False,</span> <span class="pre">cycle)</span></tt> when it
contains a cycle. It returns <tt class="docutils literal"><span class="pre">(False,</span> <span class="pre">None)</span></tt> when the graph is not
connected.</li>
<li><tt class="docutils literal"><span class="pre">output</span></tt> (<tt class="docutils literal"><span class="pre">'vertex'</span></tt> (default) or <tt class="docutils literal"><span class="pre">'edge'</span></tt>) &#8211; whether the
certificate is given as a list of vertices or a list of
edges.</li>
</ul>
<p>When the certificate cycle is given as a list of edges, the
edges are given as <span class="math">\((v_i, v_{i+1}, l)\)</span> where <span class="math">\(v_1, v_2, \dots,
v_n\)</span> are the vertices of the cycles (in their cyclic order).</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">is_tree</span><span class="p">()</span> <span class="k">for</span> <span class="n">T</span> <span class="ow">in</span> <span class="n">graphs</span><span class="o">.</span><span class="n">trees</span><span class="p">(</span><span class="mi">15</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The empty graph is not considered to be a tree:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">EmptyGraph</span><span class="p">()</span><span class="o">.</span><span class="n">is_tree</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>With certificates:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomTree</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_tree</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(True, None)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">isit</span><span class="p">,</span> <span class="n">cycle</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_tree</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">isit</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">cycle</span>
<span class="go">True</span>
</pre></div>
</div>
<p>One can also ask for the certificate as a list of edges:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_tree</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)</span>
<span class="go">(False, [(3, 2, None), (2, 1, None), (1, 0, None), (0, 3, None)])</span>
</pre></div>
</div>
<p>This is useful for graphs with multiple edges:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)],</span> <span class="n">multiedges</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_tree</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(False, [1, 2])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_tree</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)</span>
<span class="go">(False, [(1, 2, &#39;a&#39;), (2, 1, &#39;b&#39;)])</span>
</pre></div>
</div>
<p>TESTS:</p>
<p><a class="reference external" href="http://trac.sagemath.org/14434">trac ticket #14434</a> is fixed:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span><span class="mi">4</span><span class="p">:[</span><span class="mi">9</span><span class="p">],</span><span class="mi">5</span><span class="p">:[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span><span class="mi">7</span><span class="p">:[</span><span class="mi">9</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span><span class="n">cycle</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_tree</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">10</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_cycle</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">10</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_triangle_free">
<tt class="descname">is_triangle_free</tt><big>(</big><em>algorithm='bitset'</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.is_triangle_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether <tt class="docutils literal"><span class="pre">self</span></tt> is triangle-free</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">algorithm</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">'bitset'</span></tt>) specifies the algorithm to
use among:<ul>
<li><tt class="docutils literal"><span class="pre">'matrix'</span></tt> &#8211; tests if the trace of the adjacency matrix is
positive.</li>
<li><tt class="docutils literal"><span class="pre">'bitset'</span></tt> &#8211; encodes adjacencies into bitsets and uses fast
bitset operations to test if the input graph contains a
triangle. This method is generaly faster than stantard matrix
multiplication.</li>
</ul>
</li>
</ul>
<p>EXAMPLE:</p>
<p>The Petersen Graph is triangle-free:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_triangle_free</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>or a complete Bipartite Graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_triangle_free</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;matrix&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_triangle_free</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;bitset&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>a tripartite graph, though, contains many triangles:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_triangle_free</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;matrix&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_triangle_free</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;bitset&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Comparison of algorithms:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span> <span class="c1"># long test</span>
<span class="gp">... </span>      <span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomBarabasiAlbert</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">... </span>      <span class="n">bm</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">is_triangle_free</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;matrix&#39;</span><span class="p">)</span>
<span class="gp">... </span>      <span class="n">bb</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">is_triangle_free</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;bitset&#39;</span><span class="p">)</span>
<span class="gp">... </span>      <span class="k">if</span> <span class="n">bm</span> <span class="o">!=</span> <span class="n">bb</span><span class="p">:</span>
<span class="gp">... </span>         <span class="k">print</span> <span class="s2">&quot;That&#39;s not good!&quot;</span>
</pre></div>
</div>
<p>Asking for an unknown algorithm:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_triangle_free</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;tip top&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Algorithm &#39;tip top&#39; not yet implemented. Please contribute.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_weakly_chordal">
<tt class="descname">is_weakly_chordal</tt><big>(</big><em>g</em>, <em>certificate=False</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.is_weakly_chordal" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether the given graph is weakly chordal, i.e., the graph and its
complement have no induced cycle of length at least 5.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">certificate</span></tt> &#8211; Boolean value (default: <tt class="docutils literal"><span class="pre">False</span></tt>) whether to
return a certificate. If <tt class="docutils literal"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">False</span></tt>, return <tt class="docutils literal"><span class="pre">True</span></tt> or
<tt class="docutils literal"><span class="pre">False</span></tt> according to the graph. If <tt class="docutils literal"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></tt>, return</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">(False,</span> <span class="pre">forbidden_subgraph)</span></tt> when the graph contains a
forbidden subgraph H, this graph is returned.</p>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">(True,</span> <span class="pre">[])</span></tt> when the graph is weakly chordal.</dt>
<dd><p class="first last">For this case, it is not known how to provide a certificate.</p>
</dd>
</dl>
</li>
</ul>
</li>
</ul>
<p>ALGORITHM:</p>
<p>This algorithm checks whether the graph <tt class="docutils literal"><span class="pre">g</span></tt> or its complement
contain an induced cycle of length at least 5.</p>
<p>Using is_long_hole_free() and is_long_antihole_free() yields a run time
of <span class="math">\(O(m^2)\)</span> (where <span class="math">\(m\)</span> is the number of edges of the graph).</p>
<p>EXAMPLES:</p>
<p>The Petersen Graph is not weakly chordal and contains a hole:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">r</span><span class="p">,</span><span class="n">s</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_weakly_chordal</span><span class="p">(</span><span class="n">certificate</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">r</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.join">
<tt class="descname">join</tt><big>(</big><em>other</em>, <em>verbose_relabel=None</em>, <em>labels='pairs'</em>, <em>immutable=None</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the join of <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">other</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">verbose_relabel</span></tt> - deprecated.</li>
<li><tt class="docutils literal"><span class="pre">labels</span></tt> - (defaults to &#8216;pairs&#8217;) If set to &#8216;pairs&#8217;, each
element <tt class="docutils literal"><span class="pre">v</span></tt> in the first graph will be named <tt class="docutils literal"><span class="pre">(0,v)</span></tt> and
each element <tt class="docutils literal"><span class="pre">u</span></tt> in <tt class="docutils literal"><span class="pre">other</span></tt> will be named <tt class="docutils literal"><span class="pre">(1,u)</span></tt> in
the result. If set to &#8216;integers&#8217;, the elements of the result
will be relabeled with consecutive integers.</li>
<li><tt class="docutils literal"><span class="pre">immutable</span></tt> (boolean) &#8211; whether to create a mutable/immutable
join. <tt class="docutils literal"><span class="pre">immutable=None</span></tt> (default) means that the graphs and their
join will behave the same way.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.union" title="sage.graphs.generic_graph.GenericGraph.union"><tt class="xref py py-meth docutils literal"><span class="pre">union()</span></tt></a></li>
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.disjoint_union" title="sage.graphs.generic_graph.GenericGraph.disjoint_union"><tt class="xref py py-meth docutils literal"><span class="pre">disjoint_union()</span></tt></a></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">H</span><span class="p">);</span> <span class="n">J</span>
<span class="go">Cycle graph join : Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1)]</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="s1">&#39;integers&#39;</span><span class="p">);</span> <span class="n">J</span>
<span class="go">Cycle graph join : Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4]</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None), (0, 2, None), (0, 3, None), (0, 4, None), (1, 2, None), (1, 3, None), (1, 4, None), (2, 3, None), (2, 4, None)]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">name</span><span class="p">(</span><span class="s2">&quot;Graph on 3 vertices&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">name</span><span class="p">(</span><span class="s2">&quot;Graph on 2 vertices&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">H</span><span class="p">);</span> <span class="n">J</span>
<span class="go">Graph on 3 vertices join Graph on 2 vertices: Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1)]</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="s1">&#39;integers&#39;</span><span class="p">);</span> <span class="n">J</span>
<span class="go">Graph on 3 vertices join Graph on 2 vertices: Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 3, None), (0, 4, None), (1, 3, None), (1, 4, None), (2, 3, None), (2, 4, None)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.kirchhoff_symanzik_polynomial">
<tt class="descname">kirchhoff_symanzik_polynomial</tt><big>(</big><em>name='t'</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.kirchhoff_symanzik_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Kirchhoff-Symanzik polynomial of a graph.</p>
<p>This is a polynomial in variables <span class="math">\(t_e\)</span> (each of them representing an
edge of the graph <span class="math">\(G\)</span>) defined as a sum over all spanning trees:</p>
<div class="math">
\[\Psi_G(t) = \sum_{T\subseteq V\atop{\text{a spanning tree}}} \prod_{e \not\in E(T)} t_e\]</div>
<p>This is also called the first Symanzik polynomial or the Kirchhoff
polynomial.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">name</span></tt>: name of the variables (default: <tt class="docutils literal"><span class="pre">'t'</span></tt>)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>a polynomial with integer coefficients</li>
</ul>
<p>ALGORITHM:</p>
<blockquote>
<div><p>This is computed here using a determinant, as explained in Section
3.1 of <a class="reference internal" href="#marcolli2009" id="id33">[Marcolli2009]</a>.</p>
<p>As an intermediate step, one computes a cycle basis <span class="math">\(\mathcal C\)</span> of
<span class="math">\(G\)</span> and a rectangular <span class="math">\(|\mathcal C| \times |E(G)|\)</span> matrix with
entries in <span class="math">\(\{-1,0,1\}\)</span>, which describes which edge belong to which
cycle of <span class="math">\(\mathcal C\)</span> and their respective orientations.</p>
<p>More precisely, after fixing an arbitrary orientation for each edge
<span class="math">\(e\in E(G)\)</span> and each cycle <span class="math">\(C\in\mathcal C\)</span>, one gets a sign for
every incident pair (edge, cycle) which is <span class="math">\(1\)</span> if the orientation
coincide and <span class="math">\(-1\)</span> otherwise.</p>
</div></blockquote>
<p>EXAMPLES:</p>
<p>For the cycle of length 5:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">kirchhoff_symanzik_polynomial</span><span class="p">()</span>
<span class="go">t0 + t1 + t2 + t3 + t4</span>
</pre></div>
</div>
<p>One can use another letter for variables:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">kirchhoff_symanzik_polynomial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
<span class="go">u0 + u1 + u2 + u3 + u4</span>
</pre></div>
</div>
<p>For the &#8216;coffee bean&#8217; graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">)],</span><span class="n">multiedges</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">kirchhoff_symanzik_polynomial</span><span class="p">()</span>
<span class="go">t0*t1 + t0*t2 + t1*t2</span>
</pre></div>
</div>
<p>For the &#8216;parachute&#8217; graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">)],</span> <span class="n">multiedges</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">kirchhoff_symanzik_polynomial</span><span class="p">()</span>
<span class="go">t0*t1 + t0*t2 + t1*t2 + t1*t3 + t2*t3</span>
</pre></div>
</div>
<p>For the complete graph with 4 vertices:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">kirchhoff_symanzik_polynomial</span><span class="p">()</span>
<span class="go">t0*t1*t3 + t0*t2*t3 + t1*t2*t3 + t0*t1*t4 + t0*t2*t4 + t1*t2*t4</span>
<span class="go">+ t1*t3*t4 + t2*t3*t4 + t0*t1*t5 + t0*t2*t5 + t1*t2*t5 + t0*t3*t5</span>
<span class="go">+ t2*t3*t5 + t0*t4*t5 + t1*t4*t5 + t3*t4*t5</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="marcolli2009" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id33">[Marcolli2009]</a></td><td>Matilde Marcolli, Feynman Motives, Chapter 3,
Feynman integrals and algebraic varieties,
<a class="reference external" href="http://www.its.caltech.edu/~matilde/LectureN3.pdf">http://www.its.caltech.edu/~matilde/LectureN3.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="brown2011" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Brown2011]</td><td>Francis Brown, Multiple zeta values and periods: From
moduli spaces to Feynman integrals, in Contemporary Mathematics vol
539</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.lovasz_theta">
<tt class="descname">lovasz_theta</tt><big>(</big><em>graph</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.lovasz_theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the value of Lovász theta-function of graph</p>
<p>For a graph <span class="math">\(G\)</span> this function is denoted by <span class="math">\(\theta(G)\)</span>, and it can be
computed in polynomial time. Mathematically, its most important property is the following:</p>
<div class="math">
\[\alpha(G)\leq\theta(G)\leq\chi(\overline{G})\]</div>
<p>with <span class="math">\(\alpha(G)\)</span> and <span class="math">\(\chi(\overline{G})\)</span> being, respectively, the maximum
size of an <a class="reference internal" href="#sage.graphs.graph.Graph.independent_set" title="sage.graphs.graph.Graph.independent_set"><tt class="xref py py-meth docutils literal"><span class="pre">independent</span> <span class="pre">set</span></tt></a>
set of <span class="math">\(G\)</span> and the <a class="reference internal" href="#sage.graphs.graph.Graph.chromatic_number" title="sage.graphs.graph.Graph.chromatic_number"><tt class="xref py py-meth docutils literal"><span class="pre">chromatic</span> <span class="pre">number</span></tt></a> of the <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.complement" title="sage.graphs.generic_graph.GenericGraph.complement"><tt class="xref py py-meth docutils literal"><span class="pre">complement</span></tt></a> <span class="math">\(\overline{G}\)</span> of <span class="math">\(G\)</span>.</p>
<p>For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Lovász_number">Wikipedia article Lovász_number</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>Implemented for undirected graphs only. Use to_undirected to convert a
digraph to an undirected graph.</li>
<li>This function requires the optional package <tt class="docutils literal"><span class="pre">csdp</span></tt>, which you can
install with with <tt class="docutils literal"><span class="pre">sage</span> <span class="pre">-i</span> <span class="pre">csdp</span></tt>.</li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">lovasz_theta</span><span class="p">()</span>                             <span class="c1"># optional csdp</span>
<span class="go">4.0</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">lovasz_theta</span><span class="p">()</span>          <span class="c1"># optional csdp</span>
<span class="go">2.236068</span>
</pre></div>
</div>
<p>TEST:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">lovasz_theta</span><span class="p">()</span> <span class="c1"># indirect doctest</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.matching">
<tt class="descname">matching</tt><big>(</big><em>value_only=False</em>, <em>algorithm='Edmonds'</em>, <em>use_edge_labels=True</em>, <em>solver=None</em>, <em>verbose=0</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.matching" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a maximum weighted matching of the graph
represented by the list of its edges. For more information, see the
<a class="reference external" href="http://en.wikipedia.org/wiki/Matching_%28graph_theory%29">Wikipedia article on matchings</a>.</p>
<p>Given a graph <span class="math">\(G\)</span> such that each edge <span class="math">\(e\)</span> has a weight <span class="math">\(w_e\)</span>,
a maximum matching is a subset <span class="math">\(S\)</span> of the edges of <span class="math">\(G\)</span> of
maximum weight such that no two edges of <span class="math">\(S\)</span> are incident
with each other.</p>
<p>As an optimization problem, it can be expressed as:</p>
<div class="math">
\[\begin{split}\mbox{Maximize : }&amp;\sum_{e\in G.edges()} w_e b_e\\
\mbox{Such that : }&amp;\forall v \in G, \sum_{(u,v)\in G.edges()} b_{(u,v)}\leq 1\\
&amp;\forall x\in G, b_x\mbox{ is a binary variable}\end{split}\]</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">value_only</span></tt> &#8211; boolean (default: <tt class="docutils literal"><span class="pre">False</span></tt>). When set to
<tt class="docutils literal"><span class="pre">True</span></tt>, only the cardinal (or the weight) of the matching is
returned.</li>
<li><tt class="docutils literal"><span class="pre">algorithm</span></tt> &#8211; string (default: <tt class="docutils literal"><span class="pre">&quot;Edmonds&quot;</span></tt>)<ul>
<li><tt class="docutils literal"><span class="pre">&quot;Edmonds&quot;</span></tt> selects Edmonds&#8217; algorithm as implemented in NetworkX</li>
<li><tt class="docutils literal"><span class="pre">&quot;LP&quot;</span></tt> uses a Linear Program formulation of the matching problem</li>
</ul>
</li>
<li><tt class="docutils literal"><span class="pre">use_edge_labels</span></tt> &#8211; boolean (default: <tt class="docutils literal"><span class="pre">False</span></tt>)<ul>
<li>When set to <tt class="docutils literal"><span class="pre">True</span></tt>, computes a weighted matching where each edge
is weighted by its label. (If an edge has no label, <span class="math">\(1\)</span> is assumed.)</li>
<li>When set to <tt class="docutils literal"><span class="pre">False</span></tt>, each edge has weight <span class="math">\(1\)</span>.</li>
</ul>
</li>
<li><tt class="docutils literal"><span class="pre">solver</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) Specify a Linear Program (LP)
solver to be used. If set to <tt class="docutils literal"><span class="pre">None</span></tt>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-meth docutils literal"><span class="pre">solve</span></tt></a>
of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">MixedIntegerLinearProgram</span></tt></a>.</li>
<li><tt class="docutils literal"><span class="pre">verbose</span></tt> &#8211; integer (default: <tt class="docutils literal"><span class="pre">0</span></tt>). Sets the level of
verbosity. Set to 0 by default, which means quiet.
Only useful when <tt class="docutils literal"><span class="pre">algorithm</span> <span class="pre">==</span> <span class="pre">&quot;LP&quot;</span></tt>.</li>
</ul>
<p>ALGORITHM:</p>
<p>The problem is solved using Edmond&#8217;s algorithm implemented in
NetworkX, or using Linear Programming depending on the value of
<tt class="docutils literal"><span class="pre">algorithm</span></tt>.</p>
<p>EXAMPLES:</p>
<p>Maximum matching in a Pappus Graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PappusGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">matching</span><span class="p">(</span><span class="n">value_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">9.0</span>
</pre></div>
</div>
<p>Same test with the Linear Program formulation:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PappusGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">matching</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;LP&quot;</span><span class="p">,</span> <span class="n">value_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">9.0</span>
</pre></div>
</div>
<div class="figure">
<img alt="../../_images/graph-3.png" src="../../_images/graph-3.png" />
</div>
<p>TESTS:</p>
<p>If <tt class="docutils literal"><span class="pre">algorithm</span></tt> is set to anything different from <tt class="docutils literal"><span class="pre">&quot;Edmonds&quot;</span></tt> or
<tt class="docutils literal"><span class="pre">&quot;LP&quot;</span></tt>, an exception is raised:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PappusGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">matching</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;somethingdifferent&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">algorithm must be set to either &quot;Edmonds&quot; or &quot;LP&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.matching_polynomial">
<tt class="descname">matching_polynomial</tt><big>(</big><em>G</em>, <em>complement=True</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.matching_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the matching polynomial of the graph <span class="math">\(G\)</span>.</p>
<p>If <span class="math">\(p(G, k)\)</span> denotes the number of <span class="math">\(k\)</span>-matchings (matchings with <span class="math">\(k\)</span> edges)
in <span class="math">\(G\)</span>, then the matching polynomial is defined as <a class="reference internal" href="matchpoly.html#godsil93" id="id35">[Godsil93]</a>:</p>
<div class="math">
\[\mu(x)=\sum_{k \geq 0} (-1)^k p(G,k) x^{n-2k}\]</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">complement</span></tt> - (default: <tt class="docutils literal"><span class="pre">True</span></tt>) whether to use Godsil&#8217;s duality
theorem to compute the matching polynomial from that of the graphs
complement (see ALGORITHM).</li>
<li><tt class="docutils literal"><span class="pre">name</span></tt> - optional string for the variable name in the polynomial</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <tt class="docutils literal"><span class="pre">complement</span></tt> option uses matching polynomials of complete graphs,
which are cached. So if you are crazy enough to try computing the
matching polynomial on a graph with millions of vertices, you might not
want to use this option, since it will end up caching millions of
polynomials of degree in the millions.</p>
</div>
<p>ALGORITHM:</p>
<p>The algorithm used is a recursive one, based on the following observation
<a class="reference internal" href="matchpoly.html#godsil93" id="id36">[Godsil93]</a>:</p>
<ul>
<li><p class="first">If <span class="math">\(e\)</span> is an edge of <span class="math">\(G\)</span>, <span class="math">\(G'\)</span> is the result of deleting the edge <span class="math">\(e\)</span>, and
<span class="math">\(G''\)</span> is the result of deleting each vertex in <span class="math">\(e\)</span>, then the matching
polynomial of <span class="math">\(G\)</span> is equal to that of <span class="math">\(G'\)</span> minus that of <span class="math">\(G''\)</span>.</p>
<p>(the algorithm actually computes the <em>signless</em> matching polynomial, for
which the recursion is the same when one replaces the substraction by an
addition. It is then converted into the matching polynomial and returned)</p>
</li>
</ul>
<p>Depending on the value of <tt class="docutils literal"><span class="pre">complement</span></tt>, Godsil&#8217;s duality theorem
<a class="reference internal" href="matchpoly.html#godsil93" id="id37">[Godsil93]</a> can also be used to compute <span class="math">\(\mu(x)\)</span> :</p>
<div class="math">
\[\mu(\overline{G}, x) = \sum_{k \geq 0} p(G,k) \mu( K_{n-2k}, x)\]</div>
<p>Where <span class="math">\(\overline{G}\)</span> is the complement of <span class="math">\(G\)</span>, and <span class="math">\(K_n\)</span> the complete graph
on <span class="math">\(n\)</span> vertices.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">matching_polynomial</span><span class="p">()</span>
<span class="go">x^10 - 15*x^8 + 75*x^6 - 145*x^4 + 90*x^2 - 6</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">x^10 - 15*x^8 + 75*x^6 - 145*x^4 + 90*x^2 - 6</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;tom&#39;</span><span class="p">)</span>
<span class="go">tom^10 - 15*tom^8 + 75*tom^6 - 145*tom^4 + 90*tom^2 - 6</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="o">.</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">prod</span><span class="p">([</span><span class="n">h</span><span class="o">.</span><span class="n">matching_polynomial</span><span class="p">()</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">L</span><span class="p">])</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">matching_polynomial</span><span class="p">()</span>  <span class="c1"># long time (up to 10s on sage.math, 2011)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">):</span>  <span class="c1"># long time (10s on sage.math, 2011)</span>
<span class="go">....:     for t in graphs.trees(i):</span>
<span class="go">....:         if t.matching_polynomial() != t.characteristic_polynomial():</span>
<span class="go">....:             raise RuntimeError(&#39;bug for a tree A of size {0}&#39;.format(i))</span>
<span class="go">....:         c = t.complement()</span>
<span class="go">....:         if c.matching_polynomial(complement=False) != c.matching_polynomial():</span>
<span class="go">....:             raise RuntimeError(&#39;bug for a tree B of size {0}&#39;.format(i))</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.matchpoly</span> <span class="kn">import</span> <span class="n">matching_polynomial</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">x^2 - 1</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">x^3 - 3*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">x^4 - 6*x^2 + 3</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">x^5 - 10*x^3 + 15*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="go">x^6 - 15*x^4 + 45*x^2 - 15</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="go">x^7 - 21*x^5 + 105*x^3 - 105*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>
<span class="go">x^8 - 28*x^6 + 210*x^4 - 420*x^2 + 105</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">9</span><span class="p">))</span>
<span class="go">x^9 - 36*x^7 + 378*x^5 - 1260*x^3 + 945*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">x^10 - 45*x^8 + 630*x^6 - 3150*x^4 + 4725*x^2 - 945</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">11</span><span class="p">))</span>
<span class="go">x^11 - 55*x^9 + 990*x^7 - 6930*x^5 + 17325*x^3 - 10395*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">12</span><span class="p">))</span>
<span class="go">x^12 - 66*x^10 + 1485*x^8 - 13860*x^6 + 51975*x^4 - 62370*x^2 + 10395</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">13</span><span class="p">))</span>
<span class="go">x^13 - 78*x^11 + 2145*x^9 - 25740*x^7 + 135135*x^5 - 270270*x^3 + 135135*x</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">x^3 - 3*x</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">x^3 - 2*x</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">x^3 - x</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[],</span> <span class="mi">1</span><span class="p">:[],</span> <span class="mi">2</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">x^3</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">x^2 - 1</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">x^3 - 3*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">x^4 - 6*x^2 + 3</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">x^5 - 10*x^3 + 15*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">x^6 - 15*x^4 + 45*x^2 - 15</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">x^7 - 21*x^5 + 105*x^3 - 105*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">x^8 - 28*x^6 + 210*x^4 - 420*x^2 + 105</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">9</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">x^9 - 36*x^7 + 378*x^5 - 1260*x^3 + 945*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">x^10 - 45*x^8 + 630*x^6 - 3150*x^4 + 4725*x^2 - 945</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">11</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">x^11 - 55*x^9 + 990*x^7 - 6930*x^5 + 17325*x^3 - 10395*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">x^12 - 66*x^10 + 1485*x^8 - 13860*x^6 + 51975*x^4 - 62370*x^2 + 10395</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">13</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">x^13 - 78*x^11 + 2145*x^9 - 25740*x^7 + 135135*x^5 - 270270*x^3 + 135135*x</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Non-integer labels should work, (<a class="reference external" href="http://trac.sagemath.org/15545">trac ticket #15545</a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">matching_polynomial</span><span class="p">()</span>
<span class="go">x^12</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.maximum_average_degree">
<tt class="descname">maximum_average_degree</tt><big>(</big><em>value_only=True</em>, <em>solver=None</em>, <em>verbose=0</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.maximum_average_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Maximum Average Degree (MAD) of the current graph.</p>
<p>The Maximum Average Degree (MAD) of a graph is defined as
the average degree of its densest subgraph. More formally,
<tt class="docutils literal"><span class="pre">Mad(G)</span> <span class="pre">=</span> <span class="pre">\max_{H\subseteq</span> <span class="pre">G}</span> <span class="pre">Ad(H)</span></tt>, where <span class="math">\(Ad(G)\)</span> denotes
the average degree of <span class="math">\(G\)</span>.</p>
<p>This can be computed in polynomial time.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">value_only</span></tt> (boolean) &#8211; <tt class="docutils literal"><span class="pre">True</span></tt> by default<ul>
<li>If <tt class="docutils literal"><span class="pre">value_only=True</span></tt>, only the numerical
value of the <span class="math">\(MAD\)</span> is returned.</li>
<li>Else, the subgraph of <span class="math">\(G\)</span> realizing the <span class="math">\(MAD\)</span>
is returned.</li>
</ul>
</li>
<li><tt class="docutils literal"><span class="pre">solver</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) Specify a Linear Program (LP)
solver to be used. If set to <tt class="docutils literal"><span class="pre">None</span></tt>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-meth docutils literal"><span class="pre">solve</span></tt></a>
of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">MixedIntegerLinearProgram</span></tt></a>.</li>
<li><tt class="docutils literal"><span class="pre">verbose</span></tt> &#8211; integer (default: <tt class="docutils literal"><span class="pre">0</span></tt>). Sets the level of
verbosity. Set to 0 by default, which means quiet.</li>
</ul>
<p>EXAMPLES:</p>
<p>In any graph, the <span class="math">\(Mad\)</span> is always larger than the average
degree:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="o">.</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">mad_g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">maximum_average_degree</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">average_degree</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">mad_g</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Unlike the average degree, the <span class="math">\(Mad\)</span> of the disjoint
union of two graphs is the maximum of the <span class="math">\(Mad\)</span> of each
graphs:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="o">.</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">mad_h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">maximum_average_degree</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">g</span><span class="o">+</span><span class="n">h</span><span class="p">)</span><span class="o">.</span><span class="n">maximum_average_degree</span><span class="p">()</span> <span class="o">==</span> <span class="nb">max</span><span class="p">(</span><span class="n">mad_g</span><span class="p">,</span> <span class="n">mad_h</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The subgraph of a regular graph realizing the maximum
average degree is always the whole graph</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">mad_g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">maximum_average_degree</span><span class="p">(</span><span class="n">value_only</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">mad_g</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This also works for complete bipartite graphs</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">mad_g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">maximum_average_degree</span><span class="p">(</span><span class="n">value_only</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">mad_g</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.minimum_outdegree_orientation">
<tt class="descname">minimum_outdegree_orientation</tt><big>(</big><em>use_edge_labels=False</em>, <em>solver=None</em>, <em>verbose=0</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.minimum_outdegree_orientation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an orientation of <tt class="docutils literal"><span class="pre">self</span></tt> with the smallest possible maximum
outdegree.</p>
<p>Given a Graph <span class="math">\(G\)</span>, is is polynomial to compute an orientation
<span class="math">\(D\)</span> of the edges of <span class="math">\(G\)</span> such that the maximum out-degree in
<span class="math">\(D\)</span> is minimized. This problem, though, is NP-complete in the
weighted case <a class="reference internal" href="#amoz06" id="id38">[AMOZ06]</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">use_edge_labels</span></tt> &#8211; boolean (default: <tt class="docutils literal"><span class="pre">False</span></tt>)<ul>
<li>When set to <tt class="docutils literal"><span class="pre">True</span></tt>, uses edge labels as weights to
compute the orientation and assumes a weight of <span class="math">\(1\)</span>
when there is no value available for a given edge.</li>
<li>When set to <tt class="docutils literal"><span class="pre">False</span></tt> (default), gives a weight of 1
to all the edges.</li>
</ul>
</li>
<li><tt class="docutils literal"><span class="pre">solver</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) Specify a Linear Program (LP)
solver to be used. If set to <tt class="docutils literal"><span class="pre">None</span></tt>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-meth docutils literal"><span class="pre">solve</span></tt></a>
of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">MixedIntegerLinearProgram</span></tt></a>.</li>
<li><tt class="docutils literal"><span class="pre">verbose</span></tt> &#8211; integer (default: <tt class="docutils literal"><span class="pre">0</span></tt>). Sets the level of
verbosity. Set to 0 by default, which means quiet.</li>
</ul>
<p>EXAMPLE:</p>
<p>Given a complete bipartite graph <span class="math">\(K_{n,m}\)</span>, the maximum out-degree
of an optimal orientation is <span class="math">\(\left\lceil \frac {nm} {n+m}\right\rceil\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">minimum_outdegree_orientation</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">max</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">out_degree</span><span class="p">())</span> <span class="o">==</span> <span class="n">ceil</span><span class="p">((</span><span class="mi">4</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="mi">4</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="amoz06" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id38">[AMOZ06]</a></td><td>Asahiro, Y. and Miyano, E. and Ono, H. and Zenmyo, K.
Graph orientation algorithms to minimize the maximum outdegree
Proceedings of the 12th Computing: The Australasian Theory Symposium
Volume 51, page 20
Australian Computer Society, Inc. 2006</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.minor">
<tt class="descname">minor</tt><big>(</big><em>H</em>, <em>solver=None</em>, <em>verbose=0</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.minor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the vertices of a minor isomorphic to <span class="math">\(H\)</span> in the current graph.</p>
<p>We say that a graph <span class="math">\(G\)</span> has a <span class="math">\(H\)</span>-minor (or that it has
a graph isomorphic to <span class="math">\(H\)</span> as a minor), if for all <span class="math">\(h\in H\)</span>,
there exist disjoint sets <span class="math">\(S_h \subseteq V(G)\)</span> such that
once the vertices of each <span class="math">\(S_h\)</span> have been merged to create
a new graph <span class="math">\(G'\)</span>, this new graph contains <span class="math">\(H\)</span> as a subgraph.</p>
<p>For more information, see the
<a class="reference external" href="http://en.wikipedia.org/wiki/Minor_%28graph_theory%29">Wikipedia article on graph minor</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">H</span></tt> &#8211; The minor to find for in the current graph.</li>
<li><tt class="docutils literal"><span class="pre">solver</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) Specify a Linear Program (LP)
solver to be used. If set to <tt class="docutils literal"><span class="pre">None</span></tt>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-meth docutils literal"><span class="pre">solve</span></tt></a>
of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">MixedIntegerLinearProgram</span></tt></a>.</li>
<li><tt class="docutils literal"><span class="pre">verbose</span></tt> &#8211; integer (default: <tt class="docutils literal"><span class="pre">0</span></tt>). Sets the level of
verbosity. Set to 0 by default, which means quiet.</li>
</ul>
<p>OUTPUT:</p>
<p>A dictionary associating to each vertex of <span class="math">\(H\)</span> the set of vertices
in the current graph representing it.</p>
<p>ALGORITHM:</p>
<p>Mixed Integer Linear Programming</p>
<p>COMPLEXITY:</p>
<p>Theoretically, when <span class="math">\(H\)</span> is fixed, testing for the existence of
a <span class="math">\(H\)</span>-minor is polynomial. The known algorithms are highly
exponential in <span class="math">\(H\)</span>, though.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function can be expected to be <em>very</em> slow, especially
where the minor does not exist.</p>
</div>
<p>EXAMPLES:</p>
<p>Trying to find a minor isomorphic to <span class="math">\(K_4\)</span> in
the <span class="math">\(4\times 4\)</span> grid:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">GridGraph</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">minor</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">gg</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">max_level</span> <span class="o">=</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">_</span> <span class="o">=</span> <span class="p">[</span><span class="n">gg</span><span class="o">.</span><span class="n">merge_vertices</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">L</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">gg</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We can also try to prove this way that the Petersen graph
is not planar, as it has a <span class="math">\(K_5\)</span> minor:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">K5_minor</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">minor</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>                    <span class="c1"># long time</span>
</pre></div>
</div>
<p>And even a <span class="math">\(K_{3,3}\)</span> minor:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K33_minor</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">minor</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>        <span class="c1"># long time</span>
</pre></div>
</div>
<p>(It is much faster to use the linear-time test of
planarity in this situation, though.)</p>
<p>As there is no cycle in a tree, looking for a <span class="math">\(K_3\)</span> minor is useless.
This function will raise an exception in this case:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">edges</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_tree</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">minor</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">This graph has no minor isomorphic to H !</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.modular_decomposition">
<tt class="descname">modular_decomposition</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.modular_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the modular decomposition of the current graph.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In order to use this method you must install the
<tt class="docutils literal"><span class="pre">modular_decomposition</span></tt> optional package. See
<a class="reference external" href="../../../misc/sage/misc/package.html#module-sage.misc.package" title="(in Sage Reference Manual: Utilities v7.1)"><tt class="xref py py-mod docutils literal"><span class="pre">sage.misc.package</span></tt></a>.</p>
</div>
<p>Crash course on modular decomposition:</p>
<p>A module <span class="math">\(M\)</span> of a graph <span class="math">\(G\)</span> is a proper subset of its vertices
such that for all <span class="math">\(u \in V(G)-M, v,w\in M\)</span> the relation <span class="math">\(u
\sim v \Leftrightarrow u \sim w\)</span> holds, where <span class="math">\(\sim\)</span> denotes
the adjacency relation in <span class="math">\(G\)</span>. Equivalently, <span class="math">\(M \subset V(G)\)</span>
is a module if all its vertices have the same adjacency
relations with each vertex outside of the module (vertex by
vertex).</p>
<p>Hence, for a set like a module, it is very easy to encode the
information of the adjacencies between the vertices inside and
outside the module &#8211; we can actually add a new vertex <span class="math">\(v_M\)</span>
to our graph representing our module <span class="math">\(M\)</span>, and let <span class="math">\(v_M\)</span> be
adjacent to <span class="math">\(u\in V(G)-M\)</span> if and only if some <span class="math">\(v\in M\)</span> (and
hence all the vertices contained in the module) is adjacent to
<span class="math">\(u\)</span>. We can now independently (and recursively) study the
structure of our module <span class="math">\(M\)</span> and the new graph <span class="math">\(G-M+\{v_M\}\)</span>,
without any loss of information.</p>
<p>Here are two very simple modules :</p>
<blockquote>
<div><ul class="simple">
<li>A connected component <span class="math">\(C\)</span> (or the union of some &#8211;but
not all&#8211; of them) of a disconnected graph <span class="math">\(G\)</span>, for
instance, is a module, as no vertex of <span class="math">\(C\)</span> has a
neighbor outside of it.</li>
<li>An anticomponent <span class="math">\(C\)</span> (or the union of some &#8211;but not
all&#8211; of them) of an non-anticonnected graph <span class="math">\(G\)</span>, for
the same reason (it is just the complement of the
previous graph !).</li>
</ul>
</div></blockquote>
<p>These modules being of special interest, the disjoint union of
graphs is called a Parallel composition, and the complement of
a disjoint union is called a Parallel composition. A graph
whose only modules are singletons is called Prime.</p>
<p>For more information on modular decomposition, in particular
for an explanation of the terms &#8220;Parallel,&#8221; &#8220;Prime&#8221; and
&#8220;Serie,&#8221; see the <a class="reference external" href="http://en.wikipedia.org/wiki/Modular_decomposition">Wikipedia article on modular decomposition</a>.</p>
<p>You may also be interested in the survey from Michel Habib and
Christophe Paul entitled &#8220;A survey on Algorithmic aspects of
modular decomposition&#8221; <a class="reference internal" href="#habpau10" id="id39">[HabPau10]</a>.</p>
<p>OUTPUT:</p>
<p>A pair of two values (recursively encoding the decomposition) :</p>
<ul class="simple">
<li>The type of the current module :<ul>
<li><tt class="docutils literal"><span class="pre">&quot;Parallel&quot;</span></tt></li>
<li><tt class="docutils literal"><span class="pre">&quot;Prime&quot;</span></tt></li>
<li><tt class="docutils literal"><span class="pre">&quot;Serie&quot;</span></tt></li>
</ul>
</li>
<li>The list of submodules (as list of pairs <tt class="docutils literal"><span class="pre">(type,</span> <span class="pre">list)</span></tt>,
recursively...) or the vertex&#8217;s name if the module is a
singleton.</li>
</ul>
<p>EXAMPLES:</p>
<p>The Bull Graph is prime:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">BullGraph</span><span class="p">()</span><span class="o">.</span><span class="n">modular_decomposition</span><span class="p">()</span> <span class="c1"># optional -- modular_decomposition</span>
<span class="go">(&#39;Prime&#39;, [3, 4, 0, 1, 2])</span>
</pre></div>
</div>
<p>The Petersen Graph too:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">modular_decomposition</span><span class="p">()</span> <span class="c1"># optional -- modular_decomposition</span>
<span class="go">(&#39;Prime&#39;, [2, 6, 3, 9, 7, 8, 0, 1, 5, 4])</span>
</pre></div>
</div>
<p>This a clique on 5 vertices with 2 pendant edges, though, has a more
interesting decomposition</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">modular_decomposition</span><span class="p">()</span> <span class="c1"># optional -- modular_decomposition</span>
<span class="go">(&#39;Serie&#39;, [0, (&#39;Parallel&#39;, [5, (&#39;Serie&#39;, [1, 4, 3, 2]), 6])])</span>
</pre></div>
</div>
<p>ALGORITHM:</p>
<p>This function uses a C implementation of a 2-step algorithm
implemented by Fabien de Montgolfier <a class="reference internal" href="#fmdec" id="id40">[FMDec]</a> :</p>
<blockquote>
<div><ul class="simple">
<li>Computation of a factorizing permutation <a class="reference internal" href="#habibviennot1999" id="id41">[HabibViennot1999]</a>.</li>
<li>Computation of the tree itself <a class="reference internal" href="#caphabmont02" id="id42">[CapHabMont02]</a>.</li>
</ul>
</div></blockquote>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_prime" title="sage.graphs.graph.Graph.is_prime"><tt class="xref py py-meth docutils literal"><span class="pre">is_prime()</span></tt></a> &#8211; Tests whether a graph is prime.</li>
</ul>
</div>
<p>REFERENCE:</p>
<table class="docutils citation" frame="void" id="fmdec" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id40">[FMDec]</a></td><td>Fabien de Montgolfier
<a class="reference external" href="http://www.liafa.jussieu.fr/~fm/algos/index.html">http://www.liafa.jussieu.fr/~fm/algos/index.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="habibviennot1999" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id41">[HabibViennot1999]</a></td><td>Michel Habib, Christiphe Paul, Laurent Viennot
Partition refinement techniques: An interesting algorithmic tool kit
International Journal of Foundations of Computer Science
vol. 10 n2 pp.147&#8211;170, 1999</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="caphabmont02" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id42">[CapHabMont02]</a></td><td>C. Capelle, M. Habib et F. de Montgolfier
Graph decomposition and Factorising Permutations
Discrete Mathematics and Theoretical Computer Sciences, vol 5 no. 1 , 2002.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="habpau10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id39">[HabPau10]</a></td><td>Michel Habib and Christophe Paul
A survey of the algorithmic aspects of modular decomposition
Computer Science Review
vol 4, number 1, pages 41&#8211;59, 2010
<a class="reference external" href="http://www.lirmm.fr/~paul/md-survey.pdf">http://www.lirmm.fr/~paul/md-survey.pdf</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.odd_girth">
<tt class="descname">odd_girth</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.odd_girth" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the odd girth of self.</p>
<p>The odd girth of a graph is defined as the smallest cycle of odd length.</p>
<p>OUTPUT:</p>
<p>The odd girth of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<p>The McGee graph has girth 7 and therefore its odd girth is 7 as well.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">McGeeGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">odd_girth</span><span class="p">()</span>
<span class="go">7</span>
</pre></div>
</div>
<p>Any complete graph on more than 2 vertices contains a triangle and has
thus odd girth 3.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">odd_girth</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Every bipartite graph has no odd cycles and consequently odd girth of
infinity.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">odd_girth</span><span class="p">()</span>
<span class="go">+Infinity</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.girth" title="sage.graphs.generic_graph.GenericGraph.girth"><tt class="xref py py-meth docutils literal"><span class="pre">girth()</span></tt></a> &#8211; computes
the girth of a graph.</li>
</ul>
</div>
<p>REFERENCES:</p>
<p>The property relating the odd girth to the coefficients of the
characteristic polynomial is an old result from algebraic graph theory
see</p>
<table class="docutils citation" frame="void" id="har62" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Har62]</td><td>Harary, F (1962). The determinant of the adjacency matrix of
a graph, SIAM Review 4, 202-210</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="biggs93" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Biggs93]</td><td>Biggs, N. L. Algebraic Graph Theory, 2nd ed. Cambridge,
England: Cambridge University Press, pp. 45, 1993.</td></tr>
</tbody>
</table>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">odd_girth</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span><span class="o">.</span><span class="n">odd_girth</span><span class="p">()</span>
<span class="go">11</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.perfect_matchings">
<tt class="descname">perfect_matchings</tt><big>(</big><em>labels=False</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.perfect_matchings" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an interator over all perfect matchings of the graph.</p>
<p>ALGORITHM:</p>
<p>Choose a vertex <span class="math">\(v\)</span>, then recurse through all edges incident to <span class="math">\(v\)</span>,
removing one edge at a time whenever an edge is added to a matching.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">labels</span></tt> &#8211; boolean (default: <tt class="docutils literal"><span class="pre">False</span></tt>); when <tt class="docutils literal"><span class="pre">True</span></tt>, the
edges in each perfect matching are triples (containing the label
as the third element), otherwise the edges are pairs</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.graphs.graph.Graph.matching" title="sage.graphs.graph.Graph.matching"><tt class="xref py py-meth docutils literal"><span class="pre">matching()</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">GridGraph</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">perfect_matchings</span><span class="p">())</span>
<span class="go">[[((0, 0), (0, 1)), ((0, 2), (1, 2)), ((1, 0), (1, 1))],</span>
<span class="go"> [((0, 1), (0, 2)), ((1, 1), (1, 2)), ((0, 0), (1, 0))],</span>
<span class="go"> [((0, 1), (1, 1)), ((0, 2), (1, 2)), ((0, 0), (1, 0))]]</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">perfect_matchings</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="go">[[(0, 1, None), (2, 3, None)],</span>
<span class="go"> [(0, 2, None), (1, 3, None)],</span>
<span class="go"> [(0, 3, None), (1, 2, None)]]</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">perfect_matchings</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="go">[[(-2, 1, &#39;x&#39;), (-1, 2, &#39;y&#39;)],</span>
<span class="go"> [(-1, 1, &#39;a&#39;), (-2, 2, &#39;b&#39;)]]</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">mpc</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">matching_polynomial</span><span class="p">()</span><span class="o">.</span><span class="n">coefficients</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">perfect_matchings</span><span class="p">()))</span> <span class="o">==</span> <span class="n">mpc</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">immutable</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">perfect_matchings</span><span class="p">())</span>
<span class="go">[[(0, 1), (2, 3), (4, 9), (6, 8), (5, 7)],</span>
<span class="go"> [(0, 1), (2, 7), (3, 4), (5, 8), (6, 9)],</span>
<span class="go"> [(0, 4), (1, 2), (3, 8), (6, 9), (5, 7)],</span>
<span class="go"> [(0, 4), (1, 6), (2, 3), (5, 8), (7, 9)],</span>
<span class="go"> [(0, 5), (1, 2), (3, 4), (6, 8), (7, 9)],</span>
<span class="go"> [(0, 5), (1, 6), (2, 7), (3, 8), (4, 9)]]</span>

<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">perfect_matchings</span><span class="p">())</span>
<span class="go">[[]]</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">perfect_matchings</span><span class="p">())</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.random_spanning_tree">
<tt class="descname">random_spanning_tree</tt><big>(</big><em>output_as_graph=False</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.random_spanning_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a random spanning tree of the graph.</p>
<p>This uses the Aldous-Broder algorithm (<a class="reference internal" href="spanning_tree.html#broder89" id="id43">[Broder89]</a>, <a class="reference internal" href="spanning_tree.html#aldous90" id="id44">[Aldous90]</a>)
to generate a random spanning tree with the uniform distribution,
as follows.</p>
<p>Start from any vertex. Perform a random walk by choosing at every
step one neighbor uniformly at random. Every time a new vertex <span class="math">\(j\)</span>
is met, add the edge <span class="math">\((i, j)\)</span> to the spanning tree, where <span class="math">\(i\)</span> is
the previous vertex in the random walk.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">output_as_graph</span></tt> &#8211; boolean (default: <tt class="docutils literal"><span class="pre">False</span></tt>) whether to return a
list of edges or a graph.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.spanning_trees_count" title="sage.graphs.generic_graph.GenericGraph.spanning_trees_count"><tt class="xref py py-meth docutils literal"><span class="pre">spanning_trees_count()</span></tt></a>
and <a class="reference internal" href="#sage.graphs.graph.Graph.spanning_trees" title="sage.graphs.graph.Graph.spanning_trees"><tt class="xref py py-meth docutils literal"><span class="pre">spanning_trees()</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">TietzeGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">random_spanning_tree</span><span class="p">(</span><span class="n">output_as_graph</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Graph on 12 vertices</span>
<span class="gp">sage: </span><span class="n">rg</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">random_spanning_tree</span><span class="p">();</span> <span class="n">rg</span> <span class="c1"># random</span>
<span class="go">[(0, 9),</span>
<span class="go">(9, 11),</span>
<span class="go">(0, 8),</span>
<span class="go">(8, 7),</span>
<span class="go">(7, 6),</span>
<span class="go">(7, 2),</span>
<span class="go">(2, 1),</span>
<span class="go">(1, 5),</span>
<span class="go">(9, 10),</span>
<span class="go">(5, 4),</span>
<span class="go">(2, 3)]</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">rg</span><span class="p">)</span><span class="o">.</span><span class="n">is_tree</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A visual example for the grid graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pos</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">get_pos</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">random_spanning_tree</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">set_pos</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">vertex_labels</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">random_spanning_tree</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">works only for non-empty connected graphs</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">random_spanning_tree</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">works only for non-empty connected graphs</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.rank_decomposition">
<tt class="descname">rank_decomposition</tt><big>(</big><em>G</em>, <em>verbose=False</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.rank_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes an optimal rank-decomposition of the given graph.</p>
<p>This function is available as a method of the <a class="reference internal" href="#module-sage.graphs.graph" title="sage.graphs.graph"><tt class="xref py py-class docutils literal"><span class="pre">Graph</span></tt></a> class. See <a class="reference internal" href="#sage.graphs.graph.Graph.rank_decomposition" title="sage.graphs.graph.Graph.rank_decomposition"><tt class="xref py py-meth docutils literal"><span class="pre">rank_decomposition</span></tt></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">verbose</span></tt> (boolean) &#8211; whether to display progress information while
computing the decomposition.</li>
</ul>
<p>OUTPUT:</p>
<p>A pair <tt class="docutils literal"><span class="pre">(rankwidth,</span> <span class="pre">decomposition_tree)</span></tt>, where <tt class="docutils literal"><span class="pre">rankwidth</span></tt> is a
numerical value and <tt class="docutils literal"><span class="pre">decomposition_tree</span></tt> is a ternary tree describing the
decomposition (cf. the module&#8217;s documentation).</p>
<p>EXAMPLE:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions.rankwidth</span> <span class="kn">import</span> <span class="n">rank_decomposition</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">rank_decomposition</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">(3, Graph on 19 vertices)</span>
</pre></div>
</div>
<p>On more than 32 vertices:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">rank_decomposition</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">RuntimeError</span>: <span class="n">the rank decomposition cannot be computed on graphs of &gt;= 32 vertices</span>
</pre></div>
</div>
<p>The empty graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">rank_decomposition</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">(0, Graph on 0 vertices)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.seidel_adjacency_matrix">
<tt class="descname">seidel_adjacency_matrix</tt><big>(</big><em>vertices=None</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.seidel_adjacency_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Seidel adjacency matrix of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>Returns <span class="math">\(J-I-2A\)</span>, for <span class="math">\(A\)</span> the (ordinary)
<tt class="xref py py-meth docutils literal"><span class="pre">adjacency</span> <span class="pre">matrix</span></tt> of <tt class="docutils literal"><span class="pre">self</span></tt>,
<span class="math">\(I\)</span> the identity matrix, and <span class="math">\(J\)</span> the all-1 matrix.
It is closely related to <a class="reference internal" href="#sage.graphs.graph.Graph.twograph" title="sage.graphs.graph.Graph.twograph"><tt class="xref py py-meth docutils literal"><span class="pre">twograph()</span></tt></a>.</p>
<p>The matrix returned is over the integers. If a different ring is
desired, use either <a class="reference external" href="../../../matrices/sage/matrix/matrix0.html#sage.matrix.matrix0.Matrix.change_ring" title="(in Sage Reference Manual: Matrices and Spaces of Matrices v7.1)"><tt class="xref py py-meth docutils literal"><span class="pre">sage.matrix.matrix0.Matrix.change_ring()</span></tt></a>
method or <tt class="xref py py-func docutils literal"><span class="pre">matrix()</span></tt> function.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">vertices</span></tt> (list) &#8211; the ordering of the vertices defining how they
should appear in the matrix. By default, the ordering given by
<tt class="xref py py-meth docutils literal"><span class="pre">GenericGraph.vertices()</span></tt> is used.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">seidel_adjacency_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">minpoly</span><span class="p">()</span>
<span class="go">x^2 - 5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.seidel_switching">
<tt class="descname">seidel_switching</tt><big>(</big><em>s</em>, <em>inplace=True</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.seidel_switching" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Seidel switching of <tt class="docutils literal"><span class="pre">self</span></tt> w.r.t. subset of vertices <tt class="docutils literal"><span class="pre">s</span></tt>.</p>
<p>Returns the graph obtained by Seidel switching of <tt class="docutils literal"><span class="pre">self</span></tt>
with respect to the subset of vertices <tt class="docutils literal"><span class="pre">s</span></tt>. This is the graph
given by Seidel adjacency matrix <span class="math">\(DSD\)</span>, for <span class="math">\(S\)</span> the Seidel
adjacency matrix of <tt class="docutils literal"><span class="pre">self</span></tt>, and <span class="math">\(D\)</span> the diagonal matrix with -1s
at positions corresponding to <tt class="docutils literal"><span class="pre">s</span></tt>, and 1s elsewhere.</p>
<p>INPUT:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">s</span></tt> &#8211; a list of vertices of <tt class="docutils literal"><span class="pre">self</span></tt></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">inplace</span></tt> (boolean) &#8211; whether to do the modification inplace, or to
return a copy of the graph after switching.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">seidel_switching</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">seidel_adjacency_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">minpoly</span><span class="p">()</span>
<span class="go">x^2 - 5</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">seidel_switching</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">seidel_switching</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">==</span> <span class="n">H</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.spanning_trees">
<tt class="descname">spanning_trees</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.spanning_trees" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of all spanning trees.</p>
<p>If the graph is disconnected, returns the empty list.</p>
<p>Uses the Read-Tarjan backtracking algorithm <a class="reference internal" href="#rt75" id="id45">[RT75]</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)],</span><span class="n">multiedges</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">spanning_trees</span><span class="p">())</span>
<span class="go">8</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">spanning_trees_count</span><span class="p">()</span>
<span class="go">8</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">)],</span><span class="n">multiedges</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">spanning_trees</span><span class="p">())</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">spanning_trees_count</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.spanning_trees_count" title="sage.graphs.generic_graph.GenericGraph.spanning_trees_count"><tt class="xref py py-meth docutils literal"><span class="pre">spanning_trees_count()</span></tt></a>
&#8211; counts the number of spanning trees.</li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.random_spanning_tree" title="sage.graphs.graph.Graph.random_spanning_tree"><tt class="xref py py-meth docutils literal"><span class="pre">random_spanning_tree()</span></tt></a>
&#8211; returns a random spanning tree.</li>
</ul>
</div>
<p>TESTS:</p>
<p>Works with looped graphs:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="n">i</span><span class="p">:[</span><span class="n">i</span><span class="p">,(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">6</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">spanning_trees</span><span class="p">()</span>
<span class="go">[Graph on 6 vertices,</span>
<span class="go"> Graph on 6 vertices,</span>
<span class="go"> Graph on 6 vertices,</span>
<span class="go"> Graph on 6 vertices,</span>
<span class="go"> Graph on 6 vertices,</span>
<span class="go"> Graph on 6 vertices]</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="rt75" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id45">[RT75]</a></td><td>Read, R. C. and Tarjan, R. E.
Bounds on Backtrack Algoritms for Listing Cycles, Paths, and Spanning Trees
Networks, Volume 5 (1975), numer 3, pages 237-252.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.sparse6_string">
<tt class="descname">sparse6_string</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.sparse6_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sparse6 representation of the graph as an ASCII string.
Only valid for undirected graphs on 0 to 262143 vertices, but loops
and multiple edges are permitted.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As the sparse6 format only handles graphs whose vertex set is
<span class="math">\(\{0,...,n-1\}\)</span>, a <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.relabel" title="sage.graphs.generic_graph.GenericGraph.relabel"><tt class="xref py py-meth docutils literal"><span class="pre">relabelled</span> <span class="pre">copy</span></tt></a> of your graph will
be encoded if necessary.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">BullGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">sparse6_string</span><span class="p">()</span>
<span class="go">&#39;:Da@en&#39;</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">sparse6_string</span><span class="p">()</span>
<span class="go">&#39;:?&#39;</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">loops</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">multiedges</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">data_structure</span><span class="o">=</span><span class="s2">&quot;sparse&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;:?&#39;</span><span class="p">,</span><span class="n">data_structure</span><span class="o">=</span><span class="s2">&quot;sparse&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">G</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TEST:</p>
<p>Check that <a class="reference external" href="http://trac.sagemath.org/18445">trac ticket #18445</a> is fixed:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">KneserGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sparse6_string</span><span class="p">())</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">15</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.strong_orientation">
<tt class="descname">strong_orientation</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.strong_orientation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a strongly connected orientation of the current graph.</p>
<p>An orientation of an undirected graph is a digraph obtained by giving an
unique direction to each of its edges. An orientation is said to be
strong if there is a directed path between each pair of vertices.  See
also the <a class="reference external" href="https://en.wikipedia.org/wiki/Strongly_connected_component">Wikipedia article Strongly_connected_component</a>.</p>
<p>If the graph is 2-edge-connected, a strongly connected orientation
can be found in linear time. If the given graph is not 2-connected,
the orientation returned will ensure that each 2-connected component
has a strongly connected orientation.</p>
<p>OUTPUT:</p>
<p>A digraph representing an orientation of the current graph.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>This method assumes the graph is connected.</li>
<li>This algorithm works in O(m).</li>
</ul>
</div>
<p>EXAMPLE:</p>
<p>For a 2-regular graph, a strong orientation gives to each vertex
an out-degree equal to 1:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">strong_orientation</span><span class="p">()</span><span class="o">.</span><span class="n">out_degree</span><span class="p">()</span>
<span class="go">[1, 1, 1, 1, 1]</span>
</pre></div>
</div>
<p>The Petersen Graph is 2-edge connected. It then has a strongly
connected orientation:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">strong_orientation</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">strongly_connected_components</span><span class="p">())</span>
<span class="go">1</span>
</pre></div>
</div>
<p>The same goes for the CubeGraph in any dimension</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">strong_orientation</span><span class="p">()</span><span class="o">.</span><span class="n">strongly_connected_components</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A multigraph also has a strong orientation</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span><span class="n">multiedges</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">strong_orientation</span><span class="p">()</span>
<span class="go">Multi-digraph on 2 vertices</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.to_directed">
<tt class="descname">to_directed</tt><big>(</big><em>implementation='c_graph'</em>, <em>data_structure=None</em>, <em>sparse=None</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.to_directed" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a directed version of the graph. A single edge becomes two
edges, one in each direction.</p>
<p>INPUT:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">data_structure</span></tt> &#8211; one of <tt class="docutils literal"><span class="pre">&quot;sparse&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;static_sparse&quot;</span></tt>, or
<tt class="docutils literal"><span class="pre">&quot;dense&quot;</span></tt>. See the documentation of <a class="reference internal" href="#sage.graphs.graph.Graph" title="sage.graphs.graph.Graph"><tt class="xref py py-class docutils literal"><span class="pre">Graph</span></tt></a> or
<a class="reference internal" href="digraph.html#sage.graphs.digraph.DiGraph" title="sage.graphs.digraph.DiGraph"><tt class="xref py py-class docutils literal"><span class="pre">DiGraph</span></tt></a>.</li>
<li><tt class="docutils literal"><span class="pre">sparse</span></tt> (boolean) &#8211; <tt class="docutils literal"><span class="pre">sparse=True</span></tt> is an alias for
<tt class="docutils literal"><span class="pre">data_structure=&quot;sparse&quot;</span></tt>, and <tt class="docutils literal"><span class="pre">sparse=False</span></tt> is an alias for
<tt class="docutils literal"><span class="pre">data_structure=&quot;dense&quot;</span></tt>.</li>
</ul>
</div></blockquote>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
<span class="go">Petersen graph: Digraph on 10 vertices</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Immutable graphs yield immutable graphs:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="n">immutable</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span><span class="o">.</span><span class="n">_backend</span>
<span class="go">&lt;type &#39;sage.graphs.base.static_sparse_backend.StaticSparseBackend&#39;&gt;</span>
</pre></div>
</div>
<p><a class="reference external" href="http://trac.sagemath.org/17005">trac ticket #17005</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]],</span> <span class="n">immutable</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
<span class="go">Digraph on 2 vertices</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.to_partition">
<tt class="descname">to_partition</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.to_partition" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the partition of connected components of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">graphs</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>    <span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">to_partition</span><span class="p">()</span>
<span class="go">doctest:...: DeprecationWarning: Please use G.connected_components_sizes() instead</span>
<span class="go">See http://trac.sagemath.org/17449 for details.</span>
<span class="go">[1, 1, 1]</span>
<span class="go">[2, 1]</span>
<span class="go">[3]</span>
<span class="go">[3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.to_undirected">
<tt class="descname">to_undirected</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.to_undirected" title="Permalink to this definition">¶</a></dt>
<dd><p>Since the graph is already undirected, simply returns a copy of
itself.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">to_undirected</span><span class="p">()</span>
<span class="go">Petersen graph: Graph on 10 vertices</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.topological_minor">
<tt class="descname">topological_minor</tt><big>(</big><em>H</em>, <em>vertices=False</em>, <em>paths=False</em>, <em>solver=None</em>, <em>verbose=0</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.topological_minor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a topological <span class="math">\(H\)</span>-minor from <tt class="docutils literal"><span class="pre">self</span></tt> if one exists.</p>
<p>We say that a graph <span class="math">\(G\)</span> has a topological <span class="math">\(H\)</span>-minor (or that
it has a graph isomorphic to <span class="math">\(H\)</span> as a topological minor), if
<span class="math">\(G\)</span> contains a subdivision of a graph isomorphic to <span class="math">\(H\)</span> (i.e.
obtained from <span class="math">\(H\)</span> through arbitrary subdivision of its edges)
as a subgraph.</p>
<p>For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Minor_(graph_theory)">Wikipedia article Minor_(graph_theory)</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">H</span></tt> &#8211; The topological minor to find in the current graph.</li>
<li><tt class="docutils literal"><span class="pre">solver</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) Specify a Linear Program (LP)
solver to be used. If set to <tt class="docutils literal"><span class="pre">None</span></tt>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-meth docutils literal"><span class="pre">solve</span></tt></a>
of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">MixedIntegerLinearProgram</span></tt></a>.</li>
<li><tt class="docutils literal"><span class="pre">verbose</span></tt> &#8211; integer (default: <tt class="docutils literal"><span class="pre">0</span></tt>). Sets the level of
verbosity. Set to 0 by default, which means quiet.</li>
</ul>
<p>OUTPUT:</p>
<p>The topological <span class="math">\(H\)</span>-minor found is returned as a subgraph <span class="math">\(M\)</span>
of <tt class="docutils literal"><span class="pre">self</span></tt>, such that the vertex <span class="math">\(v\)</span> of <span class="math">\(M\)</span> that represents a
vertex <span class="math">\(h\in H\)</span> has <tt class="docutils literal"><span class="pre">h</span></tt> as a label (see
<a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.get_vertex" title="sage.graphs.generic_graph.GenericGraph.get_vertex"><tt class="xref py py-meth docutils literal"><span class="pre">get_vertex</span></tt></a>
and
<a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.set_vertex" title="sage.graphs.generic_graph.GenericGraph.set_vertex"><tt class="xref py py-meth docutils literal"><span class="pre">set_vertex</span></tt></a>),
and such that every edge of <span class="math">\(M\)</span> has as a label the edge of <span class="math">\(H\)</span>
it (partially) represents.</p>
<p>If no topological minor is found, this method returns
<tt class="docutils literal"><span class="pre">False</span></tt>.</p>
<p>ALGORITHM:</p>
<p>Mixed Integer Linear Programming.</p>
<p>COMPLEXITY:</p>
<p>Theoretically, when <span class="math">\(H\)</span> is fixed, testing for the existence of
a topological <span class="math">\(H\)</span>-minor is polynomial. The known algorithms
are highly exponential in <span class="math">\(H\)</span>, though.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>This function can be expected to be <em>very</em> slow, especially where
the topological minor does not exist.</p>
<p class="last">(CPLEX seems to be <em>much</em> more efficient than GLPK on this kind of
problem)</p>
</div>
<p>EXAMPLES:</p>
<p>Petersen&#8217;s graph has a topological <span class="math">\(K_4\)</span>-minor:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">topological_minor</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">Subgraph of (Petersen graph): Graph on ...</span>
</pre></div>
</div>
<p>And a topological <span class="math">\(K_{3,3}\)</span>-minor:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">topological_minor</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="go">Subgraph of (Petersen graph): Graph on ...</span>
</pre></div>
</div>
<p>And of course, a tree has no topological <span class="math">\(C_3\)</span>-minor:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="o">.</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">edges</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">topological_minor</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.treewidth">
<tt class="descname">treewidth</tt><big>(</big><em>k=None</em>, <em>certificate=False</em>, <em>algorithm=None</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.treewidth" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the tree-width of <span class="math">\(G\)</span> (and provides a decomposition)</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">k</span></tt> (integer) &#8211; the width to be considered. When <tt class="docutils literal"><span class="pre">k</span></tt> is an
integer, the method checks that the graph has treewidth <span class="math">\(\leq k\)</span>. If
<tt class="docutils literal"><span class="pre">k</span></tt> is <tt class="docutils literal"><span class="pre">None</span></tt> (default), the method computes the optimal
tree-width.</li>
<li><tt class="docutils literal"><span class="pre">certificate</span></tt> &#8211; whether to return the tree-decomposition itself.</li>
<li><tt class="docutils literal"><span class="pre">algorithm</span></tt> &#8211; whether to use <tt class="docutils literal"><span class="pre">&quot;sage&quot;</span></tt> or <tt class="docutils literal"><span class="pre">&quot;tdlib&quot;</span></tt> (requires
the installation of the &#8216;tdlib&#8217; package). The default behaviour is to
use &#8216;tdlib&#8217; if it is available, and Sage&#8217;s own algorithm when it is
not.</li>
</ul>
<p>OUTPUT:</p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">g.treewidth()</span></tt> returns the treewidth of <tt class="docutils literal"><span class="pre">g</span></tt>. When <tt class="docutils literal"><span class="pre">k</span></tt> is</dt>
<dd>specified, it returns <tt class="docutils literal"><span class="pre">False</span></tt> when no tree-decomposition of width
<span class="math">\(\leq k\)</span> exists or <tt class="docutils literal"><span class="pre">True</span></tt> otherwise. When <tt class="docutils literal"><span class="pre">certificate=True</span></tt>,
the tree-decomposition is also returned.</dd>
</dl>
</div></blockquote>
<p>ALGORITHM:</p>
<blockquote>
<div><p>This function virtually explores the graph of all pairs
<tt class="docutils literal"><span class="pre">(vertex_cut,cc)</span></tt>, where <tt class="docutils literal"><span class="pre">vertex_cut</span></tt> is a vertex cut of the
graph of cardinality <span class="math">\(\leq k+1\)</span>, and <tt class="docutils literal"><span class="pre">connected_component</span></tt> is a
connected component of the graph induced by <tt class="docutils literal"><span class="pre">G-vertex_cut</span></tt>.</p>
<p>We deduce that the pair <tt class="docutils literal"><span class="pre">(vertex_cut,cc)</span></tt> is feasible with
tree-width <span class="math">\(k\)</span> if <tt class="docutils literal"><span class="pre">cc</span></tt> is empty, or if a vertex <tt class="docutils literal"><span class="pre">v</span></tt> from
<tt class="docutils literal"><span class="pre">vertex_cut</span></tt> can be replaced with a vertex from <tt class="docutils literal"><span class="pre">cc</span></tt>, such that
the pair <tt class="docutils literal"><span class="pre">(vertex_cut+v,cc-v)</span></tt> is feasible.</p>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The implementation would be much faster if <tt class="docutils literal"><span class="pre">cc</span></tt>, the argument of the
recursive function, was a bitset. It would also be very nice to not copy
the graph in order to compute connected components, for this is really a
waste of time.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="graph_decompositions/vertex_separation.html#sage.graphs.graph_decompositions.vertex_separation.path_decomposition" title="sage.graphs.graph_decompositions.vertex_separation.path_decomposition"><tt class="xref py py-meth docutils literal"><span class="pre">path_decomposition()</span></tt></a>
computes the pathwidth of a graph. See also the
<a class="reference internal" href="graph_decompositions/vertex_separation.html#module-sage.graphs.graph_decompositions.vertex_separation" title="sage.graphs.graph_decompositions.vertex_separation"><tt class="xref py py-mod docutils literal"><span class="pre">vertex_separation</span></tt></a> module.</p>
</div>
<p>EXAMPLES:</p>
<p>The PetersenGraph has treewidth 4:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">treewidth</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">treewidth</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Tree decomposition: Graph on 6 vertices</span>
</pre></div>
</div>
<p>The treewidth of a 2d grid is its smallest side:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">treewidth</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">treewidth</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">treewidth</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">treewidth</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">treewidth</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Tree decomposition: Graph on 4 vertices</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">treewidth</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">treewidth</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">treewidth</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">treewidth</span><span class="p">()</span>
<span class="go">-1</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">treewidth</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">treewidth</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">treewidth</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">is_tree</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">treewidth</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">treewidth</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Tree decomposition: Graph on 6 vertices</span>
</pre></div>
</div>
<p>All edges do appear (<a class="reference external" href="http://trac.sagemath.org/17893">trac ticket #17893</a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">td</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">treewidth</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">bag</span> <span class="ow">in</span> <span class="n">td</span><span class="p">:</span>
<span class="go">....:    g.delete_edges(list(combinations(bag,2)))</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<p><a class="reference external" href="http://trac.sagemath.org/19358">trac ticket #19358</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="go">....:     for j in range(2):</span>
<span class="go">....:         g.add_path([i,(i,j),(i+1)%3])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">treewidth</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Trivially true:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">treewidth</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">35</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">treewidth</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">35</span><span class="p">,</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Tree decomposition: Graph on 1 vertex</span>
</pre></div>
</div>
<p>Bad input:</p>
<blockquote>
<div>sage: graphs.PetersenGraph().treewidth(k=-3)
Traceback (most recent call last):
...
ValueError: k(=-3) must be a nonnegative integer</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.tutte_polynomial">
<tt class="descname">tutte_polynomial</tt><big>(</big><em>G</em>, <em>edge_selector=None</em>, <em>cache=None</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.tutte_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Tutte polynomial of the graph <span class="math">\(G\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">edge_selector</span></tt> (optional; method) this argument allows the user
to specify his own heuristic for selecting edges used in the deletion
contraction recurrence</li>
<li><tt class="docutils literal"><span class="pre">cache</span></tt> &#8211; (optional; dict) a dictionary to cache the Tutte
polynomials generated in the recursive process.  One will be
created automatically if not provided.</li>
</ul>
<p>EXAMPLES:</p>
<p>The Tutte polynomial of any tree of order <span class="math">\(n\)</span> is <span class="math">\(x^{n-1}\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">tutte_polynomial</span><span class="p">()</span> <span class="o">==</span> <span class="n">x</span><span class="o">**</span><span class="mi">9</span> <span class="k">for</span> <span class="n">T</span> <span class="ow">in</span> <span class="n">graphs</span><span class="o">.</span><span class="n">trees</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Tutte polynomial of the Petersen graph is:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">tutte_polynomial</span><span class="p">()</span>
<span class="go">x^9 + 6*x^8 + 21*x^7 + 56*x^6 + 12*x^5*y + y^6 + 114*x^5 + 70*x^4*y</span>
<span class="go">+ 30*x^3*y^2 + 15*x^2*y^3 + 10*x*y^4 + 9*y^5 + 170*x^4 + 170*x^3*y</span>
<span class="go">+ 105*x^2*y^2 + 65*x*y^3 + 35*y^4 + 180*x^3 + 240*x^2*y + 171*x*y^2</span>
<span class="go">+ 75*y^3 + 120*x^2 + 168*x*y + 84*y^2 + 36*x + 36*y</span>
</pre></div>
</div>
<p>The Tutte polynomial of <span class="math">\(G\)</span> evaluated at (1,1) is the number of
spanning trees of <span class="math">\(G\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mf">0.6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">tutte_polynomial</span><span class="p">()(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">G</span><span class="o">.</span><span class="n">spanning_trees_count</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Given that <span class="math">\(T(x,y)\)</span> is the Tutte polynomial of a graph <span class="math">\(G\)</span> with
<span class="math">\(n\)</span> vertices and <span class="math">\(c\)</span> connected components, then <span class="math">\((-1)^{n-c} x^k
T(1-x,0)\)</span> is the chromatic polynomial of <span class="math">\(G\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">OctahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">tutte_polynomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">^</span><span class="mi">5</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">T</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">(x - 2) * (x - 1) * x * (x^3 - 9*x^2 + 29*x - 32)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">(x - 2) * (x - 1) * x * (x^3 - 9*x^2 + 29*x - 32)</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Providing an external cache:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
<span class="gp">sage: </span><span class="n">_</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">tutte_polynomial</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="n">cache</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Verify that #18366 is fixed:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">multiedges</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">)]);</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">tutte_polynomial</span><span class="p">()(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">52</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">spanning_trees_count</span><span class="p">()</span>
<span class="go">52</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.two_factor_petersen">
<tt class="descname">two_factor_petersen</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.two_factor_petersen" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a decomposition of the graph into 2-factors.</p>
<p>Petersen&#8217;s 2-factor decomposition theorem asserts that any
<span class="math">\(2r\)</span>-regular graph <span class="math">\(G\)</span> can be decomposed into 2-factors.
Equivalently, it means that the edges of any <span class="math">\(2r\)</span>-regular
graphs can be partitionned in <span class="math">\(r\)</span> sets <span class="math">\(C_1,\dots,C_r\)</span> such
that for all <span class="math">\(i\)</span>, the set <span class="math">\(C_i\)</span> is a disjoint union of cycles
( a 2-regular graph ).</p>
<p>As any graph of maximal degree <span class="math">\(\Delta\)</span> can be completed into
a regular graph of degree <span class="math">\(2\lceil\frac\Delta 2\rceil\)</span>, this
result also means that the edges of any graph of degree <span class="math">\(\Delta\)</span>
can be partitionned in <span class="math">\(r=2\lceil\frac\Delta 2\rceil\)</span> sets
<span class="math">\(C_1,\dots,C_r\)</span> such that for all <span class="math">\(i\)</span>, the set <span class="math">\(C_i\)</span> is a
graph of maximal degree <span class="math">\(2\)</span> ( a disjoint union of paths
and cycles ).</p>
<p>EXAMPLE:</p>
<p>The Complete Graph on <span class="math">\(7\)</span> vertices is a <span class="math">\(6\)</span>-regular graph, so it can
be edge-partitionned into <span class="math">\(2\)</span>-regular graphs:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">classes</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">two_factor_petersen</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">classes</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">gg</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">gg</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="nb">max</span><span class="p">(</span><span class="n">gg</span><span class="o">.</span><span class="n">degree</span><span class="p">())</span><span class="o">&lt;=</span><span class="mi">2</span>
<span class="go">True</span>
<span class="go">True</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Set</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">classes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">classes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">classes</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CirculantGraph</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">cl</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">two_factor_petersen</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">edge_colors</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;black&#39;</span><span class="p">:</span><span class="n">cl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;red&#39;</span><span class="p">:</span><span class="n">cl</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
<span class="go">Graphics object consisting of 73 graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.twograph">
<tt class="descname">twograph</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.twograph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the two-graph of <tt class="docutils literal"><span class="pre">self</span></tt></p>
<p>Returns the <a class="reference external" href="../../../combinat/sage/combinat/designs/twographs.html#sage.combinat.designs.twographs.TwoGraph" title="(in Sage Reference Manual: Combinatorics v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">two-graph</span></tt></a>
with the triples
<span class="math">\(T=\{t \in \binom {V}{3} : \left| \binom {t}{2} \cap E \right| \text{odd} \}\)</span>
where <span class="math">\(V\)</span> and <span class="math">\(E\)</span> are vertices and edges of <tt class="docutils literal"><span class="pre">self</span></tt>, respectively.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">twograph</span><span class="p">()</span>
<span class="go">Incidence structure with 10 points and 60 blocks</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">chang_graphs</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T8</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">line_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">T8</span><span class="o">.</span><span class="n">seidel_switching</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="bp">None</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="bp">None</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="bp">None</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="bp">None</span><span class="p">)],</span><span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T8</span><span class="o">.</span><span class="n">twograph</span><span class="p">()</span><span class="o">==</span><span class="n">C</span><span class="o">.</span><span class="n">twograph</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">T8</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.designs.twographs</span> <span class="kn">import</span> <span class="n">TwoGraph</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">twograph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">TwoGraph</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Incidence structure with 10 points and 60 blocks</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="../../../combinat/sage/combinat/designs/twographs.html#sage.combinat.designs.twographs.TwoGraph.descendant" title="(in Sage Reference Manual: Combinatorics v7.1)"><tt class="xref py py-meth docutils literal"><span class="pre">descendant()</span></tt></a>
&#8211; computes the descendant graph of the two-graph of self at a vertex</li>
<li><a class="reference external" href="../../../combinat/sage/combinat/designs/twographs.html#sage.combinat.designs.twographs.twograph_descendant" title="(in Sage Reference Manual: Combinatorics v7.1)"><tt class="xref py py-func docutils literal"><span class="pre">twograph_descendant()</span></tt></a>
&#8211; ditto, but much faster.</li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.vertex_cover">
<tt class="descname">vertex_cover</tt><big>(</big><em>algorithm='Cliquer'</em>, <em>value_only=False</em>, <em>reduction_rules=True</em>, <em>solver=None</em>, <em>verbosity=0</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.vertex_cover" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a minimum vertex cover of self represented by a set of vertices.</p>
<p>A minimum vertex cover of a graph is a set <span class="math">\(S\)</span> of vertices such that
each edge is incident to at least one element of <span class="math">\(S\)</span>, and such that <span class="math">\(S\)</span>
is of minimum cardinality. For more information, see the
<a class="reference external" href="https://en.wikipedia.org/wiki/Vertex_cover">Wikipedia article on vertex cover</a>.</p>
<p>Equivalently, a vertex cover is defined as the complement of an
independent set.</p>
<p>As an optimization problem, it can be expressed as follows:</p>
<div class="math">
\[\begin{split}\mbox{Minimize : }&amp;\sum_{v\in G} b_v\\
\mbox{Such that : }&amp;\forall (u,v) \in G.edges(), b_u+b_v\geq 1\\
&amp;\forall x\in G, b_x\mbox{ is a binary variable}\end{split}\]</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">algorithm</span></tt> &#8211; string (default: <tt class="docutils literal"><span class="pre">&quot;Cliquer&quot;</span></tt>). Indicating
which algorithm to use. It can be one of those two values.<ul>
<li><tt class="docutils literal"><span class="pre">&quot;Cliquer&quot;</span></tt> will compute a minimum vertex cover
using the Cliquer package.</li>
<li><tt class="docutils literal"><span class="pre">&quot;MILP&quot;</span></tt> will compute a minimum vertex cover through a mixed
integer linear program.</li>
<li>If <tt class="docutils literal"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;mcqd&quot;</span></tt> - Uses the MCQD solver
(<a class="reference external" href="http://www.sicmm.org/~konc/maxclique/">http://www.sicmm.org/~konc/maxclique/</a>). Note that the MCQD
package must be installed.</li>
</ul>
</li>
<li><tt class="docutils literal"><span class="pre">value_only</span></tt> &#8211; boolean (default: <tt class="docutils literal"><span class="pre">False</span></tt>). If set to <tt class="docutils literal"><span class="pre">True</span></tt>,
only the size of a minimum vertex cover is returned. Otherwise,
a minimum vertex cover is returned as a list of vertices.</li>
<li><tt class="docutils literal"><span class="pre">reduction_rules</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">True</span></tt>) Specify if the reductions
rules from kernelization must be applied as pre-processing or not.
See <a class="reference internal" href="#acflss04" id="id47">[ACFLSS04]</a> for more details. Note that depending on the
instance, it might be faster to disable reduction rules.</li>
<li><tt class="docutils literal"><span class="pre">solver</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) Specify a Linear Program (LP)
solver to be used. If set to <tt class="docutils literal"><span class="pre">None</span></tt>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-meth docutils literal"><span class="pre">solve</span></tt></a>
of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">MixedIntegerLinearProgram</span></tt></a>.</li>
<li><tt class="docutils literal"><span class="pre">verbosity</span></tt> &#8211; non-negative integer (default: <tt class="docutils literal"><span class="pre">0</span></tt>). Set the level
of verbosity you want from the linear program solver. Since the
problem of computing a vertex cover is <span class="math">\(NP\)</span>-complete, its solving may
take some time depending on the graph. A value of 0 means that there
will be no message printed by the solver. This option is only useful
if <tt class="docutils literal"><span class="pre">algorithm=&quot;MILP&quot;</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<p>On the Pappus graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PappusGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">vertex_cover</span><span class="p">(</span><span class="n">value_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">9</span>
</pre></div>
</div>
<div class="figure">
<img alt="../../_images/graph-4.png" src="../../_images/graph-4.png" />
</div>
<p>TESTS:</p>
<p>The two algorithms should return the same result:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">vc1</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex_cover</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;MILP&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">vc2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex_cover</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Cliquer&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">vc1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">vc2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The cardinality of the vertex cover is unchanged when reduction rules are used. First for trees:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">):</span>
<span class="gp">... </span>      <span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomTree</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">... </span>      <span class="n">vc1_set</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex_cover</span><span class="p">()</span>
<span class="gp">... </span>      <span class="n">vc1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vc1_set</span><span class="p">)</span>
<span class="gp">... </span>      <span class="n">vc2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex_cover</span><span class="p">(</span><span class="n">value_only</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">reduction_rules</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">... </span>      <span class="k">if</span> <span class="n">vc1</span> <span class="o">!=</span> <span class="n">vc2</span><span class="p">:</span>
<span class="gp">... </span>          <span class="k">print</span> <span class="s2">&quot;Error :&quot;</span><span class="p">,</span> <span class="n">vc1</span><span class="p">,</span> <span class="n">vc2</span>
<span class="gp">... </span>          <span class="k">print</span> <span class="s2">&quot;With reduction rules :&quot;</span><span class="p">,</span> <span class="n">vc1</span>
<span class="gp">... </span>          <span class="k">print</span> <span class="s2">&quot;Without reduction rules :&quot;</span><span class="p">,</span> <span class="n">vc2</span>
<span class="gp">... </span>          <span class="k">break</span>
<span class="gp">... </span>      <span class="n">g</span><span class="o">.</span><span class="n">delete_vertices</span><span class="p">(</span><span class="n">vc1_set</span><span class="p">)</span>
<span class="gp">... </span>      <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>          <span class="k">print</span> <span class="s2">&quot;This thing is not a vertex cover !&quot;</span>
</pre></div>
</div>
<p>Then for random GNP graphs:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">):</span>
<span class="gp">... </span>      <span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">4</span><span class="o">/</span><span class="mi">50</span><span class="p">)</span>
<span class="gp">... </span>      <span class="n">vc1_set</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex_cover</span><span class="p">()</span>
<span class="gp">... </span>      <span class="n">vc1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vc1_set</span><span class="p">)</span>
<span class="gp">... </span>      <span class="n">vc2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex_cover</span><span class="p">(</span><span class="n">value_only</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">reduction_rules</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">... </span>      <span class="k">if</span> <span class="n">vc1</span> <span class="o">!=</span> <span class="n">vc2</span><span class="p">:</span>
<span class="gp">... </span>          <span class="k">print</span> <span class="s2">&quot;Error :&quot;</span><span class="p">,</span> <span class="n">vc1</span><span class="p">,</span> <span class="n">vc2</span>
<span class="gp">... </span>          <span class="k">print</span> <span class="s2">&quot;With reduction rules :&quot;</span><span class="p">,</span> <span class="n">vc1</span>
<span class="gp">... </span>          <span class="k">print</span> <span class="s2">&quot;Without reduction rules :&quot;</span><span class="p">,</span> <span class="n">vc2</span>
<span class="gp">... </span>          <span class="k">break</span>
<span class="gp">... </span>      <span class="n">g</span><span class="o">.</span><span class="n">delete_vertices</span><span class="p">(</span><span class="n">vc1_set</span><span class="p">)</span>
<span class="gp">... </span>      <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>          <span class="k">print</span> <span class="s2">&quot;This thing is not a vertex cover !&quot;</span>
</pre></div>
</div>
<p>Testing mcqd:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">vertex_cover</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;mcqd&quot;</span><span class="p">,</span><span class="n">value_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c1"># optional - mcqd</span>
<span class="go">6</span>
</pre></div>
</div>
<p>Given a wrong algorithm:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">vertex_cover</span><span class="p">(</span><span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;guess&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The algorithm must be &quot;Cliquer&quot; &quot;MILP&quot; or &quot;mcqd&quot;.</span>
</pre></div>
</div>
<p>REFERENCE:</p>
<table class="docutils citation" frame="void" id="acflss04" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[ACFLSS04]</td><td><em>(<a class="fn-backref" href="#id24">1</a>, <a class="fn-backref" href="#id47">2</a>)</em> F. N. Abu-Khzam, R. L. Collins, M. R. Fellows, M. A.
Langston, W. H. Suters, and C. T. Symons: Kernelization Algorithm for
the Vertex Cover Problem: Theory and Experiments. <em>SIAM ALENEX/ANALCO</em>
2004: 62-69.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.write_to_eps">
<tt class="descname">write_to_eps</tt><big>(</big><em>filename</em>, <em>**options</em><big>)</big><a class="headerlink" href="#sage.graphs.graph.Graph.write_to_eps" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes a plot of the graph to <tt class="docutils literal"><span class="pre">filename</span></tt> in <tt class="docutils literal"><span class="pre">eps</span></tt> format.</p>
<p>INPUT:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">filename</span></tt> &#8211; a string</li>
<li><tt class="docutils literal"><span class="pre">**options</span></tt> &#8211; same layout options as <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.layout" title="sage.graphs.generic_graph.GenericGraph.layout"><tt class="xref py py-meth docutils literal"><span class="pre">layout()</span></tt></a></li>
</ul>
</div></blockquote>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">write_to_eps</span><span class="p">(</span><span class="n">tmp_filename</span><span class="p">(</span><span class="n">ext</span><span class="o">=</span><span class="s1">&#39;.eps&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>It is relatively simple to include this file in a LaTeX
document.  <tt class="docutils literal"><span class="pre">\usepackage{graphics}</span></tt> must appear in the
preamble, and <tt class="docutils literal"><span class="pre">\includegraphics{filename}</span></tt> will include
the file. To compile the document to <tt class="docutils literal"><span class="pre">pdf</span></tt> with <tt class="docutils literal"><span class="pre">pdflatex</span></tt> or <tt class="docutils literal"><span class="pre">xelatex</span></tt>
the file needs first to be converted to <tt class="docutils literal"><span class="pre">pdf</span></tt>, for example
with <tt class="docutils literal"><span class="pre">ps2pdf</span> <span class="pre">filename.eps</span> <span class="pre">filename.pdf</span></tt>.</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference internal" href="#">Undirected graphs</a><ul>
<li><a class="reference internal" href="#graph-format">Graph Format</a><ul>
<li><a class="reference internal" href="#supported-formats">Supported formats</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generators">Generators</a></li>
<li><a class="reference internal" href="#labels">Labels</a></li>
<li><a class="reference internal" href="#database">Database</a></li>
<li><a class="reference internal" href="#visualization">Visualization</a></li>
<li><a class="reference internal" href="#mutability">Mutability</a></li>
<li><a class="reference internal" href="#methods">Methods</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="generic_graph.html"
                                  title="previous chapter">Generic graphs (common to directed/undirected)</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="digraph.html"
                                  title="next chapter">Directed graphs</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../_sources/sage/graphs/graph.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="digraph.html" title="Directed graphs"
             >next</a> |</li>
        <li class="right" >
          <a href="generic_graph.html" title="Generic graphs (common to directed/undirected)"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Graph Theory</a> &raquo;</li>
 
      </ul>
    </div>
    
    <div class="footer">
        &copy; Copyright 2005--2016, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>