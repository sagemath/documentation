
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Undirected graphs &#8212; Sage Reference Manual v8.9: Graph Theory</title>
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script async="async" type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Directed graphs" href="digraph.html" />
    <link rel="prev" title="Generic graphs (common to directed/undirected)" href="generic_graph.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />
    <script src="../../../_static/thebe.js" type="text/javascript"></script>
    <script src="../../../_static/thebe-sage.js" type="text/javascript"></script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="digraph.html" title="Directed graphs"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="generic_graph.html" title="Generic graphs (common to directed/undirected)"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Graph Theory</a> &#187;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="undirected-graphs">
<span id="sage-graphs-graph"></span><h1>Undirected graphs<a class="headerlink" href="#undirected-graphs" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.graphs.graph"></span><p>This module implements functions and operations involving undirected graphs.</p>
<p><strong>Algorithmically hard stuff</strong></p>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.chromatic_index" title="sage.graphs.graph.Graph.chromatic_index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">chromatic_index()</span></code></a></td>
<td>Return the chromatic index of the graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.chromatic_number" title="sage.graphs.graph.Graph.chromatic_number"><code class="xref py py-meth docutils literal notranslate"><span class="pre">chromatic_number()</span></code></a></td>
<td>Return the minimal number of colors needed to color the vertices of the graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.chromatic_polynomial" title="sage.graphs.graph.Graph.chromatic_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">chromatic_polynomial()</span></code></a></td>
<td>Compute the chromatic polynomial of the graph G.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.chromatic_quasisymmetric_function" title="sage.graphs.graph.Graph.chromatic_quasisymmetric_function"><code class="xref py py-meth docutils literal notranslate"><span class="pre">chromatic_quasisymmetric_function()</span></code></a></td>
<td>Return the chromatic quasisymmetric function of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.chromatic_symmetric_function" title="sage.graphs.graph.Graph.chromatic_symmetric_function"><code class="xref py py-meth docutils literal notranslate"><span class="pre">chromatic_symmetric_function()</span></code></a></td>
<td>Return the chromatic symmetric function of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.coloring" title="sage.graphs.graph.Graph.coloring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coloring()</span></code></a></td>
<td>Return the first (optimal) proper vertex-coloring found.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.convexity_properties" title="sage.graphs.graph.Graph.convexity_properties"><code class="xref py py-meth docutils literal notranslate"><span class="pre">convexity_properties()</span></code></a></td>
<td>Return a <code class="docutils literal notranslate"><span class="pre">ConvexityProperties</span></code> object corresponding to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.has_homomorphism_to" title="sage.graphs.graph.Graph.has_homomorphism_to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_homomorphism_to()</span></code></a></td>
<td>Checks whether there is a homomorphism between two graphs.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.independent_set" title="sage.graphs.graph.Graph.independent_set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">independent_set()</span></code></a></td>
<td>Return a maximum independent set.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.independent_set_of_representatives" title="sage.graphs.graph.Graph.independent_set_of_representatives"><code class="xref py py-meth docutils literal notranslate"><span class="pre">independent_set_of_representatives()</span></code></a></td>
<td>Return an independent set of representatives.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_perfect" title="sage.graphs.graph.Graph.is_perfect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_perfect()</span></code></a></td>
<td>Tests whether the graph is perfect.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.matching_polynomial" title="sage.graphs.graph.Graph.matching_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">matching_polynomial()</span></code></a></td>
<td>Computes the matching polynomial of the graph <span class="math notranslate nohighlight">\(G\)</span>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.minor" title="sage.graphs.graph.Graph.minor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">minor()</span></code></a></td>
<td>Return the vertices of a minor isomorphic to <span class="math notranslate nohighlight">\(H\)</span> in the current graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.pathwidth" title="sage.graphs.graph.Graph.pathwidth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pathwidth()</span></code></a></td>
<td>Compute the pathwidth of <code class="docutils literal notranslate"><span class="pre">self</span></code> (and provides a decomposition)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.rank_decomposition" title="sage.graphs.graph.Graph.rank_decomposition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rank_decomposition()</span></code></a></td>
<td>Compute an optimal rank-decomposition of the given graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.topological_minor" title="sage.graphs.graph.Graph.topological_minor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">topological_minor()</span></code></a></td>
<td>Return a topological <span class="math notranslate nohighlight">\(H\)</span>-minor from <code class="docutils literal notranslate"><span class="pre">self</span></code> if one exists.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.treewidth" title="sage.graphs.graph.Graph.treewidth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">treewidth()</span></code></a></td>
<td>Computes the tree-width of <span class="math notranslate nohighlight">\(G\)</span> (and provides a decomposition)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.tutte_polynomial" title="sage.graphs.graph.Graph.tutte_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tutte_polynomial()</span></code></a></td>
<td>Return the Tutte polynomial of the graph <span class="math notranslate nohighlight">\(G\)</span>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.vertex_cover" title="sage.graphs.graph.Graph.vertex_cover"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertex_cover()</span></code></a></td>
<td>Return a minimum vertex cover of self represented by a set of vertices.</td>
</tr>
</tbody>
</table>
<p><strong>Basic methods</strong></p>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.bipartite_color" title="sage.graphs.graph.Graph.bipartite_color"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bipartite_color()</span></code></a></td>
<td>Return a dictionary with vertices as the keys and the color class as the values.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.bipartite_sets" title="sage.graphs.graph.Graph.bipartite_sets"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bipartite_sets()</span></code></a></td>
<td>Return <span class="math notranslate nohighlight">\((X,Y)\)</span> where <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> are the nodes in each bipartite set of graph <span class="math notranslate nohighlight">\(G\)</span>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.graph6_string" title="sage.graphs.graph.Graph.graph6_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph6_string()</span></code></a></td>
<td>Return the graph6 representation of the graph as an ASCII string.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_directed" title="sage.graphs.graph.Graph.is_directed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_directed()</span></code></a></td>
<td>Since graph is undirected, returns False.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.join" title="sage.graphs.graph.Graph.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code></a></td>
<td>Return the join of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.sparse6_string" title="sage.graphs.graph.Graph.sparse6_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sparse6_string()</span></code></a></td>
<td>Return the sparse6 representation of the graph as an ASCII string.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.to_directed" title="sage.graphs.graph.Graph.to_directed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_directed()</span></code></a></td>
<td>Return a directed version of the graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.to_undirected" title="sage.graphs.graph.Graph.to_undirected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_undirected()</span></code></a></td>
<td>Since the graph is already undirected, simply returns a copy of itself.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.write_to_eps" title="sage.graphs.graph.Graph.write_to_eps"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write_to_eps()</span></code></a></td>
<td>Write a plot of the graph to <code class="docutils literal notranslate"><span class="pre">filename</span></code> in <code class="docutils literal notranslate"><span class="pre">eps</span></code> format.</td>
</tr>
</tbody>
</table>
<p><strong>Clique-related methods</strong></p>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.clique_complex" title="sage.graphs.graph.Graph.clique_complex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clique_complex()</span></code></a></td>
<td>Return the clique complex of self.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.clique_maximum" title="sage.graphs.graph.Graph.clique_maximum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clique_maximum()</span></code></a></td>
<td>Return the vertex set of a maximal order complete subgraph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.clique_number" title="sage.graphs.graph.Graph.clique_number"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clique_number()</span></code></a></td>
<td>Return the order of the largest clique of the graph</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.clique_polynomial" title="sage.graphs.graph.Graph.clique_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clique_polynomial()</span></code></a></td>
<td>Return the clique polynomial of self.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.cliques_containing_vertex" title="sage.graphs.graph.Graph.cliques_containing_vertex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cliques_containing_vertex()</span></code></a></td>
<td>Return the cliques containing each vertex, represented as a dictionary of lists of lists, keyed by vertex.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.cliques_get_clique_bipartite" title="sage.graphs.graph.Graph.cliques_get_clique_bipartite"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cliques_get_clique_bipartite()</span></code></a></td>
<td>Return a bipartite graph constructed such that maximal cliques are the right vertices and the left vertices are retained from the given graph. Right and left vertices are connected if the bottom vertex belongs to the clique represented by a top vertex.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.cliques_get_max_clique_graph" title="sage.graphs.graph.Graph.cliques_get_max_clique_graph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cliques_get_max_clique_graph()</span></code></a></td>
<td>Return the clique graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.cliques_maximal" title="sage.graphs.graph.Graph.cliques_maximal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cliques_maximal()</span></code></a></td>
<td>Return the list of all maximal cliques.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.cliques_maximum" title="sage.graphs.graph.Graph.cliques_maximum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cliques_maximum()</span></code></a></td>
<td>Returns the vertex sets of <em>ALL</em> the maximum complete subgraphs.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.cliques_number_of" title="sage.graphs.graph.Graph.cliques_number_of"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cliques_number_of()</span></code></a></td>
<td>Return a dictionary of the number of maximal cliques containing each vertex, keyed by vertex.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.cliques_vertex_clique_number" title="sage.graphs.graph.Graph.cliques_vertex_clique_number"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cliques_vertex_clique_number()</span></code></a></td>
<td>Return a dictionary of sizes of the largest maximal cliques containing each vertex, keyed by vertex.</td>
</tr>
</tbody>
</table>
<p><strong>Connectivity, orientations, trees</strong></p>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.bounded_outdegree_orientation" title="sage.graphs.graph.Graph.bounded_outdegree_orientation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bounded_outdegree_orientation()</span></code></a></td>
<td>Computes an orientation of <code class="docutils literal notranslate"><span class="pre">self</span></code> such that every vertex <span class="math notranslate nohighlight">\(v\)</span> has out-degree less than <span class="math notranslate nohighlight">\(b(v)\)</span></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.bridges" title="sage.graphs.graph.Graph.bridges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bridges()</span></code></a></td>
<td>Return a list of the bridges (or cut edges).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.cleave" title="sage.graphs.graph.Graph.cleave"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cleave()</span></code></a></td>
<td>Return the connected subgraphs separated by the input vertex cut.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.degree_constrained_subgraph" title="sage.graphs.graph.Graph.degree_constrained_subgraph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">degree_constrained_subgraph()</span></code></a></td>
<td>Returns a degree-constrained subgraph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.ear_decomposition" title="sage.graphs.graph.Graph.ear_decomposition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ear_decomposition()</span></code></a></td>
<td>Return an Ear decomposition of the graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.gomory_hu_tree" title="sage.graphs.graph.Graph.gomory_hu_tree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gomory_hu_tree()</span></code></a></td>
<td>Return a Gomory-Hu tree of self.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_triconnected" title="sage.graphs.graph.Graph.is_triconnected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_triconnected()</span></code></a></td>
<td>Check whether the graph is triconnected.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.minimum_outdegree_orientation" title="sage.graphs.graph.Graph.minimum_outdegree_orientation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">minimum_outdegree_orientation()</span></code></a></td>
<td>Returns an orientation of <code class="docutils literal notranslate"><span class="pre">self</span></code> with the smallest possible maximum outdegree.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.orientations" title="sage.graphs.graph.Graph.orientations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">orientations()</span></code></a></td>
<td>Return an iterator over orientations of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.random_orientation" title="sage.graphs.graph.Graph.random_orientation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">random_orientation()</span></code></a></td>
<td>Return a random orientation of a graph <span class="math notranslate nohighlight">\(G\)</span>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.random_spanning_tree" title="sage.graphs.graph.Graph.random_spanning_tree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">random_spanning_tree()</span></code></a></td>
<td>Return a random spanning tree of the graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.spanning_trees" title="sage.graphs.graph.Graph.spanning_trees"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spanning_trees()</span></code></a></td>
<td>Returns a list of all spanning trees.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.spqr_tree" title="sage.graphs.graph.Graph.spqr_tree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spqr_tree()</span></code></a></td>
<td>Return an SPQR-tree representing the triconnected components of the graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.strong_orientation" title="sage.graphs.graph.Graph.strong_orientation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">strong_orientation()</span></code></a></td>
<td>Returns a strongly connected orientation of the current graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.strong_orientations_iterator" title="sage.graphs.graph.Graph.strong_orientations_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">strong_orientations_iterator()</span></code></a></td>
<td>Returns an iterator over all strong orientations of a graph <span class="math notranslate nohighlight">\(G\)</span>.</td>
</tr>
</tbody>
</table>
<p><strong>Distances</strong></p>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.centrality_degree" title="sage.graphs.graph.Graph.centrality_degree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">centrality_degree()</span></code></a></td>
<td>Return the degree centrality of a vertex.</td>
</tr>
</tbody>
</table>
<p><strong>Graph properties</strong></p>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.apex_vertices" title="sage.graphs.graph.Graph.apex_vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apex_vertices()</span></code></a></td>
<td>Return the list of apex vertices.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_apex" title="sage.graphs.graph.Graph.is_apex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_apex()</span></code></a></td>
<td>Test if the graph is apex.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_arc_transitive" title="sage.graphs.graph.Graph.is_arc_transitive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_arc_transitive()</span></code></a></td>
<td>Check if self is an arc-transitive graph</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_asteroidal_triple_free" title="sage.graphs.graph.Graph.is_asteroidal_triple_free"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_asteroidal_triple_free()</span></code></a></td>
<td>Test if the input graph is asteroidal triple-free</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_biconnected" title="sage.graphs.graph.Graph.is_biconnected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_biconnected()</span></code></a></td>
<td>Test if the graph is biconnected.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_block_graph" title="sage.graphs.graph.Graph.is_block_graph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_block_graph()</span></code></a></td>
<td>Return whether this graph is a block graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_cactus" title="sage.graphs.graph.Graph.is_cactus"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_cactus()</span></code></a></td>
<td>Check whether the graph is cactus graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_cartesian_product" title="sage.graphs.graph.Graph.is_cartesian_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_cartesian_product()</span></code></a></td>
<td>Test whether the graph is a Cartesian product.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_circumscribable" title="sage.graphs.graph.Graph.is_circumscribable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_circumscribable()</span></code></a></td>
<td>Test whether the graph is the graph of a circumscribed polyhedron.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_cograph" title="sage.graphs.graph.Graph.is_cograph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_cograph()</span></code></a></td>
<td>Check whether the graph is cograph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_comparability" title="sage.graphs.graph.Graph.is_comparability"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_comparability()</span></code></a></td>
<td>Tests whether the graph is a comparability graph</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_distance_regular" title="sage.graphs.graph.Graph.is_distance_regular"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_distance_regular()</span></code></a></td>
<td>Test if the graph is distance-regular</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_edge_transitive" title="sage.graphs.graph.Graph.is_edge_transitive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_edge_transitive()</span></code></a></td>
<td>Check if self is an edge transitive graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_even_hole_free" title="sage.graphs.graph.Graph.is_even_hole_free"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_even_hole_free()</span></code></a></td>
<td>Tests whether <code class="docutils literal notranslate"><span class="pre">self</span></code> contains an induced even hole.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_forest" title="sage.graphs.graph.Graph.is_forest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_forest()</span></code></a></td>
<td>Tests if the graph is a forest, i.e. a disjoint union of trees.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_half_transitive" title="sage.graphs.graph.Graph.is_half_transitive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_half_transitive()</span></code></a></td>
<td>Check if self is a half-transitive graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_inscribable" title="sage.graphs.graph.Graph.is_inscribable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_inscribable()</span></code></a></td>
<td>Test whether the graph is the graph of an inscribed polyhedron.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_line_graph" title="sage.graphs.graph.Graph.is_line_graph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_line_graph()</span></code></a></td>
<td>Tests wether the graph is a line graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_long_antihole_free" title="sage.graphs.graph.Graph.is_long_antihole_free"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_long_antihole_free()</span></code></a></td>
<td>Tests whether the given graph contains an induced subgraph that is isomorphic to the complement of a cycle of length at least 5.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_long_hole_free" title="sage.graphs.graph.Graph.is_long_hole_free"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_long_hole_free()</span></code></a></td>
<td>Tests whether <code class="docutils literal notranslate"><span class="pre">g</span></code> contains an induced cycle of length at least 5.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_odd_hole_free" title="sage.graphs.graph.Graph.is_odd_hole_free"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_odd_hole_free()</span></code></a></td>
<td>Tests whether <code class="docutils literal notranslate"><span class="pre">self</span></code> contains an induced odd hole.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_overfull" title="sage.graphs.graph.Graph.is_overfull"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_overfull()</span></code></a></td>
<td>Tests whether the current graph is overfull.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_partial_cube" title="sage.graphs.graph.Graph.is_partial_cube"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_partial_cube()</span></code></a></td>
<td>Test whether the given graph is a partial cube.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_permutation" title="sage.graphs.graph.Graph.is_permutation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_permutation()</span></code></a></td>
<td>Tests whether the graph is a permutation graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_polyhedral" title="sage.graphs.graph.Graph.is_polyhedral"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_polyhedral()</span></code></a></td>
<td>Check whether the graph is the graph of the polyhedron.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_prime" title="sage.graphs.graph.Graph.is_prime"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_prime()</span></code></a></td>
<td>Test whether the current graph is prime.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_semi_symmetric" title="sage.graphs.graph.Graph.is_semi_symmetric"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_semi_symmetric()</span></code></a></td>
<td>Check if self is semi-symmetric.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_split" title="sage.graphs.graph.Graph.is_split"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_split()</span></code></a></td>
<td>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the graph is a Split graph, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_strongly_regular" title="sage.graphs.graph.Graph.is_strongly_regular"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_strongly_regular()</span></code></a></td>
<td>Check whether the graph is strongly regular.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_tree" title="sage.graphs.graph.Graph.is_tree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_tree()</span></code></a></td>
<td>Tests if the graph is a tree</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_triangle_free" title="sage.graphs.graph.Graph.is_triangle_free"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_triangle_free()</span></code></a></td>
<td>Returns whether <code class="docutils literal notranslate"><span class="pre">self</span></code> is triangle-free</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.is_weakly_chordal" title="sage.graphs.graph.Graph.is_weakly_chordal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_weakly_chordal()</span></code></a></td>
<td>Tests whether the given graph is weakly chordal, i.e., the graph and its complement have no induced cycle of length at least 5.</td>
</tr>
</tbody>
</table>
<p><strong>Leftovers</strong></p>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.common_neighbors_matrix" title="sage.graphs.graph.Graph.common_neighbors_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">common_neighbors_matrix()</span></code></a></td>
<td>Return a matrix of numbers of common neighbors between each pairs.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.cores" title="sage.graphs.graph.Graph.cores"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cores()</span></code></a></td>
<td>Return the core number for each vertex in an ordered list.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.effective_resistance" title="sage.graphs.graph.Graph.effective_resistance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">effective_resistance()</span></code></a></td>
<td>Return the effective resistance between nodes <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.effective_resistance_matrix" title="sage.graphs.graph.Graph.effective_resistance_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">effective_resistance_matrix()</span></code></a></td>
<td>Return a matrix whose (<span class="math notranslate nohighlight">\(i\)</span> , <span class="math notranslate nohighlight">\(j\)</span>) entry gives the effective resistance between vertices <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.fractional_chromatic_index" title="sage.graphs.graph.Graph.fractional_chromatic_index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fractional_chromatic_index()</span></code></a></td>
<td>Return the fractional chromatic index of the graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.has_perfect_matching" title="sage.graphs.graph.Graph.has_perfect_matching"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_perfect_matching()</span></code></a></td>
<td>Return whether this graph has a perfect matching.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.ihara_zeta_function_inverse" title="sage.graphs.graph.Graph.ihara_zeta_function_inverse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ihara_zeta_function_inverse()</span></code></a></td>
<td>Compute the inverse of the Ihara zeta function of the graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.kirchhoff_symanzik_polynomial" title="sage.graphs.graph.Graph.kirchhoff_symanzik_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kirchhoff_symanzik_polynomial()</span></code></a></td>
<td>Return the Kirchhoff-Symanzik polynomial of a graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.least_effective_resistance" title="sage.graphs.graph.Graph.least_effective_resistance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">least_effective_resistance()</span></code></a></td>
<td>Return a list of pairs of nodes with the least effective resistance.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.lovasz_theta" title="sage.graphs.graph.Graph.lovasz_theta"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lovasz_theta()</span></code></a></td>
<td>Return the value of Lovász theta-function of graph</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.magnitude_function" title="sage.graphs.graph.Graph.magnitude_function"><code class="xref py py-meth docutils literal notranslate"><span class="pre">magnitude_function()</span></code></a></td>
<td>Return the magnitude function of the graph as a rational function.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.matching" title="sage.graphs.graph.Graph.matching"><code class="xref py py-meth docutils literal notranslate"><span class="pre">matching()</span></code></a></td>
<td>Return a maximum weighted matching of the graph represented by the list of its edges.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.maximum_average_degree" title="sage.graphs.graph.Graph.maximum_average_degree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximum_average_degree()</span></code></a></td>
<td>Return the Maximum Average Degree (MAD) of the current graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.modular_decomposition" title="sage.graphs.graph.Graph.modular_decomposition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">modular_decomposition()</span></code></a></td>
<td>Return the modular decomposition of the current graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.most_common_neighbors" title="sage.graphs.graph.Graph.most_common_neighbors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">most_common_neighbors()</span></code></a></td>
<td>Return vertex pairs with maximal number of common neighbors.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.perfect_matchings" title="sage.graphs.graph.Graph.perfect_matchings"><code class="xref py py-meth docutils literal notranslate"><span class="pre">perfect_matchings()</span></code></a></td>
<td>Return an iterator over all perfect matchings of the graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.seidel_adjacency_matrix" title="sage.graphs.graph.Graph.seidel_adjacency_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">seidel_adjacency_matrix()</span></code></a></td>
<td>Return the Seidel adjacency matrix of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.seidel_switching" title="sage.graphs.graph.Graph.seidel_switching"><code class="xref py py-meth docutils literal notranslate"><span class="pre">seidel_switching()</span></code></a></td>
<td>Return the Seidel switching of <code class="docutils literal notranslate"><span class="pre">self</span></code> w.r.t. subset of vertices <code class="docutils literal notranslate"><span class="pre">s</span></code>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.graph.Graph.two_factor_petersen" title="sage.graphs.graph.Graph.two_factor_petersen"><code class="xref py py-meth docutils literal notranslate"><span class="pre">two_factor_petersen()</span></code></a></td>
<td>Return a decomposition of the graph into 2-factors.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.graph.Graph.twograph" title="sage.graphs.graph.Graph.twograph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">twograph()</span></code></a></td>
<td>Return the two-graph of <code class="docutils literal notranslate"><span class="pre">self</span></code></td>
</tr>
</tbody>
</table>
<p>AUTHORS:</p>
<ul class="simple">
<li>Robert L. Miller (2006-10-22): initial version</li>
<li>William Stein (2006-12-05): Editing</li>
<li><dl class="first docutils">
<dt>Robert L. Miller (2007-01-13): refactoring, adjusting for NetworkX-0.33, fixed</dt>
<dd>plotting bugs (2007-01-23): basic tutorial, edge labels, loops, multiple
edges and arcs (2007-02-07): graph6 and sparse6 formats, matrix input</dd>
</dl>
</li>
<li>Emily Kirkmann (2007-02-11): added graph_border option to plot and show</li>
<li><dl class="first docutils">
<dt>Robert L. Miller (2007-02-12): vertex color-maps, graph boundaries, graph6</dt>
<dd>helper functions in Cython</dd>
</dl>
</li>
<li>Robert L. Miller Sage Days 3 (2007-02-17-21): 3d plotting in Tachyon</li>
<li>Robert L. Miller (2007-02-25): display a partition</li>
<li><dl class="first docutils">
<dt>Robert L. Miller (2007-02-28): associate arbitrary objects to vertices, edge</dt>
<dd>and arc label display (in 2d), edge coloring</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Robert L. Miller (2007-03-21): Automorphism group, isomorphism check,</dt>
<dd>canonical label</dd>
</dl>
</li>
<li>Robert L. Miller (2007-06-07-09): NetworkX function wrapping</li>
<li>Michael W. Hansen (2007-06-09): Topological sort generation</li>
<li>Emily Kirkman, Robert L. Miller Sage Days 4: Finished wrapping NetworkX</li>
<li><dl class="first docutils">
<dt>Emily Kirkman (2007-07-21): Genus (including circular planar, all embeddings</dt>
<dd>and all planar embeddings), all paths, interior paths</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Bobby Moretti (2007-08-12): fixed up plotting of graphs with edge colors</dt>
<dd>differentiated by label</dd>
</dl>
</li>
<li>Jason Grout (2007-09-25): Added functions, bug fixes, and general enhancements</li>
<li>Robert L. Miller (Sage Days 7): Edge labeled graph isomorphism</li>
<li>Tom Boothby (Sage Days 7): Miscellaneous awesomeness</li>
<li>Tom Boothby (2008-01-09): Added graphviz output</li>
<li>David Joyner (2009-2): Fixed docstring bug related to GAP.</li>
<li><dl class="first docutils">
<dt>Stephen Hartke (2009-07-26): Fixed bug in blocks_and_cut_vertices() that</dt>
<dd>caused an incorrect result when the vertex 0 was a cut vertex.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Stephen Hartke (2009-08-22): Fixed bug in blocks_and_cut_vertices() where the</dt>
<dd>list of cut_vertices is not treated as a set.</dd>
</dl>
</li>
<li>Anders Jonsson (2009-10-10): Counting of spanning trees and out-trees added.</li>
<li><dl class="first docutils">
<dt>Nathann Cohen (2009-09) <span class="classifier-delimiter">:</span> <span class="classifier">Cliquer, Connectivity, Flows and everything that</span></dt>
<dd>uses Linear Programming and class numerical.MIP</dd>
</dl>
</li>
<li>Nicolas M. Thiery (2010-02): graph layout code refactoring, dot2tex/graphviz
interface</li>
<li>David Coudert (2012-04) : Reduction rules in vertex_cover.</li>
<li><dl class="first docutils">
<dt>Birk Eisermann (2012-06): added recognition of weakly chordal graphs and</dt>
<dd>long-hole-free / long-antihole-free graphs</dd>
</dl>
</li>
<li>Alexandre P. Zuge (2013-07): added join operation.</li>
<li>Amritanshu Prasad (2014-08): added clique polynomial</li>
<li>Julian Rüth (2018-06-21): upgrade to NetworkX 2</li>
<li>David Coudert (2018-10-07): cleaning</li>
<li>Amanda Francis, Caitlin Lienkaemper, Kate Collins, Rajat Mittal (2019-03-10):
methods for computing effective resistance</li>
<li>Amanda Francis, Caitlin Lienkaemper, Kate Collins, Rajat Mittal (2019-03-19):
most_common_neighbors and common_neighbors_matrix added.</li>
</ul>
<div class="section" id="graph-format">
<h2>Graph Format<a class="headerlink" href="#graph-format" title="Permalink to this headline">¶</a></h2>
<div class="section" id="supported-formats">
<h3>Supported formats<a class="headerlink" href="#supported-formats" title="Permalink to this headline">¶</a></h3>
<p>Sage Graphs can be created from a wide range of inputs. A few examples are
covered here.</p>
<ul>
<li><p class="first">NetworkX dictionary format:</p>
<blockquote>
<div><div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">9</span><span class="p">],</span> \
<span class="go">      5: [7, 8], 6: [8,9], 7: [9]}</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">d</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Graph on 10 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>    <span class="c1"># or G.show()</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">A NetworkX graph:</p>
<blockquote>
<div><div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">networkx</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">complete_bipartite_graph</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">[7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 12, 12, 12, 12, 12, 12, 12]</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">graph6 or sparse6 format:</p>
<blockquote>
<div><div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;:I`AKGsaOs`cI]Gb~&#39;</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Looped multi-graph on 10 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>    <span class="c1"># or G.show()</span>
</pre></div>
</div>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">\</span></code> character is an escape character in Python, and also a
character used by graph6 strings:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;Ihe</span><span class="se">\n</span><span class="s1">@GUA&#39;</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">RuntimeError: the string (Ihe) seems corrupt: for n = 10, the string is too short</span>
</pre></div>
</div>
<p>In Python, the escaped character <code class="docutils literal notranslate"><span class="pre">\</span></code> is represented by <code class="docutils literal notranslate"><span class="pre">\\</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;Ihe</span><span class="se">\\</span><span class="s1">n@GUA&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>    <span class="c1"># or G.show()</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><dl class="first docutils">
<dt>adjacency matrix: In an adjacency matrix, each column and each row represent a</dt>
<dd><p class="first">vertex. If a 1 shows up in row <span class="math notranslate nohighlight">\(i\)</span>, column <span class="math notranslate nohighlight">\(j\)</span>, there is an edge <span class="math notranslate nohighlight">\((i,j)\)</span>.</p>
<div class="last highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> \
<span class="go">(0,1,0,1,0,0,0,1,0,0), (0,0,1,0,1,0,0,0,1,0),(1,0,0,1,0,0,0,0,0,1), \</span>
<span class="go">(1,0,0,0,0,0,0,1,1,0), (0,1,0,0,0,0,0,0,1,1),(0,0,1,0,0,1,0,0,0,1), \</span>
<span class="go">(0,0,0,1,0,1,1,0,0,0), (0,0,0,0,1,0,1,1,0,0)])</span>
<span class="gp">sage: </span><span class="n">M</span>
<span class="go">[0 1 0 0 1 1 0 0 0 0]</span>
<span class="go">[1 0 1 0 0 0 1 0 0 0]</span>
<span class="go">[0 1 0 1 0 0 0 1 0 0]</span>
<span class="go">[0 0 1 0 1 0 0 0 1 0]</span>
<span class="go">[1 0 0 1 0 0 0 0 0 1]</span>
<span class="go">[1 0 0 0 0 0 0 1 1 0]</span>
<span class="go">[0 1 0 0 0 0 0 0 1 1]</span>
<span class="go">[0 0 1 0 0 1 0 0 0 1]</span>
<span class="go">[0 0 0 1 0 1 1 0 0 0]</span>
<span class="go">[0 0 0 0 1 0 1 1 0 0]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">M</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Graph on 10 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>    <span class="c1"># or G.show()</span>
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>incidence matrix: In an incidence matrix, each row represents a vertex and</dt>
<dd><p class="first">each column represents an edge.</p>
<div class="last highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">....: </span>            <span class="p">(</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">....: </span>            <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">....: </span>            <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">....: </span>            <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
<span class="gp">....: </span>            <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">....: </span>            <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">....: </span>            <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">....: </span>            <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">....: </span>            <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">M</span>
<span class="go">[-1  0  0  0  1  0  0  0  0  0 -1  0  0  0  0]</span>
<span class="go">[ 1 -1  0  0  0  0  0  0  0  0  0 -1  0  0  0]</span>
<span class="go">[ 0  1 -1  0  0  0  0  0  0  0  0  0 -1  0  0]</span>
<span class="go">[ 0  0  1 -1  0  0  0  0  0  0  0  0  0 -1  0]</span>
<span class="go">[ 0  0  0  1 -1  0  0  0  0  0  0  0  0  0 -1]</span>
<span class="go">[ 0  0  0  0  0 -1  0  0  0  1  1  0  0  0  0]</span>
<span class="go">[ 0  0  0  0  0  0  0  1 -1  0  0  1  0  0  0]</span>
<span class="go">[ 0  0  0  0  0  1 -1  0  0  0  0  0  1  0  0]</span>
<span class="go">[ 0  0  0  0  0  0  0  0  1 -1  0  0  0  1  0]</span>
<span class="go">[ 0  0  0  0  0  0  1 -1  0  0  0  0  0  0  1]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">M</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Graph on 10 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>    <span class="c1"># or G.show()</span>
<span class="gp">sage: </span><span class="n">DiGraph</span><span class="p">(</span><span class="n">matrix</span><span class="p">(</span><span class="mi">2</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span> <span class="n">format</span><span class="o">=</span><span class="s2">&quot;incidence_matrix&quot;</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: there must be two nonzero entries (-1 &amp; 1) per column</span>
</pre></div>
</div>
</dd>
</dl>
</li>
<li><p class="first">a list of edges:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span>
<span class="go">Graph on 5 vertices</span>
</pre></div>
</div>
</li>
<li><p class="first">an igraph Graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">igraph</span>                                <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">igraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)]))</span> <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">g</span>                                            <span class="c1"># optional - python_igraph</span>
<span class="go">Graph on 4 vertices</span>
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="generators">
<h2>Generators<a class="headerlink" href="#generators" title="Permalink to this headline">¶</a></h2>
<p>Use <code class="docutils literal notranslate"><span class="pre">graphs(n)</span></code> to iterate through all non-isomorphic graphs of given size:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">graphs</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">degree_sequence</span><span class="p">())</span>
<span class="go">[0, 0, 0, 0]</span>
<span class="go">[1, 1, 0, 0]</span>
<span class="go">[2, 1, 1, 0]</span>
<span class="go">[3, 1, 1, 1]</span>
<span class="go">[1, 1, 1, 1]</span>
<span class="go">[2, 2, 1, 1]</span>
<span class="go">[2, 2, 2, 0]</span>
<span class="go">[3, 2, 2, 1]</span>
<span class="go">[2, 2, 2, 2]</span>
<span class="go">[3, 3, 2, 2]</span>
<span class="go">[3, 3, 3, 3]</span>
</pre></div>
</div>
<p>Similarly <code class="docutils literal notranslate"><span class="pre">graphs()</span></code> will iterate through all graphs. The complete graph of 4
vertices is of course the smallest graph with chromatic number bigger than
three:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">graphs</span><span class="p">():</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="k">break</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>For some commonly used graphs to play with, type:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="p">[</span><span class="n">tab</span><span class="p">]</span>          <span class="c1"># not tested</span>
</pre></div>
</div>
<p>and hit {tab}. Most of these graphs come with their own custom plot, so you can
see how people usually visualize these graphs.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>    <span class="c1"># or G.show()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">degree_histogram</span><span class="p">()</span>
<span class="go">[0, 0, 0, 10]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span>
<span class="go">[0 1 0 0 1 1 0 0 0 0]</span>
<span class="go">[1 0 1 0 0 0 1 0 0 0]</span>
<span class="go">[0 1 0 1 0 0 0 1 0 0]</span>
<span class="go">[0 0 1 0 1 0 0 0 1 0]</span>
<span class="go">[1 0 0 1 0 0 0 0 0 1]</span>
<span class="go">[1 0 0 0 0 0 0 1 1 0]</span>
<span class="go">[0 1 0 0 0 0 0 0 1 1]</span>
<span class="go">[0 0 1 0 0 1 0 0 0 1]</span>
<span class="go">[0 0 0 1 0 1 1 0 0 0]</span>
<span class="go">[0 0 0 0 1 0 1 1 0 0]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>    <span class="c1"># or S.show()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">density</span><span class="p">()</span>
<span class="go">1/2</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">GraphQuery</span><span class="p">(</span><span class="n">display_cols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;graph6&#39;</span><span class="p">],</span> <span class="n">num_vertices</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">diameter</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">get_graphs_list</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">graphs_list</span><span class="o">.</span><span class="n">show_graphs</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="labels">
<span id="graph-labels"></span><h2>Labels<a class="headerlink" href="#labels" title="Permalink to this headline">¶</a></h2>
<p>Each vertex can have any hashable object as a label. These are things like
strings, numbers, and tuples. Each edge is given a default label of <code class="docutils literal notranslate"><span class="pre">None</span></code>,
but if specified, edges can have any label at all. Edges between vertices <span class="math notranslate nohighlight">\(u\)</span>
and <span class="math notranslate nohighlight">\(v\)</span> are represented typically as <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></code>, where <code class="docutils literal notranslate"><span class="pre">l</span></code> is the label for
the edge.</p>
<p>Note that vertex labels themselves cannot be mutable items:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span> <span class="mi">0</span> <span class="p">:</span> <span class="p">{</span> <span class="n">M</span> <span class="p">:</span> <span class="bp">None</span> <span class="p">}</span> <span class="p">})</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: mutable matrices are unhashable</span>
</pre></div>
</div>
<p>However, if one wants to define a dictionary, with the same keys and arbitrary
objects for entries, one can make that association:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span> <span class="p">:</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DodecahedralGraph</span><span class="p">(),</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">graphs</span><span class="o">.</span><span class="n">FlowerSnark</span><span class="p">(),</span> \
<span class="go">      2 : graphs.MoebiusKantorGraph(), 3 : graphs.PetersenGraph() }</span>
<span class="gp">sage: </span><span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">Moebius-Kantor Graph: Graph on 16 vertices</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">TetrahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">set_vertices</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">get_vertex</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Flower Snark: Graph on 20 vertices</span>
</pre></div>
</div>
</div>
<div class="section" id="database">
<h2>Database<a class="headerlink" href="#database" title="Permalink to this headline">¶</a></h2>
<p>There is a database available for searching for graphs that satisfy a certain
set of parameters, including number of vertices and edges, density, maximum and
minimum degree, diameter, radius, and connectivity. To see a list of all search
parameter keywords broken down by their designated table names, type</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graph_db_info</span><span class="p">()</span>
<span class="go">{...}</span>
</pre></div>
</div>
<p>For more details on data types or keyword input, enter</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">GraphQuery</span><span class="err">?</span>    <span class="c1"># not tested</span>
</pre></div>
</div>
<p>The results of a query can be viewed with the show method, or can be viewed
individually by iterating through the results</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">GraphQuery</span><span class="p">(</span><span class="n">display_cols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;graph6&#39;</span><span class="p">],</span><span class="n">num_vertices</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">diameter</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="go">Graph6</span>
<span class="gt">--------------------</span>
<span class="n">F</span><span class="err">?`</span><span class="n">po</span>
<span class="n">F</span><span class="err">?</span><span class="n">gqg</span>
<span class="n">F</span><span class="err">@?</span><span class="p">]</span><span class="n">O</span>
<span class="n">F</span><span class="nd">@OKg</span>
<span class="n">F</span><span class="nd">@R@o</span>
<span class="n">FA_pW</span>
<span class="n">FEOhW</span>
<span class="n">FGC</span><span class="p">{</span><span class="n">o</span>
<span class="n">FIAHo</span>
</pre></div>
</div>
<p>Show each graph as you iterate through the results:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">Q</span><span class="p">:</span>
<span class="gp">....: </span>    <span class="n">show</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="visualization">
<h2>Visualization<a class="headerlink" href="#visualization" title="Permalink to this headline">¶</a></h2>
<p>To see a graph <span class="math notranslate nohighlight">\(G\)</span> you are working with, there are three main options. You can
view the graph in two dimensions via matplotlib with <code class="docutils literal notranslate"><span class="pre">show()</span></code>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="o">.</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>And you can view it in three dimensions via jmol with <code class="docutils literal notranslate"><span class="pre">show3d()</span></code>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show3d</span><span class="p">()</span>
</pre></div>
</div>
<p>Or it can be rendered with <span class="math notranslate nohighlight">\(\LaTeX\)</span>.  This requires the right additions to a
standard <span class="math notranslate nohighlight">\(\mbox{\rm\TeX}\)</span> installation.  Then standard Sage commands, such as
<code class="docutils literal notranslate"><span class="pre">view(G)</span></code> will display the graph, or <code class="docutils literal notranslate"><span class="pre">latex(G)</span></code> will produce a string
suitable for inclusion in a <span class="math notranslate nohighlight">\(\LaTeX\)</span> document.  More details on this are at the
<a class="reference internal" href="graph_latex.html#module-sage.graphs.graph_latex" title="sage.graphs.graph_latex"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.graphs.graph_latex</span></code></a> module.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_latex</span> <span class="kn">import</span> <span class="n">check_tkz_graph</span>
<span class="gp">sage: </span><span class="n">check_tkz_graph</span><span class="p">()</span>  <span class="c1"># random - depends on TeX installation</span>
<span class="gp">sage: </span><span class="n">latex</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">\begin{tikzpicture}</span>
<span class="go">...</span>
<span class="go">\end{tikzpicture}</span>
</pre></div>
</div>
</div>
<div class="section" id="mutability">
<h2>Mutability<a class="headerlink" href="#mutability" title="Permalink to this headline">¶</a></h2>
<p>Graphs are mutable, and thus unusable as dictionary keys, unless
<code class="docutils literal notranslate"><span class="pre">data_structure=&quot;static_sparse&quot;</span></code> is used:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">{</span><span class="n">G</span><span class="p">:</span><span class="mi">1</span><span class="p">}[</span><span class="n">G</span><span class="p">]</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: This graph is mutable, and thus not hashable. Create an immutable copy by `g.copy(immutable=True)`</span>
<span class="gp">sage: </span><span class="n">G_immutable</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">immutable</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G_immutable</span> <span class="o">==</span> <span class="n">G</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">{</span><span class="n">G_immutable</span><span class="p">:</span><span class="mi">1</span><span class="p">}[</span><span class="n">G_immutable</span><span class="p">]</span>
<span class="go">1</span>
</pre></div>
</div>
</div>
<div class="section" id="methods">
<h2>Methods<a class="headerlink" href="#methods" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="sage.graphs.graph.Graph">
<em class="property">class </em><code class="descclassname">sage.graphs.graph.</code><code class="descname">Graph</code><span class="sig-paren">(</span><em>data=None</em>, <em>pos=None</em>, <em>loops=None</em>, <em>format=None</em>, <em>weighted=None</em>, <em>data_structure='sparse'</em>, <em>vertex_labels=True</em>, <em>name=None</em>, <em>multiedges=None</em>, <em>convert_empty_dict_labels_to_None=None</em>, <em>sparse=True</em>, <em>immutable=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph" title="sage.graphs.generic_graph.GenericGraph"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.graphs.generic_graph.GenericGraph</span></code></a></p>
<p>Undirected graph.</p>
<p>A graph is a set of vertices connected by edges. See the
<a class="reference external" href="https://en.wikipedia.org/wiki/Graph_(mathematics)">Wikipedia article Graph_(mathematics)</a> for more information. For a collection of
pre-defined graphs, see the <a class="reference internal" href="graph_generators.html#module-sage.graphs.graph_generators" title="sage.graphs.graph_generators"><code class="xref py py-mod docutils literal notranslate"><span class="pre">graph_generators</span></code></a> module.</p>
<p>A <a class="reference internal" href="#sage.graphs.graph.Graph" title="sage.graphs.graph.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a> object has many methods whose list can be obtained by
typing <code class="docutils literal notranslate"><span class="pre">g.&lt;tab&gt;</span></code> (i.e. hit the ‘tab’ key) or by reading the documentation
of <a class="reference internal" href="#module-sage.graphs.graph" title="sage.graphs.graph"><code class="xref py py-mod docutils literal notranslate"><span class="pre">graph</span></code></a>, <a class="reference internal" href="generic_graph.html#module-sage.graphs.generic_graph" title="sage.graphs.generic_graph"><code class="xref py py-mod docutils literal notranslate"><span class="pre">generic_graph</span></code></a>, and
<a class="reference internal" href="digraph.html#module-sage.graphs.digraph" title="sage.graphs.digraph"><code class="xref py py-mod docutils literal notranslate"><span class="pre">digraph</span></code></a>.</p>
<p>INPUT:</p>
<p>By default, a <a class="reference internal" href="#sage.graphs.graph.Graph" title="sage.graphs.graph.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a> object is simple (i.e. no <em>loops</em> nor <em>multiple
edges</em>) and unweighted. This can be easily tuned with the appropriate flags
(see below).</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">data</span></code> – can be any of the following (see the <code class="docutils literal notranslate"><span class="pre">format</span></code> argument):</p>
<ol class="arabic">
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">Graph()</span></code> – build a graph on 0 vertices.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">Graph(5)</span></code> – return an edgeless graph on the 5 vertices 0,…,4.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">Graph([list_of_vertices,</span> <span class="pre">list_of_edges])</span></code> – returns a graph with
given vertices/edges.</p>
<p>To bypass auto-detection, prefer the more explicit
<code class="docutils literal notranslate"><span class="pre">Graph([V,</span> <span class="pre">E],</span> <span class="pre">format='vertices_and_edges')</span></code>.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">Graph(list_of_edges)</span></code> – return a graph with a given list of edges
(see documentation of
<a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.add_edges" title="sage.graphs.generic_graph.GenericGraph.add_edges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_edges()</span></code></a>).</p>
<p>To bypass auto-detection, prefer the more explicit
<code class="docutils literal notranslate"><span class="pre">Graph(L,</span> <span class="pre">format='list_of_edges')</span></code>.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">Graph({1:</span> <span class="pre">[2,</span> <span class="pre">3,</span> <span class="pre">4],</span> <span class="pre">3:</span> <span class="pre">[4]})</span></code> – return a graph by associating to
each vertex the list of its neighbors.</p>
<p>To bypass auto-detection, prefer the more explicit
<code class="docutils literal notranslate"><span class="pre">Graph(D,</span> <span class="pre">format='dict_of_lists')</span></code>.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">Graph({1:</span> <span class="pre">{2:</span> <span class="pre">'a',</span> <span class="pre">3:'b'}</span> <span class="pre">,3:{2:'c'}})</span></code> – return a graph by
associating a list of neighbors to each vertex and providing its edge
label.</p>
<p>To bypass auto-detection, prefer the more explicit
<code class="docutils literal notranslate"><span class="pre">Graph(D,</span> <span class="pre">format='dict_of_dicts')</span></code>.</p>
<p>For graphs with multiple edges, you can provide a list of labels
instead, e.g.: <code class="docutils literal notranslate"><span class="pre">Graph({1:</span> <span class="pre">{2:</span> <span class="pre">['a1',</span> <span class="pre">'a2'],</span> <span class="pre">3:['b']}</span> <span class="pre">,3:{2:['c']}})</span></code>.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">Graph(a_symmetric_matrix)</span></code> – return a graph with given (weighted)
adjacency matrix (see documentation of
<a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.adjacency_matrix" title="sage.graphs.generic_graph.GenericGraph.adjacency_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">adjacency_matrix()</span></code></a>).</p>
<p>To bypass auto-detection, prefer the more explicit <code class="docutils literal notranslate"><span class="pre">Graph(M,</span>
<span class="pre">format='adjacency_matrix')</span></code>. To take weights into account, use
<code class="docutils literal notranslate"><span class="pre">format='weighted_adjacency_matrix'</span></code> instead.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">Graph(a_nonsymmetric_matrix)</span></code> – return a graph with given incidence
matrix (see documentation of
<a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.incidence_matrix" title="sage.graphs.generic_graph.GenericGraph.incidence_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">incidence_matrix()</span></code></a>).</p>
<p>To bypass auto-detection, prefer the more explicit
<code class="docutils literal notranslate"><span class="pre">Graph(M,</span> <span class="pre">format='incidence_matrix')</span></code>.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">Graph([V,</span> <span class="pre">f])</span></code> – return a graph from a vertex set <code class="docutils literal notranslate"><span class="pre">V</span></code> and a
<em>symmetric</em> function <code class="docutils literal notranslate"><span class="pre">f</span></code>. The graph contains an edge <span class="math notranslate nohighlight">\(u,v\)</span> whenever
<code class="docutils literal notranslate"><span class="pre">f(u,v)</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>.. Example: <code class="docutils literal notranslate"><span class="pre">Graph([</span> <span class="pre">[1..10],</span> <span class="pre">lambda</span> <span class="pre">x,y:</span>
<span class="pre">abs(x-y).is_square()])</span></code></p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">Graph(':I`ES&#64;obGkqegW~')</span></code> – return a graph from a graph6 or sparse6
string (see documentation of <a class="reference internal" href="#sage.graphs.graph.Graph.graph6_string" title="sage.graphs.graph.Graph.graph6_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph6_string()</span></code></a> or
<a class="reference internal" href="#sage.graphs.graph.Graph.sparse6_string" title="sage.graphs.graph.Graph.sparse6_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sparse6_string()</span></code></a>).</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">Graph(a_seidel_matrix,</span> <span class="pre">format='seidel_adjacency_matrix')</span></code> – return
a graph with a given Seidel adjacency matrix (see documentation of
<a class="reference internal" href="#sage.graphs.graph.Graph.seidel_adjacency_matrix" title="sage.graphs.graph.Graph.seidel_adjacency_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">seidel_adjacency_matrix()</span></code></a>).</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">Graph(another_graph)</span></code> – return a graph from a Sage (di)graph,
<a class="reference external" href="https://pygraphviz.github.io/">pygraphviz</a> graph, <a class="reference external" href="https://networkx.github.io/">NetworkX</a> graph, or <a class="reference external" href="http://igraph.org/python/">igraph</a> graph.</p>
</li>
</ol>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">pos</span></code> – a positioning dictionary (cf. documentation of
<a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.layout" title="sage.graphs.generic_graph.GenericGraph.layout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">layout()</span></code></a>). For example, to
draw 4 vertices on a square:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">{0: [-1,-1],</span>
<span class="go"> 1: [ 1,-1],</span>
<span class="go"> 2: [ 1, 1],</span>
<span class="go"> 3: [-1, 1]}</span>
</pre></div>
</div>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code> – (must be an explicitly named parameter, i.e.,</dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">name=&quot;complete&quot;)</span></code> gives the graph a name</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">loops</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); whether to allow loops (ignored</dt>
<dd><p class="first last">if data is an instance of the <code class="docutils literal notranslate"><span class="pre">Graph</span></code> class)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">multiedges</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); whether to allow multiple</dt>
<dd><p class="first last">edges (ignored if data is an instance of the <code class="docutils literal notranslate"><span class="pre">Graph</span></code> class).</p>
</dd>
</dl>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">weighted</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); whether graph thinks of
itself as weighted or not. See
<a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.weighted" title="sage.graphs.generic_graph.GenericGraph.weighted"><code class="xref py py-meth docutils literal notranslate"><span class="pre">weighted()</span></code></a>.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">format</span></code> – if set to <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), <a class="reference internal" href="#sage.graphs.graph.Graph" title="sage.graphs.graph.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a> tries to guess
input’s format. To avoid this possibly time-consuming step, one of the
following values can be specified (see description above): <code class="docutils literal notranslate"><span class="pre">&quot;int&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;graph6&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;sparse6&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;rule&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;list_of_edges&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;dict_of_lists&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;dict_of_dicts&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;adjacency_matrix&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;weighted_adjacency_matrix&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;seidel_adjacency_matrix&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;incidence_matrix&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;NX&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;igraph&quot;</span></code>.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">sparse</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); <code class="docutils literal notranslate"><span class="pre">sparse=True</span></code> is an alias for
<code class="docutils literal notranslate"><span class="pre">data_structure=&quot;sparse&quot;</span></code>, and <code class="docutils literal notranslate"><span class="pre">sparse=False</span></code> is an alias for
<code class="docutils literal notranslate"><span class="pre">data_structure=&quot;dense&quot;</span></code>.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">data_structure</span></code> – one of the following (for more information, see
<a class="reference internal" href="base/overview.html#module-sage.graphs.base.overview" title="sage.graphs.base.overview"><code class="xref py py-mod docutils literal notranslate"><span class="pre">overview</span></code></a>)</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">&quot;dense&quot;</span></code> – selects the <a class="reference internal" href="base/dense_graph.html#module-sage.graphs.base.dense_graph" title="sage.graphs.base.dense_graph"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dense_graph</span></code></a>
backend.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;sparse&quot;</span></code> – selects the <a class="reference internal" href="base/sparse_graph.html#module-sage.graphs.base.sparse_graph" title="sage.graphs.base.sparse_graph"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sparse_graph</span></code></a>
backend.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;static_sparse&quot;</span></code> – selects the
<a class="reference internal" href="base/static_sparse_backend.html#module-sage.graphs.base.static_sparse_backend" title="sage.graphs.base.static_sparse_backend"><code class="xref py py-mod docutils literal notranslate"><span class="pre">static_sparse_backend</span></code></a> (this backend is faster
than the sparse backend and smaller in memory, and it is immutable, so
that the resulting graphs can be used as dictionary keys).</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">immutable</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to create a
immutable graph. Note that <code class="docutils literal notranslate"><span class="pre">immutable=True</span></code> is actually a shortcut for
<code class="docutils literal notranslate"><span class="pre">data_structure='static_sparse'</span></code>. Set to <code class="docutils literal notranslate"><span class="pre">False</span></code> by default.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">vertex_labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether to allow any
object as a vertex (slower), or only the integers <span class="math notranslate nohighlight">\(0,...,n-1\)</span>, where <span class="math notranslate nohighlight">\(n\)</span>
is the number of vertices.</p>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">convert_empty_dict_labels_to_None</span></code> – this arguments sets the default</dt>
<dd><p class="first last">edge labels used by NetworkX (empty dictionaries) to be replaced by
<code class="docutils literal notranslate"><span class="pre">None</span></code>, the default Sage edge label. It is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> iff a
NetworkX graph is on the input.</p>
</dd>
</dl>
</li>
</ul>
<p>EXAMPLES:</p>
<p>We illustrate the first seven input formats (the other two involve packages
that are currently not standard in Sage):</p>
<ol class="arabic">
<li><p class="first">An integer giving the number of vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="n">g</span>
<span class="go">Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
</li>
<li><p class="first">A dictionary of dictionaries:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:{</span><span class="mi">1</span><span class="p">:</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="s1">&#39;z&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">:</span><span class="s1">&#39;a&#39;</span><span class="p">},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">5</span><span class="p">:</span><span class="s1">&#39;out&#39;</span><span class="p">}});</span> <span class="n">g</span>
<span class="go">Graph on 5 vertices</span>
</pre></div>
</div>
<p>The labels (‘x’, ‘z’, ‘a’, ‘out’) are labels for edges. For example,
‘out’ is the label for the edge on 2 and 5. Labels can be used as
weights, if all the labels share some common parent.:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">f</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">SymmetricGroup</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">({</span><span class="n">b</span><span class="p">:{</span><span class="n">d</span><span class="p">:</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="n">e</span><span class="p">:</span><span class="s1">&#39;p&#39;</span><span class="p">},</span> <span class="n">c</span><span class="p">:{</span><span class="n">d</span><span class="p">:</span><span class="s1">&#39;p&#39;</span><span class="p">,</span><span class="n">e</span><span class="p">:</span><span class="s1">&#39;c&#39;</span><span class="p">}})</span>
<span class="go">Graph on 4 vertices</span>
</pre></div>
</div>
</li>
<li><p class="first">A dictionary of lists:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">]});</span> <span class="n">g</span>
<span class="go">Graph on 5 vertices</span>
</pre></div>
</div>
</li>
<li><p class="first">A list of vertices and a function describing adjacencies. Note that the
list of vertices and the function must be enclosed in a list (i.e., [list
of vertices, function]).</p>
<p>Construct the Paley graph over GF(13).:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">=</span><span class="n">Graph</span><span class="p">([</span><span class="n">GF</span><span class="p">(</span><span class="mi">13</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">:</span> <span class="n">i</span><span class="o">!=</span><span class="n">j</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">is_square</span><span class="p">()])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span>
<span class="go">[0 1 0 1 1 0 0 0 0 1 1 0 1]</span>
<span class="go">[1 0 1 0 1 1 0 0 0 0 1 1 0]</span>
<span class="go">[0 1 0 1 0 1 1 0 0 0 0 1 1]</span>
<span class="go">[1 0 1 0 1 0 1 1 0 0 0 0 1]</span>
<span class="go">[1 1 0 1 0 1 0 1 1 0 0 0 0]</span>
<span class="go">[0 1 1 0 1 0 1 0 1 1 0 0 0]</span>
<span class="go">[0 0 1 1 0 1 0 1 0 1 1 0 0]</span>
<span class="go">[0 0 0 1 1 0 1 0 1 0 1 1 0]</span>
<span class="go">[0 0 0 0 1 1 0 1 0 1 0 1 1]</span>
<span class="go">[1 0 0 0 0 1 1 0 1 0 1 0 1]</span>
<span class="go">[1 1 0 0 0 0 1 1 0 1 0 1 0]</span>
<span class="go">[0 1 1 0 0 0 0 1 1 0 1 0 1]</span>
<span class="go">[1 0 1 1 0 0 0 0 1 1 0 1 0]</span>
</pre></div>
</div>
<p>Construct the line graph of a complete graph.:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">line_graph</span><span class="o">=</span><span class="n">Graph</span><span class="p">([</span><span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="n">false</span><span class="p">),</span> \
<span class="go">       lambda i,j: len(set(i).intersection(set(j)))&gt;0], \</span>
<span class="go">       loops=False)</span>
<span class="gp">sage: </span><span class="n">line_graph</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]</span>
<span class="gp">sage: </span><span class="n">line_graph</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span>
<span class="go">[0 1 1 1 1 0]</span>
<span class="go">[1 0 1 1 0 1]</span>
<span class="go">[1 1 0 0 1 1]</span>
<span class="go">[1 1 0 0 1 1]</span>
<span class="go">[1 0 1 1 0 1]</span>
<span class="go">[0 1 1 1 1 0]</span>
</pre></div>
</div>
</li>
<li><p class="first">A graph6 or sparse6 string: Sage automatically recognizes whether a
string is in graph6 or sparse6 format:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;:I`AKGsaOs`cI]Gb~&#39;</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Looped multi-graph on 10 vertices</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;G?????&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s2">&quot;G&#39;?G?C&quot;</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">RuntimeError: the string seems corrupt: valid characters are</span>
<span class="go">?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;G??????&#39;</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">RuntimeError: the string (G??????) seems corrupt: for n = 8, the string is too long</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s2">&quot;:I&#39;AKGsaOs`cI]Gb~&quot;</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">RuntimeError: the string seems corrupt: valid characters are</span>
<span class="go">?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~</span>
</pre></div>
</div>
<p>There are also list functions to take care of lists of graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;:IgMoqoCUOqeb</span><span class="se">\n</span><span class="s1">:I`AKGsaOs`cI]Gb~</span><span class="se">\n</span><span class="s1">:I`EDOAEQ?PccSsge</span><span class="se">\\</span><span class="s1">N</span><span class="se">\n</span><span class="s1">&#39;</span>
<span class="gp">sage: </span><span class="n">graphs_list</span><span class="o">.</span><span class="n">from_sparse6</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[Looped multi-graph on 10 vertices, Looped multi-graph on 10 vertices, Looped multi-graph on 10 vertices]</span>
</pre></div>
</div>
</li>
<li><p class="first">A Sage matrix:
Note: If format is not specified, then Sage assumes a symmetric square
matrix is an adjacency matrix, otherwise an incidence matrix.</p>
<ul>
<li><p class="first">an adjacency matrix:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">am</span><span class="p">();</span> <span class="n">M</span>
<span class="go">[0 1 0 0 1 1 0 0 0 0]</span>
<span class="go">[1 0 1 0 0 0 1 0 0 0]</span>
<span class="go">[0 1 0 1 0 0 0 1 0 0]</span>
<span class="go">[0 0 1 0 1 0 0 0 1 0]</span>
<span class="go">[1 0 0 1 0 0 0 0 0 1]</span>
<span class="go">[1 0 0 0 0 0 0 1 1 0]</span>
<span class="go">[0 1 0 0 0 0 0 0 1 1]</span>
<span class="go">[0 0 1 0 0 1 0 0 0 1]</span>
<span class="go">[0 0 0 1 0 1 1 0 0 0]</span>
<span class="go">[0 0 0 0 1 0 1 1 0 0]</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="go">Graph on 10 vertices</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]]),</span><span class="n">loops</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Looped multi-graph on 2 vertices</span>

<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]]);</span> <span class="n">M</span>
<span class="go">[   0    1   -1]</span>
<span class="go">[   1    0 -1/2]</span>
<span class="go">[  -1 -1/2    0]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Graph on 3 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">weighted</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</li>
<li><p class="first">an incidence matrix:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]);</span> <span class="n">M</span>
<span class="go">[-1  0  0  0  1]</span>
<span class="go">[ 1 -1  0  0  0]</span>
<span class="go">[ 0  1 -1  0  0]</span>
<span class="go">[ 0  0  1 -1  0]</span>
<span class="go">[ 0  0  0  1 -1]</span>
<span class="go">[ 0  0  0  0  0]</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="go">Graph on 6 vertices</span>

<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">]]))</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: there must be one or two nonzero entries per column in an incidence matrix, got entries [1, 1, 1] in column 0</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">]]))</span>
<span class="go">Graph on 3 vertices</span>

<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]);</span> <span class="n">M</span>
<span class="go">[ 0  1 -1]</span>
<span class="go">[ 1  0 -1]</span>
<span class="go">[-1 -1  0]</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Graph on 3 vertices</span>

<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]);</span> <span class="n">M</span>
<span class="go">[ 0  1  1]</span>
<span class="go">[ 1  0  1]</span>
<span class="go">[-1 -1  0]</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: there must be one or two nonzero entries per column in an incidence matrix, got entries [1, 1] in column 2</span>
</pre></div>
</div>
</li>
</ul>
<blockquote>
<div><p>Check that <a class="reference external" href="https://trac.sagemath.org/9714">trac ticket #9714</a> is fixed:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">MA</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">GA</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">MA</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s1">&#39;adjacency_matrix&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">MI</span> <span class="o">=</span> <span class="n">GA</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">(</span><span class="n">oriented</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">MI</span>
<span class="go">[2 1 1 0 0 0]</span>
<span class="go">[0 1 1 2 2 0]</span>
<span class="go">[0 0 0 0 0 2]</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">MI</span><span class="p">)</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<span class="go">[(0, 0), (0, 1), (0, 1), (1, 1), (1, 1), (2, 2)]</span>

<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]);</span> <span class="n">M</span>
<span class="go">[ 1]</span>
<span class="go">[-1]</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">M</span><span class="p">)</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None)]</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">A Seidel adjacency matrix:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.matrices.hadamard_matrix</span> <span class="kn">import</span> \
<span class="gp">....: </span> <span class="n">regular_symmetric_hadamard_matrix_with_constant_diagonal</span> <span class="k">as</span> <span class="n">rshcd</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">=</span><span class="n">rshcd</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span> <span class="n">matrix</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">format</span><span class="o">=</span><span class="s2">&quot;seidel_adjacency_matrix&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(16, 6, 2, 2)</span>
</pre></div>
</div>
</li>
<li><p class="first">List of edges, or labelled edges:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span>
<span class="go">Graph on 5 vertices</span>

<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s2">&quot;Peace&quot;</span><span class="p">),(</span><span class="mi">7</span><span class="p">,</span><span class="o">-</span><span class="mi">9</span><span class="p">,</span><span class="s2">&quot;and&quot;</span><span class="p">),(</span><span class="mi">77</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Love&quot;</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span>
<span class="go">Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">)],</span> <span class="n">loops</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">multiedges</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">loops</span><span class="p">()</span>
<span class="go">[(3, 3, &#39;2&#39;)]</span>
</pre></div>
</div>
</li>
<li><p class="first">A NetworkX MultiGraph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">networkx</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">MultiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">Graph on 5 vertices</span>
</pre></div>
</div>
</li>
<li><p class="first">A NetworkX graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">networkx</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">DiGraph</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">Digraph on 5 vertices</span>
</pre></div>
</div>
</li>
<li><p class="first">An igraph Graph (see also
<a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.igraph_graph" title="sage.graphs.generic_graph.GenericGraph.igraph_graph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">igraph_graph()</span></code></a>):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">igraph</span>                      <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">igraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span> <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>                           <span class="c1"># optional - python_igraph</span>
<span class="go">Graph on 3 vertices</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">vertex_labels</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, the names of the vertices are given by
the vertex attribute <code class="docutils literal notranslate"><span class="pre">'name'</span></code>, if available:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">igraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span> <span class="n">vertex_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">]})</span>  <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>                                                   <span class="c1"># optional - python_igraph</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">igraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span> <span class="n">vertex_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">]})</span> <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>                                                   <span class="c1"># optional - python_igraph</span>
<span class="go">[0, 1, 2]</span>
</pre></div>
</div>
<p>If the igraph Graph has edge attributes, they are used as edge labels:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">igraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span> <span class="n">edge_attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;weight&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]})</span> <span class="c1"># optional - python_igraph</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>                                                               <span class="c1"># optional - python_igraph</span>
<span class="go">[(0, 1, {&#39;name&#39;: &#39;a&#39;, &#39;weight&#39;: 1}), (0, 2, {&#39;name&#39;: &#39;b&#39;, &#39;weight&#39;: 3})]</span>
</pre></div>
</div>
</li>
</ol>
<p>When defining an undirected graph from a function <code class="docutils literal notranslate"><span class="pre">f</span></code>, it is <em>very</em>
important that <code class="docutils literal notranslate"><span class="pre">f</span></code> be symmetric. If it is not, anything can happen:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f_sym</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">f_nonsym</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">G_sym</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">f_sym</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G_sym</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G_nonsym</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">f_nonsym</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G_nonsym</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">G_nonsym</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">G_sym</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>By default, graphs are mutable and can thus not be used as a dictionary
key:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">{</span><span class="n">G</span><span class="p">:</span><span class="mi">1</span><span class="p">}[</span><span class="n">G</span><span class="p">]</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: This graph is mutable, and thus not hashable. Create an immutable copy by `g.copy(immutable=True)`</span>
</pre></div>
</div>
<p>When providing the optional arguments <code class="docutils literal notranslate"><span class="pre">data_structure=&quot;static_sparse&quot;</span></code> or
<code class="docutils literal notranslate"><span class="pre">immutable=True</span></code> (both mean the same), then an immutable graph results.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G_imm</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">immutable</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H_imm</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">data_structure</span><span class="o">=</span><span class="s1">&#39;static_sparse&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G_imm</span> <span class="o">==</span> <span class="n">H_imm</span> <span class="o">==</span> <span class="n">G</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">{</span><span class="n">G_imm</span><span class="p">:</span><span class="mi">1</span><span class="p">}[</span><span class="n">H_imm</span><span class="p">]</span>
<span class="go">1</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.graphs.graph.Graph.apex_vertices">
<code class="descname">apex_vertices</code><span class="sig-paren">(</span><em>k=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.apex_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of apex vertices.</p>
<p>A graph is apex if it can be made planar by the removal of a single
vertex. The deleted vertex is called <code class="docutils literal notranslate"><span class="pre">an</span> <span class="pre">apex</span></code> of the graph, and a
graph may have more than one apex. For instance, in the minimal
nonplanar graphs <span class="math notranslate nohighlight">\(K_5\)</span> or <span class="math notranslate nohighlight">\(K_{3,3}\)</span>, every vertex is an apex. The apex
graphs include graphs that are themselves planar, in which case again
every vertex is an apex. The null graph is also counted as an apex graph
even though it has no vertex to remove.  If the graph is not connected,
we say that it is apex if it has at most one non planar connected
component and that this component is apex.  See the
<a class="reference external" href="https://en.wikipedia.org/wiki/Apex_graph">Wikipedia article Apex_graph</a> for more information.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_apex" title="sage.graphs.graph.Graph.is_apex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_apex()</span></code></a></li>
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.is_planar" title="sage.graphs.generic_graph.GenericGraph.is_planar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_planar()</span></code></a></li>
</ul>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">k</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); when set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the method
returns the list of all apex of the graph, possibly empty if the graph
is not apex. When set to a positive integer, the method ends as soon
as <span class="math notranslate nohighlight">\(k\)</span> apex vertices are found.</li>
</ul>
<p>OUTPUT:</p>
<p>By default, the method returns the list of all apex of the graph. When
parameter <code class="docutils literal notranslate"><span class="pre">k</span></code> is set to a positive integer, the returned list is
bounded to <span class="math notranslate nohighlight">\(k\)</span> apex vertices.</p>
<p>EXAMPLES:</p>
<p><span class="math notranslate nohighlight">\(K_5\)</span> and <span class="math notranslate nohighlight">\(K_{3,3}\)</span> are apex graphs, and each of their vertices is an
apex:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">apex_vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_apex</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">apex_vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4, 5]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">apex_vertices</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[0, 1, 2]</span>
</pre></div>
</div>
<p>A <span class="math notranslate nohighlight">\(4\\times 4\)</span>-grid is apex and each of its vertices is an apex. When
adding a universal vertex, the resulting graph is apex and the universal
vertex is the unique apex vertex</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">set</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">apex_vertices</span><span class="p">())</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="s1">&#39;universal&#39;</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">apex_vertices</span><span class="p">()</span>
<span class="go">[&#39;universal&#39;]</span>
</pre></div>
</div>
<p>The Petersen graph is not apex:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">apex_vertices</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>A graph is apex if all its connected components are apex, but at most
one is not planar:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K5</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">M</span><span class="o">+</span><span class="n">K5</span><span class="p">)</span><span class="o">.</span><span class="n">apex_vertices</span><span class="p">()</span>
<span class="go">[9, 10, 11, 12, 13]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">M</span><span class="o">+</span><span class="n">K5</span><span class="o">+</span><span class="n">K5</span><span class="p">)</span><span class="o">.</span><span class="n">apex_vertices</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>Neighbors of an apex of degree 2 are apex:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="mi">666</span><span class="p">,</span> <span class="mi">666</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_path</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_planar</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">apex_vertices</span><span class="p">())</span>
<span class="go">[(1, 1), (2, 2), (3, 3), (666, 666)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.bipartite_color">
<code class="descname">bipartite_color</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.bipartite_color" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary with vertices as the keys and the color class
as the values.</p>
<p>Fails with an error if the graph is not bipartite.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">bipartite_color</span><span class="p">()</span>
<span class="go">{0: 1, 1: 0, 2: 1, 3: 0}</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">bipartite_color</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">RuntimeError: Graph is not bipartite.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.bipartite_sets">
<code class="descname">bipartite_sets</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.bipartite_sets" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <span class="math notranslate nohighlight">\((X,Y)\)</span> where <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> are the nodes in each bipartite set of
graph <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>Fails with an error if graph is not bipartite.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">bipartite_sets</span><span class="p">()</span>
<span class="go">({0, 2}, {1, 3})</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">bipartite_sets</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">RuntimeError: Graph is not bipartite.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.bounded_outdegree_orientation">
<code class="descname">bounded_outdegree_orientation</code><span class="sig-paren">(</span><em>bound</em>, <em>solver=None</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.bounded_outdegree_orientation" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes an orientation of <code class="docutils literal notranslate"><span class="pre">self</span></code> such that every vertex <span class="math notranslate nohighlight">\(v\)</span> has
out-degree less than <span class="math notranslate nohighlight">\(b(v)\)</span></p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">bound</span></code> – Maximum bound on the out-degree. Can be of three
different types :</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>An integer <span class="math notranslate nohighlight">\(k\)</span>. In this case, computes an orientation whose maximum
out-degree is less than <span class="math notranslate nohighlight">\(k\)</span>.</li>
<li>A dictionary associating to each vertex its associated maximum
out-degree.</li>
<li>A function associating to each vertex its associated maximum
out-degree.</li>
</ul>
</div></blockquote>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Linear Program (LP) solver
to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For more
information on LP solvers and which default solver is used, see the
method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</li>
</ul>
<p>OUTPUT:</p>
<p>A DiGraph representing the orientation if it exists. A <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>
exception is raised otherwise.</p>
<p>ALGORITHM:</p>
<p>The problem is solved through a maximum flow :</p>
<p>Given a graph <span class="math notranslate nohighlight">\(G\)</span>, we create a <code class="docutils literal notranslate"><span class="pre">DiGraph</span></code> <span class="math notranslate nohighlight">\(D\)</span> defined on <span class="math notranslate nohighlight">\(E(G)\cup
V(G)\cup \{s,t\}\)</span>. We then link <span class="math notranslate nohighlight">\(s\)</span> to all of <span class="math notranslate nohighlight">\(V(G)\)</span> (these edges having
a capacity equal to the bound associated to each element of <span class="math notranslate nohighlight">\(V(G)\)</span>), and
all the elements of <span class="math notranslate nohighlight">\(E(G)\)</span> to <span class="math notranslate nohighlight">\(t\)</span> . We then link each <span class="math notranslate nohighlight">\(v \in V(G)\)</span> to
each of its incident edges in <span class="math notranslate nohighlight">\(G\)</span>. A maximum integer flow of value
<span class="math notranslate nohighlight">\(|E(G)|\)</span> corresponds to an admissible orientation of <span class="math notranslate nohighlight">\(G\)</span>. Otherwise,
none exists.</p>
<p>EXAMPLES:</p>
<p>There is always an orientation of a graph <span class="math notranslate nohighlight">\(G\)</span> such that a vertex <span class="math notranslate nohighlight">\(v\)</span> has
out-degree at most <span class="math notranslate nohighlight">\(\lceil \frac {d(v)} 2 \rceil\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="o">.</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">ceil</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">bounded_outdegree_orientation</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">D</span><span class="o">.</span><span class="n">out_degree</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">g</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Chvatal’s graph, being 4-regular, can be oriented in such a way that its
maximum out-degree is 2:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">bounded_outdegree_orientation</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">max</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">out_degree</span><span class="p">())</span>
<span class="go">2</span>
</pre></div>
</div>
<p>For any graph <span class="math notranslate nohighlight">\(G\)</span>, it is possible to compute an orientation such that
the maximum out-degree is at most the maximum average degree of <span class="math notranslate nohighlight">\(G\)</span>
divided by 2. Anything less, though, is impossible.</p>
<blockquote>
<div>sage: g = graphs.RandomGNP(40, .4)
sage: mad = g.maximum_average_degree()</div></blockquote>
<p>Hence this is possible</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">bounded_outdegree_orientation</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">mad</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>While this is not:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">try</span><span class="p">:</span>
<span class="gp">....: </span>    <span class="n">g</span><span class="o">.</span><span class="n">bounded_outdegree_orientation</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">mad</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">....: </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Error&quot;</span><span class="p">)</span>
<span class="gp">....: </span><span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
<span class="gp">....: </span>    <span class="k">pass</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.bridges">
<code class="descname">bridges</code><span class="sig-paren">(</span><em>G</em>, <em>labels=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.bridges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the bridges (or cut edges).</p>
<p>A bridge is an edge whose deletion disconnects the undirected graph.
A disconnected graph has no bridge.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">False</span></code>, each bridge is a
tuple <span class="math notranslate nohighlight">\((u, v)\)</span> of vertices</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.connectivity</span> <span class="kn">import</span> <span class="n">bridges</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.connectivity</span> <span class="kn">import</span> <span class="n">is_connected</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">is_connected</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">bridges</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">[(1, 10, None)]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">bridges</span><span class="p">()</span>
<span class="go">[(1, 10, None)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.centrality_degree">
<code class="descname">centrality_degree</code><span class="sig-paren">(</span><em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.centrality_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the degree centrality of a vertex.</p>
<p>The degree centrality of a vertex <span class="math notranslate nohighlight">\(v\)</span> is its degree, divided by
<span class="math notranslate nohighlight">\(|V(G)|-1\)</span>. For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Centrality">Wikipedia article Centrality</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">v</span></code> – a vertex (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); set to <code class="docutils literal notranslate"><span class="pre">None</span></code> (default) to
get a dictionary associating each vertex with its centrality degree.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.centrality_closeness" title="sage.graphs.generic_graph.GenericGraph.centrality_closeness"><code class="xref py py-meth docutils literal notranslate"><span class="pre">centrality_closeness()</span></code></a></li>
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.centrality_betweenness" title="sage.graphs.generic_graph.GenericGraph.centrality_betweenness"><code class="xref py py-meth docutils literal notranslate"><span class="pre">centrality_betweenness()</span></code></a></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">())</span><span class="o">.</span><span class="n">centrality_degree</span><span class="p">()</span>
<span class="go">{0: 4/11, 1: 4/11, 2: 4/11, 3: 4/11,  4: 4/11,  5: 4/11,</span>
<span class="go"> 6: 4/11, 7: 4/11, 8: 4/11, 9: 4/11, 10: 4/11, 11: 4/11}</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DiamondGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">centrality_degree</span><span class="p">()</span>
<span class="go">{0: 2/3, 1: 1, 2: 1, 3: 2/3}</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">centrality_degree</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.chromatic_index">
<code class="descname">chromatic_index</code><span class="sig-paren">(</span><em>solver=None</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.chromatic_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chromatic index of the graph.</p>
<p>The chromatic index is the minimal number of colors needed to properly
color the edges of the graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify the Linear Program (LP)
solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</li>
</ul>
<p>This method is a frontend for method
<a class="reference internal" href="graph_coloring.html#sage.graphs.graph_coloring.edge_coloring" title="sage.graphs.graph_coloring.edge_coloring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.graphs.graph_coloring.edge_coloring()</span></code></a> that uses a mixed
integer-linear programming formulation to compute the chromatic index.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Edge_coloring">Wikipedia article Edge_coloring</a> for further details on edge coloring</li>
<li><a class="reference internal" href="graph_coloring.html#sage.graphs.graph_coloring.edge_coloring" title="sage.graphs.graph_coloring.edge_coloring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.graphs.graph_coloring.edge_coloring()</span></code></a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.fractional_chromatic_index" title="sage.graphs.graph.Graph.fractional_chromatic_index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fractional_chromatic_index()</span></code></a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.chromatic_number" title="sage.graphs.graph.Graph.chromatic_number"><code class="xref py py-meth docutils literal notranslate"><span class="pre">chromatic_number()</span></code></a></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>The clique <span class="math notranslate nohighlight">\(K_n\)</span> has chromatic index <span class="math notranslate nohighlight">\(n\)</span> when <span class="math notranslate nohighlight">\(n\)</span> is odd and <span class="math notranslate nohighlight">\(n-1\)</span> when
<span class="math notranslate nohighlight">\(n\)</span> is even:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_index</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_index</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_index</span><span class="p">()</span>
<span class="go">5</span>
</pre></div>
</div>
<p>The path <span class="math notranslate nohighlight">\(P_n\)</span> with <span class="math notranslate nohighlight">\(n \geq 2\)</span> has chromatic index 2:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_index</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
<p>The windmill graph with parameters <span class="math notranslate nohighlight">\(k,n\)</span> has chromatic index <span class="math notranslate nohighlight">\((k-1)n\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">k</span><span class="p">,</span><span class="n">n</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span><span class="mi">4</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">WindmillGraph</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">chromatic_index</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.chromatic_number">
<code class="descname">chromatic_number</code><span class="sig-paren">(</span><em>algorithm='DLX'</em>, <em>solver=None</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.chromatic_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimal number of colors needed to color the vertices of the
graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – Select an algorithm from the following supported
algorithms:<ul>
<li>If <code class="docutils literal notranslate"><span class="pre">algorithm=&quot;DLX&quot;</span></code> (default), the chromatic number is computed
using the dancing link algorithm. It is inefficient speedwise to
compute the chromatic number through the dancing link algorithm
because this algorithm computes <em>all</em> the possible colorings to
check that one exists.</li>
<li>If <code class="docutils literal notranslate"><span class="pre">algorithm=&quot;CP&quot;</span></code>, the chromatic number is computed using the
coefficients of the chromatic polynomial. Again, this method is
inefficient in terms of speed and it only useful for small graphs.</li>
<li>If <code class="docutils literal notranslate"><span class="pre">algorithm=&quot;MILP&quot;</span></code>, the chromatic number is computed using a
mixed integer linear program. The performance of this implementation
is affected by whether optional MILP solvers have been installed
(see the <a class="reference external" href="../../../numerical/sage/numerical/mip.html#module-sage.numerical.mip" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">MILP</span> <span class="pre">module</span></code></a>, or Sage’s tutorial
on Linear Programming).</li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Linear Program (LP)
solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve()</span></code></a>
of the class <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of verbosity
for the MILP algorithm. Its default value is 0, which means <em>quiet</em>.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">For more functions related to graph coloring, see the module
<a class="reference internal" href="graph_coloring.html#module-sage.graphs.graph_coloring" title="sage.graphs.graph_coloring"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.graphs.graph_coloring</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;DLX&quot;</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;MILP&quot;</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;CP&quot;</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>A bipartite graph has (by definition) chromatic number 2:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">RandomBipartite</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mf">0.7</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
<p>A complete multipartite graph with k parts has chromatic number <span class="math notranslate nohighlight">\(k\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteMultipartiteGraph</span><span class="p">([</span><span class="mi">5</span><span class="p">]</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">()</span> <span class="o">==</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The complete graph has the largest chromatic number from all the graphs
of order <span class="math notranslate nohighlight">\(n\)</span>. Namely its chromatic number is <span class="math notranslate nohighlight">\(n\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">()</span> <span class="o">==</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Kneser graph with parameters <span class="math notranslate nohighlight">\((n, 2)\)</span> for <span class="math notranslate nohighlight">\(n &gt; 3\)</span> has chromatic
number <span class="math notranslate nohighlight">\(n-2\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">KneserGraph</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">()</span> <span class="o">==</span> <span class="n">i</span><span class="o">-</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Flower Snark graph has chromatic index 4 hence its line graph has
chromatic number 4:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">FlowerSnark</span><span class="p">()</span><span class="o">.</span><span class="n">line_graph</span><span class="p">()</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.chromatic_polynomial">
<code class="descname">chromatic_polynomial</code><span class="sig-paren">(</span><em>G</em>, <em>return_tree_basis=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.chromatic_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the chromatic polynomial of the graph G.</p>
<p>The algorithm used is a recursive one, based on the following observations
of Read:</p>
<blockquote>
<div><ul class="simple">
<li>The chromatic polynomial of a tree on n vertices is x(x-1)^(n-1).</li>
<li>If e is an edge of G, G’ is the result of deleting the edge e, and G’’
is the result of contracting e, then the chromatic polynomial of G is
equal to that of G’ minus that of G’‘.</li>
</ul>
</div></blockquote>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span>
<span class="go">x^4 - 4*x^3 + 6*x^2 - 3*x</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span>
<span class="go">x^3 - 3*x^2 + 2*x</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span>
<span class="go">x^8 - 12*x^7 + 66*x^6 - 214*x^5 + 441*x^4 - 572*x^3 + 423*x^2 - 133*x</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span>
<span class="go">x^10 - 15*x^9 + 105*x^8 - 455*x^7 + 1353*x^6 - 2861*x^5 + 4275*x^4 - 4305*x^3 + 2606*x^2 - 704*x</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span>
<span class="go">x^6 - 9*x^5 + 36*x^4 - 75*x^3 + 78*x^2 - 31*x</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">(x - 1) * x</span>
<span class="go">(x - 2) * (x - 1) * x</span>
<span class="go">(x - 3) * (x - 2) * (x - 1) * x</span>
<span class="go">(x - 4) * (x - 3) * (x - 2) * (x - 1) * x</span>
<span class="go">(x - 5) * (x - 4) * (x - 3) * (x - 2) * (x - 1) * x</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">(x - 2) * (x - 1) * x * (x^2 - 2*x + 2)</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">OctahedralGraph</span><span class="p">()</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">(x - 2) * (x - 1) * x * (x^3 - 9*x^2 + 29*x - 32)</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">WheelGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">(x - 2) * (x - 1) * x * (x^2 - 5*x + 7)</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">WheelGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">(x - 3) * (x - 2) * (x - 1) * x * (x^2 - 4*x + 5)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">LCFGraph</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">],</span> <span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span>  <span class="c1"># long time (6s on sage.math, 2011)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># long time</span>
<span class="go">0</span>
</pre></div>
</div>
<p>By definition, the chromatic number of a graph G is the least integer k such that
the chromatic polynomial of G is strictly positive at k:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">min</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">if</span> <span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mf">0.7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">min</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">if</span> <span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.chromatic_quasisymmetric_function">
<code class="descname">chromatic_quasisymmetric_function</code><span class="sig-paren">(</span><em>t=None</em>, <em>R=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.chromatic_quasisymmetric_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chromatic quasisymmetric function of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Let <span class="math notranslate nohighlight">\(G\)</span> be a graph whose vertex set is totally ordered. The chromatic
quasisymmetric function <span class="math notranslate nohighlight">\(X_G(t)\)</span> was first described in <a class="reference internal" href="../../../references/index.html#sw2012" id="id1">[SW2012]</a>. We
use the equivalent definition given in <a class="reference internal" href="../../../references/index.html#bc2018" id="id2">[BC2018]</a>:</p>
<div class="math notranslate nohighlight">
\[X_G(t) = \sum_{\sigma=(\sigma_1,\ldots,\sigma_n)}
t^{\operatorname{asc}(\sigma)}
M_{|\sigma_1|,\ldots,|\sigma_n|},\]</div>
<p>where we sum over all ordered set partitions of the vertex set of <span class="math notranslate nohighlight">\(G\)</span>
such that each block <span class="math notranslate nohighlight">\(\sigma_i\)</span> is an independent (i.e., stable) set of
<span class="math notranslate nohighlight">\(G\)</span>, and where <span class="math notranslate nohighlight">\(\operatorname{asc}(\sigma)\)</span> denotes the number of edges
<span class="math notranslate nohighlight">\(\{u, v\}\)</span> of <span class="math notranslate nohighlight">\(G\)</span> such that <span class="math notranslate nohighlight">\(u &lt; v\)</span> and <span class="math notranslate nohighlight">\(v\)</span> appears in a later part of
<span class="math notranslate nohighlight">\(\sigma\)</span> than <span class="math notranslate nohighlight">\(u\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">t</span></code> – (optional) the parameter <span class="math notranslate nohighlight">\(t\)</span>; uses the variable <span class="math notranslate nohighlight">\(t\)</span> in
<span class="math notranslate nohighlight">\(\ZZ[t]\)</span> by default</li>
<li><code class="docutils literal notranslate"><span class="pre">R</span></code> – (optional) the base ring for the quasisymmetric functions;
uses the parent of <span class="math notranslate nohighlight">\(t\)</span> by default</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">chromatic_quasisymmetric_function</span><span class="p">()</span>
<span class="go">(2*t^2+2*t+2)*M[1, 1, 1] + M[1, 2] + t^2*M[2, 1]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">XG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_quasisymmetric_function</span><span class="p">();</span> <span class="n">XG</span>
<span class="go">(t^3+11*t^2+11*t+1)*M[1, 1, 1, 1] + (3*t^2+3*t)*M[1, 1, 2]</span>
<span class="go"> + (3*t^2+3*t)*M[1, 2, 1] + (3*t^2+3*t)*M[2, 1, 1]</span>
<span class="go"> + (t^2+t)*M[2, 2]</span>
<span class="gp">sage: </span><span class="n">XG</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="go">(t^3+11*t^2+11*t+1)*m[1, 1, 1, 1] + (3*t^2+3*t)*m[2, 1, 1]</span>
<span class="go"> + (t^2+t)*m[2, 2]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">chromatic_quasisymmetric_function</span><span class="p">()</span>
<span class="go">(t^6+3*t^5+5*t^4+6*t^3+5*t^2+3*t+1)*M[1, 1, 1, 1]</span>
</pre></div>
</div>
<p>Not all chromatic quasisymmetric functions are symmetric:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">chromatic_quasisymmetric_function</span><span class="p">()</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We check that at <span class="math notranslate nohighlight">\(t = 1\)</span>, we recover the usual chromatic symmetric
function:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">XG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_quasisymmetric_function</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span> <span class="n">XG</span>
<span class="go">120*M[1, 1, 1, 1, 1] + 30*M[1, 1, 1, 2] + 30*M[1, 1, 2, 1]</span>
<span class="go"> + 30*M[1, 2, 1, 1] + 10*M[1, 2, 2] + 30*M[2, 1, 1, 1]</span>
<span class="go"> + 10*M[2, 1, 2] + 10*M[2, 2, 1]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="n">XG</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">())</span>
<span class="go">p[1, 1, 1, 1, 1] - 5*p[2, 1, 1, 1] + 5*p[2, 2, 1]</span>
<span class="go"> + 5*p[3, 1, 1] - 5*p[3, 2] - 5*p[4, 1] + 4*p[5]</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">ClawGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">XG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_quasisymmetric_function</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span> <span class="n">XG</span>
<span class="go">24*M[1, 1, 1, 1] + 6*M[1, 1, 2] + 6*M[1, 2, 1] + M[1, 3]</span>
<span class="go"> + 6*M[2, 1, 1] + M[3, 1]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="n">XG</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">())</span>
<span class="go">p[1, 1, 1, 1] - 3*p[2, 1, 1] + 3*p[3, 1] - p[4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.chromatic_symmetric_function">
<code class="descname">chromatic_symmetric_function</code><span class="sig-paren">(</span><em>R=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.chromatic_symmetric_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chromatic symmetric function of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Let <span class="math notranslate nohighlight">\(G\)</span> be a graph. The chromatic symmetric function <span class="math notranslate nohighlight">\(X_G\)</span> was described
in <a class="reference internal" href="../../../references/index.html#sta1995" id="id3">[Sta1995]</a>, specifically Theorem 2.5 states that</p>
<div class="math notranslate nohighlight">
\[X_G = \sum_{F \subseteq E(G)} (-1)^{|F|} p_{\lambda(F)},\]</div>
<p>where <span class="math notranslate nohighlight">\(\lambda(F)\)</span> is the partition of the sizes of the connected
components of the subgraph induced by the edges <span class="math notranslate nohighlight">\(F\)</span> and <span class="math notranslate nohighlight">\(p_{\mu}\)</span> is the
powersum symmetric function.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">R</span></code> – (optional) the base ring for the symmetric functions;
this uses <span class="math notranslate nohighlight">\(\ZZ\)</span> by default</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">XG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_symmetric_function</span><span class="p">();</span> <span class="n">XG</span>
<span class="go">p[1, 1, 1, 1, 1] - 5*p[2, 1, 1, 1] + 5*p[2, 2, 1]</span>
<span class="go"> + 5*p[3, 1, 1] - 5*p[3, 2] - 5*p[4, 1] + 4*p[5]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">XG</span><span class="p">)</span>
<span class="go">30*s[1, 1, 1, 1, 1] + 10*s[2, 1, 1, 1] + 10*s[2, 2, 1]</span>
</pre></div>
</div>
<p>Not all graphs have a positive Schur expansion:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">ClawGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">XG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_symmetric_function</span><span class="p">();</span> <span class="n">XG</span>
<span class="go">p[1, 1, 1, 1] - 3*p[2, 1, 1] + 3*p[3, 1] - p[4]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">XG</span><span class="p">)</span>
<span class="go">8*s[1, 1, 1, 1] + 5*s[2, 1, 1] - s[2, 2] + s[3, 1]</span>
</pre></div>
</div>
<p>We show that given a triangle <span class="math notranslate nohighlight">\(\{e_1, e_2, e_3\}\)</span>, we have
<span class="math notranslate nohighlight">\(X_G = X_{G - e_1} + X_{G - e_2} - X_{G - e_1 - e_2}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">XG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">chromatic_symmetric_function</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G1</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G1</span><span class="o">.</span><span class="n">delete_edge</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">XG1</span> <span class="o">=</span> <span class="n">G1</span><span class="o">.</span><span class="n">chromatic_symmetric_function</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G2</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G2</span><span class="o">.</span><span class="n">delete_edge</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">XG2</span> <span class="o">=</span> <span class="n">G2</span><span class="o">.</span><span class="n">chromatic_symmetric_function</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G3</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">G1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G3</span><span class="o">.</span><span class="n">delete_edge</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">XG3</span> <span class="o">=</span> <span class="n">G3</span><span class="o">.</span><span class="n">chromatic_symmetric_function</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">XG</span> <span class="o">==</span> <span class="n">XG1</span> <span class="o">+</span> <span class="n">XG2</span> <span class="o">-</span> <span class="n">XG3</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.cleave">
<code class="descname">cleave</code><span class="sig-paren">(</span><em>G</em>, <em>cut_vertices=None</em>, <em>virtual_edges=True</em>, <em>solver=None</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.cleave" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the connected subgraphs separated by the input vertex cut.</p>
<p>Given a connected (multi)graph <span class="math notranslate nohighlight">\(G\)</span> and a vertex cut <span class="math notranslate nohighlight">\(X\)</span>, this method
computes the list of subgraphs of <span class="math notranslate nohighlight">\(G\)</span> induced by each connected component
<span class="math notranslate nohighlight">\(c\)</span> of <span class="math notranslate nohighlight">\(G\setminus X\)</span> plus <span class="math notranslate nohighlight">\(X\)</span>, i.e., <span class="math notranslate nohighlight">\(G[c\cup X]\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">G</span></code> – a Graph.</li>
<li><code class="docutils literal notranslate"><span class="pre">cut_vertices</span></code> – iterable container of vertices (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a
set of vertices representing a vertex cut of <code class="docutils literal notranslate"><span class="pre">G</span></code>. If no vertex cut is
given, the method will compute one via a call to
<a class="reference internal" href="connectivity.html#sage.graphs.connectivity.vertex_connectivity" title="sage.graphs.connectivity.vertex_connectivity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertex_connectivity()</span></code></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">virtual_edges</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether to add virtual
edges to the sides of the cut or not. A virtual edge is an edge between a
pair of vertices of the cut that are not connected by an edge in <code class="docutils literal notranslate"><span class="pre">G</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specifies a Linear Program (LP)
solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For more
information on LP solvers and which default solver is used, see the method
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.numerical.mip.MixedIntegerLinearProgram.solve()</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.numerical.mip.MixedIntegerLinearProgram</span></code></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of verbosity. Set
to 0 by default, which means quiet.</li>
</ul>
<p>OUTPUT: A triple <span class="math notranslate nohighlight">\((S, C, f)\)</span>, where</p>
<ul class="simple">
<li><span class="math notranslate nohighlight">\(S\)</span> is a list of the graphs that are sides of the vertex cut.</li>
<li><span class="math notranslate nohighlight">\(C\)</span> is the graph of the cocycles. For each pair of vertices of the cut,
if there exists an edge between them, <span class="math notranslate nohighlight">\(C\)</span> has one copy of each edge
connecting them in <code class="docutils literal notranslate"><span class="pre">G</span></code> per sides of the cut plus one extra copy.
Furthermore, when <code class="docutils literal notranslate"><span class="pre">virtual_edges</span> <span class="pre">==</span> <span class="pre">True</span></code>, if a pair of vertices of the
cut is not connected by an edge in <code class="docutils literal notranslate"><span class="pre">G</span></code>, then it has one virtual edge
between them per sides of the cut.</li>
<li><span class="math notranslate nohighlight">\(f\)</span> is the complement of the subgraph of <code class="docutils literal notranslate"><span class="pre">G</span></code> induced by the vertex
cut. Hence, its vertex set is the vertex cut, and its edge set is the set
of virtual edges (i.e., edges between pairs of vertices of the cut that
are not connected by an edge in <code class="docutils literal notranslate"><span class="pre">G</span></code>). When <code class="docutils literal notranslate"><span class="pre">virtual_edges</span> <span class="pre">==</span> <span class="pre">False</span></code>,
the edge set is empty.</li>
</ul>
<p>EXAMPLES:</p>
<p>If there is an edge between cut vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.connectivity</span> <span class="kn">import</span> <span class="n">cleave</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">G</span><span class="o">.</span><span class="n">add_clique</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(),</span> <span class="n">G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">()])</span>
<span class="gp">sage: </span><span class="n">S1</span><span class="p">,</span><span class="n">C1</span><span class="p">,</span><span class="n">f1</span> <span class="o">=</span> <span class="n">cleave</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cut_vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">S1</span><span class="p">]</span>
<span class="go">[4, 4, 4]</span>
<span class="gp">sage: </span><span class="n">C1</span><span class="o">.</span><span class="n">order</span><span class="p">(),</span> <span class="n">C1</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">(2, 4)</span>
<span class="gp">sage: </span><span class="n">f1</span><span class="o">.</span><span class="n">vertices</span><span class="p">(),</span> <span class="n">f1</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">([0, 1], [])</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">virtual_edges</span> <span class="pre">==</span> <span class="pre">False</span></code> and there is an edge between cut vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span> <span class="o">==</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[]])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="p">,</span><span class="n">C2</span><span class="p">,</span><span class="n">f2</span> <span class="o">=</span> <span class="n">cleave</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cut_vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">virtual_edges</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S1</span> <span class="o">==</span> <span class="n">S2</span><span class="p">,</span> <span class="n">C1</span> <span class="o">==</span> <span class="n">C2</span><span class="p">,</span> <span class="n">f1</span> <span class="o">==</span> <span class="n">f2</span><span class="p">)</span>
<span class="go">(True, True, True)</span>
</pre></div>
</div>
<p>If cut vertices doesn’t have edge between them:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">delete_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S1</span><span class="p">,</span><span class="n">C1</span><span class="p">,</span><span class="n">f1</span> <span class="o">=</span> <span class="n">cleave</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cut_vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">S1</span><span class="p">]</span>
<span class="go">[4, 4, 4]</span>
<span class="gp">sage: </span><span class="n">C1</span><span class="o">.</span><span class="n">order</span><span class="p">(),</span> <span class="n">C1</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">(2, 3)</span>
<span class="gp">sage: </span><span class="n">f1</span><span class="o">.</span><span class="n">vertices</span><span class="p">(),</span> <span class="n">f1</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">([0, 1], [(0, 1, None)])</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">virtual_edges</span> <span class="pre">==</span> <span class="pre">False</span></code> and the cut vertices are not connected by an
edge:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span> <span class="o">==</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[]])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="p">,</span><span class="n">C2</span><span class="p">,</span><span class="n">f2</span> <span class="o">=</span> <span class="n">cleave</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cut_vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">virtual_edges</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">S2</span><span class="p">]</span>
<span class="go">[4, 4, 4]</span>
<span class="gp">sage: </span><span class="n">C2</span><span class="o">.</span><span class="n">order</span><span class="p">(),</span> <span class="n">C2</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">(2, 0)</span>
<span class="gp">sage: </span><span class="n">f2</span><span class="o">.</span><span class="n">vertices</span><span class="p">(),</span> <span class="n">f2</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">([0, 1], [])</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S1</span> <span class="o">==</span> <span class="n">S2</span><span class="p">,</span> <span class="n">C1</span> <span class="o">==</span> <span class="n">C2</span><span class="p">,</span> <span class="n">f1</span> <span class="o">==</span> <span class="n">f2</span><span class="p">)</span>
<span class="go">(False, False, False)</span>
</pre></div>
</div>
<p>If <span class="math notranslate nohighlight">\(G\)</span> is a biconnected multigraph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_multiple_edges</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="n">f</span> <span class="o">=</span> <span class="n">cleave</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cut_vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">S</span><span class="p">:</span>
<span class="gp">....: </span>    <span class="k">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[(0, 1), (0, 1), (0, 1), (0, 2), (0, 2), (0, 3), (0, 3), (1, 2), (1, 2), (1, 3), (1, 3), (2, 3), (2, 3)]</span>
<span class="go">[(0, 1), (0, 1), (0, 1), (0, 4), (0, 4), (1, 4), (1, 4)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.clique_complex">
<code class="descname">clique_complex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.clique_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the clique complex of self.</p>
<p>This is the largest simplicial complex on the vertices of self whose
1-skeleton is self.</p>
<p>This is only makes sense for undirected simple graphs.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span><span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">clique_complex</span><span class="p">()</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 4) and facets {(4,), (0, 1, 2)}</span>

<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">clique_complex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3, 4) and facets {(0, 1, 4), (0, 1, 2, 3)}</span>
<span class="gp">sage: </span><span class="n">i</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">i</span><span class="o">==</span><span class="n">h</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">==</span><span class="n">i</span><span class="o">.</span><span class="n">clique_complex</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.clique_maximum">
<code class="descname">clique_maximum</code><span class="sig-paren">(</span><em>algorithm='Cliquer'</em>, <em>solver=None</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.clique_maximum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex set of a maximal order complete subgraph.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – the algorithm to be used :</p>
<ul>
<li><p class="first">If <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;Cliquer&quot;</span></code> (default), wraps the C program
Cliquer <a class="reference internal" href="../../../references/index.html#no2003" id="id4">[NO2003]</a>.</p>
</li>
<li><p class="first">If <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;MILP&quot;</span></code>, the problem is solved through a Mixed
Integer Linear Program.</p>
<p>(see <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>)</p>
</li>
<li><p class="first">If <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;mcqd&quot;</span></code>, uses the MCQD solver
(<a class="reference external" href="http://www.sicmm.org/~konc/maxclique/">http://www.sicmm.org/~konc/maxclique/</a>). Note that the MCQD
package must be installed.</p>
</li>
</ul>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Linear Program (LP)
solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p>
</li>
</ul>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">solver</span></code> and <code class="docutils literal notranslate"><span class="pre">verbose</span></code> are used only when
<code class="docutils literal notranslate"><span class="pre">algorithm=&quot;MILP&quot;</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently only implemented for undirected graphs. Use to_undirected
to convert a digraph to an undirected graph.</p>
</div>
<p>ALGORITHM:</p>
<p>This function is based on Cliquer <a class="reference internal" href="../../../references/index.html#no2003" id="id5">[NO2003]</a>.</p>
<p>EXAMPLES:</p>
<p>Using Cliquer (default):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">clique_maximum</span><span class="p">()</span>
<span class="go">[7, 9]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;DJ{&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">clique_maximum</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4]</span>
</pre></div>
</div>
<p>Through a Linear Program:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">clique_maximum</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;MILP&quot;</span><span class="p">))</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.clique_number">
<code class="descname">clique_number</code><span class="sig-paren">(</span><em>algorithm='Cliquer'</em>, <em>cliques=None</em>, <em>solver=None</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.clique_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the order of the largest clique of the graph</p>
<p>This is also called as the clique number.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently only implemented for undirected graphs. Use <code class="docutils literal notranslate"><span class="pre">to_undirected</span></code>
to convert a digraph to an undirected graph.</p>
</div>
<p>INPUT:</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – the algorithm to be used :</p>
<ul>
<li><p class="first">If <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;Cliquer&quot;</span></code>, wraps the C program Cliquer
<a class="reference internal" href="../../../references/index.html#no2003" id="id6">[NO2003]</a>.</p>
</li>
<li><p class="first">If <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;networkx&quot;</span></code>, uses the NetworkX’s implementation of
the Bron and Kerbosch Algorithm <a class="reference internal" href="../../../references/index.html#bk1973" id="id7">[BK1973]</a>.</p>
</li>
<li><p class="first">If <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;MILP&quot;</span></code>, the problem is solved through a Mixed
Integer Linear Program.</p>
<p>(see <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>)</p>
</li>
<li><p class="first">If <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;mcqd&quot;</span></code>, uses the MCQD solver
(<a class="reference external" href="http://www.sicmm.org/~konc/maxclique/">http://www.sicmm.org/~konc/maxclique/</a>). Note that the MCQD
package must be installed.</p>
</li>
</ul>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">cliques</span></code> – an optional list of cliques that can be input if
already computed. Ignored unless <code class="docutils literal notranslate"><span class="pre">algorithm==&quot;networkx&quot;</span></code>.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Linear Program (LP)
solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</p>
</li>
</ul>
<p>ALGORITHM:</p>
<p>This function is based on Cliquer <a class="reference internal" href="../../../references/index.html#no2003" id="id9">[NO2003]</a> and <a class="reference internal" href="../../../references/index.html#bk1973" id="id10">[BK1973]</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;DJ{&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">clique_number</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">clique_number</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>By definition the clique number of a complete graph is its order:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">clique_number</span><span class="p">()</span> <span class="o">==</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">15</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A non-empty graph without edges has a clique number of 1:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">((</span><span class="n">i</span><span class="o">*</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">clique_number</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">15</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A complete multipartite graph with k parts has clique number k:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">((</span><span class="n">i</span><span class="o">*</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteMultipartiteGraph</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="p">[</span><span class="mi">5</span><span class="p">]))</span><span class="o">.</span><span class="n">clique_number</span><span class="p">()</span> <span class="o">==</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.clique_polynomial">
<code class="descname">clique_polynomial</code><span class="sig-paren">(</span><em>t=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.clique_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the clique polynomial of self.</p>
<p>This is the polynomial where the coefficient of <span class="math notranslate nohighlight">\(t^n\)</span> is the number of
cliques in the graph with <span class="math notranslate nohighlight">\(n\)</span> vertices. The constant term of the clique
polynomial is always taken to be one.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">clique_polynomial</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">clique_polynomial</span><span class="p">()</span>
<span class="go">t^2 + 2*t + 1</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">clique_polynomial</span><span class="p">()</span>
<span class="go">4*t^2 + 4*t + 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.cliques_containing_vertex">
<code class="descname">cliques_containing_vertex</code><span class="sig-paren">(</span><em>vertices=None</em>, <em>cliques=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.cliques_containing_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cliques containing each vertex, represented as a dictionary
of lists of lists, keyed by vertex.</p>
<p>Returns a single list if only one input vertex.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently only implemented for undirected graphs. Use to_undirected
to convert a digraph to an undirected graph.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – the vertices to inspect (default is entire graph)</li>
<li><code class="docutils literal notranslate"><span class="pre">cliques</span></code> – list of cliques (if already computed)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;DJ{&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_containing_vertex</span><span class="p">()</span>
<span class="go">{0: [[4, 0]], 1: [[4, 1, 2, 3]], 2: [[4, 1, 2, 3]], 3: [[4, 1, 2, 3]], 4: [[4, 0], [4, 1, 2, 3]]}</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">cliques_maximal</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">E</span>
<span class="go">[[0, 4], [1, 2, 3, 4]]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_containing_vertex</span><span class="p">(</span><span class="n">cliques</span><span class="o">=</span><span class="n">E</span><span class="p">)</span>
<span class="go">{0: [[0, 4]], 1: [[1, 2, 3, 4]], 2: [[1, 2, 3, 4]], 3: [[1, 2, 3, 4]], 4: [[0, 4], [1, 2, 3, 4]]}</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cliques_containing_vertex</span><span class="p">()</span>
<span class="go">{0: [[0, 1, 2], [0, 1, 3]], 1: [[0, 1, 2], [0, 1, 3]], 2: [[0, 1, 2]], 3: [[0, 1, 3]]}</span>
</pre></div>
</div>
<p>Since each clique of a 2 dimensional grid corresponds to an edge, the
number of cliques in which a vertex is involved equals its degree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">cliques_containing_vertex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">cliques</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">cliques</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">cliques_containing_vertex</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="go">{(0, 1): [[(0, 1), (0, 0)], [(0, 1), (0, 2)], [(0, 1), (1, 1)]]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.cliques_get_clique_bipartite">
<code class="descname">cliques_get_clique_bipartite</code><span class="sig-paren">(</span><em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.cliques_get_clique_bipartite" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a bipartite graph constructed such that maximal cliques are the
right vertices and the left vertices are retained from the given
graph. Right and left vertices are connected if the bottom vertex
belongs to the clique represented by a top vertex.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently only implemented for undirected graphs. Use to_undirected
to convert a digraph to an undirected graph.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">())</span><span class="o">.</span><span class="n">cliques_get_clique_bipartite</span><span class="p">()</span>
<span class="go">Bipartite graph on 36 vertices</span>
<span class="gp">sage: </span><span class="p">((</span><span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">())</span><span class="o">.</span><span class="n">cliques_get_clique_bipartite</span><span class="p">())</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">vertex_size</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">vertex_labels</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cliques_get_clique_bipartite</span><span class="p">()</span>
<span class="go">Bipartite graph on 6 vertices</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">cliques_get_clique_bipartite</span><span class="p">())</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.cliques_get_max_clique_graph">
<code class="descname">cliques_get_max_clique_graph</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.cliques_get_max_clique_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the clique graph.</p>
<p>Vertices of the result are the maximal cliques of the graph, and edges
of the result are between maximal cliques with common members in the
original graph.</p>
<p>For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Clique_graph">Wikipedia article Clique_graph</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently only implemented for undirected graphs. Use to_undirected
to convert a digraph to an undirected graph.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">())</span><span class="o">.</span><span class="n">cliques_get_max_clique_graph</span><span class="p">()</span>
<span class="go">Graph on 24 vertices</span>
<span class="gp">sage: </span><span class="p">((</span><span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">())</span><span class="o">.</span><span class="n">cliques_get_max_clique_graph</span><span class="p">())</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">vertex_size</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">vertex_labels</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cliques_get_max_clique_graph</span><span class="p">()</span>
<span class="go">Graph on 2 vertices</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">cliques_get_max_clique_graph</span><span class="p">())</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.cliques_maximal">
<code class="descname">cliques_maximal</code><span class="sig-paren">(</span><em>algorithm='native'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.cliques_maximal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of all maximal cliques.</p>
<p>Each clique is represented by a list of vertices. A clique is an induced
complete subgraph, and a maximal clique is one not contained in a larger
one.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – can be set to <code class="docutils literal notranslate"><span class="pre">&quot;native&quot;</span></code> (default) to use Sage’s
own implementation, or to <code class="docutils literal notranslate"><span class="pre">&quot;NetworkX&quot;</span></code> to use NetworkX’
implementation of the Bron and Kerbosch Algorithm <a class="reference internal" href="../../../references/index.html#bk1973" id="id11">[BK1973]</a>.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method sorts its output before returning it. If you prefer to
save the extra time, you can call
<a class="reference internal" href="independent_sets.html#sage.graphs.independent_sets.IndependentSets" title="sage.graphs.independent_sets.IndependentSets"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.graphs.independent_sets.IndependentSets</span></code></a> directly.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Sage’s implementation of the enumeration of <em>maximal</em> independent
sets is not much faster than NetworkX’ (expect a 2x speedup), which
is surprising as it is written in Cython. This being said, the
algorithm from NetworkX appears to be sligthly different from this
one, and that would be a good thing to explore if one wants to
improve the implementation.</p>
</div>
<p>ALGORITHM:</p>
<p>This function is based on NetworkX’s implementation of the Bron and
Kerbosch Algorithm <a class="reference internal" href="../../../references/index.html#bk1973" id="id12">[BK1973]</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">()</span><span class="o">.</span><span class="n">cliques_maximal</span><span class="p">()</span>
<span class="go">[[0, 1], [0, 4], [0, 6], [0, 9], [1, 2], [1, 5], [1, 7], [2, 3],</span>
<span class="go"> [2, 6], [2, 8], [3, 4], [3, 7], [3, 9], [4, 5], [4, 8], [5, 10],</span>
<span class="go"> [5, 11], [6, 10], [6, 11], [7, 8], [7, 11], [8, 10], [9, 10], [9, 11]]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cliques_maximal</span><span class="p">()</span>
<span class="go">[[0, 1, 2], [0, 1, 3]]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_maximal</span><span class="p">()</span>
<span class="go">[[0, 1], [0, 4], [0, 5], [1, 2], [1, 6], [2, 3], [2, 7], [3, 4],</span>
<span class="go"> [3, 8], [4, 9], [5, 7], [5, 8], [6, 8], [6, 9], [7, 9]]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;DJ{&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_maximal</span><span class="p">()</span>
<span class="go">[[0, 4], [1, 2, 3, 4]]</span>
</pre></div>
</div>
<p>Comparing the two implementations:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="o">.</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s1</span> <span class="o">=</span> <span class="n">Set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">cliques_maximal</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;NetworkX&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">s2</span> <span class="o">=</span> <span class="n">Set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">cliques_maximal</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;native&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.cliques_maximum">
<code class="descname">cliques_maximum</code><span class="sig-paren">(</span><em>graph</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.cliques_maximum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the vertex sets of <em>ALL</em> the maximum complete subgraphs.</p>
<p>Returns the list of all maximum cliques, with each clique represented by a
list of vertices. A clique is an induced complete subgraph, and a maximum
clique is one of maximal order.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently only implemented for undirected graphs. Use
<a class="reference internal" href="digraph.html#sage.graphs.digraph.DiGraph.to_undirected" title="sage.graphs.digraph.DiGraph.to_undirected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_undirected()</span></code></a> to convert a digraph
to an undirected graph.</p>
</div>
<p>ALGORITHM:</p>
<p>This function is based on Cliquer <a class="reference internal" href="../../../references/index.html#no2003" id="id13">[NO2003]</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">()</span><span class="o">.</span><span class="n">cliques_maximum</span><span class="p">()</span> <span class="c1"># indirect doctest</span>
<span class="go">[[0, 1], [0, 4], [0, 6], [0, 9], [1, 2], [1, 5], [1, 7], [2, 3],</span>
<span class="go"> [2, 6], [2, 8], [3, 4], [3, 7], [3, 9], [4, 5], [4, 8], [5, 10],</span>
<span class="go"> [5, 11], [6, 10], [6, 11], [7, 8], [7, 11], [8, 10], [9, 10], [9, 11]]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cliques_maximum</span><span class="p">()</span>
<span class="go">[[0, 1, 2], [0, 1, 3]]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_maximum</span><span class="p">()</span>
<span class="go">[[0, 1], [0, 4], [0, 5], [1, 2], [1, 6], [2, 3], [2, 7], [3, 4],</span>
<span class="go"> [3, 8], [4, 9], [5, 7], [5, 8], [6, 8], [6, 9], [7, 9]]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;DJ{&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_maximum</span><span class="p">()</span>
<span class="go">[[1, 2, 3, 4]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.cliques_number_of">
<code class="descname">cliques_number_of</code><span class="sig-paren">(</span><em>vertices=None</em>, <em>cliques=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.cliques_number_of" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary of the number of maximal cliques containing each
vertex, keyed by vertex.</p>
<p>This returns a single value if only one input vertex.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently only implemented for undirected graphs. Use to_undirected
to convert a digraph to an undirected graph.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – the vertices to inspect (default is entire graph)</li>
<li><code class="docutils literal notranslate"><span class="pre">cliques</span></code> – list of cliques (if already computed)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;DJ{&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_number_of</span><span class="p">()</span>
<span class="go">{0: 1, 1: 1, 2: 1, 3: 1, 4: 2}</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">cliques_maximal</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">E</span>
<span class="go">[[0, 4], [1, 2, 3, 4]]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_number_of</span><span class="p">(</span><span class="n">cliques</span><span class="o">=</span><span class="n">E</span><span class="p">)</span>
<span class="go">{0: 1, 1: 1, 2: 1, 3: 1, 4: 2}</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">cliques_number_of</span><span class="p">()</span>
<span class="go">{(0, 0): 2, (0, 1): 3, (0, 2): 2, (1, 0): 2, (1, 1): 3, (1, 2): 2}</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">cliques_number_of</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="go">{(0, 1): 3, (1, 2): 2}</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cliques_number_of</span><span class="p">()</span>
<span class="go">{0: 2, 1: 2, 2: 1, 3: 1}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.cliques_vertex_clique_number">
<code class="descname">cliques_vertex_clique_number</code><span class="sig-paren">(</span><em>algorithm='cliquer'</em>, <em>vertices=None</em>, <em>cliques=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.cliques_vertex_clique_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary of sizes of the largest maximal cliques containing
each vertex, keyed by vertex.</p>
<p>Returns a single value if only one input vertex.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently only implemented for undirected graphs. Use to_undirected
to convert a digraph to an undirected graph.</p>
</div>
<p>INPUT:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – either <code class="docutils literal notranslate"><span class="pre">cliquer</span></code> or <code class="docutils literal notranslate"><span class="pre">networkx</span></code><ul>
<li><code class="docutils literal notranslate"><span class="pre">cliquer</span></code> – This wraps the C program Cliquer <a class="reference internal" href="../../../references/index.html#no2003" id="id14">[NO2003]</a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">networkx</span></code> – This function is based on NetworkX’s implementation
of the Bron and Kerbosch Algorithm <a class="reference internal" href="../../../references/index.html#bk1973" id="id15">[BK1973]</a>.</li>
</ul>
</li>
</ul>
</div></blockquote>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – the vertices to inspect (default is entire graph).
Ignored unless <code class="docutils literal notranslate"><span class="pre">algorithm=='networkx'</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">cliques</span></code> – list of cliques (if already computed).  Ignored unless
<code class="docutils literal notranslate"><span class="pre">algorithm=='networkx'</span></code>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;DJ{&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_vertex_clique_number</span><span class="p">()</span>
<span class="go">{0: 2, 1: 4, 2: 4, 3: 4, 4: 4}</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">cliques_maximal</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">E</span>
<span class="go">[[0, 4], [1, 2, 3, 4]]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cliques_vertex_clique_number</span><span class="p">(</span><span class="n">cliques</span><span class="o">=</span><span class="n">E</span><span class="p">,</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;networkx&quot;</span><span class="p">)</span>
<span class="go">{0: 2, 1: 4, 2: 4, 3: 4, 4: 4}</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">cliques_vertex_clique_number</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;networkx&quot;</span><span class="p">)</span>
<span class="go">{(0, 0): 2, (0, 1): 2, (0, 2): 2, (1, 0): 2, (1, 1): 2, (1, 2): 2}</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">cliques_vertex_clique_number</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="go">{(0, 1): 2, (1, 2): 2}</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cliques_vertex_clique_number</span><span class="p">()</span>
<span class="go">{0: 3, 1: 3, 2: 3, 3: 3}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.coloring">
<code class="descname">coloring</code><span class="sig-paren">(</span><em>algorithm='DLX'</em>, <em>hex_colors=False</em>, <em>solver=None</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.coloring" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the first (optimal) proper vertex-coloring found.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – Select an algorithm from the following supported
algorithms:<ul>
<li>If <code class="docutils literal notranslate"><span class="pre">algorithm=&quot;DLX&quot;</span></code> (default), the coloring is computed using the
dancing link algorithm.</li>
<li>If <code class="docutils literal notranslate"><span class="pre">algorithm=&quot;MILP&quot;</span></code>, the coloring is computed using a mixed
integer linear program. The performance of this implementation is
affected by whether optional MILP solvers have been installed (see
the <a class="reference external" href="../../../numerical/sage/numerical/mip.html#module-sage.numerical.mip" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">MILP</span> <span class="pre">module</span></code></a>).</li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">hex_colors</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, return a
dictionary which can easily be used for plotting.</li>
<li><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Linear Program (LP)
solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve()</span></code></a>
of the class <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of verbosity
for the MILP algorithm. Its default value is 0, which means <em>quiet</em>.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">For more functions related to graph coloring, see the
module <a class="reference internal" href="graph_coloring.html#module-sage.graphs.graph_coloring" title="sage.graphs.graph_coloring"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.graphs.graph_coloring</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s2">&quot;Fooba&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">coloring</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;MILP&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">coloring</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;DLX&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">are_equal_colorings</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">Set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="n">A</span><span class="p">))</span> <span class="o">==</span> <span class="n">Set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="n">B</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">are_equal_colorings</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">are_equal_colorings</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">partition</span><span class="o">=</span><span class="n">P</span><span class="p">)</span>
<span class="go">Graphics object consisting of 16 graphics primitives</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">coloring</span><span class="p">(</span><span class="n">hex_colors</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;MILP&quot;</span><span class="p">)</span>
<span class="go">{&#39;#0000ff&#39;: [4], &#39;#00ff00&#39;: [0, 6, 5], &#39;#ff0000&#39;: [2, 1, 3]}</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">coloring</span><span class="p">(</span><span class="n">hex_colors</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;DLX&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span>
<span class="go">{&#39;#0000ff&#39;: [4], &#39;#00ff00&#39;: [1, 2, 3], &#39;#ff0000&#39;: [0, 5, 6]}</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">vertex_colors</span><span class="o">=</span><span class="n">H</span><span class="p">)</span>
<span class="go">Graphics object consisting of 16 graphics primitives</span>
</pre></div>
</div>
<div class="figure">
<img alt="../../_images/graph-1.svg" src="../../_images/graph-1.svg" /></div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.common_neighbors_matrix">
<code class="descname">common_neighbors_matrix</code><span class="sig-paren">(</span><em>vertices=None</em>, <em>nonedgesonly=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.common_neighbors_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a matrix of numbers of common neighbors between each pairs.</p>
<p>The <span class="math notranslate nohighlight">\((i , j)\)</span> entry of the matrix gives the number of common
neighbors between vertices <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>.</p>
<p>This method is only valid for simple (no loops, no multiple edges)
graphs.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">nonedgesonly</span></code>– boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, assigns
<span class="math notranslate nohighlight">\(0\)</span> value to adjacent vertices.</li>
<li><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – list (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the ordering of the
vertices defining how they should appear in the matrix. By default,
the ordering given by <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.vertices" title="sage.graphs.generic_graph.GenericGraph.vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GenericGraph.vertices()</span></code></a> is used.</li>
</ul>
<p>OUTPUT: matrix</p>
<p>EXAMPLES:</p>
<p>The common neighbors matrix  for a straight linear 2-tree counting
only non-adjacent vertex pairs</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G1</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G1</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G1</span><span class="o">.</span><span class="n">common_neighbors_matrix</span><span class="p">(</span><span class="n">nonedgesonly</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="go">[0 0 0 2 1 0]</span>
<span class="go">[0 0 0 0 2 1]</span>
<span class="go">[0 0 0 0 0 2]</span>
<span class="go">[2 0 0 0 0 0]</span>
<span class="go">[1 2 0 0 0 0]</span>
<span class="go">[0 1 2 0 0 0]</span>
</pre></div>
</div>
<p>We now show the common neighbors matrix which includes adjacent
vertices</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G1</span><span class="o">.</span><span class="n">common_neighbors_matrix</span><span class="p">(</span><span class="n">nonedgesonly</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="go">[0 1 1 2 1 0]</span>
<span class="go">[1 0 2 1 2 1]</span>
<span class="go">[1 2 0 2 1 2]</span>
<span class="go">[2 1 2 0 2 1]</span>
<span class="go">[1 2 1 2 0 1]</span>
<span class="go">[0 1 2 1 1 0]</span>
</pre></div>
</div>
<p>The common neighbors matrix  for a fan on 6 vertices counting only
non-adjacent vertex pairs</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">common_neighbors_matrix</span><span class="p">()</span>
<span class="go">[0 0 0 0 0 0 0]</span>
<span class="go">[0 0 0 2 1 1 1]</span>
<span class="go">[0 0 0 0 2 1 1]</span>
<span class="go">[0 2 0 0 0 2 1]</span>
<span class="go">[0 1 2 0 0 0 1]</span>
<span class="go">[0 1 1 2 0 0 1]</span>
<span class="go">[0 1 1 1 1 1 0]</span>
</pre></div>
</div>
<p>It is an error to input anything other than a simple graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span><span class="n">loops</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">common_neighbors_matrix</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: This method is not known to work on graphs with loops. </span>
<span class="go">Perhaps this method can be updated to handle them, but in the </span>
<span class="go">meantime if you want to use it please disallow loops using </span>
<span class="go">allow_loops().</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.graphs.graph.Graph.most_common_neighbors" title="sage.graphs.graph.Graph.most_common_neighbors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">most_common_neighbors()</span></code></a> –
returns node pairs with most shared neighbors</li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.convexity_properties">
<code class="descname">convexity_properties</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.convexity_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <code class="docutils literal notranslate"><span class="pre">ConvexityProperties</span></code> object corresponding to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This object contains the methods related to convexity in graphs (convex
hull, hull number) and caches useful information so that it becomes
comparatively cheaper to compute the convex hull of many different sets
of the same graph.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">In order to know what can be done through this object, please refer
to module <a class="reference internal" href="convexity_properties.html#module-sage.graphs.convexity_properties" title="sage.graphs.convexity_properties"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.graphs.convexity_properties</span></code></a>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>If you want to compute many convex hulls, keep this object in memory
! When it is created, it builds a table of useful information to
compute convex hulls. As a result</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">convexity_properties</span><span class="p">()</span><span class="o">.</span><span class="n">hull</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">convexity_properties</span><span class="p">()</span><span class="o">.</span><span class="n">hull</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="go">[2, 3, 7]</span>
</pre></div>
</div>
<p>Is a terrible waste of computations, while</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">CP</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">convexity_properties</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">CP</span><span class="o">.</span><span class="n">hull</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">CP</span><span class="o">.</span><span class="n">hull</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="go">[2, 3, 7]</span>
</pre></div>
</div>
<p class="last">Makes perfect sense.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.cores">
<code class="descname">cores</code><span class="sig-paren">(</span><em>k=None</em>, <em>with_labels=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.cores" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the core number for each vertex in an ordered list.</p>
<p>(for homomorphisms cores, see the <a class="reference internal" href="#sage.graphs.graph.Graph.has_homomorphism_to" title="sage.graphs.graph.Graph.has_homomorphism_to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.has_homomorphism_to()</span></code></a>
method)</p>
<p>DEFINITIONS:</p>
<ul>
<li><p class="first"><em>K-cores</em> in graph theory were introduced by Seidman in 1983 and by
Bollobas in 1984 as a method of (destructively) simplifying graph
topology to aid in analysis and visualization. They have been more
recently defined as the following by Batagelj et al:</p>
<p><em>Given a graph `G` with vertices set `V` and edges set `E`, the
`k`-core of `G` is the graph obtained from `G` by recursively removing
the vertices with degree less than `k`, for as long as there are any.</em></p>
<p>This operation can be useful to filter or to study some properties of
the graphs. For instance, when you compute the 2-core of graph G, you
are cutting all the vertices which are in a tree part of graph.  (A
tree is a graph with no loops). See the <a class="reference external" href="https://en.wikipedia.org/wiki/K-core">Wikipedia article K-core</a>.</p>
<p><a class="reference internal" href="../../../references/index.html#psw1996" id="id16">[PSW1996]</a> defines a <span class="math notranslate nohighlight">\(k\)</span>-core of <span class="math notranslate nohighlight">\(G\)</span> as the largest subgraph (it is
unique) of <span class="math notranslate nohighlight">\(G\)</span> with minimum degree at least <span class="math notranslate nohighlight">\(k\)</span>.</p>
</li>
<li><p class="first">Core number of a vertex</p>
<p>The core number of a vertex <span class="math notranslate nohighlight">\(v\)</span> is the largest integer <span class="math notranslate nohighlight">\(k\)</span> such that
<span class="math notranslate nohighlight">\(v\)</span> belongs to the <span class="math notranslate nohighlight">\(k\)</span>-core of <span class="math notranslate nohighlight">\(G\)</span>.</p>
</li>
<li><p class="first">Degeneracy</p>
<p>The <em>degeneracy</em> of a graph <span class="math notranslate nohighlight">\(G\)</span>, usually denoted <span class="math notranslate nohighlight">\(\delta^*(G)\)</span>, is the
smallest integer <span class="math notranslate nohighlight">\(k\)</span> such that the graph <span class="math notranslate nohighlight">\(G\)</span> can be reduced to the
empty graph by iteratively removing vertices of degree <span class="math notranslate nohighlight">\(\leq k\)</span>.
Equivalently, <span class="math notranslate nohighlight">\(\delta^*(G)=k\)</span> if <span class="math notranslate nohighlight">\(k\)</span> is the smallest integer such that
the <span class="math notranslate nohighlight">\(k\)</span>-core of <span class="math notranslate nohighlight">\(G\)</span> is empty.</p>
</li>
</ul>
<p>IMPLEMENTATION:</p>
<p>This implementation is based on the NetworkX implementation of the
algorithm described in <a class="reference internal" href="../../../references/index.html#bz2003" id="id17">[BZ2003]</a>.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">k</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>);</p>
<blockquote>
<div><ul class="simple">
<li>If <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">None</span></code> (default), returns the core number for each vertex.</li>
<li>If <code class="docutils literal notranslate"><span class="pre">k</span></code> is an integer, returns a pair <code class="docutils literal notranslate"><span class="pre">(ordering,</span> <span class="pre">core)</span></code>, where
<code class="docutils literal notranslate"><span class="pre">core</span></code> is the list of vertices in the <span class="math notranslate nohighlight">\(k\)</span>-core of <code class="docutils literal notranslate"><span class="pre">self</span></code>, and
<code class="docutils literal notranslate"><span class="pre">ordering</span></code> is an elimination order for the other vertices such
that each vertex is of degree strictly less than <span class="math notranslate nohighlight">\(k\)</span> when it is to
be eliminated from the graph.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">with_labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); when set to
<code class="docutils literal notranslate"><span class="pre">False</span></code>, and <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">None</span></code>, the method returns a list whose <span class="math notranslate nohighlight">\(i\)</span> th
element is the core number of the <span class="math notranslate nohighlight">\(i\)</span> th vertex. When set to <code class="docutils literal notranslate"><span class="pre">True</span></code>,
the method returns a dictionary whose keys are vertices, and whose
values are the corresponding core numbers.</p>
</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li>Graph cores is also a notion related to graph homomorphisms. For
this second meaning, see <a class="reference internal" href="#sage.graphs.graph.Graph.has_homomorphism_to" title="sage.graphs.graph.Graph.has_homomorphism_to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.has_homomorphism_to()</span></code></a>.</li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">FruchtGraph</span><span class="p">())</span><span class="o">.</span><span class="n">cores</span><span class="p">()</span>
<span class="go">[3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">FruchtGraph</span><span class="p">())</span><span class="o">.</span><span class="n">cores</span><span class="p">(</span><span class="n">with_labels</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">{0: 3, 1: 3, 2: 3, 3: 3, 4: 3, 5: 3, 6: 3, 7: 3, 8: 3, 9: 3, 10: 3, 11: 3}</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">random_matrix</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">density</span><span class="o">=.</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">nonzero_positions</span><span class="p">(),</span> <span class="n">loops</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">cores</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">cores</span><span class="p">(</span><span class="n">with_labels</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span> <span class="n">cores</span>
<span class="go">{0: 3, 1: 3, 2: 3, 3: 3, 4: 2, 5: 2, 6: 3, 7: 1, 8: 3, 9: 3, 10: 3, 11: 3, 12: 3, 13: 3, 14: 2, 15: 3, 16: 3, 17: 3, 18: 3, 19: 3}</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="n">cores</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">c</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">]</span> <span class="c1"># the vertices in the 2-core</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</span>
</pre></div>
</div>
<p>Checking the 2-core of a random lobster is indeed the empty set:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomLobster</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ordering</span><span class="p">,</span> <span class="n">core</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">cores</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">core</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.degree_constrained_subgraph">
<code class="descname">degree_constrained_subgraph</code><span class="sig-paren">(</span><em>bounds</em>, <em>solver=None</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.degree_constrained_subgraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a degree-constrained subgraph.</p>
<p>Given a graph <span class="math notranslate nohighlight">\(G\)</span> and two functions <span class="math notranslate nohighlight">\(f, g:V(G)\rightarrow \mathbb Z\)</span>
such that <span class="math notranslate nohighlight">\(f \leq g\)</span>, a degree-constrained subgraph in <span class="math notranslate nohighlight">\(G\)</span> is
a subgraph <span class="math notranslate nohighlight">\(G' \subseteq G\)</span> such that for any vertex <span class="math notranslate nohighlight">\(v \in G\)</span>,
<span class="math notranslate nohighlight">\(f(v) \leq d_{G'}(v) \leq g(v)\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">bounds</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); Two possibilities:<ul>
<li>A dictionary whose keys are the vertices, and values a pair of
real values <code class="docutils literal notranslate"><span class="pre">(min,max)</span></code> corresponding to the values
<span class="math notranslate nohighlight">\((f(v),g(v))\)</span>.</li>
<li>A function associating to each vertex a pair of
real values <code class="docutils literal notranslate"><span class="pre">(min,max)</span></code> corresponding to the values
<span class="math notranslate nohighlight">\((f(v),g(v))\)</span>.</li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Linear Program (LP)
solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a>
of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>When a solution exists, this method outputs the degree-constrained
subgraph as a Graph object.</li>
<li>When no solution exists, returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>This algorithm computes the degree-constrained subgraph of minimum
weight.</li>
<li>If the graph’s edges are weighted, these are taken into account.</li>
<li>This problem can be solved in polynomial time.</li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>Is there a perfect matching in an even cycle?</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bounds</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">degree_constrained_subgraph</span><span class="p">(</span><span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.ear_decomposition">
<code class="descname">ear_decomposition</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.ear_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an Ear decomposition of the graph.</p>
<p>An ear of an undirected graph <span class="math notranslate nohighlight">\(G\)</span> is a path <span class="math notranslate nohighlight">\(P\)</span> where the two endpoints
of the path may coincide (i.e., form a cycle), but where otherwise no
repetition of edges or vertices is allowed, so every internal vertex of
<span class="math notranslate nohighlight">\(P\)</span> has degree two in <span class="math notranslate nohighlight">\(P\)</span>.</p>
<p>An ear decomposition of an undirected graph <span class="math notranslate nohighlight">\(G\)</span> is a partition of its
set of edges into a sequence of ears, such that the one or two endpoints
of each ear belong to earlier ears in the sequence and such that the
internal vertices of each ear do not belong to any earlier ear.</p>
<p>For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Ear_decomposition">Wikipedia article Ear_decomposition</a>.</p>
<p>This method implements the linear time algorithm presented in
<a class="reference internal" href="../../../references/index.html#sch2013" id="id18">[Sch2013]</a>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>A nested list representing the cycles and chains of the ear
decomposition of the graph.</li>
</ul>
<p>EXAMPLES:</p>
<p>Ear decomposition of an outer planar graph of order 13:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;LlCG{O@?GBOMW?&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">ear_decomposition</span><span class="p">()</span>
<span class="go">[[0, 3, 2, 1, 0],</span>
<span class="go"> [0, 7, 4, 3],</span>
<span class="go"> [0, 11, 9, 8, 7],</span>
<span class="go"> [1, 12, 2],</span>
<span class="go"> [3, 6, 5, 4],</span>
<span class="go"> [4, 6],</span>
<span class="go"> [7, 10, 8],</span>
<span class="go"> [7, 11],</span>
<span class="go"> [8, 11]]</span>
</pre></div>
</div>
<p>Ear decomposition of a biconnected graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">ear_decomposition</span><span class="p">()</span>
<span class="go">[[0, 3, 2, 1, 0]]</span>
</pre></div>
</div>
<p>Ear decomposition of a connected but not biconnected graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_cycle</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_cycle</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">ear_decomposition</span><span class="p">()</span>
<span class="go">[[0, 2, 1, 0], [3, 6, 5, 4, 3]]</span>
</pre></div>
</div>
<p>The ear decomposition of a multigraph with loops is the same as the ear
decomposition of the underlying simple graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">BullGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">allow_multiple_edges</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">allow_loops</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">u</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">random_vertex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span>
<span class="go">Bull graph: Looped multi-graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">to_simple</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">ear_decomposition</span><span class="p">()</span> <span class="o">==</span> <span class="n">h</span><span class="o">.</span><span class="n">ear_decomposition</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.effective_resistance">
<code class="descname">effective_resistance</code><span class="sig-paren">(</span><em>i</em>, <em>j</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.effective_resistance" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the effective resistance between nodes <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>.</p>
<p>The resistance distance between vertices <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> of a simple
connected graph <span class="math notranslate nohighlight">\(G\)</span> is defined as the effective resistance between the
two vertices on an electrical network constructed from <span class="math notranslate nohighlight">\(G\)</span> replacing
each edge of the graph by a unit (1 ohm) resistor.</p>
<p>See the <a class="reference external" href="https://en.wikipedia.org/wiki/Resistance_distance">Wikipedia article Resistance_distance</a> for more information.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">i</span></code>, <code class="docutils literal notranslate"><span class="pre">j</span></code> – vertices of the graph</li>
</ul>
<p>OUTPUT: rational number denoting resistance between nodes <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span></p>
<p>EXAMPLES:</p>
<p>Effective resistances in a straight linear 2-tree on 6 vertices</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">effective_resistance</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">34/55</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">effective_resistance</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">49/55</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">effective_resistance</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="go">9/11</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">effective_resistance</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="go">15/11</span>
</pre></div>
</div>
<p>Effective resistances in a fan on 6 vertices</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">effective_resistance</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="go">6/5</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">effective_resistance</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">49/55</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.graphs.graph.Graph.effective_resistance_matrix" title="sage.graphs.graph.Graph.effective_resistance_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">effective_resistance_matrix()</span></code></a> –
a similar method giving a matrix full of all effective
resistances between all nodes</li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.least_effective_resistance" title="sage.graphs.graph.Graph.least_effective_resistance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">least_effective_resistance()</span></code></a> –
gives node pairs with least effective resistances</li>
<li>See <a class="reference external" href="https://en.wikipedia.org/wiki/Resistance_distance">Wikipedia article Resistance_distance</a> for more details.</li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.effective_resistance_matrix">
<code class="descname">effective_resistance_matrix</code><span class="sig-paren">(</span><em>vertices=None</em>, <em>nonedgesonly=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.effective_resistance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a matrix whose (<span class="math notranslate nohighlight">\(i\)</span> , <span class="math notranslate nohighlight">\(j\)</span>) entry gives the effective resistance
between vertices <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>.</p>
<p>The resistance distance between vertices <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> of a simple
connected graph <span class="math notranslate nohighlight">\(G\)</span> is defined as the effective resistance between the
two vertices on an electrical network constructed from <span class="math notranslate nohighlight">\(G\)</span> replacing
each edge of the graph by a unit (1 ohm) resistor.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">nonedgesonly</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code> assign
zero resistance to pairs of adjacent vertices.</li>
<li><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – list (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the ordering of the
vertices defining how they should appear in the matrix. By default,
the ordering given by <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.vertices" title="sage.graphs.generic_graph.GenericGraph.vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GenericGraph.vertices()</span></code></a> is used.</li>
</ul>
<p>OUTPUT: matrix</p>
<p>EXAMPLES:</p>
<p>The effective resistance matrix  for a straight linear 2-tree counting
only non-adjacent vertex pairs</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">effective_resistance_matrix</span><span class="p">()</span>
<span class="go">[    0     0     0 49/55 59/55 15/11]</span>
<span class="go">[    0     0     0     0  9/11 59/55]</span>
<span class="go">[    0     0     0     0     0 49/55]</span>
<span class="go">[49/55     0     0     0     0     0]</span>
<span class="go">[59/55  9/11     0     0     0     0]</span>
<span class="go">[15/11 59/55 49/55     0     0     0]</span>
</pre></div>
</div>
<p>The same effective resistance matrix, this time including adjacent
vertices</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">effective_resistance_matrix</span><span class="p">(</span><span class="n">nonedgesonly</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">[    0 34/55 34/55 49/55 59/55 15/11]</span>
<span class="go">[34/55     0 26/55 31/55  9/11 59/55]</span>
<span class="go">[34/55 26/55     0  5/11 31/55 49/55]</span>
<span class="go">[49/55 31/55  5/11     0 26/55 34/55]</span>
<span class="go">[59/55  9/11 31/55 26/55     0 34/55]</span>
<span class="go">[15/11 59/55 49/55 34/55 34/55     0]</span>
</pre></div>
</div>
<p>This example illustrates the common neighbors matrix  for a fan on 6
vertices counting only non-adjacent vertex pairs</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">effective_resistance_matrix</span><span class="p">()</span>
<span class="go">[    0     0     0     0     0     0     0]</span>
<span class="go">[    0     0     0 49/55 56/55   6/5 89/55]</span>
<span class="go">[    0     0     0     0   4/5 56/55 81/55]</span>
<span class="go">[    0 49/55     0     0     0 49/55 16/11]</span>
<span class="go">[    0 56/55   4/5     0     0     0 81/55]</span>
<span class="go">[    0   6/5 56/55 49/55     0     0 89/55]</span>
<span class="go">[    0 89/55 81/55 16/11 81/55 89/55     0]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.graphs.graph.Graph.least_effective_resistance" title="sage.graphs.graph.Graph.least_effective_resistance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">least_effective_resistance()</span></code></a> –
gives node pairs with least effective resistances</li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.effective_resistance" title="sage.graphs.graph.Graph.effective_resistance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">effective_resistance()</span></code></a> –
computes effective resistance for a single node pair</li>
<li>See <a class="reference external" href="https://en.wikipedia.org/wiki/Resistance_Distance">Wikipedia article Resistance_Distance</a> for more details.</li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.fractional_chromatic_index">
<code class="descname">fractional_chromatic_index</code><span class="sig-paren">(</span><em>solver='PPL'</em>, <em>verbose_constraints=False</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.fractional_chromatic_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the fractional chromatic index of the graph.</p>
<p>The fractional chromatic index is a relaxed version of edge-coloring. An
edge coloring of a graph being actually a covering of its edges into the
smallest possible number of matchings, the fractional chromatic index of
a graph <span class="math notranslate nohighlight">\(G\)</span> is the smallest real value <span class="math notranslate nohighlight">\(\chi_f(G)\)</span> such that there
exists a list of matchings <span class="math notranslate nohighlight">\(M_1, ..., M_k\)</span> of <span class="math notranslate nohighlight">\(G\)</span> and coefficients
<span class="math notranslate nohighlight">\(\alpha_1, ..., \alpha_k\)</span> with the property that each edge is covered by
the matchings in the following relaxed way</p>
<div class="math notranslate nohighlight">
\[\forall e \in E(G), \sum_{e \in M_i} \alpha_i \geq 1\]</div>
<p>For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Fractional_coloring">Wikipedia article Fractional_coloring</a>.</p>
<p>ALGORITHM:</p>
<p>The fractional chromatic index is computed through Linear Programming
through its dual. The LP solved by sage is actually:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mbox{Maximize : }&amp;\sum_{e\in E(G)} r_{e}\\
\mbox{Such that : }&amp;\\
&amp;\forall M\text{ matching }\subseteq G, \sum_{e\in M}r_{v}\leq 1\\\end{split}\]</div>
<p>INPUT:</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">&quot;PPL&quot;</span></code>); specify a Linear Program (LP)
solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a>
of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The default solver used here is <code class="docutils literal notranslate"><span class="pre">&quot;PPL&quot;</span></code> which provides exact
results, i.e. a rational number, although this may be slower that
using other solvers. Be aware that this method may loop endlessly
when using some non exact solvers as reported in <a class="reference external" href="https://trac.sagemath.org/23658">trac ticket #23658</a> and
<a class="reference external" href="https://trac.sagemath.org/23798">trac ticket #23798</a>.</p>
</div>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">verbose_constraints</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to
display which constraints are being generated.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <span class="math notranslate nohighlight">\(0\)</span>); sets the level of verbosity of
the LP solver.</p>
</li>
</ul>
<p>EXAMPLES:</p>
<p>The fractional chromatic index of a <span class="math notranslate nohighlight">\(C_5\)</span> is <span class="math notranslate nohighlight">\(5/2\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">fractional_chromatic_index</span><span class="p">()</span>
<span class="go">5/2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.gomory_hu_tree">
<code class="descname">gomory_hu_tree</code><span class="sig-paren">(</span><em>algorithm=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.gomory_hu_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Gomory-Hu tree of self.</p>
<p>Given a tree <span class="math notranslate nohighlight">\(T\)</span> with labeled edges representing capacities, it is very
easy to determine the maximum flow between any pair of vertices :
it is the minimal label on the edges of the unique path between them.</p>
<p>Given a graph <span class="math notranslate nohighlight">\(G\)</span>, a Gomory-Hu tree <span class="math notranslate nohighlight">\(T\)</span> of <span class="math notranslate nohighlight">\(G\)</span> is a tree with the same
set of vertices, and such that the maximum flow between any two vertices
is the same in <span class="math notranslate nohighlight">\(G\)</span> as in <span class="math notranslate nohighlight">\(T\)</span>. See the <a class="reference external" href="https://en.wikipedia.org/wiki/Gomory–Hu_tree">Wikipedia article Gomory–Hu_tree</a>. Note
that, in general, a graph admits more than one Gomory-Hu tree.</p>
<p>See also 15.4 (Gomory-Hu trees) from <a class="reference internal" href="generic_graph.html#schrijvercombopt" id="id19">[SchrijverCombOpt]</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – select the algorithm used by the <code class="xref py py-meth docutils literal notranslate"><span class="pre">edge_cut()</span></code>
method. Refer to its documentation for allowed values and default
behaviour.</li>
</ul>
<p>OUTPUT:</p>
<p>A graph with labeled edges</p>
<p>EXAMPLES:</p>
<p>Taking the Petersen graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">gomory_hu_tree</span><span class="p">()</span>
</pre></div>
</div>
<p>Obviously, this graph is a tree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">is_tree</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note that if the original graph is not connected, then the Gomory-Hu
tree is in fact a forest:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">gomory_hu_tree</span><span class="p">()</span><span class="o">.</span><span class="n">is_forest</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">gomory_hu_tree</span><span class="p">()</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>On the other hand, such a tree has lost nothing of the initial graph
connectedness:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">flow</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">flow</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">Subsets</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">(),</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Just to make sure, we can check that the same is true for two vertices
in a random graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="o">.</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">gomory_hu_tree</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">flow</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">flow</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>And also the min cut:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">edge_connectivity</span><span class="p">()</span> <span class="o">==</span> <span class="nb">min</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">edge_labels</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.graph6_string">
<code class="descname">graph6_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.graph6_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the graph6 representation of the graph as an ASCII string.</p>
<p>This is only valid for simple (no loops, no multiple edges) graphs
on at most <span class="math notranslate nohighlight">\(2^{18}-1=262143\)</span> vertices.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As the graph6 format only handles graphs with vertex set
<span class="math notranslate nohighlight">\(\{0,...,n-1\}\)</span>, a <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.relabel" title="sage.graphs.generic_graph.GenericGraph.relabel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relabelled</span> <span class="pre">copy</span></code></a> will
be encoded, if necessary.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="digraph.html#sage.graphs.digraph.DiGraph.dig6_string" title="sage.graphs.digraph.DiGraph.dig6_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dig6_string()</span></code></a> –
a similar string format for directed graphs</li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">KrackhardtKiteGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">graph6_string</span><span class="p">()</span>
<span class="go">&#39;IvUqwK@?G&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.has_homomorphism_to">
<code class="descname">has_homomorphism_to</code><span class="sig-paren">(</span><em>H</em>, <em>core=False</em>, <em>solver=None</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.has_homomorphism_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether there is a homomorphism between two graphs.</p>
<p>A homomorphism from a graph <span class="math notranslate nohighlight">\(G\)</span> to a graph <span class="math notranslate nohighlight">\(H\)</span> is a function
<span class="math notranslate nohighlight">\(\phi:V(G)\mapsto V(H)\)</span> such that for any edge <span class="math notranslate nohighlight">\(uv \in E(G)\)</span> the pair
<span class="math notranslate nohighlight">\(\phi(u)\phi(v)\)</span> is an edge of <span class="math notranslate nohighlight">\(H\)</span>.</p>
<p>Saying that a graph can be <span class="math notranslate nohighlight">\(k\)</span>-colored is equivalent to saying that it
has a homomorphism to <span class="math notranslate nohighlight">\(K_k\)</span>, the complete graph on <span class="math notranslate nohighlight">\(k\)</span> elements.</p>
<p>For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Graph_homomorphism">Wikipedia article Graph_homomorphism</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">H</span></code> – the graph to which <code class="docutils literal notranslate"><span class="pre">self</span></code> should be sent.</li>
<li><code class="docutils literal notranslate"><span class="pre">core</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>; whether to minimize the size
of the mapping’s image (see note below). This is set to <code class="docutils literal notranslate"><span class="pre">False</span></code> by
default.</li>
<li><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Linear Program (LP)
solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a>
of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>One can compute the core of a graph (with respect to homomorphism)
with this method</p>
<div class="last highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">mapping</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">has_homomorphism_to</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">core</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="s2">&quot;The size of the core is {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">values</span><span class="p">()))))</span>
<span class="go">The size of the core is 2</span>
</pre></div>
</div>
</div>
<p>OUTPUT:</p>
<p>This method returns <code class="docutils literal notranslate"><span class="pre">False</span></code> when the homomorphism does not exist, and
returns the homomorphism otherwise as a dictionary associating a vertex
of <span class="math notranslate nohighlight">\(H\)</span> to a vertex of <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>EXAMPLES:</p>
<p>Is Petersen’s graph 3-colorable:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">has_homomorphism_to</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span>
<span class="go">True</span>
</pre></div>
</div>
<p>An odd cycle admits a homomorphism to a smaller odd cycle, but not to an
even cycle:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">has_homomorphism_to</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">has_homomorphism_to</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">has_homomorphism_to</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.has_perfect_matching">
<code class="descname">has_perfect_matching</code><span class="sig-paren">(</span><em>algorithm='Edmonds'</em>, <em>solver=None</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.has_perfect_matching" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether this graph has a perfect matching.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">&quot;Edmonds&quot;</span></code>)<ul>
<li><code class="docutils literal notranslate"><span class="pre">&quot;Edmonds&quot;</span></code> uses Edmonds’ algorithm as implemented in NetworkX to
find a matching of maximal cardinality, then check whether this
cardinality is half the number of vertices of the graph.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;LP_matching&quot;</span></code> uses a Linear Program to find a matching of
maximal cardinality, then check whether this cardinality is half the
number of vertices of the graph.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;LP&quot;</span></code> uses a Linear Program formulation of the perfect matching
problem: put a binary variable <code class="docutils literal notranslate"><span class="pre">b[e]</span></code> on each edge <span class="math notranslate nohighlight">\(e\)</span>, and for
each vertex <span class="math notranslate nohighlight">\(v\)</span>, require that the sum of the values of the edges
incident to <span class="math notranslate nohighlight">\(v\)</span> is 1.</li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Linear Program (LP)
solver to be used; if set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used</li>
<li><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of verbosity:
set to 0 by default, which means quiet (only useful when
<code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">==</span> <span class="pre">&quot;LP_matching&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">==</span> <span class="pre">&quot;LP&quot;</span></code>)</li>
</ul>
<p>For more information on LP solvers and which default solver is used, see
the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p>
<p>OUTPUT:</p>
<p>A boolean.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">has_perfect_matching</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">WheelGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">has_perfect_matching</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">WheelGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">has_perfect_matching</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">has_perfect_matching</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;LP_matching&quot;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">WheelGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">has_perfect_matching</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;LP_matching&quot;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">WheelGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">has_perfect_matching</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;LP_matching&quot;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">has_perfect_matching</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;LP_matching&quot;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">WheelGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">has_perfect_matching</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;LP_matching&quot;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">WheelGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">has_perfect_matching</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;LP_matching&quot;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.ihara_zeta_function_inverse">
<code class="descname">ihara_zeta_function_inverse</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.ihara_zeta_function_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the inverse of the Ihara zeta function of the graph.</p>
<p>This is a polynomial in one variable with integer coefficients. The
Ihara zeta function itself is the inverse of this polynomial.</p>
<p>See the <a class="reference external" href="https://en.wikipedia.org/wiki/Ihara zeta function">Wikipedia article Ihara zeta function</a> for more information.</p>
<p>ALGORITHM:</p>
<p>This is computed here as the (reversed) characteristic polynomial of a
square matrix of size twice the number of edges, related to the
adjacency matrix of the line graph, see for example Proposition 9 in
<a class="reference internal" href="../../../references/index.html#ss2008" id="id20">[SS2008]</a> and Def. 4.1 in <a class="reference internal" href="../../../references/index.html#ter2011" id="id21">[Ter2011]</a>.</p>
<p>The graph is first replaced by its 2-core, as this does not change the
Ihara zeta function.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">factor</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">ihara_zeta_function_inverse</span><span class="p">())</span>
<span class="go">(2*t - 1) * (t + 1)^2 * (t - 1)^3 * (2*t^2 + t + 1)^3</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">factor</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">ihara_zeta_function_inverse</span><span class="p">())</span>
<span class="go">(-1) * (3*t - 1) * (t + 1)^5 * (t - 1)^6 * (3*t^2 + t + 1)^4</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">factor</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">ihara_zeta_function_inverse</span><span class="p">())</span>
<span class="go">(-1) * (2*t - 1) * (t + 1)^5 * (t - 1)^6 * (2*t^2 + 2*t + 1)^4</span>
<span class="go">* (2*t^2 - t + 1)^5</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomTree</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">ihara_zeta_function_inverse</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<p><a class="reference internal" href="../../../references/index.html#hst2001" id="id22">[HST2001]</a></p>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.independent_set">
<code class="descname">independent_set</code><span class="sig-paren">(</span><em>algorithm='Cliquer'</em>, <em>value_only=False</em>, <em>reduction_rules=True</em>, <em>solver=None</em>, <em>verbosity=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.independent_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a maximum independent set.</p>
<p>An independent set of a graph is a set of pairwise non-adjacent
vertices. A maximum independent set is an independent set of maximum
cardinality.  It induces an empty subgraph.</p>
<p>Equivalently, an independent set is defined as the complement of a
vertex cover.</p>
<p>For more information, see the
<a class="reference external" href="https://en.wikipedia.org/wiki/Independent_set_(graph_theory)">Wikipedia article Independent_set_(graph_theory)</a> and the
<a class="reference external" href="https://en.wikipedia.org/wiki/Vertex_cover">Wikipedia article Vertex_cover</a>.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – the algorithm to be used</p>
<ul>
<li><p class="first">If <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;Cliquer&quot;</span></code> (default), the problem is solved
using Cliquer <a class="reference internal" href="../../../references/index.html#no2003" id="id23">[NO2003]</a>.</p>
<p>(see the <a class="reference internal" href="cliquer.html#module-sage.graphs.cliquer" title="sage.graphs.cliquer"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Cliquer</span> <span class="pre">modules</span></code></a>)</p>
</li>
<li><p class="first">If <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;MILP&quot;</span></code>, the problem is solved through a Mixed
Integer Linear Program.</p>
<p>(see <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>)</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>If <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">&quot;mcqd&quot;</span></code>, uses the MCQD solver
(<a class="reference external" href="http://www.sicmm.org/~konc/maxclique/">http://www.sicmm.org/~konc/maxclique/</a>). Note that the MCQD
package must be installed.</li>
</ul>
</div></blockquote>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">value_only</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if set to <code class="docutils literal notranslate"><span class="pre">True</span></code>,
only the size of a maximum independent set is returned. Otherwise,
a maximum independent set is returned as a list of vertices.</li>
<li><code class="docutils literal notranslate"><span class="pre">reduction_rules</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); specify if the reductions
rules from kernelization must be applied as pre-processing or not.
See <a class="reference internal" href="../../../references/index.html#acflss04" id="id25">[ACFLSS04]</a> for more details. Note that depending on the instance,
it might be faster to disable reduction rules.</li>
<li><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Linear Program (LP)
solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve()</span></code></a>
of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">verbosity</span></code> – non-negative integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); set the level
of verbosity you want from the linear program solver. Since the
problem of computing an independent set is <span class="math notranslate nohighlight">\(NP\)</span>-complete, its solving
may take some time depending on the graph. A value of 0 means that
there will be no message printed by the solver. This option is only
useful if <code class="docutils literal notranslate"><span class="pre">algorithm=&quot;MILP&quot;</span></code>.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">While Cliquer/MCAD are usually (and by far) the most efficient
implementations, the MILP formulation sometimes proves faster on
very “symmetrical” graphs.</p>
</div>
<p>EXAMPLES:</p>
<p>Using Cliquer:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">independent_set</span><span class="p">()</span>
<span class="go">[0, 3, 6, 7]</span>
</pre></div>
</div>
<p>As a linear program:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">independent_set</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;MILP&quot;</span><span class="p">))</span>
<span class="go">4</span>
</pre></div>
</div>
<div class="figure">
<img alt="../../_images/graph-2.svg" src="../../_images/graph-2.svg" /></div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.independent_set_of_representatives">
<code class="descname">independent_set_of_representatives</code><span class="sig-paren">(</span><em>family</em>, <em>solver=None</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.independent_set_of_representatives" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an independent set of representatives.</p>
<p>Given a graph <span class="math notranslate nohighlight">\(G\)</span> and a family <span class="math notranslate nohighlight">\(F=\{F_i:i\in [1,...,k]\}\)</span> of subsets of
<code class="docutils literal notranslate"><span class="pre">g.vertices()</span></code>, an Independent Set of Representatives (ISR) is an
assignation of a vertex <span class="math notranslate nohighlight">\(v_i\in F_i\)</span> to each set <span class="math notranslate nohighlight">\(F_i\)</span> such that <span class="math notranslate nohighlight">\(v_i !=
v_j\)</span> if <span class="math notranslate nohighlight">\(i&lt;j\)</span> (they are representatives) and the set <span class="math notranslate nohighlight">\(\cup_{i}v_i\)</span> is an
independent set in <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>It generalizes, for example, graph coloring and graph list coloring.</p>
<p>(See <a class="reference internal" href="../../../references/index.html#abz2007" id="id26">[ABZ2007]</a> for more information.)</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">family</span></code> – A list of lists defining the family <span class="math notranslate nohighlight">\(F\)</span> (actually, a
Family of subsets of <code class="docutils literal notranslate"><span class="pre">G.vertices()</span></code>).</li>
<li><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Linear Program (LP)
solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a>
of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>A list whose <span class="math notranslate nohighlight">\(i^{\mbox{th}}\)</span> element is the representative of the
<span class="math notranslate nohighlight">\(i^{\mbox{th}}\)</span> element of the <code class="docutils literal notranslate"><span class="pre">family</span></code> list. If there is no ISR,
<code class="docutils literal notranslate"><span class="pre">None</span></code> is returned.</li>
</ul>
<p>EXAMPLES:</p>
<p>For a bipartite graph missing one edge, the solution is as expected:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">delete_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">independent_set_of_representatives</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]])</span>
<span class="go">[1, 4]</span>
</pre></div>
</div>
<p>The Petersen Graph is 3-colorable, which can be expressed as an
independent set of representatives problem : take 3 disjoint copies of
the Petersen Graph, each one representing one color. Then take as a
partition of the set of vertices the family defined by the three copies
of each vertex. The ISR of such a family defines a 3-coloring:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span><span class="o">/</span><span class="mi">3</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="p">[[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">isr</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">independent_set_of_representatives</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">floor</span><span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">isr</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">color_classes</span> <span class="o">=</span> <span class="p">[[],[],[]]</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
<span class="gp">....: </span>  <span class="n">color_classes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">classs</span> <span class="ow">in</span> <span class="n">color_classes</span><span class="p">:</span>
<span class="gp">....: </span>  <span class="n">g</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">classs</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
<span class="go">True</span>
<span class="go">True</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_apex">
<code class="descname">is_apex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_apex" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the graph is apex.</p>
<p>A graph is apex if it can be made planar by the removal of a single
vertex. The deleted vertex is called <code class="docutils literal notranslate"><span class="pre">an</span> <span class="pre">apex</span></code> of the graph, and a
graph may have more than one apex. For instance, in the minimal
nonplanar graphs <span class="math notranslate nohighlight">\(K_5\)</span> or <span class="math notranslate nohighlight">\(K_{3,3}\)</span>, every vertex is an apex. The apex
graphs include graphs that are themselves planar, in which case again
every vertex is an apex. The null graph is also counted as an apex graph
even though it has no vertex to remove.  If the graph is not connected,
we say that it is apex if it has at most one non planar connected
component and that this component is apex.  See the <a class="reference external" href="https://en.wikipedia.org/wiki/Apex_graph">Wikipedia article Apex_graph</a>
for more information.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.graphs.graph.Graph.apex_vertices" title="sage.graphs.graph.Graph.apex_vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apex_vertices()</span></code></a></li>
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.is_planar" title="sage.graphs.generic_graph.GenericGraph.is_planar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_planar()</span></code></a></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p><span class="math notranslate nohighlight">\(K_5\)</span> and <span class="math notranslate nohighlight">\(K_{3,3}\)</span> are apex graphs, and each of their vertices is an
apex:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_apex</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_apex</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Petersen graph is not apex:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_apex</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A graph is apex if all its connected components are apex, but at most
one is not planar:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K5</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">M</span><span class="o">+</span><span class="n">K5</span><span class="p">)</span><span class="o">.</span><span class="n">is_apex</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">M</span><span class="o">+</span><span class="n">K5</span><span class="o">+</span><span class="n">K5</span><span class="p">)</span><span class="o">.</span><span class="n">is_apex</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_arc_transitive">
<code class="descname">is_arc_transitive</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_arc_transitive" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if self is an arc-transitive graph</p>
<p>A graph is arc-transitive if its automorphism group acts transitively on
its pairs of adjacent vertices.</p>
<p>Equivalently, if there exists for any pair of edges <span class="math notranslate nohighlight">\(uv,u'v'\in E(G)\)</span> an
automorphism <span class="math notranslate nohighlight">\(\phi_1\)</span> of <span class="math notranslate nohighlight">\(G\)</span> such that <span class="math notranslate nohighlight">\(\phi_1(u)=u'\)</span> and
<span class="math notranslate nohighlight">\(\phi_1(v)=v'\)</span>, as well as another automorphism <span class="math notranslate nohighlight">\(\phi_2\)</span> of <span class="math notranslate nohighlight">\(G\)</span> such
that <span class="math notranslate nohighlight">\(\phi_2(u)=v'\)</span> and <span class="math notranslate nohighlight">\(\phi_2(v)=u'\)</span></p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="https://en.wikipedia.org/wiki/arc-transitive_graph">Wikipedia article arc-transitive_graph</a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_edge_transitive" title="sage.graphs.graph.Graph.is_edge_transitive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_edge_transitive()</span></code></a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_half_transitive" title="sage.graphs.graph.Graph.is_half_transitive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_half_transitive()</span></code></a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_semi_symmetric" title="sage.graphs.graph.Graph.is_semi_symmetric"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_semi_symmetric()</span></code></a></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_arc_transitive</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">GrayGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_arc_transitive</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_asteroidal_triple_free">
<code class="descname">is_asteroidal_triple_free</code><span class="sig-paren">(</span><em>G</em>, <em>certificate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_asteroidal_triple_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the input graph is asteroidal triple-free</p>
<p>An independent set of three vertices such that each pair is joined by a path
that avoids the neighborhood of the third one is called an <em>asteroidal
triple</em>. A graph is asteroidal triple-free (AT-free) if it contains no
asteroidal triples. See the <a class="reference internal" href="asteroidal_triples.html#module-sage.graphs.asteroidal_triples" title="sage.graphs.asteroidal_triples"><code class="xref py py-mod docutils literal notranslate"><span class="pre">module's</span> <span class="pre">documentation</span></code></a> for more details.</p>
<p>This method returns <code class="docutils literal notranslate"><span class="pre">True</span></code> is the graph is AT-free and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">G</span></code> – a Graph</li>
<li><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); by default, this method
returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the graph is asteroidal triple-free and <code class="docutils literal notranslate"><span class="pre">False</span></code>
otherwise. When <code class="docutils literal notranslate"><span class="pre">certificate==True</span></code>, this method returns in addition a
list of three vertices forming an asteroidal triple if such a triple is
found, and the empty list otherwise.</li>
</ul>
<p>EXAMPLES:</p>
<p>The complete graph is AT-free, as well as its line graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_asteroidal_triple_free</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_asteroidal_triple_free</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(True, [])</span>
<span class="gp">sage: </span><span class="n">LG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">line_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">LG</span><span class="o">.</span><span class="n">is_asteroidal_triple_free</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">LLG</span> <span class="o">=</span> <span class="n">LG</span><span class="o">.</span><span class="n">line_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">LLG</span><span class="o">.</span><span class="n">is_asteroidal_triple_free</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The PetersenGraph is not AT-free:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.asteroidal_triples</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_asteroidal_triple_free</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_asteroidal_triple_free</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(False, [0, 2, 6])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_biconnected">
<code class="descname">is_biconnected</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_biconnected" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the graph is biconnected.</p>
<p>A biconnected graph is a connected graph on two or more vertices that is
not broken into disconnected pieces by deleting any single vertex.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.is_connected" title="sage.graphs.generic_graph.GenericGraph.is_connected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_connected()</span></code></a></li>
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.blocks_and_cut_vertices" title="sage.graphs.generic_graph.GenericGraph.blocks_and_cut_vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">blocks_and_cut_vertices()</span></code></a></li>
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.blocks_and_cuts_tree" title="sage.graphs.generic_graph.GenericGraph.blocks_and_cuts_tree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">blocks_and_cuts_tree()</span></code></a></li>
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Biconnected_graph">Wikipedia article Biconnected_graph</a></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_biconnected</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_path</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_biconnected</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_biconnected</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_block_graph">
<code class="descname">is_block_graph</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_block_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether this graph is a block graph.</p>
<p>A block graph is a connected graph in which every biconnected component
(block) is a clique.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Block_graph">Wikipedia article Block_graph</a> for more details on these graphs</li>
<li><a class="reference internal" href="graph_generators.html#sage.graphs.graph_generators.GraphGenerators.RandomBlockGraph" title="sage.graphs.graph_generators.GraphGenerators.RandomBlockGraph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">RandomBlockGraph()</span></code></a>
– generator of random block graphs</li>
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.blocks_and_cut_vertices" title="sage.graphs.generic_graph.GenericGraph.blocks_and_cut_vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">blocks_and_cut_vertices()</span></code></a></li>
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.blocks_and_cuts_tree" title="sage.graphs.generic_graph.GenericGraph.blocks_and_cuts_tree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">blocks_and_cuts_tree()</span></code></a></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomBlockGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">kmax</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_block_graph</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.isgci</span> <span class="kn">import</span> <span class="n">graph_classes</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="ow">in</span> <span class="n">graph_classes</span><span class="o">.</span><span class="n">Block</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">is_block_graph</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">RandomTree</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">is_block_graph</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">is_block_graph</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">is_block_graph</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_cactus">
<code class="descname">is_cactus</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_cactus" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the graph is cactus graph.</p>
<p>A graph is called <em>cactus graph</em> if it is connected and every pair of
simple cycles have at most one common vertex.</p>
<p>There are other definitions, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Cactus_graph">Wikipedia article Cactus_graph</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="mi">8</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">9</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_cactus</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">c6</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">naphthalene</span> <span class="o">=</span> <span class="n">c6</span> <span class="o">+</span> <span class="n">c6</span>
<span class="gp">sage: </span><span class="n">naphthalene</span><span class="o">.</span><span class="n">is_cactus</span><span class="p">()</span>  <span class="c1"># Not connected</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">naphthalene</span><span class="o">.</span><span class="n">merge_vertices</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">naphthalene</span><span class="o">.</span><span class="n">is_cactus</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">naphthalene</span><span class="o">.</span><span class="n">merge_vertices</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">naphthalene</span><span class="o">.</span><span class="n">is_cactus</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_cartesian_product">
<code class="descname">is_cartesian_product</code><span class="sig-paren">(</span><em>g</em>, <em>certificate=False</em>, <em>relabeling=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_cartesian_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the graph is a Cartesian product.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span>
<span class="pre">False</span></code> (default) the method only returns <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>
answers. If <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></code>, the <code class="docutils literal notranslate"><span class="pre">True</span></code> answers are replaced by
the list of the factors of the graph.</li>
<li><code class="docutils literal notranslate"><span class="pre">relabeling</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">relabeling</span> <span class="pre">=</span> <span class="pre">True</span></code>
(implies <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></code>), the method also returns a dictionary
associating to each vertex its natural coordinates as a vertex of a
product graph. If <span class="math notranslate nohighlight">\(g\)</span> is not a Cartesian product, <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned
instead.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.cartesian_product" title="sage.graphs.generic_graph.GenericGraph.cartesian_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.graphs.generic_graph.GenericGraph.cartesian_product()</span></code></a></li>
<li><a class="reference internal" href="graph_decompositions/graph_products.html#module-sage.graphs.graph_decompositions.graph_products" title="sage.graphs.graph_decompositions.graph_products"><code class="xref py py-mod docutils literal notranslate"><span class="pre">graph_products</span></code></a> – a module on
graph products.</li>
</ul>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This algorithm may run faster whenever the graph’s vertices are integers
(see <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.relabel" title="sage.graphs.generic_graph.GenericGraph.relabel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relabel()</span></code></a>). Give it a
try if it is too slow !</p>
</div>
<p>EXAMPLES:</p>
<p>The Petersen graph is prime:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions.graph_products</span> <span class="kn">import</span> <span class="n">is_cartesian_product</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">is_cartesian_product</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A 2d grid is the product of paths:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">is_cartesian_product</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">certificate</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p1</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">p2</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Forgetting the graph’s labels, then finding them back:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">relabel</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span><span class="p">,</span><span class="n">D</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_cartesian_product</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">relabeling</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span>  <span class="c1"># random isomorphism</span>
<span class="go">{0: (20, 0), 1: (20, 1), 2: (20, 2), 3: (20, 3), 4: (20, 4),</span>
<span class="go"> 5: (15, 0), 6: (15, 1), 7: (15, 2), 8: (15, 3), 9: (15, 4),</span>
<span class="go"> 10: (10, 0), 11: (10, 1), 12: (10, 2), 13: (10, 3), 14: (10, 4),</span>
<span class="go"> 15: (5, 0), 16: (5, 1), 17: (5, 2), 18: (5, 3), 19: (5, 4),</span>
<span class="go"> 20: (0, 0), 21: (0, 1), 22: (0, 2), 23: (0, 3), 24: (0, 4)}</span>
</pre></div>
</div>
<p>And of course, we find the factors back when we build a graph from a
product:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span> <span class="o">=</span> <span class="n">is_cartesian_product</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">certificate</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">any</span><span class="p">(</span> <span class="n">x</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">())</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">g1</span><span class="p">,</span><span class="n">g2</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">any</span><span class="p">(</span> <span class="n">x</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">g1</span><span class="p">,</span><span class="n">g2</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_circumscribable">
<code class="descname">is_circumscribable</code><span class="sig-paren">(</span><em>solver='ppl'</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_circumscribable" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the graph is the graph of a circumscribed polyhedron.</p>
<p>A polyhedron is circumscribed if all of its facets are tangent to a
sphere. By a theorem of Rivin (<a class="reference internal" href="../../../references/index.html#hrs1993" id="id27">[HRS1993]</a>), this can be checked by
solving a linear program that assigns weights between 0 and 1/2 on each
edge of the polyhedron, so that the weights on any face add to exactly
one and the weights on any non-facial cycle add to more than one.  If
and only if this can be done, the polyhedron can be circumscribed.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">&quot;ppl&quot;</span></code>); specify a Linear Program (LP)
solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">is_circumscribable</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">O</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">OctahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">O</span><span class="o">.</span><span class="n">is_circumscribable</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">TT</span> <span class="o">=</span> <span class="n">polytopes</span><span class="o">.</span><span class="n">truncated_tetrahedron</span><span class="p">()</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">TT</span><span class="o">.</span><span class="n">is_circumscribable</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Stellating in a face of the octahedral graph is not circumscribable:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">choice</span><span class="p">(</span><span class="n">O</span><span class="o">.</span><span class="n">faces</span><span class="p">())))</span>
<span class="gp">sage: </span><span class="n">O</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([[</span><span class="mi">6</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">f</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">O</span><span class="o">.</span><span class="n">is_circumscribable</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_polyhedral" title="sage.graphs.graph.Graph.is_polyhedral"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_polyhedral()</span></code></a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_inscribable" title="sage.graphs.graph.Graph.is_inscribable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_inscribable()</span></code></a></li>
</ul>
</div>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">Allow the use of other, inexact but faster solvers.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_cograph">
<code class="descname">is_cograph</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_cograph" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the graph is cograph.</p>
<p>A cograph is defined recursively: the single-vertex graph is
cograph, complement of cograph is cograph, and disjoint union
of two cographs is cograph. There are many other
characterizations, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Cograph">Wikipedia article Cograph</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">HouseXGraph</span><span class="p">()</span><span class="o">.</span><span class="n">is_cograph</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">HouseGraph</span><span class="p">()</span><span class="o">.</span><span class="n">is_cograph</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">Implement faster recognition algorithm, as for instance
the linear time recognition algorithm using LexBFS proposed
in <a class="reference internal" href="../../../references/index.html#bre2008" id="id28">[Bre2008]</a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_comparability">
<code class="descname">is_comparability</code><span class="sig-paren">(</span><em>g</em>, <em>algorithm='greedy'</em>, <em>certificate=False</em>, <em>check=True</em>, <em>solver=None</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_comparability" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether the graph is a comparability graph</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – choose the implementation used to do the test.<ul>
<li><code class="docutils literal notranslate"><span class="pre">&quot;greedy&quot;</span></code> – a greedy algorithm (see the documentation of the
<a class="reference internal" href="comparability.html#module-sage.graphs.comparability" title="sage.graphs.comparability"><code class="xref py py-mod docutils literal notranslate"><span class="pre">comparability</span> <span class="pre">module</span></code></a>).</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;MILP&quot;</span></code> – a Mixed Integer Linear Program formulation of the
problem. Beware, for this implementation is unable to return negative
certificates ! When <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></code>, negative certificates are
always equal to <code class="docutils literal notranslate"><span class="pre">None</span></code>. True certificates are valid, though.</li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">certificate</span></code> (boolean) – whether to return a
certificate. <em>Yes</em>-answers the certificate is a transitive orientation of
<span class="math notranslate nohighlight">\(G\)</span>, and a <em>no</em> certificates is an odd cycle of sequentially forcing
edges.</li>
<li><code class="docutils literal notranslate"><span class="pre">check</span></code> (boolean) – whether to check that the
yes-certificates are indeed transitive. As it is very quick
compared to the rest of the operation, it is enabled by default.</li>
<li><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); Specify a Linear Program (LP) solver to
be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For more information
on LP solvers and which default solver is used, see the method
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve()</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of verbosity. Set
to 0 by default, which means quiet.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.comparability</span> <span class="kn">import</span> <span class="n">is_comparability</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">is_comparability</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">is_comparability</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(True, Digraph on 5 vertices)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_directed">
<code class="descname">is_directed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_directed" title="Permalink to this definition">¶</a></dt>
<dd><p>Since graph is undirected, returns False.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">is_directed</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_distance_regular">
<code class="descname">is_distance_regular</code><span class="sig-paren">(</span><em>G</em>, <em>parameters=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_distance_regular" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the graph is distance-regular</p>
<p>A graph <span class="math notranslate nohighlight">\(G\)</span> is distance-regular if for any integers <span class="math notranslate nohighlight">\(j,k\)</span> the value of
<span class="math notranslate nohighlight">\(|\{x:d_G(x,u)=j,x\in V(G)\} \cap \{y:d_G(y,v)=j,y\in V(G)\}|\)</span> is constant
for any two vertices <span class="math notranslate nohighlight">\(u,v\in V(G)\)</span> at distance <span class="math notranslate nohighlight">\(i\)</span> from each other. In
particular <span class="math notranslate nohighlight">\(G\)</span> is regular, of degree <span class="math notranslate nohighlight">\(b_0\)</span> (see below), as one can take
<span class="math notranslate nohighlight">\(u=v\)</span>.</p>
<p>Equivalently a graph is distance-regular if there exist integers <span class="math notranslate nohighlight">\(b_i,c_i\)</span>
such that for any two vertices <span class="math notranslate nohighlight">\(u,v\)</span> at distance <span class="math notranslate nohighlight">\(i\)</span> we have</p>
<ul class="simple">
<li><span class="math notranslate nohighlight">\(b_i = |\{x:d_G(x,u)=i+1,x\in V(G)\}\cap N_G(v)\}|, \ 0\leq i\leq d-1\)</span></li>
<li><span class="math notranslate nohighlight">\(c_i = |\{x:d_G(x,u)=i-1,x\in V(G)\}\cap N_G(v)\}|, \ 1\leq i\leq d,\)</span></li>
</ul>
<p>where <span class="math notranslate nohighlight">\(d\)</span> is the diameter of the graph.  For more information on
distance-regular graphs, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Distance-regular_graph">Wikipedia article Distance-regular_graph</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">parameters</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the
function returns the pair <code class="docutils literal notranslate"><span class="pre">(b,</span> <span class="pre">c)</span></code> of lists of integers instead of
a boolean answer (see the definition above)</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.is_regular" title="sage.graphs.generic_graph.GenericGraph.is_regular"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_regular()</span></code></a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_strongly_regular" title="sage.graphs.graph.Graph.is_strongly_regular"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_strongly_regular()</span></code></a></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_distance_regular</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_distance_regular</span><span class="p">(</span><span class="n">parameters</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="go">([3, 2, None], [None, 1, 1])</span>
</pre></div>
</div>
<p>Cube graphs, which are not strongly regular, are a bit more interesting:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">is_distance_regular</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">OddGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">is_distance_regular</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Disconnected graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="n">is_distance_regular</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_edge_transitive">
<code class="descname">is_edge_transitive</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_edge_transitive" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if self is an edge transitive graph.</p>
<p>A graph is edge-transitive if its automorphism group acts transitively
on its edge set.</p>
<p>Equivalently, if there exists for any pair of edges <span class="math notranslate nohighlight">\(uv,u'v'\in E(G)\)</span> an
automorphism <span class="math notranslate nohighlight">\(\phi\)</span> of <span class="math notranslate nohighlight">\(G\)</span> such that <span class="math notranslate nohighlight">\(\phi(uv)=u'v'\)</span> (note this does not
necessarily mean that <span class="math notranslate nohighlight">\(\phi(u)=u'\)</span> and <span class="math notranslate nohighlight">\(\phi(v)=v'\)</span>).</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Edge-transitive_graph">Wikipedia article Edge-transitive_graph</a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_arc_transitive" title="sage.graphs.graph.Graph.is_arc_transitive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_arc_transitive()</span></code></a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_half_transitive" title="sage.graphs.graph.Graph.is_half_transitive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_half_transitive()</span></code></a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_semi_symmetric" title="sage.graphs.graph.Graph.is_semi_symmetric"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_semi_symmetric()</span></code></a></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_edge_transitive</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">is_edge_transitive</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">GrayGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_edge_transitive</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_edge_transitive</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_even_hole_free">
<code class="descname">is_even_hole_free</code><span class="sig-paren">(</span><em>certificate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_even_hole_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether <code class="docutils literal notranslate"><span class="pre">self</span></code> contains an induced even hole.</p>
<p>A Hole is a cycle of length at least 4 (included). It is said to be even
(resp. odd) if its length is even (resp. odd).</p>
<p>Even-hole-free graphs always contain a bisimplicial vertex, which
ensures that their chromatic number is at most twice their clique number
<a class="reference internal" href="../../../references/index.html#achrs2008" id="id29">[ACHRS2008]</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); when <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span>
<span class="pre">False</span></code>, this method only returns <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>. If
<code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></code>, the subgraph found is returned instead of
<code class="docutils literal notranslate"><span class="pre">False</span></code>.</li>
</ul>
<p>EXAMPLES:</p>
<p>Is the Petersen Graph even-hole-free</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_even_hole_free</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>As any chordal graph is hole-free, interval graphs behave the same way:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomIntervalGraph</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_even_hole_free</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>It is clear, though, that a random Bipartite Graph which is not a forest
has an even hole:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomBipartite</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_even_hole_free</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_forest</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We can check the certificate returned is indeed an even cycle:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_forest</span><span class="p">():</span>
<span class="gp">....: </span>   <span class="n">cycle</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_even_hole_free</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">....: </span>   <span class="k">if</span> <span class="n">cycle</span><span class="o">.</span><span class="n">order</span><span class="p">()</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">....: </span>       <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Error !&quot;</span><span class="p">)</span>
<span class="gp">....: </span>   <span class="k">if</span> <span class="ow">not</span> <span class="n">cycle</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span>
<span class="gp">....: </span>          <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="n">cycle</span><span class="o">.</span><span class="n">order</span><span class="p">())):</span>
<span class="gp">....: </span>       <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Error !&quot;</span><span class="p">)</span>
<span class="go">...</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="s2">&quot;Everything is Fine !&quot;</span><span class="p">)</span>
<span class="go">Everything is Fine !</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_forest">
<code class="descname">is_forest</code><span class="sig-paren">(</span><em>certificate=False</em>, <em>output='vertex'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_forest" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests if the graph is a forest, i.e. a disjoint union of trees.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return a
certificate. The method only returns boolean answers when
<code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">False</span></code> (default). When it is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, it
either answers <code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">None)</span></code> when the graph is a forest or
<code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">cycle)</span></code> when it contains a cycle.</li>
<li><code class="docutils literal notranslate"><span class="pre">output</span></code> – either <code class="docutils literal notranslate"><span class="pre">'vertex'</span></code> (default) or <code class="docutils literal notranslate"><span class="pre">'edge'</span></code>; whether the
certificate is given as a list of vertices (<code class="docutils literal notranslate"><span class="pre">output</span> <span class="pre">=</span> <span class="pre">'vertex'</span></code>) or
a list of edges (<code class="docutils literal notranslate"><span class="pre">output</span> <span class="pre">=</span> <span class="pre">'edge'</span></code>).</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">seven_acre_wood</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">trees</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">Graph</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">seven_acre_wood</span><span class="o">.</span><span class="n">is_forest</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>With certificates:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomTree</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_forest</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(True, None)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">g</span> <span class="o">+</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span> <span class="o">+</span> <span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">is_forest</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(False, [62, 63, 68, 66, 61])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_half_transitive">
<code class="descname">is_half_transitive</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_half_transitive" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if self is a half-transitive graph.</p>
<p>A graph is half-transitive if it is both vertex and edge transitive
but not arc-transitive.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="https://en.wikipedia.org/wiki/half-transitive_graph">Wikipedia article half-transitive_graph</a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_edge_transitive" title="sage.graphs.graph.Graph.is_edge_transitive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_edge_transitive()</span></code></a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_arc_transitive" title="sage.graphs.graph.Graph.is_arc_transitive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_arc_transitive()</span></code></a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_semi_symmetric" title="sage.graphs.graph.Graph.is_semi_symmetric"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_semi_symmetric()</span></code></a></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>The Petersen Graph is not half-transitive:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_half_transitive</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The smallest half-transitive graph is the Holt Graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">HoltGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">is_half_transitive</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_inscribable">
<code class="descname">is_inscribable</code><span class="sig-paren">(</span><em>solver='ppl'</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_inscribable" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the graph is the graph of an inscribed polyhedron.</p>
<p>A polyhedron is inscribed if all of its vertices are on a sphere.
This is dual to the notion of circumscribed polyhedron: A Polyhedron is
inscribed if and only if its polar dual is circumscribed and hence a
graph is inscribable if and only if its planar dual is circumscribable.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">&quot;ppl&quot;</span></code>); specify a Linear Program (LP)
solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">HerschelGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">is_inscribable</span><span class="p">()</span>               <span class="c1"># long time (&gt; 1 sec)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">planar_dual</span><span class="p">()</span><span class="o">.</span><span class="n">is_inscribable</span><span class="p">()</span> <span class="c1"># long time (&gt; 1 sec)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">is_inscribable</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Cutting off a vertex from the cube yields an uninscribable graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">vertex_iterator</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">triangle</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span> <span class="o">+</span> <span class="n">v</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">C</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">Combinations</span><span class="p">(</span><span class="n">triangle</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">triangle</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">delete_vertex</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">is_inscribable</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Breaking a face of the cube yields an uninscribable graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">face</span> <span class="o">=</span> <span class="n">choice</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">faces</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">add_edge</span><span class="p">([</span><span class="n">face</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">face</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">is_inscribable</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_polyhedral" title="sage.graphs.graph.Graph.is_polyhedral"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_polyhedral()</span></code></a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_circumscribable" title="sage.graphs.graph.Graph.is_circumscribable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_circumscribable()</span></code></a></li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_line_graph">
<code class="descname">is_line_graph</code><span class="sig-paren">(</span><em>g</em>, <em>certificate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_line_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests wether the graph is a line graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">certificate</span></code> (boolean) – whether to return a certificate along with
the boolean result. Here is what happens when <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></code>:<ul>
<li>If the graph is not a line graph, the method returns a pair <code class="docutils literal notranslate"><span class="pre">(b,</span>
<span class="pre">subgraph)</span></code> where <code class="docutils literal notranslate"><span class="pre">b</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> and <code class="docutils literal notranslate"><span class="pre">subgraph</span></code> is a subgraph
isomorphic to one of the 9 forbidden induced subgraphs of a line graph.</li>
<li>If the graph is a line graph, the method returns a triple <code class="docutils literal notranslate"><span class="pre">(b,R,isom)</span></code>
where <code class="docutils literal notranslate"><span class="pre">b</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">R</span></code> is a graph whose line graph is the graph
given as input, and <code class="docutils literal notranslate"><span class="pre">isom</span></code> is a map associating an edge of <code class="docutils literal notranslate"><span class="pre">R</span></code> to
each vertex of the graph.</li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method wastes a bit of time when the input graph is not connected.
If you have performance in mind, it is probably better to only feed it
with connected graphs only.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li>The <a class="reference internal" href="line_graph.html#module-sage.graphs.line_graph" title="sage.graphs.line_graph"><code class="xref py py-mod docutils literal notranslate"><span class="pre">line_graph</span></code></a> module.</li>
<li><a class="reference internal" href="graph_generators.html#sage.graphs.graph_generators.GraphGenerators.line_graph_forbidden_subgraphs" title="sage.graphs.graph_generators.GraphGenerators.line_graph_forbidden_subgraphs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">line_graph_forbidden_subgraphs()</span></code></a>
– the forbidden subgraphs of a line graph.</li>
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.line_graph" title="sage.graphs.generic_graph.GenericGraph.line_graph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">line_graph()</span></code></a></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>A complete graph is always the line graph of a star:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">is_line_graph</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Petersen Graph not being claw-free, it is not a line
graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">is_line_graph</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>This is indeed the subgraph returned:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">is_line_graph</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">ClawGraph</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The house graph is a line graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">HouseGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_line_graph</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>But what is the graph whose line graph is the house ?:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">is_line</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">isom</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_line_graph</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">sparse6_string</span><span class="p">()</span>
<span class="go">&#39;:DaHI~&#39;</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">isom</span>
<span class="go">{0: (0, 1), 1: (0, 2), 2: (1, 3), 3: (2, 3), 4: (3, 4)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_long_antihole_free">
<code class="descname">is_long_antihole_free</code><span class="sig-paren">(</span><em>g</em>, <em>certificate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_long_antihole_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether the given graph contains an induced subgraph that is
isomorphic to the complement of a cycle of length at least 5.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<p>Whether to return a certificate. When <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></code>, then
the function returns</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">Antihole)</span></code> if <code class="docutils literal notranslate"><span class="pre">g</span></code> contains an induced complement
of a cycle of length at least 5 returned as <code class="docutils literal notranslate"><span class="pre">Antihole</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">[])</span></code> if <code class="docutils literal notranslate"><span class="pre">g</span></code> does not contain an induced complement of
a cycle of length at least 5.
For this case it is not known how to provide a certificate.</li>
</ul>
<p>When <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">False</span></code>, the function returns just <code class="docutils literal notranslate"><span class="pre">True</span></code> or
<code class="docutils literal notranslate"><span class="pre">False</span></code> accordingly.</p>
</li>
</ul>
<p>ALGORITHM:</p>
<p>This algorithm tries to find a cycle in the graph of all induced
<span class="math notranslate nohighlight">\(\overline{P_4}\)</span> of <span class="math notranslate nohighlight">\(g\)</span>, where two copies <span class="math notranslate nohighlight">\(\overline{P}\)</span> and <span class="math notranslate nohighlight">\(\overline{P'}\)</span>
of <span class="math notranslate nohighlight">\(\overline{P_4}\)</span> are adjacent if there exists a (not necessarily induced)
copy of <span class="math notranslate nohighlight">\(\overline{P_5}=u_1u_2u_3u_4u_5\)</span> such that
<span class="math notranslate nohighlight">\(\overline{P}=u_1u_2u_3u_4\)</span> and <span class="math notranslate nohighlight">\(\overline{P'}=u_2u_3u_4u_5\)</span>.</p>
<p>This is done through a depth-first-search. For efficiency, the auxiliary
graph is constructed on-the-fly and never stored in memory.</p>
<p>The run time of this algorithm is <span class="math notranslate nohighlight">\(O(m^2)\)</span> <a class="reference internal" href="../../../references/index.html#np2007" id="id30">[NP2007]</a> (where
<span class="math notranslate nohighlight">\(m\)</span> is the number of edges of the graph).</p>
<p>EXAMPLES:</p>
<p>The Petersen Graph contains an antihole:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_long_antihole_free</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The complement of a cycle is an antihole:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">r</span><span class="p">,</span><span class="n">a</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_long_antihole_free</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">r</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_long_hole_free">
<code class="descname">is_long_hole_free</code><span class="sig-paren">(</span><em>g</em>, <em>certificate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_long_hole_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether <code class="docutils literal notranslate"><span class="pre">g</span></code> contains an induced cycle of length at least 5.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<p>Whether to return a certificate. When <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></code>, then
the function returns</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">[])</span></code> if <code class="docutils literal notranslate"><span class="pre">g</span></code> does not contain such a cycle.
For this case, it is not known how to provide a certificate.</li>
<li><code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">Hole)</span></code> if <code class="docutils literal notranslate"><span class="pre">g</span></code> contains an induced cycle of length at
least 5. <code class="docutils literal notranslate"><span class="pre">Hole</span></code> returns this cycle.</li>
</ul>
<p>If <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">False</span></code>, the function returns just <code class="docutils literal notranslate"><span class="pre">True</span></code> or
<code class="docutils literal notranslate"><span class="pre">False</span></code> accordingly.</p>
</li>
</ul>
<p>ALGORITHM:</p>
<p>This algorithm tries to find a cycle in the graph of all induced <span class="math notranslate nohighlight">\(P_4\)</span> of
<span class="math notranslate nohighlight">\(g\)</span>, where two copies <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(P'\)</span> of <span class="math notranslate nohighlight">\(P_4\)</span> are adjacent if there exists a
(not necessarily induced) copy of <span class="math notranslate nohighlight">\(P_5=u_1u_2u_3u_4u_5\)</span> such that
<span class="math notranslate nohighlight">\(P=u_1u_2u_3u_4\)</span> and <span class="math notranslate nohighlight">\(P'=u_2u_3u_4u_5\)</span>.</p>
<p>This is done through a depth-first-search. For efficiency, the auxiliary
graph is constructed on-the-fly and never stored in memory.</p>
<p>The run time of this algorithm is <span class="math notranslate nohighlight">\(O(m^2)\)</span> <a class="reference internal" href="../../../references/index.html#np2007" id="id31">[NP2007]</a> ( where
<span class="math notranslate nohighlight">\(m\)</span> is the number of edges of the graph ) .</p>
<p>EXAMPLES:</p>
<p>The Petersen Graph contains a hole:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_long_hole_free</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The following graph contains a hole, which we want to display:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">FlowerSnark</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">r</span><span class="p">,</span><span class="n">h</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_long_hole_free</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">r</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">order</span><span class="p">()))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_odd_hole_free">
<code class="descname">is_odd_hole_free</code><span class="sig-paren">(</span><em>certificate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_odd_hole_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether <code class="docutils literal notranslate"><span class="pre">self</span></code> contains an induced odd hole.</p>
<p>A Hole is a cycle of length at least 4 (included). It is said to be even
(resp. odd) if its length is even (resp. odd).</p>
<p>It is interesting to notice that while it is polynomial to check whether
a graph has an odd hole or an odd antihole <a class="reference internal" href="../../../references/index.html#cclsv2005" id="id32">[CCLSV2005]</a>, it is not known
whether testing for one of these two cases independently is polynomial
too.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); when <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span>
<span class="pre">False</span></code>, this method only returns <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>. If
<code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></code>, the subgraph found is returned instead of
<code class="docutils literal notranslate"><span class="pre">False</span></code>.</li>
</ul>
<p>EXAMPLES:</p>
<p>Is the Petersen Graph odd-hole-free</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_odd_hole_free</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Which was to be expected, as its girth is 5</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">girth</span><span class="p">()</span>
<span class="go">5</span>
</pre></div>
</div>
<p>We can check the certificate returned is indeed a 5-cycle:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cycle</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_odd_hole_free</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">cycle</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>As any chordal graph is hole-free, no interval graph has an odd hole:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomIntervalGraph</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_odd_hole_free</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_overfull">
<code class="descname">is_overfull</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_overfull" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether the current graph is overfull.</p>
<p>A graph <span class="math notranslate nohighlight">\(G\)</span> on <span class="math notranslate nohighlight">\(n\)</span> vertices and <span class="math notranslate nohighlight">\(m\)</span> edges is said to be overfull if:</p>
<ul class="simple">
<li><span class="math notranslate nohighlight">\(n\)</span> is odd</li>
<li>It satisfies <span class="math notranslate nohighlight">\(2m &gt; (n-1)\Delta(G)\)</span>, where <span class="math notranslate nohighlight">\(\Delta(G)\)</span> denotes the
maximum degree among all vertices in <span class="math notranslate nohighlight">\(G\)</span>.</li>
</ul>
<p>An overfull graph must have a chromatic index of <span class="math notranslate nohighlight">\(\Delta(G)+1\)</span>.</p>
<p>EXAMPLES:</p>
<p>A complete graph of order <span class="math notranslate nohighlight">\(n &gt; 1\)</span> is overfull if and only if <span class="math notranslate nohighlight">\(n\)</span> is
odd:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The claw graph is not overfull:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_coloring</span> <span class="kn">import</span> <span class="n">edge_coloring</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">ClawGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span>
<span class="go">Claw graph: Graph on 4 vertices</span>
<span class="gp">sage: </span><span class="n">edge_coloring</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">value_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The Holt graph is an example of a overfull graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">HoltGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Checking that all complete graphs <span class="math notranslate nohighlight">\(K_n\)</span> for even <span class="math notranslate nohighlight">\(0 \leq n \leq 100\)</span>
are not overfull:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">check_overfull_Kn_even</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">....: </span>    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">():</span>
<span class="gp">....: </span>            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;A complete graph of even order cannot be overfull.&quot;</span><span class="p">)</span>
<span class="gp">....: </span>            <span class="k">return</span>
<span class="gp">....: </span>        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
<span class="gp">....: </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Complete graphs of even order up to </span><span class="si">%s</span><span class="s2"> are not overfull.&quot;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
<span class="go">...</span>
<span class="gp">sage: </span><span class="n">check_overfull_Kn_even</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>  <span class="c1"># long time</span>
<span class="go">Complete graphs of even order up to 100 are not overfull.</span>
</pre></div>
</div>
<p>The null graph, i.e. the graph with no vertices, is not overfull:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Checking that all complete graphs <span class="math notranslate nohighlight">\(K_n\)</span> for odd <span class="math notranslate nohighlight">\(1 &lt; n \leq 100\)</span>
are overfull:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">check_overfull_Kn_odd</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">....: </span>    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="ow">not</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">():</span>
<span class="gp">....: </span>            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;A complete graph of odd order &gt; 1 must be overfull.&quot;</span><span class="p">)</span>
<span class="gp">....: </span>            <span class="k">return</span>
<span class="gp">....: </span>        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
<span class="gp">....: </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Complete graphs of odd order &gt; 1 up to </span><span class="si">%s</span><span class="s2"> are overfull.&quot;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
<span class="go">...</span>
<span class="gp">sage: </span><span class="n">check_overfull_Kn_odd</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>  <span class="c1"># long time</span>
<span class="go">Complete graphs of odd order &gt; 1 up to 100 are overfull.</span>
</pre></div>
</div>
<p>The Petersen Graph, though, is not overfull while
its chromatic index is <span class="math notranslate nohighlight">\(\Delta+1\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_overfull</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_coloring</span> <span class="kn">import</span> <span class="n">edge_coloring</span>
<span class="gp">sage: </span><span class="nb">max</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">degree</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span>  <span class="n">edge_coloring</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">value_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_partial_cube">
<code class="descname">is_partial_cube</code><span class="sig-paren">(</span><em>G</em>, <em>certificate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_partial_cube" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the given graph is a partial cube.</p>
<p>A partial cube is a graph that can be isometrically embedded into a
hypercube, i.e., its vertices can be labelled with (0,1)-vectors of some
fixed length such that the distance between any two vertices in the graph
equals the Hamming distance of their labels.</p>
<p>Originally written by D. Eppstein for the PADS library
(<a class="reference external" href="http://www.ics.uci.edu/~eppstein/PADS/">http://www.ics.uci.edu/~eppstein/PADS/</a>), see also
<a class="reference internal" href="../../../references/index.html#epp2008" id="id33">[Epp2008]</a>.  The algorithm runs in <span class="math notranslate nohighlight">\(O(n^2)\)</span> time, where <span class="math notranslate nohighlight">\(n\)</span>
is the number of vertices. See the documentation of
<a class="reference internal" href="partial_cube.html#module-sage.graphs.partial_cube" title="sage.graphs.partial_cube"><code class="xref py py-mod docutils literal notranslate"><span class="pre">partial_cube</span></code></a> for an overview of the algorithm.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); this function returns
<code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code> according to the graph, when <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span>
<span class="pre">False</span></code>. When <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></code> and the graph is a partial cube, the
function returns <code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">mapping)</span></code>, where <code class="docutils literal notranslate"><span class="pre">mapping</span></code> is an isometric
mapping of the vertices of the graph to the vertices of a hypercube
((0, 1)-strings of a fixed length). When <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></code> and the
graph is not a partial cube, <code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">None)</span></code> is returned.</li>
</ul>
<p>EXAMPLES:</p>
<p>The Petersen graph is not a partial cube:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_partial_cube</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>All prisms are partial cubes:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_partial_cube</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_perfect">
<code class="descname">is_perfect</code><span class="sig-paren">(</span><em>certificate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_perfect" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether the graph is perfect.</p>
<p>A graph <span class="math notranslate nohighlight">\(G\)</span> is said to be perfect if <span class="math notranslate nohighlight">\(\chi(H)=\omega(H)\)</span> hold for any
induced subgraph <span class="math notranslate nohighlight">\(H\subseteq_i G\)</span> (and so for <span class="math notranslate nohighlight">\(G\)</span> itself, too), where
<span class="math notranslate nohighlight">\(\chi(H)\)</span> represents the chromatic number of <span class="math notranslate nohighlight">\(H\)</span>, and <span class="math notranslate nohighlight">\(\omega(H)\)</span> its
clique number. The Strong Perfect Graph Theorem <a class="reference internal" href="../../../references/index.html#crst2006" id="id34">[CRST2006]</a> gives
another characterization of perfect graphs:</p>
<p>A graph is perfect if and only if it contains no odd hole (cycle on an
odd number <span class="math notranslate nohighlight">\(k\)</span> of vertices, <span class="math notranslate nohighlight">\(k&gt;3\)</span>) nor any odd antihole (complement of a
hole) as an induced subgraph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return a
certificate.</li>
</ul>
<p>OUTPUT:</p>
<p>When <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">False</span></code>, this function returns a boolean
value. When <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></code>, it returns a subgraph of <code class="docutils literal notranslate"><span class="pre">self</span></code>
isomorphic to an odd hole or an odd antihole if any, and <code class="docutils literal notranslate"><span class="pre">None</span></code>
otherwise.</p>
<p>EXAMPLES:</p>
<p>A Bipartite Graph is always perfect</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomBipartite</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_perfect</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>So is the line graph of a bipartite graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomBipartite</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mf">0.7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">line_graph</span><span class="p">()</span><span class="o">.</span><span class="n">is_perfect</span><span class="p">()</span> <span class="c1"># long time</span>
<span class="go">True</span>
</pre></div>
</div>
<p>As well as the Cartesian product of two complete graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_perfect</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Interval Graphs, which are chordal graphs, too</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span>  <span class="n">graphs</span><span class="o">.</span><span class="n">RandomIntervalGraph</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_perfect</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The PetersenGraph, which is triangle-free and has chromatic number 3 is
obviously not perfect:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_perfect</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We can obtain an induced 5-cycle as a certificate:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_perfect</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Subgraph of (Petersen graph): Graph on 5 vertices</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_permutation">
<code class="descname">is_permutation</code><span class="sig-paren">(</span><em>g</em>, <em>algorithm='greedy'</em>, <em>certificate=False</em>, <em>check=True</em>, <em>solver=None</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_permutation" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether the graph is a permutation graph.</p>
<p>For more information on permutation graphs, refer to the documentation of
the <a class="reference internal" href="comparability.html#module-sage.graphs.comparability" title="sage.graphs.comparability"><code class="xref py py-mod docutils literal notranslate"><span class="pre">comparability</span> <span class="pre">module</span></code></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – choose the implementation used for the subcalls to
<a class="reference internal" href="#sage.graphs.graph.Graph.is_comparability" title="sage.graphs.graph.Graph.is_comparability"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_comparability()</span></code></a>.<ul>
<li><code class="docutils literal notranslate"><span class="pre">&quot;greedy&quot;</span></code> – a greedy algorithm (see the documentation of the
<a class="reference internal" href="comparability.html#module-sage.graphs.comparability" title="sage.graphs.comparability"><code class="xref py py-mod docutils literal notranslate"><span class="pre">comparability</span> <span class="pre">module</span></code></a>).</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;MILP&quot;</span></code> – a Mixed Integer Linear Program formulation of the
problem. Beware, for this implementation is unable to return negative
certificates ! When <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></code>, negative certificates are
always equal to <code class="docutils literal notranslate"><span class="pre">None</span></code>. True certificates are valid, though.</li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">certificate</span></code> (boolean) – whether to return a certificate for the
answer given. For <code class="docutils literal notranslate"><span class="pre">True</span></code> answers the certificate is a permutation, for
<code class="docutils literal notranslate"><span class="pre">False</span></code> answers it is a no-certificate for the test of comparability or
co-comparability.</li>
<li><code class="docutils literal notranslate"><span class="pre">check</span></code> (boolean) – whether to check that the permutations returned
indeed create the expected Permutation graph. Pretty cheap compared to the
rest, hence a good investment. It is enabled by default.</li>
<li><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); Specify a Linear Program (LP) solver to
be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For more information
on LP solvers and which default solver is used, see the method
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve()</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of verbosity. Set
to 0 by default, which means quiet.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As the <code class="docutils literal notranslate"><span class="pre">True</span></code> certificate is a <a class="reference external" href="../../../combinat/sage/combinat/permutation.html#sage.combinat.permutation.Permutation" title="(in Sage Reference Manual: Combinatorics v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Permutation</span></code></a> object, the
segment intersection model of the permutation graph can be visualized
through a call to <a class="reference external" href="../../../combinat/sage/combinat/permutation.html#sage.combinat.permutation.Permutation.show" title="(in Sage Reference Manual: Combinatorics v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Permutation.show</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<p>A permutation realizing the bull graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.comparability</span> <span class="kn">import</span> <span class="n">is_permutation</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">BullGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">_</span> <span class="p">,</span> <span class="n">certif</span> <span class="o">=</span> <span class="n">is_permutation</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PermutationGraph</span><span class="p">(</span><span class="o">*</span><span class="n">certif</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Plotting the realization as an intersection graph of segments:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">true</span><span class="p">,</span> <span class="n">perm</span> <span class="o">=</span> <span class="n">is_permutation</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p1</span> <span class="o">=</span> <span class="n">Permutation</span><span class="p">([</span><span class="n">nn</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">perm</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">p2</span> <span class="o">=</span> <span class="n">Permutation</span><span class="p">([</span><span class="n">nn</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">perm</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">p2</span> <span class="o">*</span> <span class="n">p1</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">representation</span> <span class="o">=</span> <span class="s2">&quot;braid&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_polyhedral">
<code class="descname">is_polyhedral</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_polyhedral" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the graph is the graph of the polyhedron.</p>
<p>By a theorem of Steinitz (Satz 43, p. 77 of <a class="reference internal" href="../../../references/index.html#st1922" id="id35">[St1922]</a>), graphs of
three-dimensional polyhedra are exactly the simple 3-vertex-connected
planar graphs.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">is_polyhedral</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">K33</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K33</span><span class="o">.</span><span class="n">is_polyhedral</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span><span class="o">.</span><span class="n">is_polyhedral</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="k">if</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">is_polyhedral</span><span class="p">()]</span>
<span class="go">[4]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.vertex_connectivity" title="sage.graphs.generic_graph.GenericGraph.vertex_connectivity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertex_connectivity()</span></code></a></li>
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.is_planar" title="sage.graphs.generic_graph.GenericGraph.is_planar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_planar()</span></code></a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_circumscribable" title="sage.graphs.graph.Graph.is_circumscribable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_circumscribable()</span></code></a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_inscribable" title="sage.graphs.graph.Graph.is_inscribable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_inscribable()</span></code></a></li>
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Polyhedral_graph">Wikipedia article Polyhedral_graph</a></li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_prime">
<code class="descname">is_prime</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_prime" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the current graph is prime.</p>
<p>A graph is prime if all its modules are trivial (i.e. empty, all of the
graph or singletons) – see <a class="reference internal" href="#sage.graphs.graph.Graph.modular_decomposition" title="sage.graphs.graph.Graph.modular_decomposition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">modular_decomposition()</span></code></a>.</p>
<p>EXAMPLES:</p>
<p>The Petersen Graph and the Bull Graph are both prime:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">is_prime</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">BullGraph</span><span class="p">()</span><span class="o">.</span><span class="n">is_prime</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Though quite obviously, the disjoint union of them is not:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span> <span class="o">+</span> <span class="n">graphs</span><span class="o">.</span><span class="n">BullGraph</span><span class="p">())</span><span class="o">.</span><span class="n">is_prime</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_semi_symmetric">
<code class="descname">is_semi_symmetric</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_semi_symmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if self is semi-symmetric.</p>
<p>A graph is semi-symmetric if it is regular, edge-transitive but not
vertex-transitive.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Semi-symmetric_graph">Wikipedia article Semi-symmetric_graph</a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_edge_transitive" title="sage.graphs.graph.Graph.is_edge_transitive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_edge_transitive()</span></code></a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_arc_transitive" title="sage.graphs.graph.Graph.is_arc_transitive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_arc_transitive()</span></code></a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_half_transitive" title="sage.graphs.graph.Graph.is_half_transitive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_half_transitive()</span></code></a></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>The Petersen graph is not semi-symmetric:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_semi_symmetric</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The Gray graph is the smallest possible cubic semi-symmetric graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">GrayGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_semi_symmetric</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Another well known semi-symmetric graph is the Ljubljana graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">LjubljanaGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">is_semi_symmetric</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_split">
<code class="descname">is_split</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_split" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the graph is a Split graph, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>A Graph <span class="math notranslate nohighlight">\(G\)</span> is said to be a split graph if its vertices <span class="math notranslate nohighlight">\(V(G)\)</span> can be
partitioned into two sets <span class="math notranslate nohighlight">\(K\)</span> and <span class="math notranslate nohighlight">\(I\)</span> such that the vertices of <span class="math notranslate nohighlight">\(K\)</span>
induce a complete graph, and those of <span class="math notranslate nohighlight">\(I\)</span> are an independent set.</p>
<p>There is a simple test to check whether a graph is a split graph (see,
for instance, the book “Graph Classes, a survey” <a class="reference internal" href="../../../references/index.html#bls1999" id="id36">[BLS1999]</a> page
203) :</p>
<p>Given the degree sequence <span class="math notranslate nohighlight">\(d_1 \geq ... \geq d_n\)</span> of <span class="math notranslate nohighlight">\(G\)</span>, a graph is a
split graph if and only if :</p>
<div class="math notranslate nohighlight">
\[\sum_{i=1}^\omega d_i = \omega (\omega - 1) + \sum_{i=\omega + 1}^nd_i\]</div>
<p>where <span class="math notranslate nohighlight">\(\omega = max \{i:d_i\geq i-1\}\)</span>.</p>
<p>EXAMPLES:</p>
<p>Split graphs are, in particular, chordal graphs. Hence, The Petersen
graph can not be split:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">is_split</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We can easily build some “random” split graph by creating a complete
graph, and adding vertices only connected to some random vertices of the
clique:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sets</span> <span class="o">=</span> <span class="n">Subsets</span><span class="p">(</span><span class="n">Set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">25</span><span class="p">):</span>
<span class="gp">....: </span>   <span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sets</span><span class="o">.</span><span class="n">random_element</span><span class="p">()])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_split</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Another characterisation of split graph states that a graph is a split
graph if and only if does not contain the 4-cycle, 5-cycle or <span class="math notranslate nohighlight">\(2K_2\)</span> as
an induced subgraph. Hence for the above graph we have:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">forbidden_subgraphs</span> <span class="o">=</span> <span class="p">[</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="nb">sum</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">subgraph_search_count</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">induced</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">H</span> <span class="ow">in</span> <span class="n">forbidden_subgraphs</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_strongly_regular">
<code class="descname">is_strongly_regular</code><span class="sig-paren">(</span><em>g</em>, <em>parameters=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_strongly_regular" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the graph is strongly regular.</p>
<p>A simple graph <span class="math notranslate nohighlight">\(G\)</span> is said to be strongly regular with parameters
<span class="math notranslate nohighlight">\((n, k, \lambda, \mu)\)</span> if and only if:</p>
<ul class="simple">
<li><span class="math notranslate nohighlight">\(G\)</span> has <span class="math notranslate nohighlight">\(n\)</span> vertices</li>
<li><span class="math notranslate nohighlight">\(G\)</span> is <span class="math notranslate nohighlight">\(k\)</span>-regular</li>
<li>Any two adjacent vertices of <span class="math notranslate nohighlight">\(G\)</span> have <span class="math notranslate nohighlight">\(\lambda\)</span> common neighbors</li>
<li>Any two non-adjacent vertices of <span class="math notranslate nohighlight">\(G\)</span> have <span class="math notranslate nohighlight">\(\mu\)</span> common neighbors</li>
</ul>
<p>By convention, the complete graphs, the graphs with no edges and the empty
graph are not strongly regular.</p>
<p>See the <a class="reference external" href="https://en.wikipedia.org/wiki/Strongly regular graph">Wikipedia article Strongly regular graph</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">parameters</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
quadruple <span class="math notranslate nohighlight">\((n, k, \lambda, \mu)\)</span>. If <code class="docutils literal notranslate"><span class="pre">parameters</span> <span class="pre">=</span> <span class="pre">False</span></code> (default),
this method only returns <code class="docutils literal notranslate"><span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">False</span></code> answers.
If <code class="docutils literal notranslate"><span class="pre">parameters</span> <span class="pre">=</span> <span class="pre">True</span></code>, the <code class="docutils literal notranslate"><span class="pre">True</span></code> answers are replaced by quadruples
<span class="math notranslate nohighlight">\((n, k, \lambda, \mu)\)</span>. See definition above.</li>
</ul>
<p>EXAMPLES:</p>
<p>Petersen’s graph is strongly regular:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(10, 3, 0, 1)</span>
</pre></div>
</div>
<p>And Clebsch’s graph is too:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">ClebschGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(16, 5, 0, 2)</span>
</pre></div>
</div>
<p>But Chvatal’s graph is not:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">ChvatalGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Complete graphs are not strongly regular. (<a class="reference external" href="https://trac.sagemath.org/14297">trac ticket #14297</a>)</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Completements of complete graphs are not strongly regular:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The empty graph is not strongly regular:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">EmptyGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>If the input graph has loops or multiedges an exception is raised:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span><span class="n">loops</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: This method is not known to work on graphs with</span>
<span class="go">loops. Perhaps this method can be updated to handle them, but in the</span>
<span class="go">meantime if you want to use it please disallow loops using</span>
<span class="go">allow_loops().</span>

<span class="gp">sage: </span><span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span><span class="n">multiedges</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">is_strongly_regular</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: This method is not known to work on graphs with</span>
<span class="go">multiedges. Perhaps this method can be updated to handle them, but in</span>
<span class="go">the meantime if you want to use it please disallow multiedges using</span>
<span class="go">allow_multiple_edges().</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_tree">
<code class="descname">is_tree</code><span class="sig-paren">(</span><em>certificate=False</em>, <em>output='vertex'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests if the graph is a tree</p>
<p>The empty graph is defined to be not a tree.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return a
certificate. The method only returns boolean answers when
<code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">False</span></code> (default). When it is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, it
either answers <code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">None)</span></code> when the graph is a tree or <code class="docutils literal notranslate"><span class="pre">(False,</span>
<span class="pre">cycle)</span></code> when it contains a cycle. It returns <code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">None)</span></code> when
the graph is empty or not connected.</li>
<li><code class="docutils literal notranslate"><span class="pre">output</span></code> – either <code class="docutils literal notranslate"><span class="pre">'vertex'</span></code> (default) or <code class="docutils literal notranslate"><span class="pre">'edge'</span></code>; whether the
certificate is given as a list of vertices (<code class="docutils literal notranslate"><span class="pre">output</span> <span class="pre">=</span> <span class="pre">'vertex'</span></code>) or
a list of edges (<code class="docutils literal notranslate"><span class="pre">output</span> <span class="pre">=</span> <span class="pre">'edge'</span></code>).</li>
</ul>
<p>When the certificate cycle is given as a list of edges, the edges are
given as <span class="math notranslate nohighlight">\((v_i, v_{i+1}, l)\)</span> where <span class="math notranslate nohighlight">\(v_1, v_2, \dots, v_n\)</span> are the
vertices of the cycles (in their cyclic order).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">is_tree</span><span class="p">()</span> <span class="k">for</span> <span class="n">T</span> <span class="ow">in</span> <span class="n">graphs</span><span class="o">.</span><span class="n">trees</span><span class="p">(</span><span class="mi">15</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>With certificates:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomTree</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_tree</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(True, None)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">isit</span><span class="p">,</span> <span class="n">cycle</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_tree</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">isit</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">cycle</span>
<span class="go">True</span>
</pre></div>
</div>
<p>One can also ask for the certificate as a list of edges:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_tree</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)</span>
<span class="go">(False, [(3, 2, None), (2, 1, None), (1, 0, None), (0, 3, None)])</span>
</pre></div>
</div>
<p>This is useful for graphs with multiple edges:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)],</span> <span class="n">multiedges</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_tree</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(False, [1, 2])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_tree</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)</span>
<span class="go">(False, [(1, 2, &#39;a&#39;), (2, 1, &#39;b&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_triangle_free">
<code class="descname">is_triangle_free</code><span class="sig-paren">(</span><em>algorithm='bitset'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_triangle_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether <code class="docutils literal notranslate"><span class="pre">self</span></code> is triangle-free</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'bitset'</span></code>) specifies the algorithm to
use among:<ul>
<li><code class="docutils literal notranslate"><span class="pre">'matrix'</span></code> – tests if the trace of the adjacency matrix is
positive.</li>
<li><code class="docutils literal notranslate"><span class="pre">'bitset'</span></code> – encodes adjacencies into bitsets and uses fast
bitset operations to test if the input graph contains a
triangle. This method is generally faster than standard matrix
multiplication.</li>
</ul>
</li>
</ul>
<p>EXAMPLES:</p>
<p>The Petersen Graph is triangle-free:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_triangle_free</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>or a complete Bipartite Graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_triangle_free</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;matrix&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_triangle_free</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;bitset&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>a tripartite graph, though, contains many triangles:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_triangle_free</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;matrix&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_triangle_free</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;bitset&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_triconnected">
<code class="descname">is_triconnected</code><span class="sig-paren">(</span><em>G</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_triconnected" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the graph is triconnected.</p>
<p>A triconnected graph is a connected graph on 3 or more vertices that is not
broken into disconnected pieces by deleting any pair of vertices.</p>
<p>EXAMPLES:</p>
<p>The Petersen graph is triconnected:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_triconnected</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>But a 2D grid is not:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_triconnected</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>By convention, a cycle of order 3 is triconnected:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_triconnected</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>But cycles of order 4 and more are not:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">is_triconnected</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">)]</span>
<span class="go">[False, False, False, False]</span>
</pre></div>
</div>
<p>Comparing different methods on random graphs that are not always
triconnected:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomBarabasiAlbert</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_triconnected</span><span class="p">()</span> <span class="o">==</span> <span class="n">G</span><span class="o">.</span><span class="n">vertex_connectivity</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.is_connected" title="sage.graphs.generic_graph.GenericGraph.is_connected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_connected()</span></code></a></li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_biconnected" title="sage.graphs.graph.Graph.is_biconnected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_biconnected()</span></code></a></li>
<li><a class="reference internal" href="connectivity.html#sage.graphs.connectivity.spqr_tree" title="sage.graphs.connectivity.spqr_tree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spqr_tree()</span></code></a></li>
<li><a class="reference external" href="https://en.wikipedia.org/wiki/SPQR_tree">Wikipedia article SPQR_tree</a></li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.is_weakly_chordal">
<code class="descname">is_weakly_chordal</code><span class="sig-paren">(</span><em>g</em>, <em>certificate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.is_weakly_chordal" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether the given graph is weakly chordal, i.e., the graph and its
complement have no induced cycle of length at least 5.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – Boolean value (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) whether to
return a certificate. If <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">False</span></code>, return <code class="docutils literal notranslate"><span class="pre">True</span></code> or
<code class="docutils literal notranslate"><span class="pre">False</span></code> according to the graph. If <code class="docutils literal notranslate"><span class="pre">certificate</span> <span class="pre">=</span> <span class="pre">True</span></code>, return<ul>
<li><code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">forbidden_subgraph)</span></code> when the graph contains a
forbidden subgraph H, this graph is returned.</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">[])</span></code> when the graph is weakly chordal.</dt>
<dd>For this case, it is not known how to provide a certificate.</dd>
</dl>
</li>
</ul>
</li>
</ul>
<p>ALGORITHM:</p>
<p>This algorithm checks whether the graph <code class="docutils literal notranslate"><span class="pre">g</span></code> or its complement
contain an induced cycle of length at least 5.</p>
<p>Using is_long_hole_free() and is_long_antihole_free() yields a run time
of <span class="math notranslate nohighlight">\(O(m^2)\)</span> (where <span class="math notranslate nohighlight">\(m\)</span> is the number of edges of the graph).</p>
<p>EXAMPLES:</p>
<p>The Petersen Graph is not weakly chordal and contains a hole:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">r</span><span class="p">,</span><span class="n">s</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_weakly_chordal</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">r</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.join">
<code class="descname">join</code><span class="sig-paren">(</span><em>other</em>, <em>labels='pairs'</em>, <em>immutable=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the join of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">labels</span></code> – (defaults to ‘pairs’); if set to ‘pairs’, each element
<span class="math notranslate nohighlight">\(v\)</span> in the first graph will be named <span class="math notranslate nohighlight">\((0, v)\)</span> and each element <span class="math notranslate nohighlight">\(u\)</span> in
<code class="docutils literal notranslate"><span class="pre">other</span></code> will be named <span class="math notranslate nohighlight">\((1, u)\)</span> in the result. If set to ‘integers’,
the elements of the result will be relabeled with consecutive
integers.</li>
<li><code class="docutils literal notranslate"><span class="pre">immutable</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); whether to create a
mutable/immutable join. <code class="docutils literal notranslate"><span class="pre">immutable=None</span></code> (default) means that the
graphs and their join will behave the same way.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.union" title="sage.graphs.generic_graph.GenericGraph.union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">union()</span></code></a></li>
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.disjoint_union" title="sage.graphs.generic_graph.GenericGraph.disjoint_union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">disjoint_union()</span></code></a></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">H</span><span class="p">);</span> <span class="n">J</span>
<span class="go">Cycle graph join : Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1)]</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="s1">&#39;integers&#39;</span><span class="p">);</span> <span class="n">J</span>
<span class="go">Cycle graph join : Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4]</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None), (0, 2, None), (0, 3, None), (0, 4, None), (1, 2, None), (1, 3, None), (1, 4, None), (2, 3, None), (2, 4, None)]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">name</span><span class="p">(</span><span class="s2">&quot;Graph on 3 vertices&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">name</span><span class="p">(</span><span class="s2">&quot;Graph on 2 vertices&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">H</span><span class="p">);</span> <span class="n">J</span>
<span class="go">Graph on 3 vertices join Graph on 2 vertices: Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1)]</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="s1">&#39;integers&#39;</span><span class="p">);</span> <span class="n">J</span>
<span class="go">Graph on 3 vertices join Graph on 2 vertices: Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 3, None), (0, 4, None), (1, 3, None), (1, 4, None), (2, 3, None), (2, 4, None)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.kirchhoff_symanzik_polynomial">
<code class="descname">kirchhoff_symanzik_polynomial</code><span class="sig-paren">(</span><em>name='t'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.kirchhoff_symanzik_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Kirchhoff-Symanzik polynomial of a graph.</p>
<p>This is a polynomial in variables <span class="math notranslate nohighlight">\(t_e\)</span> (each of them representing an
edge of the graph <span class="math notranslate nohighlight">\(G\)</span>) defined as a sum over all spanning trees:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\Psi_G(t) = \sum_{\substack{T\subseteq V \\ \text{a spanning tree}}} \prod_{e \not\in E(T)} t_e\end{split}\]</div>
<p>This is also called the first Symanzik polynomial or the Kirchhoff
polynomial.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">name</span></code> – name of the variables (default: <code class="docutils literal notranslate"><span class="pre">'t'</span></code>)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>a polynomial with integer coefficients</li>
</ul>
<p>ALGORITHM:</p>
<blockquote>
<div><p>This is computed here using a determinant, as explained in Section
3.1 of <a class="reference internal" href="../../../references/index.html#mar2009a" id="id37">[Mar2009a]</a>.</p>
<p>As an intermediate step, one computes a cycle basis <span class="math notranslate nohighlight">\(\mathcal C\)</span> of
<span class="math notranslate nohighlight">\(G\)</span> and a rectangular <span class="math notranslate nohighlight">\(|\mathcal C| \times |E(G)|\)</span> matrix with
entries in <span class="math notranslate nohighlight">\(\{-1,0,1\}\)</span>, which describes which edge belong to which
cycle of <span class="math notranslate nohighlight">\(\mathcal C\)</span> and their respective orientations.</p>
<p>More precisely, after fixing an arbitrary orientation for each edge
<span class="math notranslate nohighlight">\(e\in E(G)\)</span> and each cycle <span class="math notranslate nohighlight">\(C\in\mathcal C\)</span>, one gets a sign for
every incident pair (edge, cycle) which is <span class="math notranslate nohighlight">\(1\)</span> if the orientation
coincide and <span class="math notranslate nohighlight">\(-1\)</span> otherwise.</p>
</div></blockquote>
<p>EXAMPLES:</p>
<p>For the cycle of length 5:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">kirchhoff_symanzik_polynomial</span><span class="p">()</span>
<span class="go">t0 + t1 + t2 + t3 + t4</span>
</pre></div>
</div>
<p>One can use another letter for variables:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">kirchhoff_symanzik_polynomial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
<span class="go">u0 + u1 + u2 + u3 + u4</span>
</pre></div>
</div>
<p>For the ‘coffee bean’ graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">)],</span> <span class="n">multiedges</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">kirchhoff_symanzik_polynomial</span><span class="p">()</span>
<span class="go">t0*t1 + t0*t2 + t1*t2</span>
</pre></div>
</div>
<p>For the ‘parachute’ graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">)],</span> <span class="n">multiedges</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">kirchhoff_symanzik_polynomial</span><span class="p">()</span>
<span class="go">t0*t1 + t0*t2 + t1*t2 + t1*t3 + t2*t3</span>
</pre></div>
</div>
<p>For the complete graph with 4 vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">kirchhoff_symanzik_polynomial</span><span class="p">()</span>
<span class="go">t0*t1*t3 + t0*t2*t3 + t1*t2*t3 + t0*t1*t4 + t0*t2*t4 + t1*t2*t4</span>
<span class="go">+ t1*t3*t4 + t2*t3*t4 + t0*t1*t5 + t0*t2*t5 + t1*t2*t5 + t0*t3*t5</span>
<span class="go">+ t2*t3*t5 + t0*t4*t5 + t1*t4*t5 + t3*t4*t5</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<p><a class="reference internal" href="../../../references/index.html#bro2011" id="id38">[Bro2011]</a></p>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.least_effective_resistance">
<code class="descname">least_effective_resistance</code><span class="sig-paren">(</span><em>nonedgesonly=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.least_effective_resistance" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of pairs of nodes with the least effective resistance.</p>
<p>The resistance distance between vertices <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> of a simple
connected graph <span class="math notranslate nohighlight">\(G\)</span> is defined as the effective resistance between the
two vertices on an electrical network constructed from <span class="math notranslate nohighlight">\(G\)</span> replacing
each edge of the graph by a unit (1 ohm) resistor.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">nonedgesonly</span></code> – Boolean (default: <span class="math notranslate nohighlight">\(True\)</span>); if true, assign zero
resistance to pairs of adjacent vertices</li>
</ul>
<p>OUTPUT: list</p>
<p>EXAMPLES:</p>
<p>Pairs of non-adjacent nodes with least effective resistance in a
straight linear 2-tree on 6 vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">least_effective_resistance</span><span class="p">()</span>
<span class="go">[(1, 4)]</span>
</pre></div>
</div>
<p>Pairs of (adjacent or non-adjacent) nodes with least effective
resistance in a straight linear 2-tree on 6 vertices</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">least_effective_resistance</span><span class="p">(</span><span class="n">nonedgesonly</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="go">[(2, 3)]</span>
</pre></div>
</div>
<p>Pairs of non-adjacent nodes with least effective resistance in a fan on
6 vertices counting only non-adjacent vertex pairs</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">least_effective_resistance</span><span class="p">()</span>
<span class="go">[(2, 4)]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.graphs.graph.Graph.effective_resistance_matrix" title="sage.graphs.graph.Graph.effective_resistance_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">effective_resistance_matrix()</span></code></a> –
a similar method giving a matrix full of all effective
resistances</li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.effective_resistance" title="sage.graphs.graph.Graph.effective_resistance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">effective_resistance()</span></code></a> –
compuetes effective resistance for a single node pair</li>
<li>See <a class="reference external" href="https://en.wikipedia.org/wiki/Resistance_distance">Wikipedia article Resistance_distance</a> for more details.</li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.lovasz_theta">
<code class="descname">lovasz_theta</code><span class="sig-paren">(</span><em>graph</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.lovasz_theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the value of Lovász theta-function of graph</p>
<p>For a graph <span class="math notranslate nohighlight">\(G\)</span> this function is denoted by <span class="math notranslate nohighlight">\(\theta(G)\)</span>, and it can be
computed in polynomial time. Mathematically, its most important property is
the following:</p>
<div class="math notranslate nohighlight">
\[\alpha(G)\leq\theta(G)\leq\chi(\overline{G})\]</div>
<p>with <span class="math notranslate nohighlight">\(\alpha(G)\)</span> and <span class="math notranslate nohighlight">\(\chi(\overline{G})\)</span> being, respectively, the maximum
size of an <a class="reference internal" href="#sage.graphs.graph.Graph.independent_set" title="sage.graphs.graph.Graph.independent_set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">independent</span> <span class="pre">set</span></code></a>
set of <span class="math notranslate nohighlight">\(G\)</span> and the <a class="reference internal" href="#sage.graphs.graph.Graph.chromatic_number" title="sage.graphs.graph.Graph.chromatic_number"><code class="xref py py-meth docutils literal notranslate"><span class="pre">chromatic</span> <span class="pre">number</span></code></a> of the <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.complement" title="sage.graphs.generic_graph.GenericGraph.complement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">complement</span></code></a> <span class="math notranslate nohighlight">\(\overline{G}\)</span> of <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Lovász_number">Wikipedia article Lovász_number</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>Implemented for undirected graphs only. Use <code class="docutils literal notranslate"><span class="pre">to_undirected</span></code>
to convert a digraph to an undirected graph.</li>
<li>This function requires the optional package <code class="docutils literal notranslate"><span class="pre">csdp</span></code>, which you can
install with <code class="docutils literal notranslate"><span class="pre">sage</span> <span class="pre">-i</span> <span class="pre">csdp</span></code>.</li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">lovasz_theta</span><span class="p">()</span>                             <span class="c1"># optional csdp</span>
<span class="go">4.0</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">lovasz_theta</span><span class="p">()</span>          <span class="c1"># optional csdp</span>
<span class="go">2.236068</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.magnitude_function">
<code class="descname">magnitude_function</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.magnitude_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the magnitude function of the graph as a rational function.</p>
<p>This is defined as the sum of all coefficients in the inverse of the
matrix <span class="math notranslate nohighlight">\(Z\)</span> whose coefficient <span class="math notranslate nohighlight">\(Z_{i,j}\)</span> indexed by a pair of vertices
<span class="math notranslate nohighlight">\((i,j)\)</span> is <span class="math notranslate nohighlight">\(q^d(i,j)\)</span> where <span class="math notranslate nohighlight">\(d\)</span> is the distance function in the graph.</p>
<p>By convention, if the distance from <span class="math notranslate nohighlight">\(i\)</span> to <span class="math notranslate nohighlight">\(j\)</span> is infinite (for two
vertices not path connected) then <span class="math notranslate nohighlight">\(Z_{i,j}=0\)</span>.</p>
<p>The value of the magnitude function at <span class="math notranslate nohighlight">\(q=0\)</span> is the cardinality of the
graph. The magnitude function of a disjoint union is the sum of the
magnitudes functions of the connected components. The magnitude function
of a Cartesian product is the product of the magnitudes functions of the
factors.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">1</span><span class="p">:[],</span> <span class="mi">2</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">magnitude_function</span><span class="p">()</span>
<span class="go">2</span>

<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">magnitude_function</span><span class="p">()</span>
<span class="go">4/(q^2 + 2*q + 1)</span>

<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">magnitude_function</span><span class="p">();</span> <span class="n">m</span>
<span class="go">5/(2*q^2 + 2*q + 1)</span>
</pre></div>
</div>
<p>One can expand the magnitude as a power series in <span class="math notranslate nohighlight">\(q\)</span> as follows:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">q</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[[</span><span class="s1">&#39;q&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">gen</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="go">5 - 10*q + 10*q^2 - 20*q^4 + 40*q^5 - 40*q^6 + ...</span>
</pre></div>
</div>
<p>One can also use the substitution <span class="math notranslate nohighlight">\(q = exp(-t)\)</span> to obtain the magnitude
function as a function of <span class="math notranslate nohighlight">\(t\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">magnitude_function</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span><span class="p">))</span>
<span class="go">6/(2*e^(-t) + 2*e^(-2*t) + e^(-3*t) + 1)</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="lein" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Lein]</td><td>Tom Leinster, <em>The magnitude of metric spaces</em>.
Doc. Math. 18 (2013), 857-905.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.matching">
<code class="descname">matching</code><span class="sig-paren">(</span><em>value_only=False</em>, <em>algorithm='Edmonds'</em>, <em>use_edge_labels=False</em>, <em>solver=None</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.matching" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a maximum weighted matching of the graph represented by the list
of its edges.</p>
<p>For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Matching_(graph_theory)">Wikipedia article Matching_(graph_theory)</a>.</p>
<p>Given a graph <span class="math notranslate nohighlight">\(G\)</span> such that each edge <span class="math notranslate nohighlight">\(e\)</span> has a weight <span class="math notranslate nohighlight">\(w_e\)</span>, a maximum
matching is a subset <span class="math notranslate nohighlight">\(S\)</span> of the edges of <span class="math notranslate nohighlight">\(G\)</span> of maximum weight such that
no two edges of <span class="math notranslate nohighlight">\(S\)</span> are incident with each other.</p>
<p>As an optimization problem, it can be expressed as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mbox{Maximize : }&amp;\sum_{e\in G.edges()} w_e b_e\\
\mbox{Such that : }&amp;\forall v \in G,
\sum_{(u,v)\in G.edges()} b_{(u,v)}\leq 1\\
&amp;\forall x\in G, b_x\mbox{ is a binary variable}\end{split}\]</div>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">value_only</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); when set to <code class="docutils literal notranslate"><span class="pre">True</span></code>,
only the cardinal (or the weight) of the matching is returned</li>
<li><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">&quot;Edmonds&quot;</span></code>)<ul>
<li><code class="docutils literal notranslate"><span class="pre">&quot;Edmonds&quot;</span></code> selects Edmonds’ algorithm as implemented in NetworkX</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;LP&quot;</span></code> uses a Linear Program formulation of the matching problem</li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">use_edge_labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)<ul>
<li>when set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, computes a weighted matching where each edge
is weighted by its label (if an edge has no label, <span class="math notranslate nohighlight">\(1\)</span> is assumed)</li>
<li>when set to <code class="docutils literal notranslate"><span class="pre">False</span></code>, each edge has weight <span class="math notranslate nohighlight">\(1\)</span></li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Linear Program (LP)
solver to be used; if set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used</li>
<li><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of verbosity:
set to 0 by default, which means quiet (only useful when <code class="docutils literal notranslate"><span class="pre">algorithm</span>
<span class="pre">==</span> <span class="pre">&quot;LP&quot;</span></code>)</li>
</ul>
<p>For more information on LP solvers and which default solver is used, see
the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.numerical.mip.MixedIntegerLinearProgram.solve()</span></code></a> of
the class <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.numerical.mip.MixedIntegerLinearProgram</span></code></a>.</p>
<p>ALGORITHM:</p>
<p>The problem is solved using Edmond’s algorithm implemented in NetworkX,
or using Linear Programming depending on the value of <code class="docutils literal notranslate"><span class="pre">algorithm</span></code>.</p>
<p>EXAMPLES:</p>
<p>Maximum matching in a Pappus Graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PappusGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">matching</span><span class="p">(</span><span class="n">value_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">9</span>
</pre></div>
</div>
<p>Same test with the Linear Program formulation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PappusGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">matching</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;LP&quot;</span><span class="p">,</span> <span class="n">value_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">9</span>
</pre></div>
</div>
<div class="figure">
<img alt="../../_images/graph-3.svg" src="../../_images/graph-3.svg" /></div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.matching_polynomial">
<code class="descname">matching_polynomial</code><span class="sig-paren">(</span><em>G</em>, <em>complement=True</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.matching_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the matching polynomial of the graph <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(p(G, k)\)</span> denotes the number of <span class="math notranslate nohighlight">\(k\)</span>-matchings (matchings with <span class="math notranslate nohighlight">\(k\)</span> edges)
in <span class="math notranslate nohighlight">\(G\)</span>, then the matching polynomial is defined as <a class="reference internal" href="../../../references/index.html#god1993" id="id39">[God1993]</a>:</p>
<div class="math notranslate nohighlight">
\[\mu(x)=\sum_{k \geq 0} (-1)^k p(G,k) x^{n-2k}\]</div>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">complement</span></code> - (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) whether to use Godsil’s duality
theorem to compute the matching polynomial from that of the graphs
complement (see ALGORITHM).</li>
<li><code class="docutils literal notranslate"><span class="pre">name</span></code> - optional string for the variable name in the polynomial</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <code class="docutils literal notranslate"><span class="pre">complement</span></code> option uses matching polynomials of complete graphs,
which are cached. So if you are crazy enough to try computing the
matching polynomial on a graph with millions of vertices, you might not
want to use this option, since it will end up caching millions of
polynomials of degree in the millions.</p>
</div>
<p>ALGORITHM:</p>
<p>The algorithm used is a recursive one, based on the following observation
<a class="reference internal" href="../../../references/index.html#god1993" id="id40">[God1993]</a>:</p>
<ul>
<li><p class="first">If <span class="math notranslate nohighlight">\(e\)</span> is an edge of <span class="math notranslate nohighlight">\(G\)</span>, <span class="math notranslate nohighlight">\(G'\)</span> is the result of deleting the edge <span class="math notranslate nohighlight">\(e\)</span>, and
<span class="math notranslate nohighlight">\(G''\)</span> is the result of deleting each vertex in <span class="math notranslate nohighlight">\(e\)</span>, then the matching
polynomial of <span class="math notranslate nohighlight">\(G\)</span> is equal to that of <span class="math notranslate nohighlight">\(G'\)</span> minus that of <span class="math notranslate nohighlight">\(G''\)</span>.</p>
<p>(the algorithm actually computes the <em>signless</em> matching polynomial, for
which the recursion is the same when one replaces the substraction by an
addition. It is then converted into the matching polynomial and returned)</p>
</li>
</ul>
<p>Depending on the value of <code class="docutils literal notranslate"><span class="pre">complement</span></code>, Godsil’s duality theorem
<a class="reference internal" href="../../../references/index.html#god1993" id="id41">[God1993]</a> can also be used to compute <span class="math notranslate nohighlight">\(\mu(x)\)</span> :</p>
<div class="math notranslate nohighlight">
\[\mu(\overline{G}, x) = \sum_{k \geq 0} p(G,k) \mu( K_{n-2k}, x)\]</div>
<p>Where <span class="math notranslate nohighlight">\(\overline{G}\)</span> is the complement of <span class="math notranslate nohighlight">\(G\)</span>, and <span class="math notranslate nohighlight">\(K_n\)</span> the complete graph
on <span class="math notranslate nohighlight">\(n\)</span> vertices.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">matching_polynomial</span><span class="p">()</span>
<span class="go">x^10 - 15*x^8 + 75*x^6 - 145*x^4 + 90*x^2 - 6</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">x^10 - 15*x^8 + 75*x^6 - 145*x^4 + 90*x^2 - 6</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;tom&#39;</span><span class="p">)</span>
<span class="go">tom^10 - 15*tom^8 + 75*tom^6 - 145*tom^4 + 90*tom^2 - 6</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="o">.</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">prod</span><span class="p">([</span><span class="n">h</span><span class="o">.</span><span class="n">matching_polynomial</span><span class="p">()</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">L</span><span class="p">])</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">matching_polynomial</span><span class="p">()</span>  <span class="c1"># long time (up to 10s on sage.math, 2011)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">):</span>  <span class="c1"># long time (10s on sage.math, 2011)</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">graphs</span><span class="o">.</span><span class="n">trees</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">matching_polynomial</span><span class="p">()</span> <span class="o">!=</span> <span class="n">t</span><span class="o">.</span><span class="n">characteristic_polynomial</span><span class="p">():</span>
<span class="gp">....: </span>            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;bug for a tree A of size {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="gp">....: </span>        <span class="n">c</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="o">!=</span> <span class="n">c</span><span class="o">.</span><span class="n">matching_polynomial</span><span class="p">():</span>
<span class="gp">....: </span>            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;bug for a tree B of size {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.matchpoly</span> <span class="kn">import</span> <span class="n">matching_polynomial</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">x^2 - 1</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">x^3 - 3*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">x^4 - 6*x^2 + 3</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">x^5 - 10*x^3 + 15*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="go">x^6 - 15*x^4 + 45*x^2 - 15</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="go">x^7 - 21*x^5 + 105*x^3 - 105*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>
<span class="go">x^8 - 28*x^6 + 210*x^4 - 420*x^2 + 105</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">9</span><span class="p">))</span>
<span class="go">x^9 - 36*x^7 + 378*x^5 - 1260*x^3 + 945*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">x^10 - 45*x^8 + 630*x^6 - 3150*x^4 + 4725*x^2 - 945</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">11</span><span class="p">))</span>
<span class="go">x^11 - 55*x^9 + 990*x^7 - 6930*x^5 + 17325*x^3 - 10395*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">12</span><span class="p">))</span>
<span class="go">x^12 - 66*x^10 + 1485*x^8 - 13860*x^6 + 51975*x^4 - 62370*x^2 + 10395</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">13</span><span class="p">))</span>
<span class="go">x^13 - 78*x^11 + 2145*x^9 - 25740*x^7 + 135135*x^5 - 270270*x^3 + 135135*x</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">x^3 - 3*x</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">x^3 - 2*x</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">x^3 - x</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[],</span> <span class="mi">1</span><span class="p">:[],</span> <span class="mi">2</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">x^3</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">x^2 - 1</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">x^3 - 3*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">x^4 - 6*x^2 + 3</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">x^5 - 10*x^3 + 15*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">x^6 - 15*x^4 + 45*x^2 - 15</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">x^7 - 21*x^5 + 105*x^3 - 105*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">x^8 - 28*x^6 + 210*x^4 - 420*x^2 + 105</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">9</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">x^9 - 36*x^7 + 378*x^5 - 1260*x^3 + 945*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">x^10 - 45*x^8 + 630*x^6 - 3150*x^4 + 4725*x^2 - 945</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">11</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">x^11 - 55*x^9 + 990*x^7 - 6930*x^5 + 17325*x^3 - 10395*x</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">x^12 - 66*x^10 + 1485*x^8 - 13860*x^6 + 51975*x^4 - 62370*x^2 + 10395</span>
<span class="gp">sage: </span><span class="n">matching_polynomial</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">13</span><span class="p">),</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">x^13 - 78*x^11 + 2145*x^9 - 25740*x^7 + 135135*x^5 - 270270*x^3 + 135135*x</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.maximum_average_degree">
<code class="descname">maximum_average_degree</code><span class="sig-paren">(</span><em>value_only=True</em>, <em>solver=None</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.maximum_average_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Maximum Average Degree (MAD) of the current graph.</p>
<p>The Maximum Average Degree (MAD) of a graph is defined as the average
degree of its densest subgraph. More formally, <code class="docutils literal notranslate"><span class="pre">Mad(G)</span> <span class="pre">=</span>
<span class="pre">\max_{H\subseteq</span> <span class="pre">G}</span> <span class="pre">Ad(H)</span></code>, where <span class="math notranslate nohighlight">\(Ad(G)\)</span> denotes the average degree of
<span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>This can be computed in polynomial time.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">value_only</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>);<ul>
<li>If <code class="docutils literal notranslate"><span class="pre">value_only=True</span></code>, only the numerical value of the <span class="math notranslate nohighlight">\(MAD\)</span> is
returned.</li>
<li>Else, the subgraph of <span class="math notranslate nohighlight">\(G\)</span> realizing the <span class="math notranslate nohighlight">\(MAD\)</span> is returned.</li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Linear Program (LP)
solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a>
of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</li>
</ul>
<p>EXAMPLES:</p>
<p>In any graph, the <span class="math notranslate nohighlight">\(Mad\)</span> is always larger than the average degree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="o">.</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">mad_g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">maximum_average_degree</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">average_degree</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">mad_g</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Unlike the average degree, the <span class="math notranslate nohighlight">\(Mad\)</span> of the disjoint union of two graphs
is the maximum of the <span class="math notranslate nohighlight">\(Mad\)</span> of each graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="o">.</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">mad_h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">maximum_average_degree</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">g</span><span class="o">+</span><span class="n">h</span><span class="p">)</span><span class="o">.</span><span class="n">maximum_average_degree</span><span class="p">()</span> <span class="o">==</span> <span class="nb">max</span><span class="p">(</span><span class="n">mad_g</span><span class="p">,</span> <span class="n">mad_h</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The subgraph of a regular graph realizing the maximum average degree is
always the whole graph</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">mad_g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">maximum_average_degree</span><span class="p">(</span><span class="n">value_only</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">mad_g</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This also works for complete bipartite graphs</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">mad_g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">maximum_average_degree</span><span class="p">(</span><span class="n">value_only</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">mad_g</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.minimum_outdegree_orientation">
<code class="descname">minimum_outdegree_orientation</code><span class="sig-paren">(</span><em>use_edge_labels=False</em>, <em>solver=None</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.minimum_outdegree_orientation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an orientation of <code class="docutils literal notranslate"><span class="pre">self</span></code> with the smallest possible maximum
outdegree.</p>
<p>Given a Graph <span class="math notranslate nohighlight">\(G\)</span>, it is polynomial to compute an orientation <span class="math notranslate nohighlight">\(D\)</span> of the
edges of <span class="math notranslate nohighlight">\(G\)</span> such that the maximum out-degree in <span class="math notranslate nohighlight">\(D\)</span> is minimized. This
problem, though, is NP-complete in the weighted case <a class="reference internal" href="../../../references/index.html#amoz2006" id="id42">[AMOZ2006]</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">use_edge_labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)<ul>
<li>When set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, uses edge labels as weights to compute the
orientation and assumes a weight of <span class="math notranslate nohighlight">\(1\)</span> when there is no value
available for a given edge.</li>
<li>When set to <code class="docutils literal notranslate"><span class="pre">False</span></code> (default), gives a weight of 1 to all the
edges.</li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Linear Program (LP)
solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a>
of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</li>
</ul>
<p>EXAMPLES:</p>
<p>Given a complete bipartite graph <span class="math notranslate nohighlight">\(K_{n,m}\)</span>, the maximum out-degree of an
optimal orientation is <span class="math notranslate nohighlight">\(\left\lceil \frac {nm} {n+m}\right\rceil\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">minimum_outdegree_orientation</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">max</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">out_degree</span><span class="p">())</span> <span class="o">==</span> <span class="n">ceil</span><span class="p">((</span><span class="mi">4</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="mi">4</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.minor">
<code class="descname">minor</code><span class="sig-paren">(</span><em>H</em>, <em>solver=None</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.minor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertices of a minor isomorphic to <span class="math notranslate nohighlight">\(H\)</span> in the current graph.</p>
<p>We say that a graph <span class="math notranslate nohighlight">\(G\)</span> has a <span class="math notranslate nohighlight">\(H\)</span>-minor (or that it has a graph
isomorphic to <span class="math notranslate nohighlight">\(H\)</span> as a minor), if for all <span class="math notranslate nohighlight">\(h\in H\)</span>, there exist disjoint
sets <span class="math notranslate nohighlight">\(S_h \subseteq V(G)\)</span> such that once the vertices of each <span class="math notranslate nohighlight">\(S_h\)</span> have
been merged to create a new graph <span class="math notranslate nohighlight">\(G'\)</span>, this new graph contains <span class="math notranslate nohighlight">\(H\)</span> as a
subgraph.</p>
<p>For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Minor_(graph_theory)">Wikipedia article Minor_(graph_theory)</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">H</span></code> – The minor to find for in the current graph.</li>
<li><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Linear Program (LP) solver
to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For more
information on LP solvers and which default solver is used, see the
method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve()</span></code></a> of
the class <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</li>
</ul>
<p>OUTPUT:</p>
<p>A dictionary associating to each vertex of <span class="math notranslate nohighlight">\(H\)</span> the set of vertices in
the current graph representing it.</p>
<p>ALGORITHM:</p>
<p>Mixed Integer Linear Programming</p>
<p>COMPLEXITY:</p>
<p>Theoretically, when <span class="math notranslate nohighlight">\(H\)</span> is fixed, testing for the existence of a
<span class="math notranslate nohighlight">\(H\)</span>-minor is polynomial. The known algorithms are highly exponential in
<span class="math notranslate nohighlight">\(H\)</span>, though.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function can be expected to be <em>very</em> slow, especially where
the minor does not exist.</p>
</div>
<p>EXAMPLES:</p>
<p>Trying to find a minor isomorphic to <span class="math notranslate nohighlight">\(K_4\)</span> in the <span class="math notranslate nohighlight">\(4\times 4\)</span> grid:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">GridGraph</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">minor</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">gg</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">max_level</span> <span class="o">=</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">_</span> <span class="o">=</span> <span class="p">[</span><span class="n">gg</span><span class="o">.</span><span class="n">merge_vertices</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">L</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">gg</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We can also try to prove this way that the Petersen graph is not planar,
as it has a <span class="math notranslate nohighlight">\(K_5\)</span> minor:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">K5_minor</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">minor</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>                    <span class="c1"># long time</span>
</pre></div>
</div>
<p>And even a <span class="math notranslate nohighlight">\(K_{3,3}\)</span> minor:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K33_minor</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">minor</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>        <span class="c1"># long time</span>
</pre></div>
</div>
<p>(It is much faster to use the linear-time test of planarity in this
situation, though.)</p>
<p>As there is no cycle in a tree, looking for a <span class="math notranslate nohighlight">\(K_3\)</span> minor is useless.
This function will raise an exception in this case:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">edges</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_tree</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">minor</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: This graph has no minor isomorphic to H !</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.modular_decomposition">
<code class="descname">modular_decomposition</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.modular_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the modular decomposition of the current graph.</p>
<p>Crash course on modular decomposition:</p>
<p>A module <span class="math notranslate nohighlight">\(M\)</span> of a graph <span class="math notranslate nohighlight">\(G\)</span> is a proper subset of its vertices such that
for all <span class="math notranslate nohighlight">\(u \in V(G)-M, v,w\in M\)</span> the relation <span class="math notranslate nohighlight">\(u \sim v \Leftrightarrow
u \sim w\)</span> holds, where <span class="math notranslate nohighlight">\(\sim\)</span> denotes the adjacency relation in
<span class="math notranslate nohighlight">\(G\)</span>. Equivalently, <span class="math notranslate nohighlight">\(M \subset V(G)\)</span> is a module if all its vertices have
the same adjacency relations with each vertex outside of the module
(vertex by vertex).</p>
<p>Hence, for a set like a module, it is very easy to encode the
information of the adjacencies between the vertices inside and outside
the module – we can actually add a new vertex <span class="math notranslate nohighlight">\(v_M\)</span> to our graph
representing our module <span class="math notranslate nohighlight">\(M\)</span>, and let <span class="math notranslate nohighlight">\(v_M\)</span> be adjacent to <span class="math notranslate nohighlight">\(u\in V(G)-M\)</span>
if and only if some <span class="math notranslate nohighlight">\(v\in M\)</span> (and hence all the vertices contained in
the module) is adjacent to <span class="math notranslate nohighlight">\(u\)</span>. We can now independently (and
recursively) study the structure of our module <span class="math notranslate nohighlight">\(M\)</span> and the new graph
<span class="math notranslate nohighlight">\(G-M+\{v_M\}\)</span>, without any loss of information.</p>
<p>Here are two very simple modules :</p>
<ul class="simple">
<li>A connected component <span class="math notranslate nohighlight">\(C\)</span> (or the union of some –but not all– of
them) of a disconnected graph <span class="math notranslate nohighlight">\(G\)</span>, for instance, is a module, as no
vertex of <span class="math notranslate nohighlight">\(C\)</span> has a neighbor outside of it.</li>
<li>An anticomponent <span class="math notranslate nohighlight">\(C\)</span> (or the union of some –but not all– of them) of
an non-anticonnected graph <span class="math notranslate nohighlight">\(G\)</span>, for the same reason (it is just the
complement of the previous graph !).</li>
</ul>
<p>These modules being of special interest, the disjoint union of graphs is
called a Parallel composition, and the complement of a disjoint union is
called a Series composition. A graph whose only modules are singletons
is called Prime.</p>
<p>For more information on modular decomposition, in particular for an
explanation of the terms “Parallel,” “Prime” and “Series,” see the
<a class="reference external" href="https://en.wikipedia.org/wiki/Modular_decomposition">Wikipedia article Modular_decomposition</a>.</p>
<p>You may also be interested in the survey from Michel Habib and
Christophe Paul entitled “A survey on Algorithmic aspects of modular
decomposition” <a class="reference internal" href="../../../references/index.html#hp2010" id="id43">[HP2010]</a>.</p>
<p>OUTPUT:</p>
<p>A pair of two values (recursively encoding the decomposition) :</p>
<ul class="simple">
<li>The type of the current module :<ul>
<li><code class="docutils literal notranslate"><span class="pre">&quot;PARALLEL&quot;</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;PRIME&quot;</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;SERIES&quot;</span></code></li>
</ul>
</li>
<li>The list of submodules (as list of pairs <code class="docutils literal notranslate"><span class="pre">(type,</span> <span class="pre">list)</span></code>,
recursively…) or the vertex’s name if the module is a singleton.</li>
</ul>
<p>EXAMPLES:</p>
<p>The Bull Graph is prime:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">BullGraph</span><span class="p">()</span><span class="o">.</span><span class="n">modular_decomposition</span><span class="p">()</span>
<span class="go">(PRIME, [1, 2, 0, 3, 4])</span>
</pre></div>
</div>
<p>The Petersen Graph too:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">modular_decomposition</span><span class="p">()</span>
<span class="go">(PRIME, [1, 4, 5, 0, 3, 7, 2, 8, 9, 6])</span>
</pre></div>
</div>
<p>This a clique on 5 vertices with 2 pendant edges, though, has a more
interesting decomposition</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">modular_decomposition</span><span class="p">()</span>
<span class="go">(SERIES, [(PARALLEL, [(SERIES, [4, 3, 2, 1]), 5, 6]), 0])</span>
</pre></div>
</div>
<p>ALGORITHM:</p>
<p>This function uses python implementation of algorithm published by Marc
Tedder, Derek Corneil, Michel Habib and Christophe Paul
<a class="reference internal" href="../../../references/index.html#tchp2008" id="id44">[TCHP2008]</a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.graphs.graph.Graph.is_prime" title="sage.graphs.graph.Graph.is_prime"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_prime()</span></code></a> – Tests whether a graph is prime.</li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.most_common_neighbors">
<code class="descname">most_common_neighbors</code><span class="sig-paren">(</span><em>nonedgesonly=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.most_common_neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vertex pairs with maximal number of common neighbors.</p>
<p>This method is only valid for simple (no loops, no multiple edges)
graphs with order <span class="math notranslate nohighlight">\(\geq 2\)</span></p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">nonedgesonly</span></code>– boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, assigns
<span class="math notranslate nohighlight">\(0\)</span> value to adjacent vertices.</li>
</ul>
<p>OUTPUT: list of tuples of edge pairs</p>
<p>EXAMPLES:</p>
<p>The maximum common neighbor (non-adjacent) pairs for a straight
linear 2-tree</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G1</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G1</span><span class="o">.</span><span class="n">most_common_neighbors</span><span class="p">()</span>
<span class="go">[(0, 3), (1, 4), (2, 5)]</span>
</pre></div>
</div>
<p>If we include non-adjacent pairs</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G1</span><span class="o">.</span><span class="n">most_common_neighbors</span><span class="p">(</span><span class="n">nonedgesonly</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="go">[(0, 3), (1, 2), (1, 4), (2, 3), (2, 5), (3, 4)]</span>
</pre></div>
</div>
<p>The common neighbors matrix  for a fan on 6 vertices counting only
non-adjacent vertex pairs</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">most_common_neighbors</span><span class="p">()</span>
<span class="go">[(1, 3), (2, 4), (3, 5)]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.graphs.graph.Graph.common_neighbors_matrix" title="sage.graphs.graph.Graph.common_neighbors_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">common_neighbors_matrix()</span></code></a> –
a similar method giving a matrix of number of common neighbors</li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.orientations">
<code class="descname">orientations</code><span class="sig-paren">(</span><em>data_structure=None</em>, <em>sparse=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.orientations" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over orientations of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>An <em>orientation</em> of an undirected graph is a directed graph such that
every edge is assigned a direction.  Hence there are <span class="math notranslate nohighlight">\(2^s\)</span> oriented
digraphs for a simple graph with <span class="math notranslate nohighlight">\(s\)</span> edges.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">data_structure</span></code> – one of <code class="docutils literal notranslate"><span class="pre">&quot;sparse&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;static_sparse&quot;</span></code>, or
<code class="docutils literal notranslate"><span class="pre">&quot;dense&quot;</span></code>; see the documentation of <a class="reference internal" href="#sage.graphs.graph.Graph" title="sage.graphs.graph.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a> or
<a class="reference internal" href="digraph.html#sage.graphs.digraph.DiGraph" title="sage.graphs.digraph.DiGraph"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraph</span></code></a>; default is the data structure of <code class="docutils literal notranslate"><span class="pre">self</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">sparse</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); <code class="docutils literal notranslate"><span class="pre">sparse=True</span></code> is an alias
for <code class="docutils literal notranslate"><span class="pre">data_structure=&quot;sparse&quot;</span></code>, and <code class="docutils literal notranslate"><span class="pre">sparse=False</span></code> is an alias for
<code class="docutils literal notranslate"><span class="pre">data_structure=&quot;dense&quot;</span></code>. By default (<code class="docutils literal notranslate"><span class="pre">None</span></code>), guess the most
suitable data structure.</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This always considers multiple edges of graphs as distinguishable,
and hence, may have repeated digraphs.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)]],</span> <span class="n">format</span><span class="o">=</span><span class="s1">&#39;vertices_and_edges&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">orientations</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(1, 2, &#39;a&#39;), (1, 3, &#39;b&#39;)]</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(1, 2, &#39;a&#39;), (3, 1, &#39;b&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.pathwidth">
<code class="descname">pathwidth</code><span class="sig-paren">(</span><em>k=None</em>, <em>certificate=False</em>, <em>algorithm='BAB'</em>, <em>verbose=False</em>, <em>max_prefix_length=20</em>, <em>max_prefix_number=1000000</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.pathwidth" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the pathwidth of <code class="docutils literal notranslate"><span class="pre">self</span></code> (and provides a decomposition)</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">k</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the width to be considered. When
<code class="docutils literal notranslate"><span class="pre">k</span></code> is an integer, the method checks that the graph has pathwidth
<span class="math notranslate nohighlight">\(\leq k\)</span>. If <code class="docutils literal notranslate"><span class="pre">k</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), the method computes the optimal
pathwidth.</li>
<li><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
path-decomposition itself</li>
<li><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">&quot;BAB&quot;</span></code>); algorithm to use among:<ul>
<li><code class="docutils literal notranslate"><span class="pre">&quot;BAB&quot;</span></code> – Use a branch-and-bound algorithm. This algorithm has no
size restriction but could take a very long time on large graphs. It can
also be used to test is the input graph has pathwidth <span class="math notranslate nohighlight">\(\leq k\)</span>, in which
cas it will return the first found solution with width <span class="math notranslate nohighlight">\(\leq k\)</span> is
<code class="docutils literal notranslate"><span class="pre">certificate==True</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">exponential</span></code> – Use an exponential time and space algorithm. This
algorithm only works of graphs on less than 32 vertices.</li>
<li><code class="docutils literal notranslate"><span class="pre">MILP</span></code> – Use a mixed integer linear programming formulation. This
algorithm has no size restriction but could take a very long time.</li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to display
information on the computations</li>
<li><code class="docutils literal notranslate"><span class="pre">max_prefix_length</span></code> – integer (default: 20); limits the length of the
stored prefixes to prevent storing too many prefixes. This parameter is
used only when <code class="docutils literal notranslate"><span class="pre">algorithm==&quot;BAB&quot;</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">max_prefix_number</span></code> – integer (default: 10**6); upper bound on the
number of stored prefixes used to prevent using too much memory. This
parameter is used only when <code class="docutils literal notranslate"><span class="pre">algorithm==&quot;BAB&quot;</span></code>.</li>
</ul>
<p>OUTPUT:</p>
<p>Return the pathwidth of <code class="docutils literal notranslate"><span class="pre">self</span></code>. When <code class="docutils literal notranslate"><span class="pre">k</span></code> is specified, it returns
<code class="docutils literal notranslate"><span class="pre">False</span></code> when no path-decomposition of width <span class="math notranslate nohighlight">\(\leq k\)</span> exists or <code class="docutils literal notranslate"><span class="pre">True</span></code>
otherwise. When <code class="docutils literal notranslate"><span class="pre">certificate=True</span></code>, the path-decomposition is also
returned.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.graphs.graph.Graph.treewidth" title="sage.graphs.graph.Graph.treewidth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.treewidth()</span></code></a> – computes the treewidth of a graph</li>
<li><a class="reference internal" href="graph_decompositions/vertex_separation.html#sage.graphs.graph_decompositions.vertex_separation.vertex_separation" title="sage.graphs.graph_decompositions.vertex_separation.vertex_separation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertex_separation()</span></code></a>
– computes the vertex separation of a (di)graph</li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>The pathwidth of a cycle is equal to 2:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">pathwidth</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pw</span><span class="p">,</span> <span class="n">decomp</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">pathwidth</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">decomp</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="go">[{0, 1, 5}, {1, 2, 5}, {2, 3, 4}, {2, 4, 5}]</span>
</pre></div>
</div>
<p>The pathwidth of a Petersen graph is 5:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">pathwidth</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">pathwidth</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">pathwidth</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">pathwidth</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(True, Graph on 5 vertices)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.perfect_matchings">
<code class="descname">perfect_matchings</code><span class="sig-paren">(</span><em>labels=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.perfect_matchings" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over all perfect matchings of the graph.</p>
<p>ALGORITHM:</p>
<p>Choose a vertex <span class="math notranslate nohighlight">\(v\)</span>, then recurse through all edges incident to <span class="math notranslate nohighlight">\(v\)</span>,
removing one edge at a time whenever an edge is added to a matching.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); when <code class="docutils literal notranslate"><span class="pre">True</span></code>, the edges
in each perfect matching are triples (containing the label as the
third element), otherwise the edges are pairs.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.graphs.graph.Graph.matching" title="sage.graphs.graph.Graph.matching"><code class="xref py py-meth docutils literal notranslate"><span class="pre">matching()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">GridGraph</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">perfect_matchings</span><span class="p">():</span>
<span class="gp">....: </span>    <span class="k">print</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
<span class="go">[((0, 0), (0, 1)), ((0, 2), (1, 2)), ((1, 0), (1, 1))]</span>
<span class="go">[((0, 0), (1, 0)), ((0, 1), (0, 2)), ((1, 1), (1, 2))]</span>
<span class="go">[((0, 0), (1, 0)), ((0, 1), (1, 1)), ((0, 2), (1, 2))]</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">perfect_matchings</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">print</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
<span class="go">[(0, 1, None), (2, 3, None)]</span>
<span class="go">[(0, 2, None), (1, 3, None)]</span>
<span class="go">[(0, 3, None), (1, 2, None)]</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">perfect_matchings</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="go">[[(-2, 1, &#39;x&#39;), (-1, 2, &#39;y&#39;)], [(-2, 2, &#39;b&#39;), (-1, 1, &#39;a&#39;)]]</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">mpc</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">matching_polynomial</span><span class="p">()</span><span class="o">.</span><span class="n">coefficients</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">perfect_matchings</span><span class="p">()))</span> <span class="o">==</span> <span class="n">mpc</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">immutable</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">perfect_matchings</span><span class="p">())</span>
<span class="go">[[(0, 1), (2, 3), (4, 9), (5, 7), (6, 8)],</span>
<span class="go"> [(0, 1), (2, 7), (3, 4), (5, 8), (6, 9)],</span>
<span class="go"> [(0, 4), (1, 2), (3, 8), (5, 7), (6, 9)],</span>
<span class="go"> [(0, 4), (1, 6), (2, 3), (5, 8), (7, 9)],</span>
<span class="go"> [(0, 5), (1, 2), (3, 4), (6, 8), (7, 9)],</span>
<span class="go"> [(0, 5), (1, 6), (2, 7), (3, 8), (4, 9)]]</span>

<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">perfect_matchings</span><span class="p">())</span>
<span class="go">[[]]</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">perfect_matchings</span><span class="p">())</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.random_orientation">
<code class="descname">random_orientation</code><span class="sig-paren">(</span><em>G</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.random_orientation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a random orientation of a graph <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>An <em>orientation</em> of an undirected graph is a directed graph such that every
edge is assigned a direction. Hence there are <span class="math notranslate nohighlight">\(2^m\)</span> oriented digraphs for a
simple graph with <span class="math notranslate nohighlight">\(m\)</span> edges.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">G</span></code> – a Graph.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.orientations</span> <span class="kn">import</span> <span class="n">random_orientation</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">random_orientation</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">order</span><span class="p">()</span> <span class="o">==</span> <span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">(),</span> <span class="n">D</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">G</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">(True, True)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.graphs.graph.Graph.orientations" title="sage.graphs.graph.Graph.orientations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">orientations()</span></code></a></li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.random_spanning_tree">
<code class="descname">random_spanning_tree</code><span class="sig-paren">(</span><em>output_as_graph=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.random_spanning_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a random spanning tree of the graph.</p>
<p>This uses the Aldous-Broder algorithm (<a class="reference internal" href="spanning_tree.html#broder89" id="id45">[Broder89]</a>, <a class="reference internal" href="spanning_tree.html#aldous90" id="id46">[Aldous90]</a>) to generate
a random spanning tree with the uniform distribution, as follows.</p>
<p>Start from any vertex. Perform a random walk by choosing at every step one
neighbor uniformly at random. Every time a new vertex <span class="math notranslate nohighlight">\(j\)</span> is met, add the
edge <span class="math notranslate nohighlight">\((i, j)\)</span> to the spanning tree, where <span class="math notranslate nohighlight">\(i\)</span> is the previous vertex in the
random walk.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">output_as_graph</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return a
list of edges or a graph</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.spanning_trees_count" title="sage.graphs.generic_graph.GenericGraph.spanning_trees_count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spanning_trees_count()</span></code></a>
and <a class="reference internal" href="#sage.graphs.graph.Graph.spanning_trees" title="sage.graphs.graph.Graph.spanning_trees"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spanning_trees()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">TietzeGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">random_spanning_tree</span><span class="p">(</span><span class="n">output_as_graph</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Graph on 12 vertices</span>
<span class="gp">sage: </span><span class="n">rg</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">random_spanning_tree</span><span class="p">();</span> <span class="n">rg</span> <span class="c1"># random</span>
<span class="go">[(0, 9),</span>
<span class="go">(9, 11),</span>
<span class="go">(0, 8),</span>
<span class="go">(8, 7),</span>
<span class="go">(7, 6),</span>
<span class="go">(7, 2),</span>
<span class="go">(2, 1),</span>
<span class="go">(1, 5),</span>
<span class="go">(9, 10),</span>
<span class="go">(5, 4),</span>
<span class="go">(2, 3)]</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="n">rg</span><span class="p">)</span><span class="o">.</span><span class="n">is_tree</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A visual example for the grid graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pos</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">get_pos</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">random_spanning_tree</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">set_pos</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">vertex_labels</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.rank_decomposition">
<code class="descname">rank_decomposition</code><span class="sig-paren">(</span><em>G</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.rank_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an optimal rank-decomposition of the given graph.</p>
<p>This function is available as a method of the <a class="reference internal" href="#module-sage.graphs.graph" title="sage.graphs.graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a> class. See <a class="reference internal" href="#sage.graphs.graph.Graph.rank_decomposition" title="sage.graphs.graph.Graph.rank_decomposition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rank_decomposition</span></code></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to display progress
information while computing the decomposition</li>
</ul>
<p>OUTPUT:</p>
<p>A pair <code class="docutils literal notranslate"><span class="pre">(rankwidth,</span> <span class="pre">decomposition_tree)</span></code>, where <code class="docutils literal notranslate"><span class="pre">rankwidth</span></code> is a
numerical value and <code class="docutils literal notranslate"><span class="pre">decomposition_tree</span></code> is a ternary tree describing the
decomposition (cf. the module’s documentation).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.graph_decompositions.rankwidth</span> <span class="kn">import</span> <span class="n">rank_decomposition</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">rank_decomposition</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">(3, Graph on 19 vertices)</span>
</pre></div>
</div>
<p>On more than 32 vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">rank_decomposition</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">RuntimeError: the rank decomposition cannot be computed on graphs of &gt;= 32 vertices</span>
</pre></div>
</div>
<p>The empty graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">rank_decomposition</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">(0, Graph on 0 vertices)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.seidel_adjacency_matrix">
<code class="descname">seidel_adjacency_matrix</code><span class="sig-paren">(</span><em>vertices=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.seidel_adjacency_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Seidel adjacency matrix of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Returns <span class="math notranslate nohighlight">\(J-I-2A\)</span>, for <span class="math notranslate nohighlight">\(A\)</span> the (ordinary) <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.adjacency_matrix" title="sage.graphs.generic_graph.GenericGraph.adjacency_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">adjacency</span> <span class="pre">matrix</span></code></a> of <code class="docutils literal notranslate"><span class="pre">self</span></code>,
<span class="math notranslate nohighlight">\(I\)</span> the identity matrix, and <span class="math notranslate nohighlight">\(J\)</span> the all-1 matrix.  It is closely
related to <a class="reference internal" href="#sage.graphs.graph.Graph.twograph" title="sage.graphs.graph.Graph.twograph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">twograph()</span></code></a>.</p>
<p>The matrix returned is over the integers. If a different ring is
desired, use either the <a class="reference external" href="../../../matrices/sage/matrix/matrix0.html#sage.matrix.matrix0.Matrix.change_ring" title="(in Sage Reference Manual: Matrices and Spaces of Matrices v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.matrix.matrix0.Matrix.change_ring()</span></code></a>
method or the <a class="reference external" href="../../../matrices/sage/matrix/constructor.html#sage.matrix.constructor.matrix" title="(in Sage Reference Manual: Matrices and Spaces of Matrices v8.9)"><code class="xref py py-func docutils literal notranslate"><span class="pre">matrix()</span></code></a> function.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – list of vertices (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the ordering of
the vertices defining how they should appear in the matrix. By
default, the ordering given by
<a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.vertices" title="sage.graphs.generic_graph.GenericGraph.vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vertices()</span></code></a> is used.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">seidel_adjacency_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">minpoly</span><span class="p">()</span>
<span class="go">x^2 - 5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.seidel_switching">
<code class="descname">seidel_switching</code><span class="sig-paren">(</span><em>s</em>, <em>inplace=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.seidel_switching" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Seidel switching of <code class="docutils literal notranslate"><span class="pre">self</span></code> w.r.t. subset of vertices <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p>
<p>Returns the graph obtained by Seidel switching of <code class="docutils literal notranslate"><span class="pre">self</span></code> with respect
to the subset of vertices <code class="docutils literal notranslate"><span class="pre">s</span></code>. This is the graph given by Seidel
adjacency matrix <span class="math notranslate nohighlight">\(DSD\)</span>, for <span class="math notranslate nohighlight">\(S\)</span> the Seidel adjacency matrix of <code class="docutils literal notranslate"><span class="pre">self</span></code>,
and <span class="math notranslate nohighlight">\(D\)</span> the diagonal matrix with -1s at positions corresponding to
<code class="docutils literal notranslate"><span class="pre">s</span></code>, and 1s elsewhere.</p>
<p>INPUT:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">s</span></code> – a list of vertices of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</li>
</ul>
</div></blockquote>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">inplace</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether to do the
modification inplace, or to return a copy of the graph after
switching.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">seidel_switching</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">seidel_adjacency_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">minpoly</span><span class="p">()</span>
<span class="go">x^2 - 5</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.spanning_trees">
<code class="descname">spanning_trees</code><span class="sig-paren">(</span><em>labels=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.spanning_trees" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of all spanning trees.</p>
<p>If the graph is disconnected, returns the empty list.</p>
<p>Uses the Read-Tarjan backtracking algorithm <a class="reference internal" href="../../../references/index.html#rt1975" id="id47">[RT1975]</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return edges
labels in the spanning trees or not</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)],</span> <span class="n">multiedges</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">spanning_trees</span><span class="p">())</span>
<span class="go">8</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">spanning_trees_count</span><span class="p">()</span>
<span class="go">8</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">)],</span> <span class="n">multiedges</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">spanning_trees</span><span class="p">())</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">spanning_trees_count</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.spanning_trees_count" title="sage.graphs.generic_graph.GenericGraph.spanning_trees_count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spanning_trees_count()</span></code></a>
– counts the number of spanning trees.</li>
<li><a class="reference internal" href="#sage.graphs.graph.Graph.random_spanning_tree" title="sage.graphs.graph.Graph.random_spanning_tree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">random_spanning_tree()</span></code></a>
– returns a random spanning tree.</li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.sparse6_string">
<code class="descname">sparse6_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.sparse6_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sparse6 representation of the graph as an ASCII string.</p>
<p>Only valid for undirected graphs on 0 to 262143 vertices, but loops
and multiple edges are permitted.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As the sparse6 format only handles graphs whose vertex set is
<span class="math notranslate nohighlight">\(\{0,...,n-1\}\)</span>, a <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.relabel" title="sage.graphs.generic_graph.GenericGraph.relabel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relabelled</span> <span class="pre">copy</span></code></a> of your graph will
be encoded if necessary.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">BullGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">sparse6_string</span><span class="p">()</span>
<span class="go">&#39;:Da@en&#39;</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">loops</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">multiedges</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">data_structure</span><span class="o">=</span><span class="s2">&quot;sparse&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;:?&#39;</span><span class="p">,</span> <span class="n">data_structure</span><span class="o">=</span><span class="s2">&quot;sparse&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">G</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.spqr_tree">
<code class="descname">spqr_tree</code><span class="sig-paren">(</span><em>G</em>, <em>algorithm='Hopcroft_Tarjan'</em>, <em>solver=None</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.spqr_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an SPQR-tree representing the triconnected components of the graph.</p>
<p>An SPQR-tree is a tree data structure used to represent the triconnected
components of a biconnected (multi)graph and the 2-vertex cuts separating
them. A node of a SPQR-tree, and the graph associated with it, can be one of
the following four types:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">&quot;S&quot;</span></code> – the associated graph is a cycle with at least three vertices.
<code class="docutils literal notranslate"><span class="pre">&quot;S&quot;</span></code> stands for <code class="docutils literal notranslate"><span class="pre">series</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;P&quot;</span></code> – the associated graph is a dipole graph, a multigraph with two
vertices and three or more edges. <code class="docutils literal notranslate"><span class="pre">&quot;P&quot;</span></code> stands for <code class="docutils literal notranslate"><span class="pre">parallel</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;Q&quot;</span></code> – the associated graph has a single real edge. This trivial case
is necessary to handle the graph that has only one edge.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;R&quot;</span></code> – the associated graph is a 3-connected graph that is not a cycle
or dipole. <code class="docutils literal notranslate"><span class="pre">&quot;R&quot;</span></code> stands for <code class="docutils literal notranslate"><span class="pre">rigid</span></code>.</li>
</ul>
<p>This method decomposes a biconnected graph into cycles, cocycles, and
3-connected blocks summed over cocycles, and arranges them as a SPQR-tree.
More precisely, it splits the graph at each of its 2-vertex cuts, giving a
unique decomposition into 3-connected blocks, cycles and cocycles. The
cocycles are dipole graphs with one edge per real edge between the included
vertices and one additional (virtual) edge per connected component resulting
from deletion of the vertices in the cut. See the <a class="reference external" href="https://en.wikipedia.org/wiki/SPQR_tree">Wikipedia article SPQR_tree</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">G</span></code> – the input graph</li>
<li><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">&quot;Hopcroft_Tarjan&quot;</span></code>); the algorithm to
use among:<ul>
<li><code class="docutils literal notranslate"><span class="pre">&quot;Hopcroft_Tarjan&quot;</span></code> (default) – use the algorithm proposed by
Hopcroft and Tarjan in <a class="reference internal" href="../../../references/index.html#hopcroft1973" id="id48">[Hopcroft1973]</a> and later corrected by Gutwenger
and Mutzel in <a class="reference internal" href="../../../references/index.html#gut2001" id="id49">[Gut2001]</a>. See
<a class="reference internal" href="connectivity.html#sage.graphs.connectivity.TriconnectivitySPQR" title="sage.graphs.connectivity.TriconnectivitySPQR"><code class="xref py py-class docutils literal notranslate"><span class="pre">TriconnectivitySPQR</span></code></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;cleave&quot;</span></code> – using method <a class="reference internal" href="connectivity.html#sage.graphs.connectivity.cleave" title="sage.graphs.connectivity.cleave"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cleave()</span></code></a></li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">solver</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specifies a Linear Program (LP)
solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For more
information on LP solvers and which default solver is used, see the method
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.numerical.mip.MixedIntegerLinearProgram.solve()</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.numerical.mip.MixedIntegerLinearProgram</span></code></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of verbosity. Set
to 0 by default, which means quiet.</li>
</ul>
<p>OUTPUT: <code class="docutils literal notranslate"><span class="pre">SPQR-tree</span></code> a tree whose vertices are labeled with the block’s type
and the subgraph of three-blocks in the decomposition.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.connectivity</span> <span class="kn">import</span> <span class="n">spqr_tree</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">G</span><span class="o">.</span><span class="n">add_clique</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(),</span> <span class="n">G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">()])</span>
<span class="gp">sage: </span><span class="n">Tree</span> <span class="o">=</span> <span class="n">spqr_tree</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Tree</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">K4</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">K4</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">Tree</span> <span class="k">if</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;R&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.connectivity</span> <span class="kn">import</span> <span class="n">spqr_tree_to_graph</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">spqr_tree_to_graph</span><span class="p">(</span><span class="n">Tree</span><span class="p">))</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">G</span><span class="o">.</span><span class="n">add_path</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(),</span> <span class="n">G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(),</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Tree</span> <span class="o">=</span> <span class="n">spqr_tree</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Tree</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">C4</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">C4</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">Tree</span> <span class="k">if</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;S&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">spqr_tree_to_graph</span><span class="p">(</span><span class="n">Tree</span><span class="p">))</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">allow_multiple_edges</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">Tree</span> <span class="o">=</span> <span class="n">spqr_tree</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Tree</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">13</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">C4</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">Tree</span> <span class="k">if</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;S&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">spqr_tree_to_graph</span><span class="p">(</span><span class="n">Tree</span><span class="p">))</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Tree</span> <span class="o">=</span> <span class="n">spqr_tree</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Tree</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">spqr_tree_to_graph</span><span class="p">(</span><span class="n">Tree</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Tree</span> <span class="o">=</span> <span class="n">spqr_tree</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Tree</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">spqr_tree_to_graph</span><span class="p">(</span><span class="n">Tree</span><span class="p">))</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="s1">&#39;LlCG{O@?GBoMw?&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">spqr_tree</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Hopcroft_Tarjan&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">spqr_tree_to_graph</span><span class="p">(</span><span class="n">T</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">T2</span> <span class="o">=</span> <span class="n">spqr_tree</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;cleave&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">spqr_tree_to_graph</span><span class="p">(</span><span class="n">T2</span><span class="p">))</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">multiedges</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">spqr_tree</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;cleave&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[(&#39;Q&#39;, Multi-graph on 2 vertices)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">spqr_tree_to_graph</span><span class="p">(</span><span class="n">T</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">spqr_tree</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Hopcroft_Tarjan&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[(&#39;Q&#39;, Multi-graph on 2 vertices)]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">spqr_tree</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;cleave&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[(&#39;P&#39;, Multi-graph on 2 vertices)]</span>

<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">spqr_tree</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Hopcroft_Tarjan&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Counter</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">T</span><span class="p">)</span>
<span class="go">Counter({&#39;R&#39;: 1})</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">spqr_tree</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;cleave&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Counter</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">T</span><span class="p">)</span>
<span class="go">Counter({&#39;R&#39;: 1})</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">G</span><span class="o">.</span><span class="n">add_path</span><span class="p">([</span><span class="n">u</span><span class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(),</span> <span class="n">G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(),</span> <span class="n">v</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">spqr_tree</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Hopcroft_Tarjan&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;P&#39;, 15), (&#39;R&#39;, 1), (&#39;S&#39;, 15)]</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">spqr_tree</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;cleave&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;P&#39;, 15), (&#39;R&#39;, 1), (&#39;S&#39;, 15)]</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">G</span><span class="o">.</span><span class="n">add_path</span><span class="p">([</span><span class="n">u</span><span class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(),</span> <span class="n">G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(),</span> <span class="n">v</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">spqr_tree</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;Hopcroft_Tarjan&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;P&#39;, 60), (&#39;R&#39;, 1), (&#39;S&#39;, 75)]</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">spqr_tree</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;cleave&quot;</span><span class="p">)</span>       <span class="c1"># long time</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>  <span class="c1"># long time</span>
<span class="go">[(&#39;P&#39;, 60), (&#39;R&#39;, 1), (&#39;S&#39;, 75)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.strong_orientation">
<code class="descname">strong_orientation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.strong_orientation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a strongly connected orientation of the current graph.</p>
<p>An orientation of an undirected graph is a digraph obtained by giving an
unique direction to each of its edges. An orientation is said to be
strong if there is a directed path between each pair of vertices.  See
also the <a class="reference external" href="https://en.wikipedia.org/wiki/Strongly_connected_component">Wikipedia article Strongly_connected_component</a>.</p>
<p>If the graph is 2-edge-connected, a strongly connected orientation
can be found in linear time. If the given graph is not 2-connected,
the orientation returned will ensure that each 2-connected component
has a strongly connected orientation.</p>
<p>OUTPUT:</p>
<p>A digraph representing an orientation of the current graph.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>This method assumes the graph is connected.</li>
<li>This algorithm works in O(m).</li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>For a 2-regular graph, a strong orientation gives to each vertex an
out-degree equal to 1:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">strong_orientation</span><span class="p">()</span><span class="o">.</span><span class="n">out_degree</span><span class="p">()</span>
<span class="go">[1, 1, 1, 1, 1]</span>
</pre></div>
</div>
<p>The Petersen Graph is 2-edge connected. It then has a strongly connected
orientation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">strong_orientation</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">strongly_connected_components</span><span class="p">())</span>
<span class="go">1</span>
</pre></div>
</div>
<p>The same goes for the CubeGraph in any dimension</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CubeGraph</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">strong_orientation</span><span class="p">()</span><span class="o">.</span><span class="n">strongly_connected_components</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A multigraph also has a strong orientation</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span> <span class="n">multiedges</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">strong_orientation</span><span class="p">()</span>
<span class="go">Multi-digraph on 2 vertices</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.strong_orientations_iterator">
<code class="descname">strong_orientations_iterator</code><span class="sig-paren">(</span><em>G</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.strong_orientations_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator over all strong orientations of a graph <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>A strong orientation of a graph is an orientation of its edges such that
the obtained digraph is strongly connected (i.e. there exist a directed path
between each pair of vertices).</p>
<p>ALGORITHM:</p>
<p>It is an adaptation of the algorithm published in <a class="reference internal" href="../../../references/index.html#cgmrv16" id="id50">[CGMRV16]</a>.
It runs in <span class="math notranslate nohighlight">\(O(mn)\)</span> amortized time, where <span class="math notranslate nohighlight">\(m\)</span> is the number of edges and
<span class="math notranslate nohighlight">\(n\)</span> is the number of vertices. The amortized time can be improved to <span class="math notranslate nohighlight">\(O(m)\)</span>
with a more involved method.
In this function, first the graph is preprocessed and a spanning tree is
generated. Then every orientation of the non-tree edges of the graph can be
extended to at least one new strong orientation by orienting properly
the edges of the spanning tree (this property is proved in <a class="reference internal" href="../../../references/index.html#cgmrv16" id="id51">[CGMRV16]</a>).
Therefore, this function generates all partial orientations of the non-tree
edges and then launches a helper function corresponding to the generation
algorithm described in <a class="reference internal" href="../../../references/index.html#cgmrv16" id="id52">[CGMRV16]</a>.
In order to avoid trivial symmetries, the orientation of an arbitrary edge
is fixed before the start of the enumeration process.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">G</span></code> – an undirected graph.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>an iterator which will produce all strong orientations of this graph.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Works only for simple graphs (no multiple edges).
To avoid symmetries an orientation of an arbitrary edge is fixed.</p>
</div>
<p>EXAMPLES:</p>
<p>A cycle has one possible (non-symmetric) strong orientation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">strong_orientations_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">it</span><span class="p">))</span>
<span class="go">1</span>
</pre></div>
</div>
<p>A tree cannot be strongly oriented:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomTree</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">strong_orientations_iterator</span><span class="p">()))</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Neither can be a disconnected graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">strong_orientations_iterator</span><span class="p">()))</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.to_directed">
<code class="descname">to_directed</code><span class="sig-paren">(</span><em>data_structure=None</em>, <em>sparse=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.to_directed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a directed version of the graph.</p>
<p>A single edge becomes two edges, one in each direction.</p>
<p>INPUT:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">data_structure</span></code> – one of <code class="docutils literal notranslate"><span class="pre">&quot;sparse&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;static_sparse&quot;</span></code>, or
<code class="docutils literal notranslate"><span class="pre">&quot;dense&quot;</span></code>. See the documentation of <a class="reference internal" href="#sage.graphs.graph.Graph" title="sage.graphs.graph.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a> or
<a class="reference internal" href="digraph.html#sage.graphs.digraph.DiGraph" title="sage.graphs.digraph.DiGraph"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraph</span></code></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">sparse</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); <code class="docutils literal notranslate"><span class="pre">sparse=True</span></code> is an
alias for <code class="docutils literal notranslate"><span class="pre">data_structure=&quot;sparse&quot;</span></code>, and <code class="docutils literal notranslate"><span class="pre">sparse=False</span></code> is an
alias for <code class="docutils literal notranslate"><span class="pre">data_structure=&quot;dense&quot;</span></code>.</li>
</ul>
</div></blockquote>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
<span class="go">Petersen graph: Digraph on 10 vertices</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.to_undirected">
<code class="descname">to_undirected</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.to_undirected" title="Permalink to this definition">¶</a></dt>
<dd><p>Since the graph is already undirected, simply returns a copy of itself.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">to_undirected</span><span class="p">()</span>
<span class="go">Petersen graph: Graph on 10 vertices</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.topological_minor">
<code class="descname">topological_minor</code><span class="sig-paren">(</span><em>H</em>, <em>vertices=False</em>, <em>paths=False</em>, <em>solver=None</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.topological_minor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a topological <span class="math notranslate nohighlight">\(H\)</span>-minor from <code class="docutils literal notranslate"><span class="pre">self</span></code> if one exists.</p>
<p>We say that a graph <span class="math notranslate nohighlight">\(G\)</span> has a topological <span class="math notranslate nohighlight">\(H\)</span>-minor (or that it has a
graph isomorphic to <span class="math notranslate nohighlight">\(H\)</span> as a topological minor), if <span class="math notranslate nohighlight">\(G\)</span> contains a
subdivision of a graph isomorphic to <span class="math notranslate nohighlight">\(H\)</span> (i.e.  obtained from <span class="math notranslate nohighlight">\(H\)</span>
through arbitrary subdivision of its edges) as a subgraph.</p>
<p>For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Minor_(graph_theory)">Wikipedia article Minor_(graph_theory)</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">H</span></code> – The topological minor to find in the current graph.</li>
<li><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Linear Program (LP)
solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</li>
</ul>
<p>OUTPUT:</p>
<p>The topological <span class="math notranslate nohighlight">\(H\)</span>-minor found is returned as a subgraph <span class="math notranslate nohighlight">\(M\)</span> of
<code class="docutils literal notranslate"><span class="pre">self</span></code>, such that the vertex <span class="math notranslate nohighlight">\(v\)</span> of <span class="math notranslate nohighlight">\(M\)</span> that represents a vertex <span class="math notranslate nohighlight">\(h\in
H\)</span> has <code class="docutils literal notranslate"><span class="pre">h</span></code> as a label (see <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.get_vertex" title="sage.graphs.generic_graph.GenericGraph.get_vertex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_vertex</span></code></a> and
<a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.set_vertex" title="sage.graphs.generic_graph.GenericGraph.set_vertex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_vertex</span></code></a>),
and such that every edge of <span class="math notranslate nohighlight">\(M\)</span> has as a label the edge of <span class="math notranslate nohighlight">\(H\)</span> it
(partially) represents.</p>
<p>If no topological minor is found, this method returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>ALGORITHM:</p>
<p>Mixed Integer Linear Programming.</p>
<p>COMPLEXITY:</p>
<p>Theoretically, when <span class="math notranslate nohighlight">\(H\)</span> is fixed, testing for the existence of a
topological <span class="math notranslate nohighlight">\(H\)</span>-minor is polynomial. The known algorithms are highly
exponential in <span class="math notranslate nohighlight">\(H\)</span>, though.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>This function can be expected to be <em>very</em> slow, especially where
the topological minor does not exist.</p>
<p class="last">(CPLEX seems to be <em>much</em> more efficient than GLPK on this kind of
problem)</p>
</div>
<p>EXAMPLES:</p>
<p>Petersen’s graph has a topological <span class="math notranslate nohighlight">\(K_4\)</span>-minor:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">topological_minor</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">Subgraph of (Petersen graph): Graph on ...</span>
</pre></div>
</div>
<p>And a topological <span class="math notranslate nohighlight">\(K_{3,3}\)</span>-minor:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">topological_minor</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="go">Subgraph of (Petersen graph): Graph on ...</span>
</pre></div>
</div>
<p>And of course, a tree has no topological <span class="math notranslate nohighlight">\(C_3\)</span>-minor:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="o">.</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">edges</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">topological_minor</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.treewidth">
<code class="descname">treewidth</code><span class="sig-paren">(</span><em>k=None</em>, <em>certificate=False</em>, <em>algorithm=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.treewidth" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the tree-width of <span class="math notranslate nohighlight">\(G\)</span> (and provides a decomposition)</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">k</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); indicates the width to be
considered. When <code class="docutils literal notranslate"><span class="pre">k</span></code> is an integer, the method checks that the graph
has treewidth <span class="math notranslate nohighlight">\(\leq k\)</span>. If <code class="docutils literal notranslate"><span class="pre">k</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), the method
computes the optimal tree-width.</li>
<li><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
tree-decomposition itself.</li>
<li><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – whether to use <code class="docutils literal notranslate"><span class="pre">&quot;sage&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;tdlib&quot;</span></code> (requires
the installation of the ‘tdlib’ package). The default behaviour is to
use ‘tdlib’ if it is available, and Sage’s own algorithm when it is
not.</li>
</ul>
<p>OUTPUT:</p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">g.treewidth()</span></code> returns the treewidth of <code class="docutils literal notranslate"><span class="pre">g</span></code>. When <code class="docutils literal notranslate"><span class="pre">k</span></code> is</dt>
<dd>specified, it returns <code class="docutils literal notranslate"><span class="pre">False</span></code> when no tree-decomposition of width
<span class="math notranslate nohighlight">\(\leq k\)</span> exists or <code class="docutils literal notranslate"><span class="pre">True</span></code> otherwise. When <code class="docutils literal notranslate"><span class="pre">certificate=True</span></code>,
the tree-decomposition is also returned.</dd>
</dl>
</div></blockquote>
<p>ALGORITHM:</p>
<blockquote>
<div><p>This function virtually explores the graph of all pairs
<code class="docutils literal notranslate"><span class="pre">(vertex_cut,cc)</span></code>, where <code class="docutils literal notranslate"><span class="pre">vertex_cut</span></code> is a vertex cut of the
graph of cardinality <span class="math notranslate nohighlight">\(\leq k+1\)</span>, and <code class="docutils literal notranslate"><span class="pre">connected_component</span></code> is a
connected component of the graph induced by <code class="docutils literal notranslate"><span class="pre">G-vertex_cut</span></code>.</p>
<p>We deduce that the pair <code class="docutils literal notranslate"><span class="pre">(vertex_cut,cc)</span></code> is feasible with
tree-width <span class="math notranslate nohighlight">\(k\)</span> if <code class="docutils literal notranslate"><span class="pre">cc</span></code> is empty, or if a vertex <code class="docutils literal notranslate"><span class="pre">v</span></code> from
<code class="docutils literal notranslate"><span class="pre">vertex_cut</span></code> can be replaced with a vertex from <code class="docutils literal notranslate"><span class="pre">cc</span></code>, such that
the pair <code class="docutils literal notranslate"><span class="pre">(vertex_cut+v,cc-v)</span></code> is feasible.</p>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The implementation would be much faster if <code class="docutils literal notranslate"><span class="pre">cc</span></code>, the argument of the
recursive function, was a bitset. It would also be very nice to not copy
the graph in order to compute connected components, for this is really a
waste of time.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="graph_decompositions/vertex_separation.html#sage.graphs.graph_decompositions.vertex_separation.path_decomposition" title="sage.graphs.graph_decompositions.vertex_separation.path_decomposition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">path_decomposition()</span></code></a>
computes the pathwidth of a graph. See also the
<a class="reference internal" href="graph_decompositions/vertex_separation.html#module-sage.graphs.graph_decompositions.vertex_separation" title="sage.graphs.graph_decompositions.vertex_separation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vertex_separation</span></code></a> module.</p>
</div>
<p>EXAMPLES:</p>
<p>The PetersenGraph has treewidth 4:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">treewidth</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">treewidth</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Tree decomposition: Graph on 6 vertices</span>
</pre></div>
</div>
<p>The treewidth of a 2d grid is its smallest side:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">treewidth</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">Grid2dGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">treewidth</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.tutte_polynomial">
<code class="descname">tutte_polynomial</code><span class="sig-paren">(</span><em>G</em>, <em>edge_selector=None</em>, <em>cache=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.tutte_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Tutte polynomial of the graph <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">edge_selector</span></code> (optional; method) this argument allows the user
to specify his own heuristic for selecting edges used in the deletion
contraction recurrence</li>
<li><code class="docutils literal notranslate"><span class="pre">cache</span></code> – (optional; dict) a dictionary to cache the Tutte
polynomials generated in the recursive process.  One will be
created automatically if not provided.</li>
</ul>
<p>EXAMPLES:</p>
<p>The Tutte polynomial of any tree of order <span class="math notranslate nohighlight">\(n\)</span> is <span class="math notranslate nohighlight">\(x^{n-1}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">tutte_polynomial</span><span class="p">()</span> <span class="o">==</span> <span class="n">x</span><span class="o">**</span><span class="mi">9</span> <span class="k">for</span> <span class="n">T</span> <span class="ow">in</span> <span class="n">graphs</span><span class="o">.</span><span class="n">trees</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Tutte polynomial of the Petersen graph is:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">tutte_polynomial</span><span class="p">()</span>
<span class="go">x^9 + 6*x^8 + 21*x^7 + 56*x^6 + 12*x^5*y + y^6 + 114*x^5 + 70*x^4*y</span>
<span class="go">+ 30*x^3*y^2 + 15*x^2*y^3 + 10*x*y^4 + 9*y^5 + 170*x^4 + 170*x^3*y</span>
<span class="go">+ 105*x^2*y^2 + 65*x*y^3 + 35*y^4 + 180*x^3 + 240*x^2*y + 171*x*y^2</span>
<span class="go">+ 75*y^3 + 120*x^2 + 168*x*y + 84*y^2 + 36*x + 36*y</span>
</pre></div>
</div>
<p>The Tutte polynomial of <span class="math notranslate nohighlight">\(G\)</span> evaluated at (1,1) is the number of
spanning trees of <span class="math notranslate nohighlight">\(G\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mf">0.6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">tutte_polynomial</span><span class="p">()(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">G</span><span class="o">.</span><span class="n">spanning_trees_count</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Given that <span class="math notranslate nohighlight">\(T(x,y)\)</span> is the Tutte polynomial of a graph <span class="math notranslate nohighlight">\(G\)</span> with
<span class="math notranslate nohighlight">\(n\)</span> vertices and <span class="math notranslate nohighlight">\(c\)</span> connected components, then <span class="math notranslate nohighlight">\((-1)^{n-c} x^k
T(1-x,0)\)</span> is the chromatic polynomial of <span class="math notranslate nohighlight">\(G\)</span>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">OctahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">tutte_polynomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">^</span><span class="mi">5</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">T</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">(x - 2) * (x - 1) * x * (x^3 - 9*x^2 + 29*x - 32)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">chromatic_polynomial</span><span class="p">()</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">(x - 2) * (x - 1) * x * (x^3 - 9*x^2 + 29*x - 32)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.two_factor_petersen">
<code class="descname">two_factor_petersen</code><span class="sig-paren">(</span><em>solver=None</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.two_factor_petersen" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a decomposition of the graph into 2-factors.</p>
<p>Petersen’s 2-factor decomposition theorem asserts that any <span class="math notranslate nohighlight">\(2r\)</span>-regular
graph <span class="math notranslate nohighlight">\(G\)</span> can be decomposed into 2-factors.  Equivalently, it means that
the edges of any <span class="math notranslate nohighlight">\(2r\)</span>-regular graphs can be partitionned in <span class="math notranslate nohighlight">\(r\)</span> sets
<span class="math notranslate nohighlight">\(C_1,\dots,C_r\)</span> such that for all <span class="math notranslate nohighlight">\(i\)</span>, the set <span class="math notranslate nohighlight">\(C_i\)</span> is a disjoint union
of cycles (a 2-regular graph).</p>
<p>As any graph of maximal degree <span class="math notranslate nohighlight">\(\Delta\)</span> can be completed into a regular
graph of degree <span class="math notranslate nohighlight">\(2\lceil\frac\Delta 2\rceil\)</span>, this result also means
that the edges of any graph of degree <span class="math notranslate nohighlight">\(\Delta\)</span> can be partitionned in
<span class="math notranslate nohighlight">\(r=2\lceil\frac\Delta 2\rceil\)</span> sets <span class="math notranslate nohighlight">\(C_1,\dots,C_r\)</span> such that for all
<span class="math notranslate nohighlight">\(i\)</span>, the set <span class="math notranslate nohighlight">\(C_i\)</span> is a graph of maximal degree <span class="math notranslate nohighlight">\(2\)</span> (a disjoint union of
paths and cycles).</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Linear Program (LP)
solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of
verbosity. Set to 0 by default, which means quiet.</li>
</ul>
<p>EXAMPLES:</p>
<p>The Complete Graph on <span class="math notranslate nohighlight">\(7\)</span> vertices is a <span class="math notranslate nohighlight">\(6\)</span>-regular graph, so it can be
edge-partitionned into <span class="math notranslate nohighlight">\(2\)</span>-regular graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">classes</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">two_factor_petersen</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">classes</span><span class="p">:</span>
<span class="gp">....: </span>    <span class="n">gg</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="n">gg</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">print</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">gg</span><span class="o">.</span><span class="n">degree</span><span class="p">())</span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="go">True</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Set</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">classes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">classes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">classes</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CirculantGraph</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">cl</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">two_factor_petersen</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">edge_colors</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;black&#39;</span><span class="p">:</span><span class="n">cl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;red&#39;</span><span class="p">:</span><span class="n">cl</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
<span class="go">Graphics object consisting of 73 graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.twograph">
<code class="descname">twograph</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.twograph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the two-graph of <code class="docutils literal notranslate"><span class="pre">self</span></code></p>
<p>Returns the <a class="reference external" href="../../../combinat/sage/combinat/designs/twographs.html#sage.combinat.designs.twographs.TwoGraph" title="(in Sage Reference Manual: Combinatorics v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">two-graph</span></code></a>
with the triples
<span class="math notranslate nohighlight">\(T=\{t \in \binom {V}{3} : \left| \binom {t}{2} \cap E \right| \text{odd} \}\)</span>
where <span class="math notranslate nohighlight">\(V\)</span> and <span class="math notranslate nohighlight">\(E\)</span> are vertices and edges of <code class="docutils literal notranslate"><span class="pre">self</span></code>, respectively.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">twograph</span><span class="p">()</span>
<span class="go">Incidence structure with 10 points and 60 blocks</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">=</span><span class="n">graphs</span><span class="o">.</span><span class="n">chang_graphs</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T8</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">line_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">T8</span><span class="o">.</span><span class="n">seidel_switching</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="bp">None</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="bp">None</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="bp">None</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="bp">None</span><span class="p">)],</span><span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T8</span><span class="o">.</span><span class="n">twograph</span><span class="p">()</span> <span class="o">==</span> <span class="n">C</span><span class="o">.</span><span class="n">twograph</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">T8</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="../../../combinat/sage/combinat/designs/twographs.html#sage.combinat.designs.twographs.TwoGraph.descendant" title="(in Sage Reference Manual: Combinatorics v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">descendant()</span></code></a> –
computes the descendant graph of the two-graph of self at a vertex</li>
<li><a class="reference external" href="../../../combinat/sage/combinat/designs/twographs.html#sage.combinat.designs.twographs.twograph_descendant" title="(in Sage Reference Manual: Combinatorics v8.9)"><code class="xref py py-func docutils literal notranslate"><span class="pre">twograph_descendant()</span></code></a>
– ditto, but much faster.</li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.vertex_cover">
<code class="descname">vertex_cover</code><span class="sig-paren">(</span><em>algorithm='Cliquer'</em>, <em>value_only=False</em>, <em>reduction_rules=True</em>, <em>solver=None</em>, <em>verbosity=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.vertex_cover" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a minimum vertex cover of self represented by a set of vertices.</p>
<p>A minimum vertex cover of a graph is a set <span class="math notranslate nohighlight">\(S\)</span> of vertices such that
each edge is incident to at least one element of <span class="math notranslate nohighlight">\(S\)</span>, and such that <span class="math notranslate nohighlight">\(S\)</span>
is of minimum cardinality. For more information, see the
<a class="reference external" href="https://en.wikipedia.org/wiki/Vertex_cover">Wikipedia article Vertex_cover</a>.</p>
<p>Equivalently, a vertex cover is defined as the complement of an
independent set.</p>
<p>As an optimization problem, it can be expressed as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mbox{Minimize : }&amp;\sum_{v\in G} b_v\\
\mbox{Such that : }&amp;\forall (u,v) \in G.edges(), b_u+b_v\geq 1\\
&amp;\forall x\in G, b_x\mbox{ is a binary variable}\end{split}\]</div>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">&quot;Cliquer&quot;</span></code>). Indicating which
algorithm to use. It can be one of those values.<ul>
<li><code class="docutils literal notranslate"><span class="pre">&quot;Cliquer&quot;</span></code> will compute a minimum vertex cover using the Cliquer
package.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;MILP&quot;</span></code> will compute a minimum vertex cover through a mixed
integer linear program.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;mcqd&quot;</span></code> will use the MCQD solver
(<a class="reference external" href="http://www.sicmm.org/~konc/maxclique/">http://www.sicmm.org/~konc/maxclique/</a>). Note that the MCQD
package must be installed.</li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">value_only</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if set to <code class="docutils literal notranslate"><span class="pre">True</span></code>,
only the size of a minimum vertex cover is returned. Otherwise,
a minimum vertex cover is returned as a list of vertices.</li>
<li><code class="docutils literal notranslate"><span class="pre">reduction_rules</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); specify if the reductions
rules from kernelization must be applied as pre-processing or not.
See <a class="reference internal" href="../../../references/index.html#acflss04" id="id54">[ACFLSS04]</a> for more details. Note that depending on the instance,
it might be faster to disable reduction rules.</li>
<li><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specify a Linear Program (LP)
solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For
more information on LP solvers and which default solver is used, see
the method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">verbosity</span></code> – non-negative integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); set the level
of verbosity you want from the linear program solver. Since the
problem of computing a vertex cover is <span class="math notranslate nohighlight">\(NP\)</span>-complete, its solving may
take some time depending on the graph. A value of 0 means that there
will be no message printed by the solver. This option is only useful
if <code class="docutils literal notranslate"><span class="pre">algorithm=&quot;MILP&quot;</span></code>.</li>
</ul>
<p>EXAMPLES:</p>
<p>On the Pappus graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PappusGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">vertex_cover</span><span class="p">(</span><span class="n">value_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">9</span>
</pre></div>
</div>
<div class="figure">
<img alt="../../_images/graph-4.svg" src="../../_images/graph-4.svg" /></div>
</dd></dl>

<dl class="method">
<dt id="sage.graphs.graph.Graph.write_to_eps">
<code class="descname">write_to_eps</code><span class="sig-paren">(</span><em>filename</em>, <em>**options</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.graph.Graph.write_to_eps" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a plot of the graph to <code class="docutils literal notranslate"><span class="pre">filename</span></code> in <code class="docutils literal notranslate"><span class="pre">eps</span></code> format.</p>
<p>INPUT:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">filename</span></code> – a string</li>
<li><code class="docutils literal notranslate"><span class="pre">**options</span></code> – same layout options as <a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.layout" title="sage.graphs.generic_graph.GenericGraph.layout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">layout()</span></code></a></li>
</ul>
</div></blockquote>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">write_to_eps</span><span class="p">(</span><span class="n">tmp_filename</span><span class="p">(</span><span class="n">ext</span><span class="o">=</span><span class="s1">&#39;.eps&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>It is relatively simple to include this file in a LaTeX document.
<code class="docutils literal notranslate"><span class="pre">\usepackage{graphics}</span></code> must appear in the preamble, and
<code class="docutils literal notranslate"><span class="pre">\includegraphics{filename}</span></code> will include the file. To compile the
document to <code class="docutils literal notranslate"><span class="pre">pdf</span></code> with <code class="docutils literal notranslate"><span class="pre">pdflatex</span></code> or <code class="docutils literal notranslate"><span class="pre">xelatex</span></code> the file needs
first to be converted to <code class="docutils literal notranslate"><span class="pre">pdf</span></code>, for example with <code class="docutils literal notranslate"><span class="pre">ps2pdf</span> <span class="pre">filename.eps</span>
<span class="pre">filename.pdf</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Undirected graphs</a><ul>
<li><a class="reference internal" href="#graph-format">Graph Format</a><ul>
<li><a class="reference internal" href="#supported-formats">Supported formats</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generators">Generators</a></li>
<li><a class="reference internal" href="#labels">Labels</a></li>
<li><a class="reference internal" href="#database">Database</a></li>
<li><a class="reference internal" href="#visualization">Visualization</a></li>
<li><a class="reference internal" href="#mutability">Mutability</a></li>
<li><a class="reference internal" href="#methods">Methods</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="generic_graph.html"
                        title="previous chapter">Generic graphs (common to directed/undirected)</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="digraph.html"
                        title="next chapter">Directed graphs</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/sage/graphs/graph.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="digraph.html" title="Directed graphs"
             >next</a> |</li>
        <li class="right" >
          <a href="generic_graph.html" title="Generic graphs (common to directed/undirected)"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Graph Theory</a> &#187;</li>
 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2019, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>