<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" /><link rel="next" title="Graph plotting" href="graph_plot.html" /><link rel="prev" title="Wrapper for Boyerâ€™s (C) planarity algorithm" href="planarity.html" />

    <meta name="generator" content="sphinx-5.2.3, furo 2022.09.29"/>
        <title>Graph traversals - Graph Theory</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?digest=d81277517bee4d6b0349d71bb2661d4890b5617c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom-furo.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom-jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom-codemirror-monokai.css" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  --color-brand-primary: #0f0fff;
  --color-brand-content: #0f0fff;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">Graph Theory</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><div class="sidebar-scroll"><a class="sidebar-brand" href="../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../../_static/logo_sagemath_black.svg" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../../_static/logo_sagemath_white.svg" alt="Dark Logo"/>
  </div>
  
      <span class="sidebar-brand-text">Sage 10.2 Reference Manual</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-home">
  <div class="sidebar-tree">
    <ul><li class="toctree-l1">
      <a class="reference internal" href="../../index.html">Home - Graph Theory</a>
    </li></ul>
  </div>
</div><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="generic_graph.html">Generic graphs (common to directed/undirected)</a></li>
<li class="toctree-l1"><a class="reference internal" href="graph.html">Undirected graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="digraph.html">Directed graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="bipartite_graph.html">Bipartite graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="views.html">View classes</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="graph_generators.html">Common graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="digraph_generators.html">Common digraphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="graph_generators_pyx.html">Common graphs and digraphs generators (Cython)</a></li>
<li class="toctree-l1"><a class="reference internal" href="graph_database.html">Graph database</a></li>
<li class="toctree-l1"><a class="reference internal" href="strongly_regular_db.html">Database of strongly regular graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="generators/distance_regular.html">Database of distance regular graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="generators/classical_geometries.html">Families of graphs derived from classical geometries over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="generators/families.html">Various families of graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="generators/basic.html">Basic graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="generators/chessboard.html">Chessboard graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="generators/intersection.html">Intersection graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="generators/platonic_solids.html">1-skeletons of Platonic solids</a></li>
<li class="toctree-l1"><a class="reference internal" href="generators/random.html">Random graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="generators/smallgraphs.html">Various small graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="generators/world_map.html">Graphs from the World Map</a></li>
<li class="toctree-l1"><a class="reference internal" href="isgci.html">ISGCI: Information System on Graph Classes and their Inclusions</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="base/overview.html">Overview of (di)graph data structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="base/c_graph.html">Fast compiled graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="base/sparse_graph.html">Fast sparse graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="base/dense_graph.html">Fast dense graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="base/static_dense_graph.html">Static dense graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="base/static_sparse_graph.html">Static sparse graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="base/static_sparse_backend.html">Static sparse graph backend</a></li>
<li class="toctree-l1"><a class="reference internal" href="base/graph_backends.html">Backends for Sage (di)graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="base/boost_graph.html">Interface to run Boost algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="hypergraph_generators.html">Hypergraph generators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../combinat/designs/incidence_structures.html">Incidence structures (i.e. hypergraphs, i.e. set systems)</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="graph_coloring.html">Graph coloring</a></li>
<li class="toctree-l1"><a class="reference internal" href="cliquer.html">Interface with Cliquer (clique-related problems)</a></li>
<li class="toctree-l1"><a class="reference internal" href="centrality.html">Centrality</a></li>
<li class="toctree-l1"><a class="reference internal" href="asteroidal_triples.html">Asteroidal triples</a></li>
<li class="toctree-l1"><a class="reference internal" href="independent_sets.html">Independent sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="comparability.html">Comparability and permutation graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="line_graph.html">Line graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="spanning_tree.html">Spanning trees</a></li>
<li class="toctree-l1"><a class="reference internal" href="pq_trees.html">PQ-Trees</a></li>
<li class="toctree-l1"><a class="reference internal" href="trees.html">Generation of trees</a></li>
<li class="toctree-l1"><a class="reference internal" href="matchpoly.html">Matching polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="genus.html">Genus</a></li>
<li class="toctree-l1"><a class="reference internal" href="lovasz_theta.html">LovÃ¡sz theta-function of graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="schnyder.html">Schnyderâ€™s algorithm for straight-line planar embeddings</a></li>
<li class="toctree-l1"><a class="reference internal" href="planarity.html">Wrapper for Boyerâ€™s (C) planarity algorithm</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Graph traversals</a></li>
<li class="toctree-l1"><a class="reference internal" href="graph_plot.html">Graph plotting</a></li>
<li class="toctree-l1"><a class="reference internal" href="graph_plot_js.html">Graph plotting in Javascript with d3.js</a></li>
<li class="toctree-l1"><a class="reference internal" href="graph_decompositions/tree_decomposition.html">Tree decompositions</a></li>
<li class="toctree-l1"><a class="reference internal" href="graph_decompositions/vertex_separation.html">Vertex separation</a></li>
<li class="toctree-l1"><a class="reference internal" href="graph_decompositions/rankwidth.html">Rank Decompositions of graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="graph_decompositions/bandwidth.html">Bandwidth of undirected graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="graph_decompositions/cutwidth.html">Cutwidth</a></li>
<li class="toctree-l1"><a class="reference internal" href="graph_decompositions/graph_products.html">Products of graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="graph_decompositions/modular_decomposition.html">Modular Decomposition</a></li>
<li class="toctree-l1"><a class="reference internal" href="graph_decompositions/clique_separators.html">Decomposition by clique minimal separators</a></li>
<li class="toctree-l1"><a class="reference internal" href="convexity_properties.html">Convexity properties of graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="weakly_chordal.html">Weakly chordal graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="distances_all_pairs.html">Distances/shortest paths between all pairs of vertices</a></li>
<li class="toctree-l1"><a class="reference internal" href="graph_latex.html">LaTeX options for graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="graph_editor.html">Graph editor widget</a></li>
<li class="toctree-l1"><a class="reference internal" href="graph_list.html">Lists of graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="graph_input.html">Functions for reading/building graphs/digraphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="hyperbolicity.html">Hyperbolicity</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutte_polynomial.html">Tutte polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="partial_cube.html">Partial cubes</a></li>
<li class="toctree-l1"><a class="reference internal" href="path_enumeration.html">Path enumeration</a></li>
<li class="toctree-l1"><a class="reference internal" href="generic_graph_pyx.html">GenericGraph Cython functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="orientations.html">Orientations</a></li>
<li class="toctree-l1"><a class="reference internal" href="connectivity.html">Connectivity related functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="edge_connectivity.html">Edge connectivity</a></li>
<li class="toctree-l1"><a class="reference internal" href="domination.html">Domination</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="graph-traversals">
<span id="sage-graphs-traversals"></span><h1>Graph traversals<a class="headerlink" href="#graph-traversals" title="Permalink to this heading">#</a></h1>
<span class="target" id="module-sage.graphs.traversals"></span><p><strong>This module implements the following graph traversals</strong></p>
<div class="table-wrapper colwidths-given contentstable docutils container">
<table class="contentstable docutils align-default">
<colgroup>
<col style="width: 30.0%" />
<col style="width: 70.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.traversals.lex_BFS" title="sage.graphs.traversals.lex_BFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_BFS()</span></code></a></p></td>
<td><p>Perform a lexicographic breadth first search (LexBFS) on the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.traversals.lex_DFS" title="sage.graphs.traversals.lex_DFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DFS()</span></code></a></p></td>
<td><p>Perform a lexicographic depth first search (LexDFS) on the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.traversals.lex_UP" title="sage.graphs.traversals.lex_UP"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_UP()</span></code></a></p></td>
<td><p>Perform a lexicographic UP search (LexUP) on the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.traversals.lex_DOWN" title="sage.graphs.traversals.lex_DOWN"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DOWN()</span></code></a></p></td>
<td><p>Perform a lexicographic DOWN search (LexDOWN) on the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.traversals.lex_M" title="sage.graphs.traversals.lex_M"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_M()</span></code></a></p></td>
<td><p>Return an ordering of the vertices according the LexM graph traversal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.traversals.lex_M_slow" title="sage.graphs.traversals.lex_M_slow"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_M_slow()</span></code></a></p></td>
<td><p>Return an ordering of the vertices according the LexM graph traversal.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.traversals.lex_M_fast" title="sage.graphs.traversals.lex_M_fast"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_M_fast()</span></code></a></p></td>
<td><p>Return an ordering of the vertices according the LexM graph traversal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.traversals.maximum_cardinality_search" title="sage.graphs.traversals.maximum_cardinality_search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximum_cardinality_search()</span></code></a></p></td>
<td><p>Return an ordering of the vertices according a maximum cardinality search.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.traversals.maximum_cardinality_search_M" title="sage.graphs.traversals.maximum_cardinality_search_M"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximum_cardinality_search_M()</span></code></a></p></td>
<td><p>Return the ordering and the edges of the triangulation produced by MCS-M.</p></td>
</tr>
</tbody>
</table>
</div>
<section id="methods">
<h2>Methods<a class="headerlink" href="#methods" title="Permalink to this heading">#</a></h2>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.traversals.is_valid_lex_M_order">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.traversals.</span></span><span class="sig-name descname"><span class="pre">is_valid_lex_M_order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.traversals.is_valid_lex_M_order" title="Permalink to this definition">#</a></dt>
<dd><p>Check whether the ordering alpha and the triangulation F are valid for G.</p>
<p>Given the graph <span class="math notranslate nohighlight">\(G = (V, E)\)</span> with vertex set <span class="math notranslate nohighlight">\(V\)</span> and edge set <span class="math notranslate nohighlight">\(E\)</span>, and the
set <span class="math notranslate nohighlight">\(F\)</span> of edges of a triangulation of <span class="math notranslate nohighlight">\(G\)</span>, let <span class="math notranslate nohighlight">\(H = (V, E\cup F)\)</span>.
By induction one can see that for every <span class="math notranslate nohighlight">\(i \in \{1, ..., n - 1\}\)</span> the
neighbors of <span class="math notranslate nohighlight">\(\alpha(i)\)</span> in <span class="math notranslate nohighlight">\(H[\{\alpha(i), ..., \alpha(n)\}]\)</span> induce a
clique. The ordering <span class="math notranslate nohighlight">\(\alpha\)</span> is a perfect elimination ordering of <span class="math notranslate nohighlight">\(H\)</span>, so
<span class="math notranslate nohighlight">\(H\)</span> is chordal. See <a class="reference internal" href="../../../references/index.html#rtl76" id="id1"><span>[RTL76]</span></a> for more details.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> â€“ a Graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">alpha</span></code> â€“ list; an ordering of the vertices of <span class="math notranslate nohighlight">\(G\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">F</span></code> â€“ an iterable of edges given either as <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v)</span></code> or <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span>
<span class="pre">label)</span></code>, the edges of the triangulation of <span class="math notranslate nohighlight">\(G\)</span></p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.traversals.lex_BFS">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.traversals.</span></span><span class="sig-name descname"><span class="pre">lex_BFS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_vertex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'fast'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.traversals.lex_BFS" title="Permalink to this definition">#</a></dt>
<dd><p>Perform a lexicographic breadth first search (LexBFS) on the graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> â€“ a sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reverse</span></code> â€“ boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
vertices in discovery order, or the reverse</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tree</span></code> â€“ boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
discovery directed tree (each vertex being linked to the one that saw
it for the first time)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> â€“ (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to
consider</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> â€“ string (default: <code class="docutils literal notranslate"><span class="pre">&quot;fast&quot;</span></code>); algorithm to use among:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;slow&quot;</span></code> â€“ This algorithm maintains for each vertex left in the graph
a code corresponding to the vertices already removed. The vertex of
maximal code (according to the lexicographic order) is then removed, and
the codes are updated. See for instance <a class="reference internal" href="../../../references/index.html#ck2008" id="id2"><span>[CK2008]</span></a> for more details.  The
time complexity of this algorithm as described in <a class="reference internal" href="../../../references/index.html#ck2008" id="id3"><span>[CK2008]</span></a> is in
<span class="math notranslate nohighlight">\(O(n + m)\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the number of vertices and <span class="math notranslate nohighlight">\(m\)</span> is the number of
edges, but our implementation is in <span class="math notranslate nohighlight">\(O(n^2)\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;fast&quot;</span></code> â€“ This algorithm uses the notion of <em>slices</em> to refine the
position of the vertices in the ordering. The time complexity of this
algorithm is in <span class="math notranslate nohighlight">\(O(n + m)\)</span>, and our implementation follows that
complexity. See <a class="reference internal" href="../../../references/index.html#hmpv2000" id="id4"><span>[HMPV2000]</span></a> and next section for more details.</p></li>
</ul>
</li>
</ul>
<p>ALGORITHM:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">&quot;fast&quot;</span></code> algorithm is the <span class="math notranslate nohighlight">\(O(n + m)\)</span> time algorithm proposed in
<a class="reference internal" href="../../../references/index.html#hmpv2000" id="id5"><span>[HMPV2000]</span></a>, where <span class="math notranslate nohighlight">\(n\)</span> is the number of vertices and <span class="math notranslate nohighlight">\(m\)</span> is the number of
edges. It uses the notion of <em>slices</em>, i.e., subsets of consecutive vertices
in the ordering, and iteratively refines the slices by subdividing them into
sub-slices to determine the exact position of the vertices in the ordering.</p>
<p>Consider an ordering <span class="math notranslate nohighlight">\(\sigma\)</span> of the vertices. For a vertex <span class="math notranslate nohighlight">\(v\)</span>, we define
<span class="math notranslate nohighlight">\(N_i(v) = \{u | u \in N(v) \text{ and } \sigma(u) &lt; i\}\)</span>, that is the subset
of neighbors of <span class="math notranslate nohighlight">\(v\)</span> appearing before the <span class="math notranslate nohighlight">\(i\)</span>-th vertex in the ordering
<span class="math notranslate nohighlight">\(\sigma\)</span>. Now, a slice of an ordering <span class="math notranslate nohighlight">\(\sigma\)</span> is a set of consecutive
vertices, <span class="math notranslate nohighlight">\(S = \{u | i \leq \sigma(u) \leq j\}\)</span>, such that for any <span class="math notranslate nohighlight">\(u \in
S\)</span>, we have <span class="math notranslate nohighlight">\(N_i(u) = N_i(\sigma^{-1}(i))\)</span> and for any <span class="math notranslate nohighlight">\(v\)</span> such that <span class="math notranslate nohighlight">\(j &lt;
\sigma(v)\)</span>, <span class="math notranslate nohighlight">\(N_i(v) \neq N_i(\sigma^{-1}(i))\)</span>. The <em>head</em> of a slice is the
first position of its vertices.</p>
<p>The algorithm starts with a single slice containing all vertices. Then, when
the position of the <span class="math notranslate nohighlight">\(i\)</span>-th vertex <span class="math notranslate nohighlight">\(v\)</span> is fixed, it explores the neighbors of
<span class="math notranslate nohighlight">\(v\)</span> that have not yet been ordered. Consider a slice <span class="math notranslate nohighlight">\(S\)</span> such that <span class="math notranslate nohighlight">\(N(x)\cap
S \neq \emptyset\)</span>. The algorithm will rearrange the ordering of the vertices
in <span class="math notranslate nohighlight">\(S\)</span> so that the first vertices are the neighbors of <span class="math notranslate nohighlight">\(v\)</span>. The sub-slice
containing the neighbors of <span class="math notranslate nohighlight">\(v\)</span> is assigned a new slice name, and the head
of slice <span class="math notranslate nohighlight">\(S\)</span> is set to the position of the first vertex of <span class="math notranslate nohighlight">\(S \setminus
N(v)\)</span> in the ordering <span class="math notranslate nohighlight">\(\sigma\)</span>.</p>
<p>Observe that each arc of the graph can induce the subdivision of a
slice. Hence, the algorithm can use up to <span class="math notranslate nohighlight">\(m + 1\)</span> different slices.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Lexicographic_breadth-first_search">Wikipedia article Lexicographic_breadth-first_search</a></p></li>
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_DFS" title="sage.graphs.generic_graph.GenericGraph.lex_DFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DFS()</span></code></a> â€“ perform a
lexicographic depth first search (LexDFS) on the graph</p></li>
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_UP" title="sage.graphs.generic_graph.GenericGraph.lex_UP"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_UP()</span></code></a> â€“ perform a
lexicographic UP search (LexUP) on the graph</p></li>
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_DOWN" title="sage.graphs.generic_graph.GenericGraph.lex_DOWN"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DOWN()</span></code></a> â€“ perform a
lexicographic DOWN search (LexDOWN) on the graph</p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>A Lex BFS is obviously an ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">())</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Lex BFS ordering of the 3-sun graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">()</span>
<span class="go">[1, 2, 3, 5, 4, 6]</span>
</pre></div>
</div>
<p>The method also works for directed graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;slow&quot;</span><span class="p">)</span>
<span class="go">[2, 3, 1]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;fast&quot;</span><span class="p">)</span>
<span class="go">[2, 3, 1]</span>
</pre></div>
</div>
<p>For a Chordal Graph, a reversed Lex BFS is a Perfect Elimination Order:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">lexicographic_product</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(2, 1), (2, 0), (1, 1), (1, 0), (0, 1), (0, 0)]</span>
</pre></div>
</div>
<p>And the vertices at the end of the tree of discovery are, for chordal
graphs, simplicial vertices (their neighborhood is a complete graph):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">ClawGraph</span><span class="p">()</span><span class="o">.</span><span class="n">lexicographic_product</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">peo</span><span class="p">,</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span> <span class="o">=</span> <span class="n">v</span><span class="p">,</span>  <span class="n">tree</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">leaves</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tree</span> <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">in_degree</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">.</span><span class="n">is_clique</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Different orderings for different traversals:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="c1"># needs sage.combinat</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">DeBruijn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;fast&quot;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;011&#39;, &#39;110&#39;, &#39;101&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;slow&quot;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;011&#39;, &#39;110&#39;, &#39;101&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;011&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_UP</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;111&#39;, &#39;011&#39;, &#39;100&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DOWN</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;011&#39;, &#39;010&#39;, &#39;110&#39;, &#39;111&#39;, &#39;101&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.traversals.lex_DFS">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.traversals.</span></span><span class="sig-name descname"><span class="pre">lex_DFS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_vertex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.traversals.lex_DFS" title="Permalink to this definition">#</a></dt>
<dd><p>Perform a lexicographic depth first search (LexDFS) on the graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> â€“ a sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reverse</span></code> â€“ boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
vertices in discovery order, or the reverse</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tree</span></code> â€“ boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
discovery directed tree (each vertex being linked to the one that saw
it for the first time)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> â€“ (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to
consider</p></li>
</ul>
<p>ALGORITHM:</p>
<p>This algorithm maintains for each vertex left in the graph a code
corresponding to the vertices already removed. The vertex of maximal
code (according to the lexicographic order) is then removed, and the
codes are updated. Lex DFS differs from Lex BFS only in the way codes are
updated after each iteration.</p>
<p>Time complexity is <span class="math notranslate nohighlight">\(O(n+m)\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the number of vertices and <span class="math notranslate nohighlight">\(m\)</span> is
the number of edges.</p>
<p>See <a class="reference internal" href="../../../references/index.html#ck2008" id="id6"><span>[CK2008]</span></a> for more details on the algorithm.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_BFS" title="sage.graphs.generic_graph.GenericGraph.lex_BFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_BFS()</span></code></a> â€“ perform a
lexicographic breadth first search (LexBFS) on the graph</p></li>
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_UP" title="sage.graphs.generic_graph.GenericGraph.lex_UP"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_UP()</span></code></a> â€“ perform a
lexicographic UP search (LexUP) on the graph</p></li>
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_DOWN" title="sage.graphs.generic_graph.GenericGraph.lex_DOWN"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DOWN()</span></code></a> â€“ perform a
lexicographic DOWN search (LexDOWN) on the graph</p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>A Lex DFS is obviously an ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">lex_DFS</span><span class="p">())</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Lex DFS ordering of the 3-sun graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">lex_DFS</span><span class="p">()</span>
<span class="go">[1, 2, 3, 5, 6, 4]</span>
</pre></div>
</div>
<p>The method also works for directed graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[2, 3, 1]</span>
</pre></div>
</div>
<p>Different orderings for different traversals:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="c1"># needs sage.combinat</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">DeBruijn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;011&#39;, &#39;110&#39;, &#39;101&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;011&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_UP</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;111&#39;, &#39;011&#39;, &#39;100&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DOWN</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;011&#39;, &#39;010&#39;, &#39;110&#39;, &#39;111&#39;, &#39;101&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.traversals.lex_DOWN">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.traversals.</span></span><span class="sig-name descname"><span class="pre">lex_DOWN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_vertex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.traversals.lex_DOWN" title="Permalink to this definition">#</a></dt>
<dd><p>Perform a lexicographic DOWN search (LexDOWN) on the graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> â€“ a sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reverse</span></code> â€“ boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
vertices in discovery order, or the reverse</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tree</span></code> â€“ boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
discovery directed tree (each vertex being linked to the one that saw
it for the first time)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> â€“ (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to
consider</p></li>
</ul>
<p>ALGORITHM:</p>
<p>This algorithm maintains for each vertex left in the graph a code
corresponding to the vertices already removed. The vertex of maximal
code (according to the lexicographic order) is then removed, and the
codes are updated. During the <span class="math notranslate nohighlight">\(i\)</span>-th iteration of the algorithm <span class="math notranslate nohighlight">\(n-i\)</span> is
prepended to the codes of all neighbors of the selected vertex that are left
in the graph.</p>
<p>Time complexity is <span class="math notranslate nohighlight">\(O(n+m)\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the number of vertices and <span class="math notranslate nohighlight">\(m\)</span> is
the number of edges.</p>
<p>See <a class="reference internal" href="../../../references/index.html#mil2017" id="id7"><span>[Mil2017]</span></a> for more details on the algorithm.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_BFS" title="sage.graphs.generic_graph.GenericGraph.lex_BFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_BFS()</span></code></a> â€“ perform a
lexicographic breadth first search (LexBFS) on the graph</p></li>
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_DFS" title="sage.graphs.generic_graph.GenericGraph.lex_DFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DFS()</span></code></a> â€“ perform a
lexicographic depth first search (LexDFS) on the graph</p></li>
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_UP" title="sage.graphs.generic_graph.GenericGraph.lex_UP"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_UP()</span></code></a> â€“ perform a
lexicographic UP search (LexUP) on the graph</p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>A Lex DOWN is obviously an ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">lex_DOWN</span><span class="p">())</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Lex DOWN ordering of the 3-sun graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">lex_DOWN</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 5]</span>
</pre></div>
</div>
<p>The method also works for directed graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DOWN</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[2, 3, 1]</span>
</pre></div>
</div>
<p>Different orderings for different traversals:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="c1"># needs sage.combinat</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">DeBruijn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;011&#39;, &#39;110&#39;, &#39;101&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;011&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_UP</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;111&#39;, &#39;011&#39;, &#39;100&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DOWN</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;011&#39;, &#39;010&#39;, &#39;110&#39;, &#39;111&#39;, &#39;101&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.traversals.lex_M">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.traversals.</span></span><span class="sig-name descname"><span class="pre">lex_M</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">triangulation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_vertex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.traversals.lex_M" title="Permalink to this definition">#</a></dt>
<dd><p>Return an ordering of the vertices according the LexM graph traversal.</p>
<p>LexM is a lexicographic ordering scheme that is a special type of
breadth-first-search. LexM can also produce a triangulation of the
given graph. This functionality is implemented in this method. For
more details on the algorithms used see Sections 4 (<code class="docutils literal notranslate"><span class="pre">'lex_M_slow'</span></code>)
and 5.3 (<code class="docutils literal notranslate"><span class="pre">'lex_M_fast'</span></code>) of <a class="reference internal" href="../../../references/index.html#rtl76" id="id8"><span>[RTL76]</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method works only for undirected graphs.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">triangulation</span></code> â€“ boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return a
list of edges that need to be added in order to triangulate the graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">labels</span></code> â€“ boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the labels
assigned to each vertex</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> â€“ (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to
consider</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> â€“ string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); one of the following
algorithms:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'lex_M_slow'</span></code>: slower implementation of LexM traversal</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'lex_M_fast'</span></code>: faster implementation of LexM traversal (works only
when <code class="docutils literal notranslate"><span class="pre">labels</span></code> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>: Sage chooses the best algorithm: <code class="docutils literal notranslate"><span class="pre">'lex_M_slow'</span></code> if
<code class="docutils literal notranslate"><span class="pre">labels</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">'lex_M_fast'</span></code> otherwise.</p></li>
</ul>
</li>
</ul>
<p>OUTPUT:</p>
<p>Depending on the values of the parameters <code class="docutils literal notranslate"><span class="pre">triangulation</span></code> and <code class="docutils literal notranslate"><span class="pre">labels</span></code>
the method will return one or more of the following (in that order):</p>
<ul class="simple">
<li><p>an ordering of vertices of the graph according to LexM ordering scheme</p></li>
<li><p>the labels assigned to each vertex</p></li>
<li><p>a list of edges that when added to the graph will triangulate it</p></li>
</ul>
<p>EXAMPLES:</p>
<p>LexM produces an ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">ord</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">lex_M</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;lex_M_fast&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="nb">ord</span><span class="p">)</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">set</span><span class="p">(</span><span class="nb">ord</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">ord</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">lex_M</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;lex_M_slow&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="nb">ord</span><span class="p">)</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">set</span><span class="p">(</span><span class="nb">ord</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Both algorithms produce a valid LexM ordering <span class="math notranslate nohighlight">\(\alpha\)</span> (i.e the neighbors of
<span class="math notranslate nohighlight">\(\alpha(i)\)</span> in <span class="math notranslate nohighlight">\(G[\{\alpha(i), ..., \alpha(n)\}]\)</span> induce a clique):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.traversals</span> <span class="kn">import</span> <span class="n">is_valid_lex_M_order</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">ord</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">lex_M</span><span class="p">(</span><span class="n">triangulation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;lex_M_slow&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">is_valid_lex_M_order</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="nb">ord</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">ord</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">lex_M</span><span class="p">(</span><span class="n">triangulation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;lex_M_fast&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">is_valid_lex_M_order</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="nb">ord</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>LexM produces a triangulation of given graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">lex_M</span><span class="p">(</span><span class="n">triangulation</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;list_of_edges&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">is_chordal</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>LexM ordering of the 3-sun graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">lex_M</span><span class="p">()</span>
<span class="go">[6, 4, 5, 3, 2, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.traversals.lex_M_fast">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.traversals.</span></span><span class="sig-name descname"><span class="pre">lex_M_fast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">triangulation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_vertex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.traversals.lex_M_fast" title="Permalink to this definition">#</a></dt>
<dd><p>Return an ordering of the vertices according the LexM graph traversal.</p>
<p>LexM is a lexicographic ordering scheme that is a special type of
breadth-first-search. This function implements the algorithm described in
Section 5.3 of <a class="reference internal" href="../../../references/index.html#rtl76" id="id9"><span>[RTL76]</span></a>.</p>
<p>Note that instead of using labels <span class="math notranslate nohighlight">\(1, 2, \ldots, k\)</span> and adding <span class="math notranslate nohighlight">\(1/2\)</span>, we
use labels <span class="math notranslate nohighlight">\(2, 4, \ldots, k\)</span> and add <span class="math notranslate nohighlight">\(1\)</span>, thus avoiding to use floats or
rationals.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method works only for undirected graphs.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> â€“ a sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">triangulation</span></code> â€“ boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
triangulation of given graph produced by the method</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> â€“ (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to consider</p></li>
</ul>
<p>OUTPUT:</p>
<p>This method will return an ordering of the vertices of <code class="docutils literal notranslate"><span class="pre">G</span></code> according to
the LexM ordering scheme. Furthermore, if <code class="docutils literal notranslate"><span class="pre">triangulation</span></code> is set to
<code class="docutils literal notranslate"><span class="pre">True</span></code> the method also returns a list of edges <code class="docutils literal notranslate"><span class="pre">F</span></code> such that when added
to <code class="docutils literal notranslate"><span class="pre">G</span></code> the resulting graph is a triangulation of <code class="docutils literal notranslate"><span class="pre">G</span></code>.</p>
<p>EXAMPLES:</p>
<p>A LexM ordering is obviously an ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.traversals</span> <span class="kn">import</span> <span class="n">lex_M_fast</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">lex_M_fast</span><span class="p">(</span><span class="n">g</span><span class="p">))</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>LexM ordering of the 3-sun graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.traversals</span> <span class="kn">import</span> <span class="n">lex_M_fast</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">lex_M_fast</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">[6, 4, 5, 3, 2, 1]</span>
</pre></div>
</div>
<p>LexM produces a triangulation of given graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.traversals</span> <span class="kn">import</span> <span class="n">lex_M_fast</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="n">lex_M_fast</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">triangulation</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">is_chordal</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.traversals.lex_M_slow">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.traversals.</span></span><span class="sig-name descname"><span class="pre">lex_M_slow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">triangulation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_vertex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.traversals.lex_M_slow" title="Permalink to this definition">#</a></dt>
<dd><p>Return an ordering of the vertices according the LexM graph traversal.</p>
<p>LexM is a lexicographic ordering scheme that is a special type of
breadth-first-search. This function implements the algorithm described in
Section 4 of <a class="reference internal" href="../../../references/index.html#rtl76" id="id10"><span>[RTL76]</span></a>.</p>
<p>During the search, the vertices are numbered from <span class="math notranslate nohighlight">\(n\)</span> to <span class="math notranslate nohighlight">\(1\)</span>. Let
<span class="math notranslate nohighlight">\(\alpha(i)\)</span> denote the vertex numbered <span class="math notranslate nohighlight">\(i\)</span> and let <span class="math notranslate nohighlight">\(\alpha^{-1}(u)\)</span> denote
the number assigned to <span class="math notranslate nohighlight">\(u\)</span>. Each vertex <span class="math notranslate nohighlight">\(u\)</span> has also a label, denoted by
<span class="math notranslate nohighlight">\(label(u)\)</span>, consisting of a list of numbers selected from <span class="math notranslate nohighlight">\([1,n]\)</span> and
ordered in decreasing order. Given two labels <span class="math notranslate nohighlight">\(L_1=[p_1, p_2,\ldots, p_k]\)</span>
and <span class="math notranslate nohighlight">\(L_1=[q_1, q_2,\ldots, q_l]\)</span>, we define <span class="math notranslate nohighlight">\(L_1&lt;L_2\)</span> if, for some <span class="math notranslate nohighlight">\(j\)</span>,
<span class="math notranslate nohighlight">\(p_i==q_i\)</span> for <span class="math notranslate nohighlight">\(i=1,\ldots,j-1\)</span> and <span class="math notranslate nohighlight">\(p_j&lt;q_j\)</span>, or if <span class="math notranslate nohighlight">\(p_i==q_i\)</span> for
<span class="math notranslate nohighlight">\(i=1,\ldots,k\)</span> and <span class="math notranslate nohighlight">\(k&lt;l\)</span>. Observe that this is exactly how Python compares
two lists.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method works only for undirected graphs.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> â€“ a sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">triangulation</span></code> â€“ boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
triangulation of the graph produced by the method</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">labels</span></code> â€“ boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the labels
assigned to each vertex</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> â€“ (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to
consider. If not specified, an arbitrary vertex is chosen.</p></li>
</ul>
<p>OUTPUT:</p>
<p>Depending on the values of the parameters <code class="docutils literal notranslate"><span class="pre">triangulation</span></code> and <code class="docutils literal notranslate"><span class="pre">labels</span></code>
the method will return one or more of the following (in that order):</p>
<ul class="simple">
<li><p>the ordering of vertices of <span class="math notranslate nohighlight">\(G\)</span></p></li>
<li><p>the labels assigned to each vertex</p></li>
<li><p>a list of edges that when added to <span class="math notranslate nohighlight">\(G\)</span> will produce a triangulation of <span class="math notranslate nohighlight">\(G\)</span></p></li>
</ul>
<p>EXAMPLES:</p>
<p>A LexM ordering is obviously an ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.traversals</span> <span class="kn">import</span> <span class="n">lex_M_slow</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">lex_M_slow</span><span class="p">(</span><span class="n">g</span><span class="p">))</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>LexM ordering and label assignments on the vertices of the 3-sun graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.traversals</span> <span class="kn">import</span> <span class="n">lex_M_slow</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">lex_M_slow</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">([6, 4, 5, 3, 2, 1],</span>
<span class="go"> {1: [], 2: [5], 3: [5, 4], 4: [4, 2], 5: [4, 3], 6: [3, 2]})</span>
</pre></div>
</div>
<p>LexM produces a triangulation of given graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.traversals</span> <span class="kn">import</span> <span class="n">lex_M_slow</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="n">lex_M_slow</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">triangulation</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">is_chordal</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.traversals.lex_UP">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.traversals.</span></span><span class="sig-name descname"><span class="pre">lex_UP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_vertex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.traversals.lex_UP" title="Permalink to this definition">#</a></dt>
<dd><p>Perform a lexicographic UP search (LexUP) on the graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> â€“ a sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reverse</span></code> â€“ boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
vertices in discovery order, or the reverse</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tree</span></code> â€“ boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
discovery directed tree (each vertex being linked to the one that saw
it for the first time)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> â€“ (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to
consider</p></li>
</ul>
<p>ALGORITHM:</p>
<p>This algorithm maintains for each vertex left in the graph a code
corresponding to the vertices already removed. The vertex of maximal
code (according to the lexicographic order) is then removed, and the
codes are updated. During the <span class="math notranslate nohighlight">\(i\)</span>-th iteration of the algorithm <span class="math notranslate nohighlight">\(i\)</span> is
appended to the codes of all neighbors of the selected vertex that are left
in the graph.</p>
<p>Time complexity is <span class="math notranslate nohighlight">\(O(n+m)\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the number of vertices and <span class="math notranslate nohighlight">\(m\)</span> is
the number of edges.</p>
<p>See <a class="reference internal" href="../../../references/index.html#mil2017" id="id11"><span>[Mil2017]</span></a> for more details on the algorithm.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_BFS" title="sage.graphs.generic_graph.GenericGraph.lex_BFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_BFS()</span></code></a> â€“ perform a
lexicographic breadth first search (LexBFS) on the graph</p></li>
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_DFS" title="sage.graphs.generic_graph.GenericGraph.lex_DFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DFS()</span></code></a> â€“ perform a
lexicographic depth first search (LexDFS) on the graph</p></li>
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_DOWN" title="sage.graphs.generic_graph.GenericGraph.lex_DOWN"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DOWN()</span></code></a> â€“ perform a
lexicographic DOWN search (LexDOWN) on the graph</p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>A Lex UP is obviously an ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">lex_UP</span><span class="p">())</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Lex UP ordering of the 3-sun graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">lex_UP</span><span class="p">()</span>
<span class="go">[1, 2, 4, 5, 6, 3]</span>
</pre></div>
</div>
<p>The method also works for directed graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_UP</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[2, 3, 1]</span>
</pre></div>
</div>
<p>Different orderings for different traversals:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="c1"># needs sage.combinat</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">DeBruijn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;011&#39;, &#39;110&#39;, &#39;101&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;011&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_UP</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;111&#39;, &#39;011&#39;, &#39;100&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DOWN</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;011&#39;, &#39;010&#39;, &#39;110&#39;, &#39;111&#39;, &#39;101&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.traversals.maximum_cardinality_search">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.traversals.</span></span><span class="sig-name descname"><span class="pre">maximum_cardinality_search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_vertex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.traversals.maximum_cardinality_search" title="Permalink to this definition">#</a></dt>
<dd><p>Return an ordering of the vertices according a maximum cardinality search.</p>
<p>Maximum cardinality search (MCS) is a graph traversal introduced in
<a class="reference internal" href="../../../references/index.html#ty1984" id="id12"><span>[TY1984]</span></a>. It starts by assigning an arbitrary vertex (or the specified
<code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code>) of <span class="math notranslate nohighlight">\(G\)</span> the last position in the ordering <span class="math notranslate nohighlight">\(\alpha\)</span>. Every
vertex keeps a weight equal to the number of its already processed neighbors
(i.e., already added to <span class="math notranslate nohighlight">\(\alpha\)</span>), and a vertex of largest such number is
chosen at each step <span class="math notranslate nohighlight">\(i\)</span> to be placed in position <span class="math notranslate nohighlight">\(n - i\)</span> in <span class="math notranslate nohighlight">\(\alpha\)</span>. This
ordering can be computed in time <span class="math notranslate nohighlight">\(O(n + m)\)</span>.</p>
<p>When the graph is chordal, the ordering returned by MCS is a <em>perfect
elimination ordering</em>, like <a class="reference internal" href="#sage.graphs.traversals.lex_BFS" title="sage.graphs.traversals.lex_BFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_BFS()</span></code></a>. So
this ordering can be used to recognize chordal graphs. See <a class="reference internal" href="../../../references/index.html#he2006" id="id13"><span>[He2006]</span></a> for
more details.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The current implementation is for connected graphs only.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> â€“ a Sage Graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reverse</span></code> â€“ boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
vertices in discovery order, or the reverse</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tree</span></code> â€“ boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to also return the
discovery directed tree (each vertex being linked to the one that saw
it for the first time)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> â€“ (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to consider</p></li>
</ul>
<p>OUTPUT:</p>
<p>By default, return the ordering <span class="math notranslate nohighlight">\(\alpha\)</span> as a list. When <code class="docutils literal notranslate"><span class="pre">tree</span></code> is
<code class="docutils literal notranslate"><span class="pre">True</span></code>, the method returns a tuple <span class="math notranslate nohighlight">\((\alpha, T)\)</span>, where <span class="math notranslate nohighlight">\(T\)</span> is a directed
tree with the same set of vertices as <span class="math notranslate nohighlight">\(G`and a directed edge from `u\)</span> to <span class="math notranslate nohighlight">\(v\)</span>
if <span class="math notranslate nohighlight">\(u\)</span> was the first vertex to saw <span class="math notranslate nohighlight">\(v\)</span>.</p>
<p>EXAMPLES:</p>
<p>When specified, the <code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> is placed at the end of the ordering,
unless parameter <code class="docutils literal notranslate"><span class="pre">reverse</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, in which case it is placed at the
beginning:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[3, 2, 1, 0]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[0, 3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[0, 1, 3, 2]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[3, 2, 1, 0]</span>
</pre></div>
</div>
<p>Returning the discovery tree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search</span><span class="p">(</span><span class="n">tree</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">initial_vertex</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">order</span><span class="p">(),</span> <span class="n">T</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">(4, 3)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(1, 0), (2, 1), (3, 2)]</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search</span><span class="p">(</span><span class="n">tree</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">initial_vertex</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[(0, 1), (1, 2), (2, 3)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.traversals.maximum_cardinality_search_M">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.traversals.</span></span><span class="sig-name descname"><span class="pre">maximum_cardinality_search_M</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_vertex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.traversals.maximum_cardinality_search_M" title="Permalink to this definition">#</a></dt>
<dd><p>Return the ordering and the edges of the triangulation produced by MCS-M.</p>
<p>Maximum cardinality search M (MCS-M) is an extension of MCS
(<a class="reference internal" href="#sage.graphs.traversals.maximum_cardinality_search" title="sage.graphs.traversals.maximum_cardinality_search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximum_cardinality_search()</span></code></a>) in the same way
that Lex-M (<a class="reference internal" href="#sage.graphs.traversals.lex_M" title="sage.graphs.traversals.lex_M"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_M()</span></code></a>) is an extension of
Lex-BFS (<a class="reference internal" href="#sage.graphs.traversals.lex_BFS" title="sage.graphs.traversals.lex_BFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_BFS()</span></code></a>). That is, in MCS-M when
<span class="math notranslate nohighlight">\(u\)</span> receives number <span class="math notranslate nohighlight">\(i\)</span> at step <span class="math notranslate nohighlight">\(n - i + 1\)</span>, it increments the weight of all
unnumbered vertices <span class="math notranslate nohighlight">\(v\)</span> for which there exists a path between <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span>
consisting only of unnumbered vertices with weight strictly less than
<span class="math notranslate nohighlight">\(w^-(u)\)</span> and <span class="math notranslate nohighlight">\(w^-(v)\)</span>, where <span class="math notranslate nohighlight">\(w^-\)</span> is the number of times a vertex has been
reached during previous iterations. See <a class="reference internal" href="../../../references/index.html#bbhp2004" id="id14"><span>[BBHP2004]</span></a> for the details of this
<span class="math notranslate nohighlight">\(O(nm)\)</span> time algorithm.</p>
<p>If <span class="math notranslate nohighlight">\(G\)</span> is not connected, the orderings of each of its connected components
are added consecutively. Furthermore, if <span class="math notranslate nohighlight">\(G\)</span> has <span class="math notranslate nohighlight">\(k\)</span> connected components
<span class="math notranslate nohighlight">\(C_i\)</span> for <span class="math notranslate nohighlight">\(0 \leq i &lt; k\)</span>, <span class="math notranslate nohighlight">\(X\)</span> contains at least one vertex of <span class="math notranslate nohighlight">\(C_i\)</span> for each
<span class="math notranslate nohighlight">\(i \geq 1\)</span>. Hence, <span class="math notranslate nohighlight">\(|X| \geq k - 1\)</span>. In particular, some isolated vertices
(i.e., of degree 0) can appear in <span class="math notranslate nohighlight">\(X\)</span> as for such a vertex <span class="math notranslate nohighlight">\(x\)</span>, we have that
<span class="math notranslate nohighlight">\(G \setminus N(x) = G\)</span> is not connected.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> â€“ a Sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> â€“ (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to consider</p></li>
</ul>
<p>OUTPUT: a tuple <span class="math notranslate nohighlight">\((\alpha, F, X)\)</span>, where</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\alpha\)</span> is the resulting ordering of the vertices. If an initial vertex
is specified, it gets the last position in the ordering <span class="math notranslate nohighlight">\(\alpha\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(F\)</span> is the list of edges of a minimal triangulation of <span class="math notranslate nohighlight">\(G\)</span> according
<span class="math notranslate nohighlight">\(\alpha\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(X\)</span> is a list of vertices such that for each <span class="math notranslate nohighlight">\(x \in X\)</span>, the
neighborhood of <span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(G\)</span> is a separator (i.e., <span class="math notranslate nohighlight">\(G \setminus N(x)\)</span> is not
connected). Note that we may have <span class="math notranslate nohighlight">\(N(x) = \emptyset\)</span> if <span class="math notranslate nohighlight">\(G\)</span> is not
connected and <span class="math notranslate nohighlight">\(x\)</span> has degree 0.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>Chordal graphs have a perfect elimination ordering, and so the set <span class="math notranslate nohighlight">\(F\)</span> of
edges of the triangulation is empty:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomChordalGraph</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">alpha</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">();</span> <span class="n">F</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>The cycle of order 4 is not chordal and so the triangulation has one edge:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">alpha</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">();</span> <span class="nb">len</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>The number of edges needed to triangulate of a cycle graph or order <span class="math notranslate nohighlight">\(n\)</span> is
<span class="math notranslate nohighlight">\(n - 3\)</span>, independently of the initial vertex:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">F</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">3</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="n">C</span><span class="o">.</span><span class="n">random_vertex</span><span class="p">())</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">F</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">3</span>
<span class="go">True</span>
</pre></div>
</div>
<p>When an initial vertex is specified, it gets the last position in the
ordering:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">([3, 2, 1, 0], [], [2, 3])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">([3, 2, 0, 1], [], [2, 3])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">([0, 1, 3, 2], [], [0, 1])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">([0, 1, 2, 3], [], [0, 1])</span>
</pre></div>
</div>
<p>When <span class="math notranslate nohighlight">\(G\)</span> is not connected, the orderings of each of its connected components
are added consecutively, the vertices of the component containing the
initial vertex occupying the last positions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[5, 4, 6, 7, 2, 3, 1, 0]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">7</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[2, 1, 3, 0, 5, 6, 4, 7]</span>
</pre></div>
</div>
<p>Furthermore, if <span class="math notranslate nohighlight">\(G\)</span> has <span class="math notranslate nohighlight">\(k\)</span> connected components, <span class="math notranslate nohighlight">\(X\)</span> contains at least one
vertex per connected component, except for the first one, and so at least <span class="math notranslate nohighlight">\(k
- 1\)</span> vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;something goes wrong&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mf">.2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">cc</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In the example of <a class="reference internal" href="../../../references/index.html#bps2010" id="id15"><span>[BPS2010]</span></a>, the triangulation has 3 edges:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">],</span>
<span class="gp">....: </span>           <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">],</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;g&#39;</span><span class="p">],</span>
<span class="gp">....: </span>           <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">],</span> <span class="s1">&#39;g&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">],</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">],</span>
<span class="gp">....: </span>           <span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">],</span> <span class="s1">&#39;j&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="graph_plot.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Graph plotting</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="planarity.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Wrapper for Boyerâ€™s (C) planarity algorithm</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2005--2023, The Sage Development Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Graph traversals</a><ul>
<li><a class="reference internal" href="#methods">Methods</a></li>
<li><a class="reference internal" href="#sage.graphs.traversals.is_valid_lex_M_order"><code class="docutils literal notranslate"><span class="pre">is_valid_lex_M_order()</span></code></a></li>
<li><a class="reference internal" href="#sage.graphs.traversals.lex_BFS"><code class="docutils literal notranslate"><span class="pre">lex_BFS()</span></code></a></li>
<li><a class="reference internal" href="#sage.graphs.traversals.lex_DFS"><code class="docutils literal notranslate"><span class="pre">lex_DFS()</span></code></a></li>
<li><a class="reference internal" href="#sage.graphs.traversals.lex_DOWN"><code class="docutils literal notranslate"><span class="pre">lex_DOWN()</span></code></a></li>
<li><a class="reference internal" href="#sage.graphs.traversals.lex_M"><code class="docutils literal notranslate"><span class="pre">lex_M()</span></code></a></li>
<li><a class="reference internal" href="#sage.graphs.traversals.lex_M_fast"><code class="docutils literal notranslate"><span class="pre">lex_M_fast()</span></code></a></li>
<li><a class="reference internal" href="#sage.graphs.traversals.lex_M_slow"><code class="docutils literal notranslate"><span class="pre">lex_M_slow()</span></code></a></li>
<li><a class="reference internal" href="#sage.graphs.traversals.lex_UP"><code class="docutils literal notranslate"><span class="pre">lex_UP()</span></code></a></li>
<li><a class="reference internal" href="#sage.graphs.traversals.maximum_cardinality_search"><code class="docutils literal notranslate"><span class="pre">maximum_cardinality_search()</span></code></a></li>
<li><a class="reference internal" href="#sage.graphs.traversals.maximum_cardinality_search_M"><code class="docutils literal notranslate"><span class="pre">maximum_cardinality_search_M()</span></code></a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/scripts/furo.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"ZZ": "\\Bold{Z}", "NN": "\\Bold{N}", "RR": "\\Bold{R}", "CC": "\\Bold{C}", "QQ": "\\Bold{Q}", "QQbar": "\\overline{\\QQ}", "GF": ["\\Bold{F}_{#1}", 1], "Zp": ["\\Bold{Z}_{#1}", 1], "Qp": ["\\Bold{Q}_{#1}", 1], "Zmod": ["\\ZZ/#1\\ZZ", 1], "CDF": "\\Bold{C}", "CIF": "\\Bold{C}", "CLF": "\\Bold{C}", "RDF": "\\Bold{R}", "RIF": "\\Bold{I} \\Bold{R}", "RLF": "\\Bold{R}", "SL": "\\mathrm{SL}", "PSL": "\\mathrm{PSL}", "lcm": "\\mathop{\\operatorname{lcm}}", "Bold": ["\\mathbf{#1}", 1]}, "inlineMath": [["$", "$"], ["\\(", "\\)"]], "maxBuffer": 51200, "autoload": {"color": [], "colorv2": ["color"]}}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    <script src="../../../_static/jupyter-sphinx-furo.js"></script>
    </body>
</html>