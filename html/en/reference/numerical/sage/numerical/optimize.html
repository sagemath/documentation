
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Numerical Root Finding and Optimization &#8212; Numerical Optimization</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sage.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/thebelab.css" />
    
    <script data-url_root="../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
    <script async="async" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Interactive Simplex Method" href="interactive_simplex_method.html" />
    <link rel="prev" title="Constraints on Linear Functions Tensored with a Free Module" href="linear_tensor_constraints.html" />
  <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />
  <!-- <script src="../../../_static/thebe.js" type="text/javascript"></script> -->
  <!-- <script src="../../../_static/thebe-sage.js" type="text/javascript"></script> -->

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="interactive_simplex_method.html" title="Interactive Simplex Method"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="linear_tensor_constraints.html" title="Constraints on Linear Functions Tensored with a Free Module"
             accesskey="P">previous</a> |</li>
  <li class="nav-item nav-item-0">
    <a href="http://www.sagemath.org"><img src="../../../_static/logo_sagemath_black.svg" class="sage-logo" title="Sage Logo"></a>
    
      <a href="../../../../index.html">Sage 9.6 Documentation</a> &#187;
      
      <a href="../../../index.html">Reference Manual</a> &#187;
      
      <a href="../../index.html">Numerical Optimization</a> &#187;
    
  </li>

        <li class="nav-item nav-item-this"><a href="">Numerical Root Finding and Optimization</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="numerical-root-finding-and-optimization">
<span id="sage-numerical-optimize"></span><h1>Numerical Root Finding and Optimization<a class="headerlink" href="#numerical-root-finding-and-optimization" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.numerical.optimize"></span><p>AUTHOR:</p>
<ul class="simple">
<li><p>William Stein (2007): initial version</p></li>
<li><p>Nathann Cohen (2008) : Bin Packing</p></li>
</ul>
<section id="functions-and-methods">
<h2>Functions and Methods<a class="headerlink" href="#functions-and-methods" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="sage.numerical.optimize.binpacking">
<span class="sig-prename descclassname"><span class="pre">sage.numerical.optimize.</span></span><span class="sig-name descname"><span class="pre">binpacking</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">items</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.numerical.optimize.binpacking" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the bin packing problem.</p>
<p>The Bin Packing problem is the following :</p>
<p>Given a list of items of weights <span class="math notranslate nohighlight">\(p_i\)</span> and a real value <span class="math notranslate nohighlight">\(k\)</span>, what is the
least number of bins such that all the items can be packed in the bins,
while ensuring that the sum of the weights of the items packed in each bin
is at most <span class="math notranslate nohighlight">\(k\)</span> ?</p>
<p>For more informations, see <a class="reference external" href="https://en.wikipedia.org/wiki/Bin_packing_problem">Wikipedia article Bin_packing_problem</a>.</p>
<p>Two versions of this problem are solved by this algorithm :</p>
<ul class="simple">
<li><p>Is it possible to put the given items in <span class="math notranslate nohighlight">\(k\)</span> bins ?</p></li>
<li><p>What is the assignment of items using the least number of bins with
the given list of items ?</p></li>
</ul>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">items</span></code> – list or dict; either a list of real values (the items’
weight), or a dictionary associating to each item its weight.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">maximum</span></code> – (default: 1); the maximal size of a bin</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); Number of bins</p>
<ul>
<li><p>When set to an integer value, the function returns a partition of the
items into <span class="math notranslate nohighlight">\(k\)</span> bins if possible, and raises an exception otherwise.</p></li>
<li><p>When set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the function returns a partition of the items
using the least possible number of bins.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) Specify a Mixed Integer Linear Programming
(MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For
more information on MILP solvers and which default solver is used, see
the method
<a class="reference internal" href="mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="sage.numerical.mip.MixedIntegerLinearProgram.solve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a>
of the class
<a class="reference internal" href="mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="sage.numerical.mip.MixedIntegerLinearProgram"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>); sets the level of verbosity. Set
to 0 by default, which means quiet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – parameter for use with MILP solvers over an
inexact base ring; see <a class="reference internal" href="mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="sage.numerical.mip.MixedIntegerLinearProgram.get_values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A list of lists, each member corresponding to a bin and containing either
the list of the weights inside it when <code class="docutils literal notranslate"><span class="pre">items</span></code> is a list of items’ weight,
or the list of items inside it when <code class="docutils literal notranslate"><span class="pre">items</span></code> is a dictionary. If there is
no solution, an exception is raised (this can only happen when <code class="docutils literal notranslate"><span class="pre">k</span></code> is
specified or if <code class="docutils literal notranslate"><span class="pre">maximum</span></code> is less than the weight of one item).</p>
<p>EXAMPLES:</p>
<p>Trying to find the minimum amount of boxes for 5 items of weights
<span class="math notranslate nohighlight">\(1/5, 1/4, 2/3, 3/4, 5/7\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.numerical.optimize</span> <span class="kn">import</span> <span class="n">binpacking</span>
<span class="gp">sage: </span><span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="o">/</span><span class="mi">7</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">bins</span> <span class="o">=</span> <span class="n">binpacking</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Checking the bins are of correct size</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bins</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Checking every item is in a bin</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b3</span> <span class="o">=</span> <span class="n">bins</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">((</span><span class="n">v</span> <span class="ow">in</span> <span class="n">b1</span> <span class="ow">or</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">b2</span> <span class="ow">or</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">b3</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>And only in one bin</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bins</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>One way to use only three boxes (which is best possible) is to put
<span class="math notranslate nohighlight">\(1/5 + 3/4\)</span> together in a box, <span class="math notranslate nohighlight">\(1/3+2/3\)</span> in another, and <span class="math notranslate nohighlight">\(5/7\)</span>
by itself in the third one.</p>
<p>Of course, we can also check that there is no solution using only two boxes</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.numerical.optimize</span> <span class="kn">import</span> <span class="n">binpacking</span>
<span class="gp">sage: </span><span class="n">binpacking</span><span class="p">([</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.8</span><span class="p">,</span><span class="mf">0.9</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: this problem has no solution !</span>
</pre></div>
</div>
<p>We can also provide a dictionary keyed by items and associating to each item
its weight. Then, the bins contain the name of the items inside it</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">values</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span><span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span><span class="mi">5</span><span class="o">/</span><span class="mi">7</span><span class="p">}</span>
<span class="gp">sage: </span><span class="n">bins</span> <span class="o">=</span> <span class="n">binpacking</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">set</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">bins</span><span class="p">))</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.numerical.optimize.find_fit">
<span class="sig-prename descclassname"><span class="pre">sage.numerical.optimize.</span></span><span class="sig-name descname"><span class="pre">find_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_guess</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solution_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.numerical.optimize.find_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds numerical estimates for the parameters of the function model to
give a best fit to data.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">data</span></code> – A two dimensional table of floating point numbers of the
form <span class="math notranslate nohighlight">\([[x_{1,1}, x_{1,2}, \ldots, x_{1,k}, f_1],
[x_{2,1}, x_{2,2}, \ldots, x_{2,k}, f_2],
\ldots,
[x_{n,1}, x_{n,2}, \ldots, x_{n,k}, f_n]]\)</span> given as either a list of
lists, matrix, or numpy array.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">model</span></code> – Either a symbolic expression, symbolic function, or a
Python function. <code class="docutils literal notranslate"><span class="pre">model</span></code> has to be a function of the variables
<span class="math notranslate nohighlight">\((x_1, x_2, \ldots, x_k)\)</span> and free parameters
<span class="math notranslate nohighlight">\((a_1, a_2, \ldots, a_l)\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_guess</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) Initial estimate for the
parameters <span class="math notranslate nohighlight">\((a_1, a_2, \ldots, a_l)\)</span>, given as either a list, tuple,
vector or numpy array. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default estimate for each
parameter is <span class="math notranslate nohighlight">\(1\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">parameters</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) A list of the parameters
<span class="math notranslate nohighlight">\((a_1, a_2, \ldots, a_l)\)</span>. If model is a symbolic function it is
ignored, and the free parameters of the symbolic function are used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">variables</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) A list of the variables
<span class="math notranslate nohighlight">\((x_1, x_2, \ldots, x_k)\)</span>. If model is a symbolic function it is
ignored, and the variables of the symbolic function are used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solution_dict</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) if <code class="docutils literal notranslate"><span class="pre">True</span></code>, return the
solution as a dictionary rather than an equation.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>First we create some data points of a sine function with some “random”
perturbations:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">set_random_seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">data</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">i</span><span class="o">-</span><span class="mf">0.2</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">normalvariate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xsrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="n">pi</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;a, b, c, x&#39;</span><span class="p">)</span>
<span class="go">(a, b, c, x)</span>
</pre></div>
</div>
<p>We define a function with free parameters <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b\)</span> and <span class="math notranslate nohighlight">\(c\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<p>We search for the parameters that give the best fit to the data:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">find_fit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>
<span class="go">[a == 1.21..., b == 0.49..., c == 0.19...]</span>
</pre></div>
</div>
<p>We can also use a Python function for the model:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span> <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fit</span> <span class="o">=</span> <span class="n">find_fit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">parameters</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">],</span> <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">solution_dict</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fit</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">fit</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">fit</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
<span class="go">(1.21..., 0.49..., 0.19...)</span>
</pre></div>
</div>
<p>We search for a formula for the <span class="math notranslate nohighlight">\(n\)</span>-th prime number:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">dataprime</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">nth_prime</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5000</span><span class="p">,</span> <span class="mi">100</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">find_fit</span><span class="p">(</span><span class="n">dataprime</span><span class="p">,</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">x</span><span class="p">),</span> <span class="n">parameters</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">])</span>
<span class="go">[a == 1.11..., b == 1.24...]</span>
</pre></div>
</div>
<p>ALGORITHM:</p>
<p>Uses <code class="docutils literal notranslate"><span class="pre">scipy.optimize.leastsq</span></code> which in turn uses MINPACK’s lmdif and
lmder algorithms.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.numerical.optimize.find_local_maximum">
<span class="sig-prename descclassname"><span class="pre">sage.numerical.optimize.</span></span><span class="sig-name descname"><span class="pre">find_local_maximum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.48e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxfun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.numerical.optimize.find_local_maximum" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerically find a local maximum of the expression <span class="math notranslate nohighlight">\(f\)</span> on the interval
<span class="math notranslate nohighlight">\([a,b]\)</span> (or <span class="math notranslate nohighlight">\([b,a]\)</span>) along with the point at which the maximum is attained.</p>
<p>Note that this function only finds a <em>local</em> maximum, and not the
global maximum on that interval – see the examples with
<a class="reference internal" href="#sage.numerical.optimize.find_local_maximum" title="sage.numerical.optimize.find_local_maximum"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_local_maximum()</span></code></a>.</p>
<p>See the documentation for <a class="reference internal" href="#sage.numerical.optimize.find_local_maximum" title="sage.numerical.optimize.find_local_maximum"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_local_maximum()</span></code></a> for more
details and possible workarounds for finding the global minimum on
an interval.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">find_local_maximum</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">(0.561096338191..., 0.8603335890...)</span>
<span class="gp">sage: </span><span class="n">find_local_maximum</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">maxfun</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="go">(0.561090323458..., 0.857926501456...)</span>
<span class="gp">sage: </span><span class="n">find_local_maximum</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="go">(1.579175535558..., 0.7853981...)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.numerical.optimize.find_local_minimum">
<span class="sig-prename descclassname"><span class="pre">sage.numerical.optimize.</span></span><span class="sig-name descname"><span class="pre">find_local_minimum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.48e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxfun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.numerical.optimize.find_local_minimum" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerically find a local minimum of the expression <code class="docutils literal notranslate"><span class="pre">f</span></code> on the
interval <span class="math notranslate nohighlight">\([a,b]\)</span> (or <span class="math notranslate nohighlight">\([b,a]\)</span>) and the point at which it attains that
minimum.  Note that <code class="docutils literal notranslate"><span class="pre">f</span></code> must be a function of (at most) one
variable.</p>
<p>Note that this function only finds a <em>local</em> minimum, and not the
global minimum on that interval – see the examples below.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">f</span></code> – a function of at most one variable.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code> – endpoints of interval on which to minimize self.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tol</span></code> – the convergence tolerance</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">maxfun</span></code> – maximum function evaluations</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">minval</span></code> – (float) the minimum value that self takes on in the
interval <span class="math notranslate nohighlight">\([a,b]\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – (float) the point at which self takes on the minimum value</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">find_local_minimum</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">(-3.28837139559..., 3.4256184695...)</span>
<span class="gp">sage: </span><span class="n">find_local_minimum</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">)</span>
<span class="go">(-3.28837136189098..., 3.42575079030572...)</span>
<span class="gp">sage: </span><span class="n">find_local_minimum</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">,</span> <span class="n">maxfun</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="go">(-3.28837084598..., 3.4250840220...)</span>
<span class="gp">sage: </span><span class="n">show</span><span class="p">(</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">find_local_minimum</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="go">(-9.4772942594..., 9.5293344109...)</span>
</pre></div>
</div>
<p>Only local minima are found; if you enlarge the interval, the
returned minimum may be <em>larger</em>! See <a class="reference external" href="https://trac.sagemath.org/2607">trac ticket #2607</a>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">find_local_minimum</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(-2.182769784677722, -2.1945027498534686)</span>
</pre></div>
</div>
<p>Enlarging the interval returns a larger minimum:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">find_local_minimum</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">(-1.3076194129914434, 1.3552111405712108)</span>
</pre></div>
</div>
<p>One work-around is to plot the function and grab the minimum from
that, although the plotting code does not necessarily do careful
numerics (observe the small number of decimal places that we
actually test):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="o">-</span><span class="mf">2.5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">ymin</span><span class="p">()</span>
<span class="go">-2.182...</span>
<span class="gp">sage: </span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="o">-</span><span class="mf">2.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">ymin</span><span class="p">()</span>
<span class="go">-2.182...</span>
</pre></div>
</div>
<p>ALGORITHM:</p>
<p>Uses <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fminbound.html">scipy.optimize.fminbound</a>
which uses Brent’s method.</p>
<p>AUTHOR:</p>
<ul class="simple">
<li><p>William Stein (2007-12-07)</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.numerical.optimize.find_root">
<span class="sig-prename descclassname"><span class="pre">sage.numerical.optimize.</span></span><span class="sig-name descname"><span class="pre">find_root</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8.881784197001252e-16</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.numerical.optimize.find_root" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerically find a root of <code class="docutils literal notranslate"><span class="pre">f</span></code> on the closed interval <span class="math notranslate nohighlight">\([a,b]\)</span>
(or <span class="math notranslate nohighlight">\([b,a]\)</span>) if possible, where <code class="docutils literal notranslate"><span class="pre">f</span></code> is a function in the one variable.
Note: this function only works in fixed (machine) precision, it is not
possible to get arbitrary precision approximations with it.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">f</span></code> – a function of one variable or symbolic equality</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code> – endpoints of the interval</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xtol</span></code>, <code class="docutils literal notranslate"><span class="pre">rtol</span></code> – the routine converges when a root is known
to lie within <code class="docutils literal notranslate"><span class="pre">xtol</span></code> of the value return. Should be <span class="math notranslate nohighlight">\(\geq 0\)</span>.
The routine modifies this to take into account the relative precision
of doubles. By default, rtol is <code class="docutils literal notranslate"><span class="pre">4*numpy.finfo(float).eps</span></code>, the
minimum allowed value for <code class="docutils literal notranslate"><span class="pre">scipy.optimize.brentq</span></code>, which is what
this method uses underneath. This value is equal to <code class="docutils literal notranslate"><span class="pre">2.0**-50</span></code> for
IEEE-754 double precision floats as used by Python.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">maxiter</span></code> – integer; if convergence is not achieved in
<code class="docutils literal notranslate"><span class="pre">maxiter</span></code> iterations, an error is raised. Must be <span class="math notranslate nohighlight">\(\geq 0\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">full_output</span></code> – bool (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>), if <code class="docutils literal notranslate"><span class="pre">True</span></code>, also return
object that contains information about convergence.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>An example involving an algebraic polynomial function:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">17</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">8</span><span class="p">)</span><span class="o">^</span><span class="mi">3</span>
<span class="gp">sage: </span><span class="n">find_root</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="go">2.999999999999995</span>
<span class="gp">sage: </span><span class="n">find_root</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># abs tol 1e-6 (note -- precision of answer isn&#39;t very good on some machines)</span>
<span class="go">0.124999</span>
<span class="gp">sage: </span><span class="n">find_root</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">)</span>
<span class="go">-17.0</span>
</pre></div>
</div>
<p>In Pomerance’s book on primes he asserts that the famous Riemann
Hypothesis is equivalent to the statement that the function <span class="math notranslate nohighlight">\(f(x)\)</span>
defined below is positive for all <span class="math notranslate nohighlight">\(x \geq 2.01\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">Li</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">prime_pi</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>We find where <span class="math notranslate nohighlight">\(f\)</span> equals, i.e., what value that is slightly smaller
than <span class="math notranslate nohighlight">\(2.01\)</span> that could have been used in the formulation of the Riemann
Hypothesis:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">find_root</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">)</span>
<span class="go">2.0082...</span>
</pre></div>
</div>
<p>This agrees with the plot:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mf">2.01</span><span class="p">)</span>
<span class="go">Graphics object consisting of 1 graphics primitive</span>
</pre></div>
</div>
<p>The following example was added due to <a class="reference external" href="https://trac.sagemath.org/4942">trac ticket #4942</a> and demonstrates that
the function need not be defined at the endpoints:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">find_root</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># abs tol 1e-6</span>
<span class="go">1.41421356237</span>
</pre></div>
</div>
<p>The following is an example, again from <a class="reference external" href="https://trac.sagemath.org/4942">trac ticket #4942</a> where Brent’s method
fails. Currently no other method is implemented, but at least we
acknowledge the fact that the algorithm fails:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">find_root</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">sage: </span><span class="n">find_root</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.00001</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">NotImplementedError: Brent&#39;s method failed to find a zero for f on the interval</span>
</pre></div>
</div>
<p>An example of a function which evaluates to NaN on the entire interval:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">find_root</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">RuntimeError: f appears to have no zero on the interval</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.numerical.optimize.linear_program">
<span class="sig-prename descclassname"><span class="pre">sage.numerical.optimize.</span></span><span class="sig-name descname"><span class="pre">linear_program</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.numerical.optimize.linear_program" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the dual linear programs:</p>
<ul class="simple">
<li><p>Minimize  <span class="math notranslate nohighlight">\(c'x\)</span> subject to <span class="math notranslate nohighlight">\(Gx + s = h\)</span>, <span class="math notranslate nohighlight">\(Ax = b\)</span>, and <span class="math notranslate nohighlight">\(s \geq 0\)</span> where
<span class="math notranslate nohighlight">\('\)</span> denotes transpose.</p></li>
<li><p>Maximize  <span class="math notranslate nohighlight">\(-h'z - b'y\)</span> subject to <span class="math notranslate nohighlight">\(G'z + A'y + c = 0\)</span> and <span class="math notranslate nohighlight">\(z \geq 0\)</span>.</p></li>
</ul>
<p>This function is deprecated.  Use <a class="reference internal" href="mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="sage.numerical.mip.MixedIntegerLinearProgram"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a> instead.</p>
<p>This function depends on the optional package <code class="docutils literal notranslate"><span class="pre">cvxopt</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">c</span></code> – a vector</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a matrix</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">h</span></code> – a vector</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code> – a matrix</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> — a vector</p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">solver</span></code> (optional) — solver to use. If None, the cvxopt’s lp-solver</dt><dd><p>is used. If it is ‘glpk’, then glpk’s solver
is used.</p>
</dd>
</dl>
</li>
</ul>
<p>These can be over any field that can be turned into a floating point
number.</p>
<p>OUTPUT:</p>
<p>A dictionary <code class="docutils literal notranslate"><span class="pre">sol</span></code> with keys <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">s</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">z</span></code> corresponding
to the variables above:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sol['x']</span></code> – the solution to the linear program</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sol['s']</span></code> – the slack variables for the solution</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sol['z']</span></code>, <code class="docutils literal notranslate"><span class="pre">sol['y']</span></code> – solutions to the dual program</p></li>
</ul>
<p>EXAMPLES:</p>
<p>First, we minimize <span class="math notranslate nohighlight">\(-4x_1 - 5x_2\)</span> subject to <span class="math notranslate nohighlight">\(2x_1 + x_2 \leq 3\)</span>,
<span class="math notranslate nohighlight">\(x_1 +  2x_2 \leq 3\)</span>, <span class="math notranslate nohighlight">\(x_1 \geq 0\)</span>, and <span class="math notranslate nohighlight">\(x_2 \geq 0\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">c</span><span class="o">=</span><span class="n">vector</span><span class="p">(</span><span class="n">RDF</span><span class="p">,[</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">=</span><span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">=</span><span class="n">vector</span><span class="p">(</span><span class="n">RDF</span><span class="p">,[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">sol</span><span class="o">=</span><span class="n">linear_program</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>                                                <span class="c1"># optional - cvxopt</span>
<span class="go">doctest:warning...</span>
<span class="go">DeprecationWarning: linear_program is deprecated; use MixedIntegerLinearProgram instead</span>
<span class="go">See https://trac.sagemath.org/32226 for details.</span>
<span class="gp">sage: </span><span class="n">sol</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>                                                                 <span class="c1"># optional - cvxopt</span>
<span class="go">(0.999..., 1.000...)</span>
</pre></div>
</div>
<p>Here we solve the same problem with ‘glpk’ interface to ‘cvxopt’:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">sol</span><span class="o">=</span><span class="n">linear_program</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">solver</span><span class="o">=</span><span class="s1">&#39;glpk&#39;</span><span class="p">)</span>                                  <span class="c1"># optional - cvxopt</span>
<span class="go">GLPK Simplex Optimizer...</span>
<span class="go">...</span>
<span class="go">OPTIMAL LP SOLUTION FOUND</span>
<span class="gp">sage: </span><span class="n">sol</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>                                                                 <span class="c1"># optional - cvxopt</span>
<span class="go">(1.0, 1.0)</span>
</pre></div>
</div>
<p>Next, we maximize <span class="math notranslate nohighlight">\(x+y-50\)</span> subject to <span class="math notranslate nohighlight">\(50x + 24y \leq 2400\)</span>,
<span class="math notranslate nohighlight">\(30x + 33y \leq 2100\)</span>, <span class="math notranslate nohighlight">\(x \geq 45\)</span>, and <span class="math notranslate nohighlight">\(y \geq 5\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">v</span><span class="o">=</span><span class="n">vector</span><span class="p">([</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">=</span><span class="n">matrix</span><span class="p">([[</span><span class="mf">50.0</span><span class="p">,</span><span class="mf">24.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],[</span><span class="mf">30.0</span><span class="p">,</span><span class="mf">33.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],[</span><span class="mf">0.0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">],[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">=</span><span class="n">vector</span><span class="p">([</span><span class="mf">2400.0</span><span class="p">,</span><span class="mf">2100.0</span><span class="p">,</span><span class="o">-</span><span class="mf">45.0</span><span class="p">,</span><span class="o">-</span><span class="mf">5.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">sol</span><span class="o">=</span><span class="n">linear_program</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>                                                <span class="c1"># optional - cvxopt</span>
<span class="gp">sage: </span><span class="n">sol</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>                                                                 <span class="c1"># optional - cvxopt</span>
<span class="go">(45.000000..., 6.2499999..., 1.00000000...)</span>
<span class="gp">sage: </span><span class="n">sol</span><span class="o">=</span><span class="n">linear_program</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">solver</span><span class="o">=</span><span class="s1">&#39;glpk&#39;</span><span class="p">)</span>                                  <span class="c1"># optional - cvxopt</span>
<span class="go">GLPK Simplex Optimizer...</span>
<span class="go">OPTIMAL LP SOLUTION FOUND</span>
<span class="gp">sage: </span><span class="n">sol</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>                                                                 <span class="c1"># optional - cvxopt</span>
<span class="go">(45.0..., 6.25..., 1.0...)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.numerical.optimize.minimize">
<span class="sig-prename descclassname"><span class="pre">sage.numerical.optimize.</span></span><span class="sig-name descname"><span class="pre">minimize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hessian</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.numerical.optimize.minimize" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is an interface to a variety of algorithms for computing
the minimum of a function of several variables.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">func</span></code> – Either a symbolic function or a Python function whose
argument is a tuple with <span class="math notranslate nohighlight">\(n\)</span> components</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x0</span></code> – Initial point for finding minimum.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gradient</span></code> – Optional gradient function. This will be computed
automatically for symbolic functions.  For Python functions, it allows
the use of algorithms requiring derivatives.  It should accept a
tuple of arguments and return a NumPy array containing the partial
derivatives at that point.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hessian</span></code> –  Optional hessian function. This will be computed
automatically for symbolic functions. For Python functions, it allows
the use of algorithms requiring derivatives. It should accept a tuple
of arguments and return a NumPy array containing the second partial
derivatives of the function.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – String specifying algorithm to use. Options are
<code class="docutils literal notranslate"><span class="pre">'default'</span></code> (for Python functions, the simplex method is the default)
(for symbolic functions bfgs is the default):</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'simplex'</span></code> – using the downhill simplex algorithm</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'powell'</span></code> – use the modified Powell algorithm</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'bfgs'</span></code> – (Broyden-Fletcher-Goldfarb-Shanno) requires gradient</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'cg'</span></code> – (conjugate-gradient) requires gradient</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'ncg'</span></code> – (newton-conjugate gradient) requires gradient and hessian</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – (optional, default: False) print convergence message</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For additional information on the algorithms implemented in this function,
consult SciPy’s <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/optimize.html">documentation on optimization and root
finding</a></p>
</div>
<p>EXAMPLES:</p>
<p>Minimize a fourth order polynomial in three variables (see the
<a class="reference external" href="https://en.wikipedia.org/wiki/Rosenbrock_function">Wikipedia article Rosenbrock_function</a>):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">vars</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="mi">100</span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">100</span><span class="o">*</span><span class="p">(</span><span class="n">z</span><span class="o">-</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span>
<span class="gp">sage: </span><span class="n">minimize</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="mf">.1</span><span class="p">,</span><span class="mf">.3</span><span class="p">,</span><span class="mf">.4</span><span class="p">])</span> <span class="c1"># abs tol 1e-6</span>
<span class="go">(1.0, 1.0, 1.0)</span>
</pre></div>
</div>
<p>Try the newton-conjugate gradient method; the gradient and hessian are
computed automatically:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">minimize</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="mf">.1</span><span class="p">,</span> <span class="mf">.3</span><span class="p">,</span> <span class="mf">.4</span><span class="p">],</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;ncg&quot;</span><span class="p">)</span> <span class="c1"># abs tol 1e-6</span>
<span class="go">(1.0, 1.0, 1.0)</span>
</pre></div>
</div>
<p>We get additional convergence information with the <span class="math notranslate nohighlight">\(verbose\)</span> option:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">minimize</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="mf">.1</span><span class="p">,</span> <span class="mf">.3</span><span class="p">,</span> <span class="mf">.4</span><span class="p">],</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;ncg&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Optimization terminated successfully.</span>
<span class="go">...</span>
<span class="go">(0.9999999..., 0.999999..., 0.999999...)</span>
</pre></div>
</div>
<p>Same example with just Python functions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">rosen</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="c1"># The Rosenbrock function</span>
<span class="gp">....: </span>   <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mf">100.0</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="n">r</span><span class="p">:]</span><span class="o">-</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mf">2.0</span><span class="n">r</span><span class="p">)</span><span class="o">**</span><span class="mf">2.0</span><span class="n">r</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="n">r</span><span class="o">-</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mf">2.0</span><span class="n">r</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="p">[</span><span class="mf">.1</span><span class="p">,</span><span class="mf">.3</span><span class="p">,</span><span class="mf">.4</span><span class="p">])</span> <span class="c1"># abs tol 3e-5</span>
<span class="go">(1.0, 1.0, 1.0)</span>
</pre></div>
</div>
<p>Same example with a pure Python function and a Python function to
compute the gradient:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">rosen</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="c1"># The Rosenbrock function</span>
<span class="gp">....: </span>   <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mf">100.0</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="n">r</span><span class="p">:]</span><span class="o">-</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mf">2.0</span><span class="n">r</span><span class="p">)</span><span class="o">**</span><span class="mf">2.0</span><span class="n">r</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="n">r</span><span class="o">-</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mf">2.0</span><span class="n">r</span><span class="p">)</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">zeros</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">rosen_der</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">....: </span>   <span class="n">xm</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="n">r</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="n">r</span><span class="p">]</span>
<span class="gp">....: </span>   <span class="n">xm_m1</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="n">r</span><span class="p">]</span>
<span class="gp">....: </span>   <span class="n">xm_p1</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="n">r</span><span class="p">:]</span>
<span class="gp">....: </span>   <span class="n">der</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">....: </span>   <span class="n">der</span><span class="p">[</span><span class="mi">1</span><span class="n">r</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="mi">200</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="n">xm</span><span class="o">-</span><span class="n">xm_m1</span><span class="o">**</span><span class="mi">2</span><span class="n">r</span><span class="p">)</span> <span class="o">-</span> <span class="mi">400</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="n">xm_p1</span> <span class="o">-</span> <span class="n">xm</span><span class="o">**</span><span class="mi">2</span><span class="n">r</span><span class="p">)</span><span class="o">*</span><span class="n">xm</span> <span class="o">-</span> <span class="mi">2</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="n">r</span><span class="o">-</span><span class="n">xm</span><span class="p">)</span>
<span class="gp">....: </span>   <span class="n">der</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">400</span><span class="n">r</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="n">r</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="n">r</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="n">r</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">....: </span>   <span class="n">der</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">200</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="n">r</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="n">r</span><span class="p">)</span>
<span class="gp">....: </span>   <span class="k">return</span> <span class="n">der</span>
<span class="gp">sage: </span><span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="p">[</span><span class="mf">.1</span><span class="p">,</span><span class="mf">.3</span><span class="p">,</span><span class="mf">.4</span><span class="p">],</span> <span class="n">gradient</span><span class="o">=</span><span class="n">rosen_der</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;bfgs&quot;</span><span class="p">)</span> <span class="c1"># abs tol 1e-6</span>
<span class="go">(1.0, 1.0, 1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.numerical.optimize.minimize_constrained">
<span class="sig-prename descclassname"><span class="pre">sage.numerical.optimize.</span></span><span class="sig-name descname"><span class="pre">minimize_constrained</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cons</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.numerical.optimize.minimize_constrained" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimize a function with constraints.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">func</span></code> – Either a symbolic function, or a Python function whose
argument is a tuple with n components</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cons</span></code> – constraints. This should be either a function or list of
functions that must be positive. Alternatively, the constraints can
be specified as a list of intervals that define the region we are
minimizing in. If the constraints are specified as functions, the
functions should be functions of a tuple with <span class="math notranslate nohighlight">\(n\)</span> components
(assuming <span class="math notranslate nohighlight">\(n\)</span> variables). If the constraints are specified as a list
of intervals and there are no constraints for a given variable, that
component can be (<code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x0</span></code> – Initial point for finding minimum</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – Optional, specify the algorithm to use:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'default'</span></code>  – default choices</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'l-bfgs-b'</span></code> – only effective if you specify bound constraints.
See <a class="reference internal" href="../../../references/index.html#zbn1997" id="id1"><span>[ZBN1997]</span></a>.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">gradient</span></code> – Optional gradient function. This will be computed
automatically for symbolic functions. This is only used when the
constraints are specified as a list of intervals.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>Let us maximize <span class="math notranslate nohighlight">\(x + y - 50\)</span> subject to the following constraints:
<span class="math notranslate nohighlight">\(50x + 24y \leq 2400\)</span>, <span class="math notranslate nohighlight">\(30x + 33y \leq 2100\)</span>, <span class="math notranslate nohighlight">\(x \geq 45\)</span>,
and <span class="math notranslate nohighlight">\(y \geq 5\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">50</span>
<span class="gp">sage: </span><span class="n">c_1</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">45</span>
<span class="gp">sage: </span><span class="n">c_2</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">5</span>
<span class="gp">sage: </span><span class="n">c_3</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="o">-</span><span class="mi">50</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">24</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2400</span>
<span class="gp">sage: </span><span class="n">c_4</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="o">-</span><span class="mi">30</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">33</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2100</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">minimize_constrained</span><span class="p">(</span><span class="n">f</span><span class="p">,[</span><span class="n">c_1</span><span class="p">,</span><span class="n">c_2</span><span class="p">,</span><span class="n">c_3</span><span class="p">,</span><span class="n">c_4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span>
<span class="go">(45.0, 6.25...)</span>
</pre></div>
</div>
<p>Let’s find a minimum of <span class="math notranslate nohighlight">\(\sin(xy)\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">minimize_constrained</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">10</span><span class="p">)],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="go">(4.8..., 4.8...)</span>
</pre></div>
</div>
<p>Check if L-BFGS-B finds the same minimum:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">minimize_constrained</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">10</span><span class="p">)],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;l-bfgs-b&#39;</span><span class="p">)</span>
<span class="go">(4.7..., 4.9...)</span>
</pre></div>
</div>
<p>Rosenbrock function (see the <a class="reference external" href="https://en.wikipedia.org/wiki/Rosenbrock_function">Wikipedia article Rosenbrock_function</a>):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">rosen</span><span class="p">,</span> <span class="n">rosen_der</span>
<span class="gp">sage: </span><span class="n">minimize_constrained</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="p">[(</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">)],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">gradient</span><span class="o">=</span><span class="n">rosen_der</span><span class="p">,</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;l-bfgs-b&#39;</span><span class="p">)</span>
<span class="go">(-10.0, 10.0)</span>
<span class="gp">sage: </span><span class="n">minimize_constrained</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="p">[(</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">)],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;l-bfgs-b&#39;</span><span class="p">)</span>
<span class="go">(-10.0, 10.0)</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Numerical Root Finding and Optimization</a><ul>
<li><a class="reference internal" href="#functions-and-methods">Functions and Methods</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="linear_tensor_constraints.html"
                          title="previous chapter">Constraints on Linear Functions Tensored with a Free Module</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="interactive_simplex_method.html"
                          title="next chapter">Interactive Simplex Method</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/sage/numerical/optimize.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="interactive_simplex_method.html" title="Interactive Simplex Method"
             >next</a> |</li>
        <li class="right" >
          <a href="linear_tensor_constraints.html" title="Constraints on Linear Functions Tensored with a Free Module"
             >previous</a> |</li>
  <li class="nav-item nav-item-0">
    <a href="http://www.sagemath.org"><img src="../../../_static/logo_sagemath_black.svg" class="sage-logo" title="Sage Logo"></a>
    
      <a href="../../../../index.html">Sage 9.6 Documentation</a> &#187;
      
      <a href="../../../index.html">Reference Manual</a> &#187;
      
      <a href="../../index.html">Numerical Optimization</a> &#187;
    
  </li>

        <li class="nav-item nav-item-this"><a href="">Numerical Root Finding and Optimization</a></li> 
      </ul>
    </div>
  
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2022, The Sage Development Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* The sidebar toggle adapts its height to the bodywrapper height. */
    const resizeObserver = new ResizeObserver(entries => {
        tog.height(bod.height());
    });
    resizeObserver.observe(bod[0]);

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
  </script>
  <script type="text/javascript">
/* detex the document title by removing "\(", "\)", "\", "$" */
document.title = document.title.replace(/\\\(/g, '').replace(/\\\)/g, '').replace(/\\/g, '').replace(/\$/g, '');
  </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>