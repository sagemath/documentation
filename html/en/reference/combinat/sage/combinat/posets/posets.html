<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Finite posets &mdash; Sage Reference Manual v7.3: Combinatorics</title>
    
    <link rel="stylesheet" href="../../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '7.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v7.3: Combinatorics" href="../../../index.html" />
    <link rel="up" title="Comprehensive Module list" href="../../../module_list.html" />
    <link rel="next" title="\(q\)-Analogues" href="../q_analogues.html" />
    <link rel="prev" title="A catalog of posets and lattices." href="poset_examples.html" />
    <link rel="icon" href="../../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../q_analogues.html" title="\(q\)-Analogues"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="poset_examples.html" title="A catalog of posets and lattices."
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../../index.html">Combinatorics</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../../../module_list.html" accesskey="U">Comprehensive Module list</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="finite-posets">
<span id="sage-combinat-posets-posets"></span><h1>Finite posets<a class="headerlink" href="#finite-posets" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.combinat.posets.posets"></span><p>This module implements finite partially ordered sets. It defines:</p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><code class="xref py py-class docutils literal"><span class="pre">FinitePoset</span></code></a></td>
<td>A class for finite posets</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePosets_n" title="sage.combinat.posets.posets.FinitePosets_n"><code class="xref py py-class docutils literal"><span class="pre">FinitePosets_n</span></code></a></td>
<td>A class for finite posets up to isomorphism (i.e. unlabeled posets)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><code class="xref py py-meth docutils literal"><span class="pre">Poset()</span></code></a></td>
<td>Construct a finite poset from various forms of input data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.is_poset" title="sage.combinat.posets.posets.is_poset"><code class="xref py py-meth docutils literal"><span class="pre">is_poset()</span></code></a></td>
<td>Return <code class="docutils literal"><span class="pre">True</span></code> if a directed graph is acyclic and transitively reduced.</td>
</tr>
</tbody>
</table>
<div class="section" id="list-of-poset-methods">
<h2>List of Poset methods<a class="headerlink" href="#list-of-poset-methods" title="Permalink to this headline">¶</a></h2>
<p><strong>Comparing, intervals and relations</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_less_than" title="sage.combinat.posets.posets.FinitePoset.is_less_than"><code class="xref py py-meth docutils literal"><span class="pre">is_less_than()</span></code></a></td>
<td>Return <code class="docutils literal"><span class="pre">True</span></code> if <span class="math">\(x\)</span> is strictly less than <span class="math">\(y\)</span> in the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_greater_than" title="sage.combinat.posets.posets.FinitePoset.is_greater_than"><code class="xref py py-meth docutils literal"><span class="pre">is_greater_than()</span></code></a></td>
<td>Return <code class="docutils literal"><span class="pre">True</span></code> if <span class="math">\(x\)</span> is strictly greater than <span class="math">\(y\)</span> in the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_lequal" title="sage.combinat.posets.posets.FinitePoset.is_lequal"><code class="xref py py-meth docutils literal"><span class="pre">is_lequal()</span></code></a></td>
<td>Return <code class="docutils literal"><span class="pre">True</span></code> if <span class="math">\(x\)</span> is less than or equal to <span class="math">\(y\)</span> in the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_gequal" title="sage.combinat.posets.posets.FinitePoset.is_gequal"><code class="xref py py-meth docutils literal"><span class="pre">is_gequal()</span></code></a></td>
<td>Return <code class="docutils literal"><span class="pre">True</span></code> if <span class="math">\(x\)</span> is greater than or equal to <span class="math">\(y\)</span> in the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.compare_elements" title="sage.combinat.posets.posets.FinitePoset.compare_elements"><code class="xref py py-meth docutils literal"><span class="pre">compare_elements()</span></code></a></td>
<td>Compare two element of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.closed_interval" title="sage.combinat.posets.posets.FinitePoset.closed_interval"><code class="xref py py-meth docutils literal"><span class="pre">closed_interval()</span></code></a></td>
<td>Return the list of elements in a closed interval of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.open_interval" title="sage.combinat.posets.posets.FinitePoset.open_interval"><code class="xref py py-meth docutils literal"><span class="pre">open_interval()</span></code></a></td>
<td>Return the list of elements in an open interval of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations" title="sage.combinat.posets.posets.FinitePoset.relations"><code class="xref py py-meth docutils literal"><span class="pre">relations()</span></code></a></td>
<td>Return the list of relations in the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_iterator" title="sage.combinat.posets.posets.FinitePoset.relations_iterator"><code class="xref py py-meth docutils literal"><span class="pre">relations_iterator()</span></code></a></td>
<td>Return an iterator over relations in the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_filter" title="sage.combinat.posets.posets.FinitePoset.order_filter"><code class="xref py py-meth docutils literal"><span class="pre">order_filter()</span></code></a></td>
<td>Return the upper set generated by elements.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_ideal" title="sage.combinat.posets.posets.FinitePoset.order_ideal"><code class="xref py py-meth docutils literal"><span class="pre">order_ideal()</span></code></a></td>
<td>Return the lower set generated by elements.</td>
</tr>
</tbody>
</table>
<p><strong>Covering</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.covers" title="sage.combinat.posets.posets.FinitePoset.covers"><code class="xref py py-meth docutils literal"><span class="pre">covers()</span></code></a></td>
<td>Return <code class="docutils literal"><span class="pre">True</span></code> if <code class="docutils literal"><span class="pre">y</span></code> covers <code class="docutils literal"><span class="pre">x</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.lower_covers" title="sage.combinat.posets.posets.FinitePoset.lower_covers"><code class="xref py py-meth docutils literal"><span class="pre">lower_covers()</span></code></a></td>
<td>Return elements covered by given element.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.upper_covers" title="sage.combinat.posets.posets.FinitePoset.upper_covers"><code class="xref py py-meth docutils literal"><span class="pre">upper_covers()</span></code></a></td>
<td>Return elements covering given element.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.cover_relations" title="sage.combinat.posets.posets.FinitePoset.cover_relations"><code class="xref py py-meth docutils literal"><span class="pre">cover_relations()</span></code></a></td>
<td>Return the list of cover relations.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.lower_covers_iterator" title="sage.combinat.posets.posets.FinitePoset.lower_covers_iterator"><code class="xref py py-meth docutils literal"><span class="pre">lower_covers_iterator()</span></code></a></td>
<td>Return an iterator over elements covered by given element.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.upper_covers_iterator" title="sage.combinat.posets.posets.FinitePoset.upper_covers_iterator"><code class="xref py py-meth docutils literal"><span class="pre">upper_covers_iterator()</span></code></a></td>
<td>Return an iterator over elements covering given element.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.cover_relations_iterator" title="sage.combinat.posets.posets.FinitePoset.cover_relations_iterator"><code class="xref py py-meth docutils literal"><span class="pre">cover_relations_iterator()</span></code></a></td>
<td>Return an iterator over cover relations of the poset.</td>
</tr>
</tbody>
</table>
<p><strong>Properties of the poset</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.cardinality" title="sage.combinat.posets.posets.FinitePoset.cardinality"><code class="xref py py-meth docutils literal"><span class="pre">cardinality()</span></code></a></td>
<td>Return the number of elements in the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.height" title="sage.combinat.posets.posets.FinitePoset.height"><code class="xref py py-meth docutils literal"><span class="pre">height()</span></code></a></td>
<td>Return the number of elements in a longest chain of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.width" title="sage.combinat.posets.posets.FinitePoset.width"><code class="xref py py-meth docutils literal"><span class="pre">width()</span></code></a></td>
<td>Return the number of elements in a longest antichain of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_number" title="sage.combinat.posets.posets.FinitePoset.relations_number"><code class="xref py py-meth docutils literal"><span class="pre">relations_number()</span></code></a></td>
<td>Return the number of relations in the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.dimension" title="sage.combinat.posets.posets.FinitePoset.dimension"><code class="xref py py-meth docutils literal"><span class="pre">dimension()</span></code></a></td>
<td>Return the dimension of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_bottom" title="sage.combinat.posets.posets.FinitePoset.has_bottom"><code class="xref py py-meth docutils literal"><span class="pre">has_bottom()</span></code></a></td>
<td>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset has a unique minimal element.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_top" title="sage.combinat.posets.posets.FinitePoset.has_top"><code class="xref py py-meth docutils literal"><span class="pre">has_top()</span></code></a></td>
<td>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset has a unique maximal element.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="sage.combinat.posets.posets.FinitePoset.is_bounded"><code class="xref py py-meth docutils literal"><span class="pre">is_bounded()</span></code></a></td>
<td>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset has both unique minimal and unique maximal element.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_chain" title="sage.combinat.posets.posets.FinitePoset.is_chain"><code class="xref py py-meth docutils literal"><span class="pre">is_chain()</span></code></a></td>
<td>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset is totally ordered.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_connected" title="sage.combinat.posets.posets.FinitePoset.is_connected"><code class="xref py py-meth docutils literal"><span class="pre">is_connected()</span></code></a></td>
<td>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset is connected.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_graded" title="sage.combinat.posets.posets.FinitePoset.is_graded"><code class="xref py py-meth docutils literal"><span class="pre">is_graded()</span></code></a></td>
<td>Return <code class="docutils literal"><span class="pre">True</span></code> if all maximal chains of the poset has same length.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_ranked" title="sage.combinat.posets.posets.FinitePoset.is_ranked"><code class="xref py py-meth docutils literal"><span class="pre">is_ranked()</span></code></a></td>
<td>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset has a rank function.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_rank_symmetric" title="sage.combinat.posets.posets.FinitePoset.is_rank_symmetric"><code class="xref py py-meth docutils literal"><span class="pre">is_rank_symmetric()</span></code></a></td>
<td>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset is rank symmetric.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_series_parallel" title="sage.combinat.posets.posets.FinitePoset.is_series_parallel"><code class="xref py py-meth docutils literal"><span class="pre">is_series_parallel()</span></code></a></td>
<td>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset can be built by ordinal sums and disjoint unions.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_eulerian" title="sage.combinat.posets.posets.FinitePoset.is_eulerian"><code class="xref py py-meth docutils literal"><span class="pre">is_eulerian()</span></code></a></td>
<td>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset is Eulerian.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_incomparable_chain_free" title="sage.combinat.posets.posets.FinitePoset.is_incomparable_chain_free"><code class="xref py py-meth docutils literal"><span class="pre">is_incomparable_chain_free()</span></code></a></td>
<td>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset is (m+n)-free.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_slender" title="sage.combinat.posets.posets.FinitePoset.is_slender"><code class="xref py py-meth docutils literal"><span class="pre">is_slender()</span></code></a></td>
<td>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset is slender.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_join_semilattice" title="sage.combinat.posets.posets.FinitePoset.is_join_semilattice"><code class="xref py py-meth docutils literal"><span class="pre">is_join_semilattice()</span></code></a></td>
<td>Return <code class="docutils literal"><span class="pre">True</span></code> is the poset has a join operation.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_meet_semilattice" title="sage.combinat.posets.posets.FinitePoset.is_meet_semilattice"><code class="xref py py-meth docutils literal"><span class="pre">is_meet_semilattice()</span></code></a></td>
<td>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset has a meet operation.</td>
</tr>
</tbody>
</table>
<p><strong>Minimal and maximal elements</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.bottom" title="sage.combinat.posets.posets.FinitePoset.bottom"><code class="xref py py-meth docutils literal"><span class="pre">bottom()</span></code></a></td>
<td>Return the bottom element of the poset, if it exists.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.top" title="sage.combinat.posets.posets.FinitePoset.top"><code class="xref py py-meth docutils literal"><span class="pre">top()</span></code></a></td>
<td>Return the top element of the poset, if it exists.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_elements" title="sage.combinat.posets.posets.FinitePoset.maximal_elements"><code class="xref py py-meth docutils literal"><span class="pre">maximal_elements()</span></code></a></td>
<td>Return the list of the maximal elements of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.minimal_elements" title="sage.combinat.posets.posets.FinitePoset.minimal_elements"><code class="xref py py-meth docutils literal"><span class="pre">minimal_elements()</span></code></a></td>
<td>Return the list of the minimal elements of the poset.</td>
</tr>
</tbody>
</table>
<p><strong>New posets from old ones</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.disjoint_union" title="sage.combinat.posets.posets.FinitePoset.disjoint_union"><code class="xref py py-meth docutils literal"><span class="pre">disjoint_union()</span></code></a></td>
<td>Return the disjoint union of the poset with other poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_sum" title="sage.combinat.posets.posets.FinitePoset.ordinal_sum"><code class="xref py py-meth docutils literal"><span class="pre">ordinal_sum()</span></code></a></td>
<td>Return the ordinal sum of the poset with other poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_product" title="sage.combinat.posets.posets.FinitePoset.ordinal_product"><code class="xref py py-meth docutils literal"><span class="pre">ordinal_product()</span></code></a></td>
<td>Return the ordinal product of the poset with other poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.product" title="sage.combinat.posets.posets.FinitePoset.product"><code class="xref py py-meth docutils literal"><span class="pre">product()</span></code></a></td>
<td>Return the Cartesian product of the poset with other poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.with_bounds" title="sage.combinat.posets.posets.FinitePoset.with_bounds"><code class="xref py py-meth docutils literal"><span class="pre">with_bounds()</span></code></a></td>
<td>Return the poset with bottom and top element adjoined.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.dual" title="sage.combinat.posets.posets.FinitePoset.dual"><code class="xref py py-meth docutils literal"><span class="pre">dual()</span></code></a></td>
<td>Return the dual poset of this poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.completion_by_cuts" title="sage.combinat.posets.posets.FinitePoset.completion_by_cuts"><code class="xref py py-meth docutils literal"><span class="pre">completion_by_cuts()</span></code></a></td>
<td>Return the Dedekind-MacNeille completion of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.connected_components" title="sage.combinat.posets.posets.FinitePoset.connected_components"><code class="xref py py-meth docutils literal"><span class="pre">connected_components()</span></code></a></td>
<td>Return the connected components of the poset as subposets.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_summands" title="sage.combinat.posets.posets.FinitePoset.ordinal_summands"><code class="xref py py-meth docutils literal"><span class="pre">ordinal_summands()</span></code></a></td>
<td>Return the ordinal summands of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.subposet" title="sage.combinat.posets.posets.FinitePoset.subposet"><code class="xref py py-meth docutils literal"><span class="pre">subposet()</span></code></a></td>
<td>Return the subposet containing elements with partial order induced by this poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.random_subposet" title="sage.combinat.posets.posets.FinitePoset.random_subposet"><code class="xref py py-meth docutils literal"><span class="pre">random_subposet()</span></code></a></td>
<td>Return a random subposet that contains each element with given probability.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.canonical_label" title="sage.combinat.posets.posets.FinitePoset.canonical_label"><code class="xref py py-meth docutils literal"><span class="pre">canonical_label()</span></code></a></td>
<td>Return copy of the poset canonically (re)labelled with elements <span class="math">\(\{0, \ldots, n-1\}\)</span>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relabel" title="sage.combinat.posets.posets.FinitePoset.relabel"><code class="xref py py-meth docutils literal"><span class="pre">relabel()</span></code></a></td>
<td>Return a copy of this poset with its elements relabelled.</td>
</tr>
</tbody>
</table>
<p><strong>Chains &amp; antichains</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_chain_of_poset" title="sage.combinat.posets.posets.FinitePoset.is_chain_of_poset"><code class="xref py py-meth docutils literal"><span class="pre">is_chain_of_poset()</span></code></a></td>
<td>Return <code class="docutils literal"><span class="pre">True</span></code> if the given list is a chain of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.chains" title="sage.combinat.posets.posets.FinitePoset.chains"><code class="xref py py-meth docutils literal"><span class="pre">chains()</span></code></a></td>
<td>Return the chains of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains" title="sage.combinat.posets.posets.FinitePoset.antichains"><code class="xref py py-meth docutils literal"><span class="pre">antichains()</span></code></a></td>
<td>Return the antichains of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_chains" title="sage.combinat.posets.posets.FinitePoset.maximal_chains"><code class="xref py py-meth docutils literal"><span class="pre">maximal_chains()</span></code></a></td>
<td>Return the maximal chains of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_antichains" title="sage.combinat.posets.posets.FinitePoset.maximal_antichains"><code class="xref py py-meth docutils literal"><span class="pre">maximal_antichains()</span></code></a></td>
<td>Return the maximal antichains of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains_iterator" title="sage.combinat.posets.posets.FinitePoset.antichains_iterator"><code class="xref py py-meth docutils literal"><span class="pre">antichains_iterator()</span></code></a></td>
<td>Return an iterator over the antichains of the poset.</td>
</tr>
</tbody>
</table>
<p><strong>Drawing</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.show" title="sage.combinat.posets.posets.FinitePoset.show"><code class="xref py py-meth docutils literal"><span class="pre">show()</span></code></a></td>
<td>Display the Hasse diagram of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.plot" title="sage.combinat.posets.posets.FinitePoset.plot"><code class="xref py py-meth docutils literal"><span class="pre">plot()</span></code></a></td>
<td>Return a Graphic object corresponding the Hasse diagram of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.graphviz_string" title="sage.combinat.posets.posets.FinitePoset.graphviz_string"><code class="xref py py-meth docutils literal"><span class="pre">graphviz_string()</span></code></a></td>
<td>Return a representation in the DOT language, ready to render in graphviz.</td>
</tr>
</tbody>
</table>
<p><strong>Comparing posets</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_isomorphic" title="sage.combinat.posets.posets.FinitePoset.is_isomorphic"><code class="xref py py-meth docutils literal"><span class="pre">is_isomorphic()</span></code></a></td>
<td>Return <code class="docutils literal"><span class="pre">True</span></code> if both posets are isomorphic.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_induced_subposet" title="sage.combinat.posets.posets.FinitePoset.is_induced_subposet"><code class="xref py py-meth docutils literal"><span class="pre">is_induced_subposet()</span></code></a></td>
<td>Return <code class="docutils literal"><span class="pre">True</span></code> if given poset is an induced subposet of this poset.</td>
</tr>
</tbody>
</table>
<p><strong>Polynomials</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.chain_polynomial" title="sage.combinat.posets.posets.FinitePoset.chain_polynomial"><code class="xref py py-meth docutils literal"><span class="pre">chain_polynomial()</span></code></a></td>
<td>Return the chain polynomial of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.characteristic_polynomial" title="sage.combinat.posets.posets.FinitePoset.characteristic_polynomial"><code class="xref py py-meth docutils literal"><span class="pre">characteristic_polynomial()</span></code></a></td>
<td>Return the characteristic polynomial of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.f_polynomial" title="sage.combinat.posets.posets.FinitePoset.f_polynomial"><code class="xref py py-meth docutils literal"><span class="pre">f_polynomial()</span></code></a></td>
<td>Return the f-polynomial of a bounded poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.flag_f_polynomial" title="sage.combinat.posets.posets.FinitePoset.flag_f_polynomial"><code class="xref py py-meth docutils literal"><span class="pre">flag_f_polynomial()</span></code></a></td>
<td>Return the flag f-polynomial of a bounded and ranked poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.flag_h_polynomial" title="sage.combinat.posets.posets.FinitePoset.flag_h_polynomial"><code class="xref py py-meth docutils literal"><span class="pre">flag_h_polynomial()</span></code></a></td>
<td>Return the flag h-polynomial of a bounded and ranked poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.h_polynomial" title="sage.combinat.posets.posets.FinitePoset.h_polynomial"><code class="xref py py-meth docutils literal"><span class="pre">h_polynomial()</span></code></a></td>
<td>Return the h-polynomial of a bounded poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.kazhdan_lusztig_polynomial" title="sage.combinat.posets.posets.FinitePoset.kazhdan_lusztig_polynomial"><code class="xref py py-meth docutils literal"><span class="pre">kazhdan_lusztig_polynomial()</span></code></a></td>
<td>Return the Kazhdan-Lusztig polynomial <span class="math">\(P_{x,y}(q)\)</span> of <code class="docutils literal"><span class="pre">self</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_polynomial" title="sage.combinat.posets.posets.FinitePoset.order_polynomial"><code class="xref py py-meth docutils literal"><span class="pre">order_polynomial()</span></code></a></td>
<td>Return the order polynomial of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.zeta_polynomial" title="sage.combinat.posets.posets.FinitePoset.zeta_polynomial"><code class="xref py py-meth docutils literal"><span class="pre">zeta_polynomial()</span></code></a></td>
<td>Return the zeta polynomial of the poset.</td>
</tr>
</tbody>
</table>
<p><strong>Polytopes</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.chain_polytope" title="sage.combinat.posets.posets.FinitePoset.chain_polytope"><code class="xref py py-meth docutils literal"><span class="pre">chain_polytope()</span></code></a></td>
<td>Return the chain polytope of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_polytope" title="sage.combinat.posets.posets.FinitePoset.order_polytope"><code class="xref py py-meth docutils literal"><span class="pre">order_polytope()</span></code></a></td>
<td>Return the order polytope of the poset.</td>
</tr>
</tbody>
</table>
<p><strong>Graphs</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.hasse_diagram" title="sage.combinat.posets.posets.FinitePoset.hasse_diagram"><code class="xref py py-meth docutils literal"><span class="pre">hasse_diagram()</span></code></a></td>
<td>Return the Hasse diagram of the poset as a directed graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.cover_relations_graph" title="sage.combinat.posets.posets.FinitePoset.cover_relations_graph"><code class="xref py py-meth docutils literal"><span class="pre">cover_relations_graph()</span></code></a></td>
<td>Return the (undirected) graph of cover relations.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.comparability_graph" title="sage.combinat.posets.posets.FinitePoset.comparability_graph"><code class="xref py py-meth docutils literal"><span class="pre">comparability_graph()</span></code></a></td>
<td>Return the comparability graph of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.incomparability_graph" title="sage.combinat.posets.posets.FinitePoset.incomparability_graph"><code class="xref py py-meth docutils literal"><span class="pre">incomparability_graph()</span></code></a></td>
<td>Return the incomparability graph of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extensions_graph" title="sage.combinat.posets.posets.FinitePoset.linear_extensions_graph"><code class="xref py py-meth docutils literal"><span class="pre">linear_extensions_graph()</span></code></a></td>
<td>Return the linear extensions graph of the poset.</td>
</tr>
</tbody>
</table>
<p><strong>Other &amp; not yet classified</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets" title="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets"><code class="xref py py-meth docutils literal"><span class="pre">isomorphic_subposets()</span></code></a></td>
<td>Return all subposets isomorphic to another poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator" title="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator"><code class="xref py py-meth docutils literal"><span class="pre">isomorphic_subposets_iterator()</span></code></a></td>
<td>Return an iterator over the subposets isomorphic to another poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_isomorphic_subposet" title="sage.combinat.posets.posets.FinitePoset.has_isomorphic_subposet"><code class="xref py py-meth docutils literal"><span class="pre">has_isomorphic_subposet()</span></code></a></td>
<td>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset contains a subposet isomorphic to another poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.moebius_function" title="sage.combinat.posets.posets.FinitePoset.moebius_function"><code class="xref py py-meth docutils literal"><span class="pre">moebius_function()</span></code></a></td>
<td>Return the value of Möbius function of given elements in the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.moebius_function_matrix" title="sage.combinat.posets.posets.FinitePoset.moebius_function_matrix"><code class="xref py py-meth docutils literal"><span class="pre">moebius_function_matrix()</span></code></a></td>
<td>Return a matrix whose <code class="docutils literal"><span class="pre">(i,j)</span></code> entry is the value of the Möbius function evaluated at <code class="docutils literal"><span class="pre">self.linear_extension()[i]</span></code> and <code class="docutils literal"><span class="pre">self.linear_extension()[j]</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_linear_extension" title="sage.combinat.posets.posets.FinitePoset.is_linear_extension"><code class="xref py py-meth docutils literal"><span class="pre">is_linear_extension()</span></code></a></td>
<td>Return whether <code class="docutils literal"><span class="pre">l</span></code> is a linear extension of <code class="docutils literal"><span class="pre">self</span></code>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extension" title="sage.combinat.posets.posets.FinitePoset.linear_extension"><code class="xref py py-meth docutils literal"><span class="pre">linear_extension()</span></code></a></td>
<td>Return a linear extension of this poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extensions" title="sage.combinat.posets.posets.FinitePoset.linear_extensions"><code class="xref py py-meth docutils literal"><span class="pre">linear_extensions()</span></code></a></td>
<td>Return the enumerated set of all the linear extensions of this poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.promotion" title="sage.combinat.posets.posets.FinitePoset.promotion"><code class="xref py py-meth docutils literal"><span class="pre">promotion()</span></code></a></td>
<td>Computes the (extended) promotion on the linear extension of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.evacuation" title="sage.combinat.posets.posets.FinitePoset.evacuation"><code class="xref py py-meth docutils literal"><span class="pre">evacuation()</span></code></a></td>
<td>Computes evacuation on the linear extension associated to the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.coxeter_transformation" title="sage.combinat.posets.posets.FinitePoset.coxeter_transformation"><code class="xref py py-meth docutils literal"><span class="pre">coxeter_transformation()</span></code></a></td>
<td>Return the matrix of the Auslander-Reiten translation acting on the Grothendieck group of the derived category of modules.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.coxeter_polynomial" title="sage.combinat.posets.posets.FinitePoset.coxeter_polynomial"><code class="xref py py-meth docutils literal"><span class="pre">coxeter_polynomial()</span></code></a></td>
<td>Return the characteristic polynomial of the Coxeter transformation.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.list" title="sage.combinat.posets.posets.FinitePoset.list"><code class="xref py py-meth docutils literal"><span class="pre">list()</span></code></a></td>
<td>List the elements of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.cuts" title="sage.combinat.posets.posets.FinitePoset.cuts"><code class="xref py py-meth docutils literal"><span class="pre">cuts()</span></code></a></td>
<td>Return the cuts of the given poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.dilworth_decomposition" title="sage.combinat.posets.posets.FinitePoset.dilworth_decomposition"><code class="xref py py-meth docutils literal"><span class="pre">dilworth_decomposition()</span></code></a></td>
<td>Return a partition of the points into the minimal number of chains.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.frank_network" title="sage.combinat.posets.posets.FinitePoset.frank_network"><code class="xref py py-meth docutils literal"><span class="pre">frank_network()</span></code></a></td>
<td>Return Frank&#8217;s network (a DiGraph along with a cost function on its edges) associated to <code class="docutils literal"><span class="pre">self</span></code>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.greene_shape" title="sage.combinat.posets.posets.FinitePoset.greene_shape"><code class="xref py py-meth docutils literal"><span class="pre">greene_shape()</span></code></a></td>
<td>Computes the Greene-Kleitman partition aka Greene shape of the poset <code class="docutils literal"><span class="pre">self</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.incidence_algebra" title="sage.combinat.posets.posets.FinitePoset.incidence_algebra"><code class="xref py py-meth docutils literal"><span class="pre">incidence_algebra()</span></code></a></td>
<td>Return the indicence algebra of <code class="docutils literal"><span class="pre">self</span></code>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_EL_labelling" title="sage.combinat.posets.posets.FinitePoset.is_EL_labelling"><code class="xref py py-meth docutils literal"><span class="pre">is_EL_labelling()</span></code></a></td>
<td>Return whether <code class="docutils literal"><span class="pre">f</span></code> is an EL labelling of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_linear_extension" title="sage.combinat.posets.posets.FinitePoset.is_linear_extension"><code class="xref py py-meth docutils literal"><span class="pre">is_linear_extension()</span></code></a></td>
<td>Return whether <code class="docutils literal"><span class="pre">l</span></code> is a linear extension of <code class="docutils literal"><span class="pre">self</span></code>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator" title="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator"><code class="xref py py-meth docutils literal"><span class="pre">isomorphic_subposets_iterator()</span></code></a></td>
<td>Return an iterator over the subposets isomorphic to another poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets" title="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets"><code class="xref py py-meth docutils literal"><span class="pre">isomorphic_subposets()</span></code></a></td>
<td>Return all subposets isomorphic to another poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.lequal_matrix" title="sage.combinat.posets.posets.FinitePoset.lequal_matrix"><code class="xref py py-meth docutils literal"><span class="pre">lequal_matrix()</span></code></a></td>
<td>Computes the matrix whose <code class="docutils literal"><span class="pre">(i,j)</span></code> entry is 1 if <code class="docutils literal"><span class="pre">self.linear_extension()[i]</span> <span class="pre">&lt;</span> <span class="pre">self.linear_extension()[j]</span></code> and 0 otherwise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.level_sets" title="sage.combinat.posets.posets.FinitePoset.level_sets"><code class="xref py py-meth docutils literal"><span class="pre">level_sets()</span></code></a></td>
<td>Return a list l such that l[i+1] is the set of minimal elements of the poset obtained by removing the elements in l[0], l[1], ..., l[i].</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_complex" title="sage.combinat.posets.posets.FinitePoset.order_complex"><code class="xref py py-meth docutils literal"><span class="pre">order_complex()</span></code></a></td>
<td>Return the order complex associated to this poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.p_partition_enumerator" title="sage.combinat.posets.posets.FinitePoset.p_partition_enumerator"><code class="xref py py-meth docutils literal"><span class="pre">p_partition_enumerator()</span></code></a></td>
<td>Return a <span class="math">\(P\)</span>-partition enumerator of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.random_order_ideal" title="sage.combinat.posets.posets.FinitePoset.random_order_ideal"><code class="xref py py-meth docutils literal"><span class="pre">random_order_ideal()</span></code></a></td>
<td>Return a random order ideal of <code class="docutils literal"><span class="pre">self</span></code> with uniform probability.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.rank" title="sage.combinat.posets.posets.FinitePoset.rank"><code class="xref py py-meth docutils literal"><span class="pre">rank()</span></code></a></td>
<td>Return the rank of an element, or the rank of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.rank_function" title="sage.combinat.posets.posets.FinitePoset.rank_function"><code class="xref py py-meth docutils literal"><span class="pre">rank_function()</span></code></a></td>
<td>Return a rank function of the poset, if it exists.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.unwrap" title="sage.combinat.posets.posets.FinitePoset.unwrap"><code class="xref py py-meth docutils literal"><span class="pre">unwrap()</span></code></a></td>
<td>Unwraps an element of this poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.with_linear_extension" title="sage.combinat.posets.posets.FinitePoset.with_linear_extension"><code class="xref py py-meth docutils literal"><span class="pre">with_linear_extension()</span></code></a></td>
<td>Return a copy of <code class="docutils literal"><span class="pre">self</span></code> with a different default linear extension.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="classes-and-functions">
<h2>Classes and functions<a class="headerlink" href="#classes-and-functions" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="sage.combinat.posets.posets.FinitePoset">
<em class="property">class </em><code class="descclassname">sage.combinat.posets.posets.</code><code class="descname">FinitePoset</code><span class="sig-paren">(</span><em>hasse_diagram</em>, <em>elements</em>, <em>category</em>, <em>facade</em>, <em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Sage Reference Manual: Basic Structures v7.3)"><code class="xref py py-class docutils literal"><span class="pre">sage.structure.unique_representation.UniqueRepresentation</span></code></a>, <a class="reference external" href="../../../../structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Sage Reference Manual: Basic Structures v7.3)"><code class="xref py py-class docutils literal"><span class="pre">sage.structure.parent.Parent</span></code></a></p>
<p>A (finite) <span class="math">\(n\)</span>-element poset constructed from a directed acyclic graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">hasse_diagram</span></code> &#8211; an instance of
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><code class="xref py py-class docutils literal"><span class="pre">FinitePoset</span></code></a>, or a
<a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v7.3)"><code class="xref py py-class docutils literal"><span class="pre">DiGraph</span></code></a> that is transitively-reduced, acyclic,
loop-free, and multiedge-free.</li>
<li><code class="docutils literal"><span class="pre">elements</span></code> &#8211; an optional list of elements, with <code class="docutils literal"><span class="pre">element[i]</span></code>
corresponding to vertex <code class="docutils literal"><span class="pre">i</span></code>. If <code class="docutils literal"><span class="pre">elements</span></code> is <code class="docutils literal"><span class="pre">None</span></code>, then it is
set to be the vertex set of the digraph. Note that if this option is set,
then <code class="docutils literal"><span class="pre">elements</span></code> is considered as a specified linear extension of the poset
and the <span class="math">\(linear_extension\)</span> attribute is set.</li>
<li><code class="docutils literal"><span class="pre">category</span></code> &#8211; <a class="reference external" href="../../../../categories/sage/categories/finite_posets.html#sage.categories.finite_posets.FinitePosets" title="(in Sage Reference Manual: Category Framework v7.3)"><code class="xref py py-class docutils literal"><span class="pre">FinitePosets</span></code></a>, or a subcategory thereof.</li>
<li><code class="docutils literal"><span class="pre">facade</span></code> &#8211; a boolean or <code class="docutils literal"><span class="pre">None</span></code> (default); whether the
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><code class="xref py py-class docutils literal"><span class="pre">FinitePoset</span></code></a>&#8216;s elements should be
wrapped to make them aware of the Poset they belong to.<ul>
<li>If <code class="docutils literal"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">True</span></code>, the
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><code class="xref py py-class docutils literal"><span class="pre">FinitePoset</span></code></a>&#8216;s elements are exactly
those given as input.</li>
<li>If <code class="docutils literal"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">False</span></code>, the
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><code class="xref py py-class docutils literal"><span class="pre">FinitePoset</span></code></a>&#8216;s elements will become
<code class="xref py py-class docutils literal"><span class="pre">PosetElement</span></code> objects.</li>
<li>If <code class="docutils literal"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">None</span></code> (default) the expected behaviour is the behaviour
of <code class="docutils literal"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">True</span></code>, unless the opposite can be deduced from the
context (i.e. for instance if a
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><code class="xref py py-class docutils literal"><span class="pre">FinitePoset</span></code></a> is built from another
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><code class="xref py py-class docutils literal"><span class="pre">FinitePoset</span></code></a>, itself built with
<code class="docutils literal"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">False</span></code>)</li>
</ul>
</li>
<li><code class="docutils literal"><span class="pre">key</span></code> &#8211; any hashable value (default: <code class="docutils literal"><span class="pre">None</span></code>).</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">uc</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.posets.posets</span> <span class="kn">import</span> <span class="n">FinitePoset</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">FinitePoset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">(</span><span class="nb">dict</span><span class="p">([[</span><span class="n">i</span><span class="p">,</span><span class="n">uc</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uc</span><span class="p">))])),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">);</span> <span class="n">P</span>
<span class="go">Finite poset containing 6 elements</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[5, 4], [5, 3], [4, 1], [0, 2], [0, 3], [2, 1], [3, 1]]</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Join of Category of finite posets and Category of finite enumerated sets</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">__class__</span>
<span class="go">&lt;class &#39;sage.combinat.posets.posets.FinitePoset_with_category&#39;&gt;</span>

<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">combinat</span><span class="o">.</span><span class="n">posets</span><span class="o">.</span><span class="n">posets</span><span class="o">.</span><span class="n">FinitePoset</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">);</span> <span class="n">Q</span>
<span class="go">Finite poset containing 6 elements</span>

<span class="gp">sage: </span><span class="n">Q</span> <span class="ow">is</span> <span class="n">P</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We keep the same underlying Hasse diagram, but change the elements:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">combinat</span><span class="o">.</span><span class="n">posets</span><span class="o">.</span><span class="n">posets</span><span class="o">.</span><span class="n">FinitePoset</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">elements</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">);</span> <span class="n">Q</span>
<span class="go">Finite poset containing 6 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 5], [2, 6], [3, 4], [3, 5], [4, 6], [5, 6]]</span>
</pre></div>
</div>
<p>We test the facade argument:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">],</span><span class="s1">&#39;c&#39;</span><span class="p">:[</span><span class="s1">&#39;d&#39;</span><span class="p">]}),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Join of Category of finite posets and Category of finite enumerated sets</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="n">P</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">],</span><span class="s1">&#39;c&#39;</span><span class="p">:[</span><span class="s1">&#39;d&#39;</span><span class="p">]}),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Join of Category of finite posets</span>
<span class="go">    and Category of finite enumerated sets</span>
<span class="go">    and Category of facade sets</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">str</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">skip</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;_test_an_element&#39;</span><span class="p">])</span> <span class="c1"># is_parent_of is not yet implemented</span>
</pre></div>
</div>
<p>Changing a non facade poset to a facade poset:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">PQ</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">PQ</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Join of Category of finite posets</span>
<span class="go">    and Category of finite enumerated sets</span>
<span class="go">    and Category of facade sets</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">PQ</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">str</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">PQ</span> <span class="ow">is</span> <span class="n">Q</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Changing a facade poset to a non facade poset:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QP</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">QP</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Join of Category of finite posets</span>
<span class="go">    and Category of finite enumerated sets</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">QP</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="n">QP</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A class that inherits from this class needs to define
<code class="docutils literal"><span class="pre">Element</span></code>. This is the class of the elements that the inheriting
class contains. For example, for this class, <code class="docutils literal"><span class="pre">FinitePoset</span></code>,
<code class="docutils literal"><span class="pre">Element</span></code> is <code class="docutils literal"><span class="pre">PosetElement</span></code>.  It can also define <code class="docutils literal"><span class="pre">_dual_class</span></code> which
is the class of dual posets of this
class. E.g. <code class="docutils literal"><span class="pre">FiniteMeetSemilattice._dual_class</span></code> is
<code class="docutils literal"><span class="pre">FiniteJoinSemilattice</span></code>.</p>
</div>
<p>TESTS:</p>
<p>Equality is derived from <a class="reference external" href="../../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Sage Reference Manual: Basic Structures v7.3)"><code class="xref py py-class docutils literal"><span class="pre">UniqueRepresentation</span></code></a>. We check that this
gives consistent results:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">==</span> <span class="n">P</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[],[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">==</span> <span class="n">P</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p2</span> <span class="o">==</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p1</span> <span class="o">!=</span> <span class="n">p2</span>
<span class="go">(False, True)</span>
<span class="gp">sage: </span><span class="p">[[</span><span class="n">p1</span><span class="o">.</span><span class="n">__eq__</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span> <span class="k">for</span> <span class="n">p1</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
<span class="go">[[True, False], [False, True]]</span>
<span class="gp">sage: </span><span class="p">[[</span><span class="n">p2</span><span class="o">.</span><span class="n">__eq__</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="k">for</span> <span class="n">p1</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
<span class="go">[[True, False], [False, True]]</span>
<span class="gp">sage: </span><span class="p">[[</span><span class="n">p2</span> <span class="o">==</span> <span class="n">p1</span> <span class="k">for</span> <span class="n">p1</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="go">[[True, False, False, False, False],</span>
<span class="go"> [False, True, False, False, False],</span>
<span class="go"> [False, False, True, False, False],</span>
<span class="go"> [False, False, False, True, False],</span>
<span class="go"> [False, False, False, False, True]]</span>

<span class="gp">sage: </span><span class="p">[[</span><span class="n">p1</span><span class="o">.</span><span class="n">__ne__</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span> <span class="k">for</span> <span class="n">p1</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
<span class="go">[[False, True], [True, False]]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[],[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">!=</span> <span class="n">Q</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">!=</span> <span class="n">P</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">!=</span> <span class="n">Q</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="p">[[</span><span class="n">p1</span><span class="o">.</span><span class="n">__ne__</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span> <span class="k">for</span> <span class="n">p1</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
<span class="go">[[False, True], [True, False]]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">==</span> <span class="n">P</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">==</span> <span class="n">P</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="sage.combinat.posets.posets.FinitePoset.Element">
<code class="descname">Element</code><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal"><span class="pre">PosetElement</span></code></p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.antichains">
<code class="descname">antichains</code><span class="sig-paren">(</span><em>element_constructor=&lt;type 'list'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.antichains" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the antichains of the poset.</p>
<p>An <em>antichain</em> of a poset is a set of elements of the
poset that are pairwise incomparable.</p>
<p>INPUT:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">element_constructor</span></code> &#8211; a function taking an iterable as
argument (default: <code class="docutils literal"><span class="pre">list</span></code>)</li>
</ul>
</div></blockquote>
<p>OUTPUT:</p>
<p>The enumerated set (of type
<a class="reference internal" href="../subsets_pairwise.html#sage.combinat.subsets_pairwise.PairwiseCompatibleSubsets" title="sage.combinat.subsets_pairwise.PairwiseCompatibleSubsets"><code class="xref py py-class docutils literal"><span class="pre">PairwiseCompatibleSubsets</span></code></a>)
of all antichains of the poset, each of which is given as an
<code class="docutils literal"><span class="pre">element_constructor.</span></code></p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">antichains</span><span class="p">();</span> <span class="n">A</span>
<span class="go">Set of antichains of Finite lattice containing 5 elements</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[[], [0], [1], [1, 2], [1, 3], [2], [3], [4]]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">8</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">[1, 2]</span>
</pre></div>
</div>
<p>To get the antichains as, say, sets, one may use the
<code class="docutils literal"><span class="pre">element_constructor</span></code> option:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">Posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">antichains</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">set</span><span class="p">))</span>
<span class="go">[set(), {0}, {1}, {2}]</span>
</pre></div>
</div>
<p>To get the antichains of a given size one can currently use:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">elements_of_depth_iterator</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[[1, 2], [1, 3]]</span>
</pre></div>
</div>
<p>Eventually the following syntax will be accepted:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">subset</span><span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># todo: not implemented</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Internally, this uses
<a class="reference internal" href="../subsets_pairwise.html#sage.combinat.subsets_pairwise.PairwiseCompatibleSubsets" title="sage.combinat.subsets_pairwise.PairwiseCompatibleSubsets"><code class="xref py py-class docutils literal"><span class="pre">sage.combinat.subsets_pairwise.PairwiseCompatibleSubsets</span></code></a>
and <code class="xref py py-class docutils literal"><span class="pre">SearchForest</span></code>. At this point, iterating
through this set is about twice slower than using
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains_iterator" title="sage.combinat.posets.posets.FinitePoset.antichains_iterator"><code class="xref py py-meth docutils literal"><span class="pre">antichains_iterator()</span></code></a> (tested on
<code class="docutils literal"><span class="pre">posets.AntichainPoset(15)</span></code>). The algorithm is the same
(depth first search through the tree), but
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains_iterator" title="sage.combinat.posets.posets.FinitePoset.antichains_iterator"><code class="xref py py-meth docutils literal"><span class="pre">antichains_iterator()</span></code></a> manually inlines things which
apparently avoids some infrastructure overhead.</p>
<p class="last">On the other hand, this returns a full featured enumerated
set, with containment testing, etc.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_antichains" title="sage.combinat.posets.posets.FinitePoset.maximal_antichains"><code class="xref py py-meth docutils literal"><span class="pre">maximal_antichains()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.chains" title="sage.combinat.posets.posets.FinitePoset.chains"><code class="xref py py-meth docutils literal"><span class="pre">chains()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.antichains_iterator">
<code class="descname">antichains_iterator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.antichains_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over the antichains of the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">antichains_iterator</span><span class="p">();</span> <span class="n">it</span>
<span class="go">&lt;generator object antichains_iterator at ...&gt;</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">([], [4])</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains" title="sage.combinat.posets.posets.FinitePoset.antichains"><code class="xref py py-meth docutils literal"><span class="pre">antichains()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.bottom">
<code class="descname">bottom</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.bottom" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unique minimal element of the poset, if it exists.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span><span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">bottom</span><span class="p">()</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">bottom</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_bottom" title="sage.combinat.posets.posets.FinitePoset.has_bottom"><code class="xref py py-meth docutils literal"><span class="pre">has_bottom()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.top" title="sage.combinat.posets.posets.FinitePoset.top"><code class="xref py py-meth docutils literal"><span class="pre">top()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.canonical_label">
<code class="descname">canonical_label</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.canonical_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unique poset on the labels <span class="math">\(\{0, \ldots, n-1\}\)</span> (where <span class="math">\(n\)</span>
is the number of elements in the poset) that is isomorphic to this
poset and invariant in the isomorphism class.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li>Canonical labeling of directed graphs:
<a class="reference external" href="../../../../graphs/sage/graphs/generic_graph.html#sage.graphs.generic_graph.GenericGraph.canonical_label" title="(in Sage Reference Manual: Graph Theory v7.3)"><code class="xref py py-meth docutils literal"><span class="pre">canonical_label()</span></code></a></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [2, 4], [2, 6], [3, 6], [4, 12], [6, 12]]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">list</span><span class="p">()</span> <span class="c1"># random</span>
<span class="go">[0, 1, 2, 3, 4, 5]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>As a facade:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [2, 4], [2, 6], [3, 6], [4, 12], [6, 12]]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
<span class="go">[0, 1, 2, 3, 4, 5]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Canonical labeling of (semi)lattice returns (semi)lattice:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span><span class="o">=</span><span class="n">DiGraph</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">=</span><span class="n">Poset</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ML</span><span class="o">=</span><span class="n">MeetSemilattice</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">()</span>
<span class="go">Finite poset containing 3 elements</span>
<span class="gp">sage: </span><span class="n">ML</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">()</span>
<span class="go">Finite meet-semilattice containing 3 elements</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">digraphs</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">linear_extension</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()</span> <span class="c1"># random</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span> <span class="c1"># random</span>
<span class="go">[[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9]]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">digraphs</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()</span> <span class="c1"># random</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.cardinality">
<code class="descname">cardinality</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.cardinality" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of elements in the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[]])</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.chain_polynomial">
<code class="descname">chain_polynomial</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.chain_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chain polynomial of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>The coefficient of <span class="math">\(q^k\)</span> is the number of chains of length <span class="math">\(k\)</span>
in <code class="docutils literal"><span class="pre">self</span></code>. The length of a chain is the number of elements.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This is not what has been called the chain polynomial
in <a class="reference internal" href="#st1986" id="id1">[St1986]</a>. The latter is identical with the order
polynomial (<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_polynomial" title="sage.combinat.posets.posets.FinitePoset.order_polynomial"><code class="xref py py-meth docutils literal"><span class="pre">order_polynomial()</span></code></a>).</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">chain_polynomial</span><span class="p">();</span> <span class="n">t</span>
<span class="go">q^3 + 3*q^2 + 3*q + 1</span>
<span class="gp">sage: </span><span class="n">t</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">chains</span><span class="p">()))</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">chain_polynomial</span><span class="p">()</span>
<span class="go">6*q^4 + 18*q^3 + 19*q^2 + 8*q + 1</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">chain_polynomial</span><span class="p">()</span>
<span class="go">5*q + 1</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">chain_polynomial</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">chain_polynomial</span><span class="p">())</span>
<span class="go">Univariate Polynomial Ring in q over Integer Ring</span>

<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[]})</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">chain_polynomial</span><span class="p">()</span>
<span class="go">q + 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.chain_polytope">
<code class="descname">chain_polytope</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.chain_polytope" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chain polytope of the poset <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>The chain polytope of a finite poset <span class="math">\(P\)</span> is defined as the subset
of <span class="math">\(\RR^P\)</span> consisting of all maps <span class="math">\(x : P \to \RR\)</span> satisfying</p>
<div class="math">
\[x(p) \geq 0 \mbox{ for all } p \in P,\]</div>
<p>and</p>
<div class="math">
\[x(p_1) + x(p_2) + \ldots + x(p_k) \leq 1
\mbox{ for all chains } p_1 &lt; p_2 &lt; \ldots &lt; p_k
\mbox{ in } P.\]</div>
<p>This polytope was defined and studied in <a class="reference internal" href="#st1986" id="id2">[St1986]</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">chain_polytope</span><span class="p">();</span><span class="n">Q</span>
<span class="go">A 3-dimensional polyhedron in QQ^3 defined as the convex hull of 8 vertices</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">chain_polytope</span><span class="p">();</span><span class="n">Q</span>
<span class="go">A 5-dimensional polyhedron in QQ^5 defined as the convex hull of 8 vertices</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.chains">
<code class="descname">chains</code><span class="sig-paren">(</span><em>element_constructor=&lt;type 'list'&gt;</em>, <em>exclude=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.chains" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chains of the poset.</p>
<p>A <em>chain</em> of a poset is a set of elements of the poset
that are pairwise comparable.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">element_constructor</span></code> &#8211; a function taking an iterable as
argument (default: <code class="docutils literal"><span class="pre">list</span></code>)</li>
<li><code class="docutils literal"><span class="pre">exclude</span></code> &#8211; elements of the poset to be excluded
(default: <code class="docutils literal"><span class="pre">None</span></code>)</li>
</ul>
<p>OUTPUT:</p>
<p>The enumerated set (of type
<a class="reference internal" href="../subsets_pairwise.html#sage.combinat.subsets_pairwise.PairwiseCompatibleSubsets" title="sage.combinat.subsets_pairwise.PairwiseCompatibleSubsets"><code class="xref py py-class docutils literal"><span class="pre">PairwiseCompatibleSubsets</span></code></a>)
of all chains of the poset, each of which is given as an
<code class="docutils literal"><span class="pre">element_constructor</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">chains</span><span class="p">();</span> <span class="n">C</span>
<span class="go">Set of chains of Finite lattice containing 5 elements</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">[[], [0], [0, 1], [0, 1, 4], [0, 2], [0, 2, 3], [0, 2, 3, 4], [0, 2, 4], [0, 3], [0, 3, 4], [0, 4], [1], [1, 4], [2], [2, 3], [2, 3, 4], [2, 4], [3], [3, 4], [4]]</span>
</pre></div>
</div>
<p>Exclusion of elements, tuple (instead of list) as constructor:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">chains</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">[(), (1,), (1, 2), (1, 2, 4), (1, 4), (1, 5), (2,), (2, 4), (4,), (5,)]</span>
</pre></div>
</div>
<p>To get the chains of a given size one can currently use:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">elements_of_depth_iterator</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[[0, 1], [0, 2], [0, 3], [0, 4], [1, 4], [2, 3], [2, 4], [3, 4]]</span>
</pre></div>
</div>
<p>Eventually the following syntax will be accepted:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">subset</span><span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># todo: not implemented</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_chains" title="sage.combinat.posets.posets.FinitePoset.maximal_chains"><code class="xref py py-meth docutils literal"><span class="pre">maximal_chains()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains" title="sage.combinat.posets.posets.FinitePoset.antichains"><code class="xref py py-meth docutils literal"><span class="pre">antichains()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.characteristic_polynomial">
<code class="descname">characteristic_polynomial</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.characteristic_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the characteristic polynomial of the poset.</p>
<p>The poset is expected to be graded and have a bottom
element.</p>
<p>If <span class="math">\(P\)</span> is a graded poset with rank <span class="math">\(n\)</span> and a unique minimal
element <span class="math">\(\hat{0}\)</span>, then the characteristic polynomial of
<span class="math">\(P\)</span> is defined to be</p>
<div class="math">
\[\sum_{x \in P} \mu(\hat{0}, x) q^{n-\rho(x)} \in \ZZ[q],\]</div>
<p>where <span class="math">\(\rho\)</span> is the rank function, and <span class="math">\(\mu\)</span> is the Möbius
function of <span class="math">\(P\)</span>.</p>
<p>See section 3.10 of <a class="reference internal" href="#enumcomb1" id="id3">[EnumComb1]</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">characteristic_polynomial</span><span class="p">()</span>
<span class="go">q^2 - 3*q + 2</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span><span class="mi">4</span><span class="p">:[</span><span class="mi">6</span><span class="p">],</span><span class="mi">5</span><span class="p">:[</span><span class="mi">6</span><span class="p">],</span><span class="mi">6</span><span class="p">:[</span><span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">characteristic_polynomial</span><span class="p">()</span>
<span class="go">q^4 - 2*q^3 + q</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">characteristic_polynomial</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.closed_interval">
<code class="descname">closed_interval</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.closed_interval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of elements <span class="math">\(z\)</span> such that <span class="math">\(x \le z \le y\)</span> in the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">closed_interval</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="go">[2, 4, 10, 20, 50, 100]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.open_interval" title="sage.combinat.posets.posets.FinitePoset.open_interval"><code class="xref py py-meth docutils literal"><span class="pre">open_interval()</span></code></a></p>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">closed_interval</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[3]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">closed_interval</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">closed_interval</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.comparability_graph">
<code class="descname">comparability_graph</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.comparability_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the comparability graph of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Comparability_graph">Wikipedia article Comparability_graph</a></p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.incomparability_graph" title="sage.combinat.posets.posets.FinitePoset.incomparability_graph"><code class="xref py py-meth docutils literal"><span class="pre">incomparability_graph()</span></code></a>, <a class="reference external" href="../../../../graphs/sage/graphs/comparability.html#module-sage.graphs.comparability" title="(in Sage Reference Manual: Graph Theory v7.3)"><code class="xref py py-mod docutils literal"><span class="pre">sage.graphs.comparability</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">comparability_graph</span><span class="p">()</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">comparability_graph</span><span class="p">();</span> <span class="n">g</span>
<span class="go">Comparability graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">7</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.compare_elements">
<code class="descname">compare_elements</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.compare_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in the poset.</p>
<ul class="simple">
<li>If <span class="math">\(x &lt; y\)</span>, return <code class="docutils literal"><span class="pre">-1</span></code>.</li>
<li>If <span class="math">\(x = y\)</span>, return <code class="docutils literal"><span class="pre">0</span></code>.</li>
<li>If <span class="math">\(x &gt; y\)</span>, return <code class="docutils literal"><span class="pre">1</span></code>.</li>
<li>If <span class="math">\(x\)</span> and <span class="math">\(y\)</span> are not comparable, return <code class="docutils literal"><span class="pre">None</span></code>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">compare_elements</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">compare_elements</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">compare_elements</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">compare_elements</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.completion_by_cuts">
<code class="descname">completion_by_cuts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.completion_by_cuts" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the completion by cuts of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>This is a lattice, also called the Dedekind-MacNeille completion.</p>
<p>See the <a class="reference external" href="https://en.wikipedia.org/wiki/Dedekind-MacNeille completion">Wikipedia article Dedekind-MacNeille completion</a>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>a finite lattice</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">completion_by_cuts</span><span class="p">()</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">completion_by_cuts</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">SymmetricGroupBruhatOrderPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">completion_by_cuts</span><span class="p">();</span> <span class="n">Q</span>
<span class="go">Finite lattice containing 7 elements</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.cuts" title="sage.combinat.posets.posets.FinitePoset.cuts"><code class="xref py py-meth docutils literal"><span class="pre">cuts()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.connected_components">
<code class="descname">connected_components</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.connected_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the connected components of the poset as subposets.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">CC</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">connected_components</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">CC</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">P</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">6</span><span class="p">:[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)</span>
<span class="go">[Finite poset containing 3 elements,</span>
<span class="go"> Finite poset containing 5 elements]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">connected_components</span><span class="p">()</span> <span class="c1"># Test empty poset</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.cover_relations">
<code class="descname">cover_relations</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.cover_relations" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of pairs <code class="docutils literal"><span class="pre">[x,</span> <span class="pre">y]</span></code> of elements of the poset such
that <code class="docutils literal"><span class="pre">y</span></code> covers <code class="docutils literal"><span class="pre">x</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [0, 2], [2, 3], [3, 4]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.cover_relations_graph">
<code class="descname">cover_relations_graph</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.cover_relations_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the graph of cover relations.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">cover_relations_graph</span><span class="p">();</span> <span class="n">G</span>
<span class="go">Graph on 4 vertices</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">cover_relations_graph</span><span class="p">();</span> <span class="n">H</span>
<span class="go">Graph on 0 vertices</span>
</pre></div>
</div>
<p>Check that it is hashable and coincides with the Hasse diagram as a
graph:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">hash</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">==</span> <span class="n">Graph</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">hasse_diagram</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.cover_relations_iterator">
<code class="descname">cover_relations_iterator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.cover_relations_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over the cover relations of the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations_iterator</span><span class="p">())</span>
<span class="go">&lt;type &#39;generator&#39;&gt;</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">z</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">cover_relations_iterator</span><span class="p">()]</span>
<span class="go">[[1, 2], [0, 2], [2, 3], [3, 4]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.covers">
<code class="descname">covers</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.covers" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if <code class="docutils literal"><span class="pre">y</span></code> covers <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
<p>Element <span class="math">\(y\)</span> covers <span class="math">\(x\)</span> if <span class="math">\(x &lt; y\)</span> and there is no <span class="math">\(z\)</span> such that
<span class="math">\(x &lt; z &lt; y\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.coxeter_polynomial">
<code class="descname">coxeter_polynomial</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.coxeter_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Coxeter polynomial of the poset.</p>
<p>OUTPUT:</p>
<p>a polynomial in one variable</p>
<p>The output is the characteristic polynomial of the Coxeter
transformation. This polynomial only depends on the derived
category of modules on the poset.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.coxeter_transformation" title="sage.combinat.posets.posets.FinitePoset.coxeter_transformation"><code class="xref py py-meth docutils literal"><span class="pre">coxeter_transformation()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">coxeter_polynomial</span><span class="p">()</span>
<span class="go">x^5 + x^4 + x + 1</span>

<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">SymmetricGroupWeakOrderPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">coxeter_polynomial</span><span class="p">()</span>
<span class="go">x^6 + x^5 - x^3 + x + 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.coxeter_transformation">
<code class="descname">coxeter_transformation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.coxeter_transformation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Coxeter transformation of the poset.</p>
<p>OUTPUT:</p>
<p>a square matrix with integer coefficients</p>
<p>The output is the matrix of the Auslander-Reiten translation
acting on the Grothendieck group of the derived category of
modules on the poset, in the basis of simple
modules. This matrix is usually called the Coxeter
transformation.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.coxeter_polynomial" title="sage.combinat.posets.posets.FinitePoset.coxeter_polynomial"><code class="xref py py-meth docutils literal"><span class="pre">coxeter_polynomial()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">coxeter_transformation</span><span class="p">()</span>
<span class="go">[ 0  0  0  0 -1]</span>
<span class="go">[ 0  0  0  1 -1]</span>
<span class="go">[ 0  1  0  0 -1]</span>
<span class="go">[-1  1  1  0 -1]</span>
<span class="go">[-1  1  0  1 -1]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">coxeter_transformation</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">**</span> <span class="mi">8</span> <span class="o">==</span> <span class="mi">1</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.cuts">
<code class="descname">cuts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.cuts" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of cuts of the poset <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>A cut is a subset <span class="math">\(A\)</span> of <code class="docutils literal"><span class="pre">self</span></code> such that the set of lower
bounds of the set of upper bounds of <span class="math">\(A\)</span> is exactly <span class="math">\(A\)</span>.</p>
<p>The cuts are computed here using the maximal independent sets in the
auxiliary graph defined as <span class="math">\(P \times [0,1]\)</span> with an edge
from <span class="math">\((x, 0)\)</span> to <span class="math">\((y, 1)\)</span> if
and only if <span class="math">\(x \not\geq_P y\)</span>. See the end of section 4 in <a class="reference internal" href="#jrj94" id="id4">[JRJ94]</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Pc</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">cuts</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">Pc</span><span class="p">]</span>
<span class="go">[[0], [0, 1, 2], [], [1], [2]]</span>
<span class="gp">sage: </span><span class="n">Pc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">frozenset({0})</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.completion_by_cuts" title="sage.combinat.posets.posets.FinitePoset.completion_by_cuts"><code class="xref py py-meth docutils literal"><span class="pre">completion_by_cuts()</span></code></a></p>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="jrj94" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[JRJ94]</a></td><td>Jourdan, Guy-Vincent; Rampon, Jean-Xavier; Jard, Claude
(1994), &#8220;Computing on-line the lattice of maximal antichains
of posets&#8221;, Order 11 (3) p. 197-210, <a class="reference external" href="https://dx.doi.org/10.1007/BF02115811">doi:10.1007/BF02115811</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.dilworth_decomposition">
<code class="descname">dilworth_decomposition</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.dilworth_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a partition of the points into the minimal number of chains.</p>
<p>According to Dilworth&#8217;s theorem, the points of a poset can be
partitioned into <span class="math">\(\alpha\)</span> chains, where <span class="math">\(\alpha\)</span> is the cardinality of
its largest antichain. This method returns such a partition.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Dilworth's_theorem">Wikipedia article Dilworth&#8217;s_theorem</a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.width" title="sage.combinat.posets.posets.FinitePoset.width"><code class="xref py py-meth docutils literal"><span class="pre">width()</span></code></a> &#8211; return the width of the poset.</p>
</div>
<p>ALGORITHM:</p>
<p>We build a bipartite graph in which a vertex <span class="math">\(v\)</span> of the poset is
represented by two vertices <span class="math">\(v^-,v^+\)</span>. For any two <span class="math">\(u,v\)</span> such that
<span class="math">\(u&lt;v\)</span> in the poset we add an edge <span class="math">\(v^+u^-\)</span>.</p>
<p>A matching in this graph is equivalent to a partition of the poset
into chains: indeed, a chain <span class="math">\(v_1...v_k\)</span> gives rise to the matching
<span class="math">\(v_1^+v_2^-,v_2^+v_3^-,...\)</span>, and from a matching one can build the
union of chains.</p>
<p>According to Dilworth&#8217;s theorem, the number of chains is equal to
<span class="math">\(\alpha\)</span> (the posets&#8217; width).</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">width</span><span class="p">()</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">dilworth_decomposition</span><span class="p">()</span>  <span class="c1"># random</span>
<span class="go">[[7, 6, 4], [11, 3], [12, 8, 0], [13, 9, 1], [14, 10, 2], [15, 5]]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">IntegerCompositions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">dilworth_decomposition</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
<span class="go">....:    for i in range(len(chain)-1):</span>
<span class="go">....:        assert p.is_greater_than(chain[i],chain[i+1])</span>
<span class="gp">sage: </span><span class="nb">set</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.dimension">
<code class="descname">dimension</code><span class="sig-paren">(</span><em>certificate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dimension of the Poset.</p>
<p>The (Dushnik-Miller) dimension of a poset is the minimal
number of total orders so that the poset can be defined as
&#8220;intersection&#8221; of all of them. Mathematically said, dimension
of a poset defined on a set <span class="math">\(X\)</span> of points is the smallest
integer <span class="math">\(n\)</span> such that there exists <span class="math">\(P_1,...,P_n\)</span> linear
extensions of <span class="math">\(P\)</span> satisfying the following property:</p>
<div class="math">
\[u\leq_P v\ \text{if and only if }\ \forall i, u\leq_{P_i} v\]</div>
<p>For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Order_dimension">Wikipedia article Order_dimension</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">certificate</span></code> (boolean; default:<code class="docutils literal"><span class="pre">False</span></code>) &#8211; whether to return an
integer (the dimension) or a certificate, i.e. a smallest set of
linear extensions.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The speed of this function greatly improves when more efficient
MILP solvers (e.g. Gurobi, CPLEX) are installed. See
<a class="reference external" href="../../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v7.3)"><code class="xref py py-class docutils literal"><span class="pre">MixedIntegerLinearProgram</span></code></a> for more information.</p>
</div>
<p>ALGORITHM:</p>
<p>As explained <a class="reference internal" href="#ft00" id="id5">[FT00]</a>, the dimension of a poset is equal to the (weak)
chromatic number of a hypergraph. More precisely:</p>
<blockquote>
<div><p>Let <span class="math">\(inc(P)\)</span> be the set of (ordered) pairs of incomparable elements
of <span class="math">\(P\)</span>, i.e. all <span class="math">\(uv\)</span> and <span class="math">\(vu\)</span> such that <span class="math">\(u\not \leq_P v\)</span> and <span class="math">\(v\not
\leq_P u\)</span>. Any linear extension of <span class="math">\(P\)</span> is a total order on <span class="math">\(X\)</span> that
can be seen as the union of relations from <span class="math">\(P\)</span> along with some
relations from <span class="math">\(inc(P)\)</span>. Thus, the dimension of <span class="math">\(P\)</span> is the smallest
number of linear extensions of <span class="math">\(P\)</span> which <em>cover</em> all points of
<span class="math">\(inc(P)\)</span>.</p>
<p>Consequently, <span class="math">\(dim(P)\)</span> is equal to the chromatic number of the
hypergraph <span class="math">\(\mathcal H_{inc}\)</span>, where <span class="math">\(\mathcal H_{inc}\)</span> is the
hypergraph defined on <span class="math">\(inc(P)\)</span> whose sets are all <span class="math">\(S\subseteq
inc(P)\)</span> such that <span class="math">\(P\cup S\)</span> is not acyclic.</p>
</div></blockquote>
<p>We solve this problem through a <a class="reference external" href="../../../../numerical/sage/numerical/mip.html#module-sage.numerical.mip" title="(in Sage Reference Manual: Numerical Optimization v7.3)"><code class="xref py py-mod docutils literal"><span class="pre">Mixed</span> <span class="pre">Integer</span> <span class="pre">Linear</span> <span class="pre">Program</span></code></a>.</p>
<p>EXAMPLES:</p>
<p>We create a poset, compute a set of linear extensions and check
that we get back the poset from them:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="p">[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">dimension</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="c1"># random -- architecture-dependent</span>
<span class="go">[[0, 2, 4, 5, 1, 3, 6], [2, 5, 0, 1, 3, 4, 6], [0, 1, 2, 3, 5, 6, 4]]</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">(</span> <span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">all</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">l</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">L</span><span class="p">))</span> <span class="p">)</span> <span class="o">==</span> <span class="n">P</span>
<span class="go">True</span>
</pre></div>
</div>
<p>According to Schnyder&#8217;s theorem, the poset (of height 2) of a graph has
dimension <span class="math">\(\leq 3\)</span> if and only if the graph is planar:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">({(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">):[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()}))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">3</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">({(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">):[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()}))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="c1"># not tested - around 4s with CPLEX</span>
<span class="go">4</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Empty Poset:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">dimension</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="ft00" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[FT00]</a></td><td>Stefan Felsner, William T. Trotter,
Dimension, Graph and Hypergraph Coloring,
Order,
2000, Volume 17, Issue 2, pp 167-177,
<a class="reference external" href="http://link.springer.com/article/10.1023%2FA%3A1006429830221">http://link.springer.com/article/10.1023%2FA%3A1006429830221</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.disjoint_union">
<code class="descname">disjoint_union</code><span class="sig-paren">(</span><em>other</em>, <em>labels='pairs'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.disjoint_union" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a poset isomorphic to disjoint union (also called direct
sum) of the poset with <code class="docutils literal"><span class="pre">other</span></code>.</p>
<p>The disjoint union of <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> is a poset that contains
every element and relation from both <span class="math">\(P\)</span> and <span class="math">\(Q\)</span>, and where
every element of <span class="math">\(P\)</span> is incomparable to every element of <span class="math">\(Q\)</span>.</p>
<p>Mathematically, it is only defined when <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> have no
common element; here we force that by giving them different
names in the resulting poset.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">other</span></code>, a poset.</li>
<li><code class="docutils literal"><span class="pre">labels</span></code> - (defaults to &#8216;pairs&#8217;) If set to &#8216;pairs&#8217;, each
element <code class="docutils literal"><span class="pre">v</span></code> in this poset will be named <code class="docutils literal"><span class="pre">(0,v)</span></code> and each
element <code class="docutils literal"><span class="pre">u</span></code> in <code class="docutils literal"><span class="pre">other</span></code> will be named <code class="docutils literal"><span class="pre">(1,u)</span></code> in the
result. If set to &#8216;integers&#8217;, the elements of the result
will be relabeled with consecutive integers.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]])</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">([</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="p">[[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">]])</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">P2</span><span class="p">);</span> <span class="n">P</span>
<span class="go">Finite poset containing 4 elements</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span>
<span class="go">[[(0, &#39;a&#39;), (0, &#39;b&#39;)], [(1, &#39;c&#39;), (1, &#39;d&#39;)]]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">P2</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="s1">&#39;integers&#39;</span><span class="p">);</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[2, 3], [0, 1]]</span>

<span class="gp">sage: </span><span class="n">N5</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">();</span> <span class="n">N5</span>
<span class="go">Finite lattice containing 5 elements</span>
<span class="gp">sage: </span><span class="n">N5</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">N5</span><span class="p">)</span>  <span class="c1"># Union of lattices is not a lattice</span>
<span class="go">Finite poset containing 10 elements</span>
</pre></div>
</div>
<p>We show how to get literally direct sum with elements untouched:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">P2</span><span class="p">)</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span>
<span class="go">[[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.dual">
<code class="descname">dual</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.dual" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dual poset of the given poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3]]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[3, 1], [2, 1]]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">LatticePoset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">]],</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[0, 1], [0, 2], [1, 3], [2, 3]]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[3, 2], [3, 1], [2, 0], [1, 0]]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Join of Category of finite lattice posets</span>
<span class="go">    and Category of finite enumerated sets</span>
<span class="go">    and Category of facade sets</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">__class__</span>
<span class="go">&lt;class &#39;sage.combinat.posets.lattices.FiniteLatticePoset_with_category&#39;&gt;</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">MeetSemilattice</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span><span class="o">.</span><span class="n">__class__</span>
<span class="go">&lt;class &#39;sage.combinat.posets.lattices.FiniteJoinSemilattice_with_category&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">JoinSemilattice</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span><span class="o">.</span><span class="n">__class__</span>
<span class="go">&lt;class &#39;sage.combinat.posets.lattices.FiniteMeetSemilattice_with_category&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.evacuation">
<code class="descname">evacuation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.evacuation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute evacuation on the linear extension associated
to the poset <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>an isomorphic poset, with the same default linear extension</li>
</ul>
<p>Evacuation is defined on a poset <code class="docutils literal"><span class="pre">self</span></code> of size <span class="math">\(n\)</span> by
applying the evacuation operator
<span class="math">\((\tau_1 \cdots \tau_{n-1}) (\tau_1 \cdots \tau_{n-2}) \cdots (\tau_1)\)</span>,
to the default linear extension <span class="math">\(\pi\)</span> of <code class="docutils literal"><span class="pre">self</span></code>
(see <a class="reference internal" href="linear_extensions.html#sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.evacuation" title="sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.evacuation"><code class="xref py py-meth docutils literal"><span class="pre">evacuation()</span></code></a>),
and relabeling <code class="docutils literal"><span class="pre">self</span></code> accordingly. For more details see <a class="reference internal" href="#stan2009" id="id6">[Stan2009]</a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extension" title="sage.combinat.posets.posets.FinitePoset.linear_extension"><code class="xref py py-meth docutils literal"><span class="pre">linear_extension()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.with_linear_extension" title="sage.combinat.posets.posets.FinitePoset.with_linear_extension"><code class="xref py py-meth docutils literal"><span class="pre">with_linear_extension()</span></code></a> and the <code class="docutils literal"><span class="pre">linear_extension</span></code> option of <a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><code class="xref py py-func docutils literal"><span class="pre">Poset()</span></code></a></li>
<li><a class="reference internal" href="linear_extensions.html#sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.evacuation" title="sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.evacuation"><code class="xref py py-meth docutils literal"><span class="pre">evacuation()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.promotion" title="sage.combinat.posets.posets.FinitePoset.promotion"><code class="xref py py-meth docutils literal"><span class="pre">promotion()</span></code></a></li>
</ul>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="stan2009" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Stan2009]</td><td><em>(<a class="fn-backref" href="#id6">1</a>, <a class="fn-backref" href="#id14">2</a>, <a class="fn-backref" href="#id20">3</a>)</em> Richard Stanley,
<em>Promotion and evacuation</em>,
Electron. J. Combin. 16 (2009), no. 2, Special volume in honor of
Anders Björner,
Research Paper 9, 24 pp.</td></tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]]),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">evacuation</span><span class="p">()</span>
<span class="go">Finite poset containing 2 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">evacuation</span><span class="p">()</span> <span class="o">==</span> <span class="n">P</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">evacuation</span><span class="p">();</span> <span class="n">Q</span>
<span class="go">Finite poset containing 7 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [2, 5], [3, 4], [3, 6], [4, 7], [6, 7]]</span>
</pre></div>
</div>
<p>Note that the results depend on the linear extension associated
to the poset:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 5, 6, 4, 7]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">evacuation</span><span class="p">();</span> <span class="n">Q</span>
<span class="go">Finite poset containing 7 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 5], [2, 3], [5, 6], [5, 4], [6, 7], [4, 7]]</span>
</pre></div>
</div>
<p>Here is an example of a poset where the elements are not labelled
by <span class="math">\(\{1,2,\ldots,n\}\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 3, 5, 15]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">evacuation</span><span class="p">();</span> <span class="n">Q</span>
<span class="go">Finite poset containing 4 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 3], [1, 5], [3, 15], [5, 15]]</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li>Anne Schilling (2012-02-18)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.f_polynomial">
<code class="descname">f_polynomial</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.f_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <span class="math">\(f\)</span>-polynomial of a bounded poset <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>This is the <span class="math">\(f\)</span>-polynomial of the order complex of the poset
minus its bounds.</p>
<p>The coefficient of <span class="math">\(q^i\)</span> is the number of chains of
<span class="math">\(i+1\)</span> elements containing both bounds of the poset.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="sage.combinat.posets.posets.FinitePoset.is_bounded"><code class="xref py py-meth docutils literal"><span class="pre">is_bounded()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.h_polynomial" title="sage.combinat.posets.posets.FinitePoset.h_polynomial"><code class="xref py py-meth docutils literal"><span class="pre">h_polynomial()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_complex" title="sage.combinat.posets.posets.FinitePoset.order_complex"><code class="xref py py-meth docutils literal"><span class="pre">order_complex()</span></code></a>,
<a class="reference external" href="../../../../homology/sage/homology/cell_complex.html#sage.homology.cell_complex.GenericCellComplex.f_vector" title="(in Sage Reference Manual: Cell complexes and their homology v7.3)"><code class="xref py py-meth docutils literal"><span class="pre">sage.homology.cell_complex.GenericCellComplex.f_vector()</span></code></a></p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This is slightly different from the <code class="docutils literal"><span class="pre">fPolynomial</span></code>
method in Macaulay2.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">f_polynomial</span><span class="p">()</span>
<span class="go">3*q^2 + q</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span><span class="mi">4</span><span class="p">:[</span><span class="mi">6</span><span class="p">],</span><span class="mi">5</span><span class="p">:[</span><span class="mi">7</span><span class="p">],</span><span class="mi">6</span><span class="p">:[</span><span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">f_polynomial</span><span class="p">()</span>
<span class="go">q^4 + 4*q^3 + 5*q^2 + q</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">2</span><span class="p">:</span> <span class="p">[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">f_polynomial</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.flag_f_polynomial">
<code class="descname">flag_f_polynomial</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.flag_f_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the flag <span class="math">\(f\)</span>-polynomial of a bounded and ranked poset
<code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>This is the sum, over all chains containing both bounds,
of a monomial encoding the ranks of the elements of the chain.</p>
<p>More precisely, if <span class="math">\(P\)</span> is a bounded ranked poset, then the
flag <span class="math">\(f\)</span>-polynomial of <span class="math">\(P\)</span> is defined as the polynomial</p>
<div class="math">
\[\begin{split}\sum_{\substack{p_0 &lt; p_1 &lt; \ldots &lt; p_k, \\
                p_0 = \min P, \ p_k = \max P}}
x_{\rho(p_1)} x_{\rho(p_2)} \cdots x_{\rho(p_k)}
\in \ZZ[x_1, x_2, \cdots, x_n]\end{split}\]</div>
<p>where <span class="math">\(\min P\)</span> and <span class="math">\(\max P\)</span> are (respectively) the minimum and
the maximum of <span class="math">\(P\)</span>, where <span class="math">\(\rho\)</span> is the rank function of <span class="math">\(P\)</span>
(normalized to satisfy <span class="math">\(\rho(\min P) = 0\)</span>), and where
<span class="math">\(n\)</span> is the rank of <span class="math">\(\max P\)</span>. (Note that the indeterminate
<span class="math">\(x_0\)</span> doesn&#8217;t actually appear in the polynomial.)</p>
<p>For technical reasons, the polynomial is returned in the
slightly larger ring <span class="math">\(\ZZ[x_0, x_1, x_2, \cdots, x_{n+1}]\)</span> by
this method.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/h-vector">Wikipedia article h-vector</a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="sage.combinat.posets.posets.FinitePoset.is_bounded"><code class="xref py py-meth docutils literal"><span class="pre">is_bounded()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.flag_h_polynomial" title="sage.combinat.posets.posets.FinitePoset.flag_h_polynomial"><code class="xref py py-meth docutils literal"><span class="pre">flag_h_polynomial()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">flag_f_polynomial</span><span class="p">()</span>
<span class="go">3*x1*x2 + x2</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span><span class="mi">4</span><span class="p">:[</span><span class="mi">6</span><span class="p">],</span><span class="mi">5</span><span class="p">:[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">fl</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">flag_f_polynomial</span><span class="p">();</span> <span class="n">fl</span>
<span class="go">2*x1*x2*x3 + 2*x1*x3 + 2*x2*x3 + x3</span>
<span class="gp">sage: </span><span class="n">q</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span><span class="s1">&#39;q&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fl</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="p">)</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">f_polynomial</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span><span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span><span class="mi">5</span><span class="p">:[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">flag_f_polynomial</span><span class="p">()</span>
<span class="go">3*x1*x2*x3 + 3*x1*x3 + x2*x3 + x3</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">flag_f_polynomial</span><span class="p">()</span>
<span class="go">x1</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">2</span><span class="p">:</span> <span class="p">[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">flag_f_polynomial</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.flag_h_polynomial">
<code class="descname">flag_h_polynomial</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.flag_h_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the flag <span class="math">\(h\)</span>-polynomial of a bounded and ranked poset
<code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>If <span class="math">\(P\)</span> is a bounded ranked poset whose maximal element has
rank <span class="math">\(n\)</span> (where the minimal element is set to have rank <span class="math">\(0\)</span>),
then the flag <span class="math">\(h\)</span>-polynomial of <span class="math">\(P\)</span> is defined as the
polynomial</p>
<div class="math">
\[\prod_{k=1}^n (1-x_k) \cdot f \left(\frac{x_1}{1-x_1},
\frac{x_2}{1-x_2}, \cdots, \frac{x_n}{1-x_n}\right)
\in \ZZ[x_1, x_2, \cdots, x_n],\]</div>
<p>where <span class="math">\(f\)</span> is the flag <span class="math">\(f\)</span>-polynomial of <span class="math">\(P\)</span> (see
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.flag_f_polynomial" title="sage.combinat.posets.posets.FinitePoset.flag_f_polynomial"><code class="xref py py-meth docutils literal"><span class="pre">flag_f_polynomial()</span></code></a>).</p>
<p>For technical reasons, the polynomial is returned in the
slightly larger ring <span class="math">\(\QQ[x_0, x_1, x_2, \cdots, x_{n+1}]\)</span> by
this method.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/h-vector">Wikipedia article h-vector</a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="sage.combinat.posets.posets.FinitePoset.is_bounded"><code class="xref py py-meth docutils literal"><span class="pre">is_bounded()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.flag_f_polynomial" title="sage.combinat.posets.posets.FinitePoset.flag_f_polynomial"><code class="xref py py-meth docutils literal"><span class="pre">flag_f_polynomial()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">flag_h_polynomial</span><span class="p">()</span>
<span class="go">2*x1*x2 + x2</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span><span class="mi">4</span><span class="p">:[</span><span class="mi">6</span><span class="p">],</span><span class="mi">5</span><span class="p">:[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">fl</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">flag_h_polynomial</span><span class="p">();</span> <span class="n">fl</span>
<span class="go">-x1*x2*x3 + x1*x3 + x2*x3 + x3</span>
<span class="gp">sage: </span><span class="n">q</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span><span class="s1">&#39;q&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fl</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="p">)</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">h_polynomial</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span><span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span><span class="mi">5</span><span class="p">:[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">flag_h_polynomial</span><span class="p">()</span>
<span class="go">2*x1*x3 + x3</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">flag_h_polynomial</span><span class="p">()</span>
<span class="go">x3</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">flag_h_polynomial</span><span class="p">()</span>
<span class="go">x1</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">2</span><span class="p">:</span> <span class="p">[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">flag_h_polynomial</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.frank_network">
<code class="descname">frank_network</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.frank_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes Frank&#8217;s network of the poset <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>This is defined in Section 8 of <a class="reference internal" href="#bf1999" id="id7">[BF1999]</a>.</p>
<p>OUTPUT:</p>
<p>A pair <span class="math">\((G, e)\)</span>, where <span class="math">\(G\)</span> is Frank&#8217;s network of <span class="math">\(P\)</span> encoded as a
<a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v7.3)"><code class="xref py py-class docutils literal"><span class="pre">DiGraph</span></code></a>, and <span class="math">\(e\)</span> is the cost function on its edges encoded
as a dictionary (indexed by these edges, which in turn are encoded
as tuples of 2 vertices).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Frank&#8217;s network of <span class="math">\(P\)</span> is a certain directed graph with <span class="math">\(2|P| + 2\)</span>
vertices, defined in Section 8 of <a class="reference internal" href="#bf1999" id="id8">[BF1999]</a>. Its set of vertices
consists of two vertices <span class="math">\((0, p)\)</span> and <span class="math">\((1, p)\)</span> for each element
<span class="math">\(p\)</span> of <span class="math">\(P\)</span>, as well as two vertices <span class="math">\((-1, 0)\)</span> and <span class="math">\((2, 0)\)</span>.
(These notations are not the ones used in <a class="reference internal" href="#bf1999" id="id9">[BF1999]</a>; see the table
below for their relation.) The edges are:</p>
<ul class="simple">
<li>for each <span class="math">\(p\)</span> in <span class="math">\(P\)</span>, an edge from <span class="math">\((-1, 0)\)</span> to <span class="math">\((0, p)\)</span>;</li>
<li>for each <span class="math">\(p\)</span> in <span class="math">\(P\)</span>, an edge from <span class="math">\((1, p)\)</span> to <span class="math">\((2, 0)\)</span>;</li>
<li>for each <span class="math">\(p\)</span> and <span class="math">\(q\)</span> in <span class="math">\(P\)</span> such that <span class="math">\(p \geq q\)</span>, an edge from
<span class="math">\((0, p)\)</span> to <span class="math">\((1, q)\)</span>.</li>
</ul>
<p>We make this digraph into a network in the sense of flow theory as
follows: The vertex <span class="math">\((-1, 0)\)</span> is considered as the source of this
network, and the vertex <span class="math">\((2, 0)\)</span> as the sink. The cost function is
defined to be <span class="math">\(1\)</span> on the edge from <span class="math">\((0, p)\)</span> to <span class="math">\((1, p)\)</span> for each
<span class="math">\(p \in P\)</span>, and to be <span class="math">\(0\)</span> on every other edge. The capacity is <span class="math">\(1\)</span>
on each edge. Here is how to translate this notations into that
used in <a class="reference internal" href="#bf1999" id="id10">[BF1999]</a>:</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="n">our</span> <span class="n">notations</span>                    <span class="p">[</span><span class="n">BF1999</span><span class="p">]</span>
   <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>                          <span class="n">s</span>
   <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>                          <span class="n">x_p</span>
   <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>                          <span class="n">y_p</span>
   <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>                           <span class="n">t</span>
    <span class="n">a</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>                           <span class="n">a</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="bf1999" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[BF1999]</td><td><em>(<a class="fn-backref" href="#id7">1</a>, <a class="fn-backref" href="#id8">2</a>, <a class="fn-backref" href="#id9">3</a>, <a class="fn-backref" href="#id10">4</a>, <a class="fn-backref" href="#id11">5</a>)</em> Thomas Britz, Sergey Fomin,
<em>Finite posets and Ferrers shapes</em>,
Advances in Mathematics 158, pp. 86-127 (2001),
<a class="reference external" href="http://arxiv.org/abs/math/9912126">Arxiv math/9912126</a> (the arXiv version has less errors).</td></tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ps</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">16</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="o">-</span><span class="mi">13</span><span class="p">],[[</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">],[</span><span class="mi">14</span><span class="p">,</span><span class="o">-</span><span class="mi">13</span><span class="p">],[</span><span class="mi">12</span><span class="p">,</span><span class="mi">16</span><span class="p">],[</span><span class="mi">16</span><span class="p">,</span><span class="o">-</span><span class="mi">13</span><span class="p">]]]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span><span class="o">.</span><span class="n">frank_network</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[((-1, 0), (0, -13), None), ((-1, 0), (0, 12), None), ((-1, 0), (0, 14), None), ((-1, 0), (0, 16), None), ((0, -13), (1, -13), None), ((0, -13), (1, 12), None), ((0, -13), (1, 14), None), ((0, -13), (1, 16), None), ((0, 12), (1, 12), None), ((0, 14), (1, 12), None), ((0, 14), (1, 14), None), ((0, 16), (1, 12), None), ((0, 16), (1, 16), None), ((1, -13), (2, 0), None), ((1, 12), (2, 0), None), ((1, 14), (2, 0), None), ((1, 16), (2, 0), None)]</span>
<span class="gp">sage: </span><span class="n">e</span>
<span class="go">{((-1, 0), (0, -13)): 0,</span>
<span class="go"> ((-1, 0), (0, 12)): 0,</span>
<span class="go"> ((-1, 0), (0, 14)): 0,</span>
<span class="go"> ((-1, 0), (0, 16)): 0,</span>
<span class="go"> ((0, -13), (1, -13)): 1,</span>
<span class="go"> ((0, -13), (1, 12)): 0,</span>
<span class="go"> ((0, -13), (1, 14)): 0,</span>
<span class="go"> ((0, -13), (1, 16)): 0,</span>
<span class="go"> ((0, 12), (1, 12)): 1,</span>
<span class="go"> ((0, 14), (1, 12)): 0,</span>
<span class="go"> ((0, 14), (1, 14)): 1,</span>
<span class="go"> ((0, 16), (1, 12)): 0,</span>
<span class="go"> ((0, 16), (1, 16)): 1,</span>
<span class="go"> ((1, -13), (2, 0)): 0,</span>
<span class="go"> ((1, 12), (2, 0)): 0,</span>
<span class="go"> ((1, 14), (2, 0)): 0,</span>
<span class="go"> ((1, 16), (2, 0)): 0}</span>
<span class="gp">sage: </span><span class="n">qs</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]]</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">(</span><span class="n">qs</span><span class="p">)</span><span class="o">.</span><span class="n">frank_network</span><span class="p">()</span>
<span class="go">(Digraph on 20 vertices,</span>
<span class="go"> {((-1, 0), (0, 1)): 0,</span>
<span class="go">  ((-1, 0), (0, 2)): 0,</span>
<span class="go">  ((-1, 0), (0, 3)): 0,</span>
<span class="go">  ((-1, 0), (0, 4)): 0,</span>
<span class="go">  ((-1, 0), (0, 5)): 0,</span>
<span class="go">  ((-1, 0), (0, 6)): 0,</span>
<span class="go">  ((-1, 0), (0, 7)): 0,</span>
<span class="go">  ((-1, 0), (0, 8)): 0,</span>
<span class="go">  ((-1, 0), (0, 9)): 0,</span>
<span class="go">  ((0, 1), (1, 1)): 1,</span>
<span class="go">  ((0, 2), (1, 2)): 1,</span>
<span class="go">  ((0, 3), (1, 1)): 0,</span>
<span class="go">  ((0, 3), (1, 2)): 0,</span>
<span class="go">  ((0, 3), (1, 3)): 1,</span>
<span class="go">  ((0, 4), (1, 1)): 0,</span>
<span class="go">  ((0, 4), (1, 2)): 0,</span>
<span class="go">  ((0, 4), (1, 3)): 0,</span>
<span class="go">  ((0, 4), (1, 4)): 1,</span>
<span class="go">  ((0, 5), (1, 5)): 1,</span>
<span class="go">  ((0, 6), (1, 6)): 1,</span>
<span class="go">  ((0, 7), (1, 5)): 0,</span>
<span class="go">  ((0, 7), (1, 7)): 1,</span>
<span class="go">  ((0, 8), (1, 8)): 1,</span>
<span class="go">  ((0, 9), (1, 1)): 0,</span>
<span class="go">  ((0, 9), (1, 9)): 1,</span>
<span class="go">  ((1, 1), (2, 0)): 0,</span>
<span class="go">  ((1, 2), (2, 0)): 0,</span>
<span class="go">  ((1, 3), (2, 0)): 0,</span>
<span class="go">  ((1, 4), (2, 0)): 0,</span>
<span class="go">  ((1, 5), (2, 0)): 0,</span>
<span class="go">  ((1, 6), (2, 0)): 0,</span>
<span class="go">  ((1, 7), (2, 0)): 0,</span>
<span class="go">  ((1, 8), (2, 0)): 0,</span>
<span class="go">  ((1, 9), (2, 0)): 0})</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li>Darij Grinberg (2013-05-09)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.ge">
<code class="descname">ge</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.ge" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if <span class="math">\(x\)</span> is greater than or equal to <span class="math">\(y\)</span> in the poset,
and <code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_greater_than" title="sage.combinat.posets.posets.FinitePoset.is_greater_than"><code class="xref py py-meth docutils literal"><span class="pre">is_greater_than()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_lequal" title="sage.combinat.posets.posets.FinitePoset.is_lequal"><code class="xref py py-meth docutils literal"><span class="pre">is_lequal()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.graphviz_string">
<code class="descname">graphviz_string</code><span class="sig-paren">(</span><em>graph_string='graph'</em>, <em>edge_string='--'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.graphviz_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a representation in the DOT language, ready to render in
graphviz.</p>
<p>REFERENCES:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.graphviz.org/doc/info/lang.html">http://www.graphviz.org/doc/info/lang.html</a></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;d&#39;</span><span class="p">],</span><span class="s1">&#39;c&#39;</span><span class="p">:[</span><span class="s1">&#39;d&#39;</span><span class="p">],</span><span class="s1">&#39;d&#39;</span><span class="p">:[</span><span class="s1">&#39;f&#39;</span><span class="p">],</span><span class="s1">&#39;e&#39;</span><span class="p">:[</span><span class="s1">&#39;f&#39;</span><span class="p">],</span><span class="s1">&#39;f&#39;</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">graphviz_string</span><span class="p">())</span>
<span class="go">graph {</span>
<span class="go">&quot;f&quot;;&quot;d&quot;;&quot;b&quot;;&quot;a&quot;;&quot;c&quot;;&quot;e&quot;;</span>
<span class="go">&quot;f&quot;--&quot;e&quot;;&quot;d&quot;--&quot;c&quot;;&quot;b&quot;--&quot;a&quot;;&quot;d&quot;--&quot;b&quot;;&quot;f&quot;--&quot;d&quot;;</span>
<span class="go">}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.greene_shape">
<code class="descname">greene_shape</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.greene_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Greene-Kleitman partition of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>The Greene-Kleitman partition of a finite poset <span class="math">\(P\)</span> is the partition
<span class="math">\((c_1 - c_0, c_2 - c_1, c_3 - c_2, \ldots)\)</span>, where <span class="math">\(c_k\)</span> is the
maximum cardinality of a union of <span class="math">\(k\)</span> chains of <span class="math">\(P\)</span>. Equivalently,
this is the conjugate of the partition <span class="math">\((a_1 - a_0, a_2 - a_1, a_3 -
a_2, \ldots)\)</span>, where <span class="math">\(a_k\)</span> is the maximum cardinality of a union of
<span class="math">\(k\)</span> antichains of <span class="math">\(P\)</span>.</p>
<p>See many sources, e. g., <a class="reference internal" href="#bf1999" id="id11">[BF1999]</a>, for proofs of this equivalence.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">greene_shape</span><span class="p">()</span>
<span class="go">[2, 1]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">greene_shape</span><span class="p">()</span>
<span class="go">[3, 1]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">19</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">22</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">greene_shape</span><span class="p">()</span>
<span class="go">[3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[],[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">greene_shape</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li>Darij Grinberg (2013-05-09)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.gt">
<code class="descname">gt</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.gt" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if <span class="math">\(x\)</span> is greater than but not equal to <span class="math">\(y\)</span> in the
poset, and <code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>For non-facade posets also <code class="docutils literal"><span class="pre">&gt;</span></code> works:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]},</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">P</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_gequal" title="sage.combinat.posets.posets.FinitePoset.is_gequal"><code class="xref py py-meth docutils literal"><span class="pre">is_gequal()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_less_than" title="sage.combinat.posets.posets.FinitePoset.is_less_than"><code class="xref py py-meth docutils literal"><span class="pre">is_less_than()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.h_polynomial">
<code class="descname">h_polynomial</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.h_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <span class="math">\(h\)</span>-polynomial of a bounded poset <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>This is the <span class="math">\(h\)</span>-polynomial of the order complex of the poset
minus its bounds.</p>
<p>This is related to the <span class="math">\(f\)</span>-polynomial by a simple change
of variables:</p>
<div class="math">
\[h(q) = (1-q)^{\deg f} f \left( \frac{q}{1-q} \right),\]</div>
<p>where <span class="math">\(f\)</span> and <span class="math">\(h\)</span> denote the <span class="math">\(f\)</span>-polynomial and the
<span class="math">\(h\)</span>-polynomial, respectively.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/h-vector">Wikipedia article h-vector</a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="sage.combinat.posets.posets.FinitePoset.is_bounded"><code class="xref py py-meth docutils literal"><span class="pre">is_bounded()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.f_polynomial" title="sage.combinat.posets.posets.FinitePoset.f_polynomial"><code class="xref py py-meth docutils literal"><span class="pre">f_polynomial()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_complex" title="sage.combinat.posets.posets.FinitePoset.order_complex"><code class="xref py py-meth docutils literal"><span class="pre">order_complex()</span></code></a>,
<a class="reference external" href="../../../../homology/sage/homology/simplicial_complex.html#sage.homology.simplicial_complex.SimplicialComplex.h_vector" title="(in Sage Reference Manual: Cell complexes and their homology v7.3)"><code class="xref py py-meth docutils literal"><span class="pre">sage.homology.simplicial_complex.SimplicialComplex.h_vector()</span></code></a></p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This is slightly different from the <code class="docutils literal"><span class="pre">hPolynomial</span></code>
method in Macaulay2.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">order_ideals_lattice</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">h_polynomial</span><span class="p">()</span>
<span class="go">q^3 + 4*q^2 + q</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">h_polynomial</span><span class="p">()</span>
<span class="go">2*q^2 + q</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">h_polynomial</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.has_bottom">
<code class="descname">has_bottom</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.has_bottom" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset has a unique minimal element, and
<code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">has_bottom</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">has_bottom</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.bottom" title="sage.combinat.posets.posets.FinitePoset.bottom"><code class="xref py py-meth docutils literal"><span class="pre">bottom()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_top" title="sage.combinat.posets.posets.FinitePoset.has_top"><code class="xref py py-meth docutils literal"><span class="pre">has_top()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="sage.combinat.posets.posets.FinitePoset.is_bounded"><code class="xref py py-meth docutils literal"><span class="pre">is_bounded()</span></code></a></p>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">has_top</span><span class="p">()</span>  <span class="c1"># Test empty poset</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.has_isomorphic_subposet">
<code class="descname">has_isomorphic_subposet</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.has_isomorphic_subposet" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset contains a subposet isomorphic to
<code class="docutils literal"><span class="pre">other</span></code>.</p>
<p>By subposet we mean that there exist a set <code class="docutils literal"><span class="pre">X</span></code> of elements such
that <code class="docutils literal"><span class="pre">self.subposet(X)</span></code> is isomorphic to <code class="docutils literal"><span class="pre">other</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">other</span></code> &#8211; a finite poset</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">N5</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>

<span class="gp">sage: </span><span class="n">N5</span><span class="o">.</span><span class="n">has_isomorphic_subposet</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">N5</span><span class="o">.</span><span class="n">has_isomorphic_subposet</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="nb">len</span><span class="p">([</span><span class="n">P</span> <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">if</span> <span class="n">P</span><span class="o">.</span><span class="n">has_isomorphic_subposet</span><span class="p">(</span><span class="n">D</span><span class="p">)])</span>
<span class="go">11</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.has_top">
<code class="descname">has_top</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.has_top" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset has a unique maximal element, and
<code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[],</span> <span class="mi">5</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">has_top</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">has_top</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.top" title="sage.combinat.posets.posets.FinitePoset.top"><code class="xref py py-meth docutils literal"><span class="pre">top()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_bottom" title="sage.combinat.posets.posets.FinitePoset.has_bottom"><code class="xref py py-meth docutils literal"><span class="pre">has_bottom()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="sage.combinat.posets.posets.FinitePoset.is_bounded"><code class="xref py py-meth docutils literal"><span class="pre">is_bounded()</span></code></a></p>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">has_top</span><span class="p">()</span>  <span class="c1"># Test empty poset</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.hasse_diagram">
<code class="descname">hasse_diagram</code><span class="sig-paren">(</span><em>wrapped=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.hasse_diagram" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Hasse diagram of <code class="docutils literal"><span class="pre">self</span></code> as a Sage <a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v7.3)"><code class="xref py py-class docutils literal"><span class="pre">DiGraph</span></code></a>. If
<code class="docutils literal"><span class="pre">dot2tex</span></code> is installed, then this sets the Hasse diagram&#8217;s latex
options to use the <code class="docutils literal"><span class="pre">dot2tex</span></code> formatting.</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">Should the vertices of the diagram have the poset as parent?</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">5</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">0</span><span class="p">]},</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">hasse_diagram</span><span class="p">()</span>
<span class="go">Digraph on 6 vertices</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;d&#39;</span><span class="p">],</span><span class="s1">&#39;c&#39;</span><span class="p">:[</span><span class="s1">&#39;d&#39;</span><span class="p">],</span><span class="s1">&#39;d&#39;</span><span class="p">:[</span><span class="s1">&#39;f&#39;</span><span class="p">],</span><span class="s1">&#39;e&#39;</span><span class="p">:[</span><span class="s1">&#39;f&#39;</span><span class="p">],</span><span class="s1">&#39;f&#39;</span><span class="p">:[]},</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">hasse_diagram</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[e, f], [c, d], [a, b], [b, d], [d, f]]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(a, b, None), (c, d, None), (b, d, None), (e, f, None), (d, f, None)]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">hasse_diagram</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[1, 3, 5, 15]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(1, 3, None), (1, 5, None), (3, 15, None), (5, 15, None)]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">set_latex_options</span><span class="p">(</span><span class="n">format</span><span class="o">=</span><span class="s2">&quot;dot2tex&quot;</span><span class="p">)</span>   <span class="c1"># optional - dot2tex</span>
<span class="gp">sage: </span><span class="n">view</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">tight_page</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># optional - dot2tex, not tested (opens external window)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.height">
<code class="descname">height</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.height" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the height (number of elements in a longest chain) of the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">height</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">height</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">height</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.incidence_algebra">
<code class="descname">incidence_algebra</code><span class="sig-paren">(</span><em>R</em>, <em>prefix='I'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.incidence_algebra" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the incidence algebra of <code class="docutils literal"><span class="pre">self</span></code> over <code class="docutils literal"><span class="pre">R</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">incidence_algebra</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">Incidence algebra of Finite lattice containing 16 elements</span>
<span class="go"> over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.incomparability_graph">
<code class="descname">incomparability_graph</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.incomparability_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the incomparability graph of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>This is the complement of the comparability graph.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.comparability_graph" title="sage.combinat.posets.posets.FinitePoset.comparability_graph"><code class="xref py py-meth docutils literal"><span class="pre">comparability_graph()</span></code></a>, <a class="reference external" href="../../../../graphs/sage/graphs/comparability.html#module-sage.graphs.comparability" title="(in Sage Reference Manual: Graph Theory v7.3)"><code class="xref py py-mod docutils literal"><span class="pre">sage.graphs.comparability</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">incomparability_graph</span><span class="p">()</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">0</span>

<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">incomparability_graph</span><span class="p">();</span> <span class="n">g</span>
<span class="go">Incomparability graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.interval">
<code class="descname">interval</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.interval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the elements <span class="math">\(z\)</span> such that <span class="math">\(x \le z \le y\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">x</span></code> &#8211; any element of the poset</li>
<li><code class="docutils literal"><span class="pre">y</span></code> &#8211; any element of the poset</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">uc</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[]]</span>
<span class="gp">sage: </span><span class="n">dag</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uc</span><span class="p">)),</span><span class="n">uc</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">dag</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">P</span><span class="p">,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">interval</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">dg</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="s2">&quot;a&quot;</span><span class="p">:[</span><span class="s2">&quot;b&quot;</span><span class="p">,</span><span class="s2">&quot;c&quot;</span><span class="p">],</span> <span class="s2">&quot;b&quot;</span><span class="p">:[</span><span class="s2">&quot;d&quot;</span><span class="p">],</span> <span class="s2">&quot;c&quot;</span><span class="p">:[</span><span class="s2">&quot;d&quot;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">dg</span><span class="p">,</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">interval</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
<span class="go">[a, b, c, d]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.intervals">
<code class="descname">intervals</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations" title="sage.combinat.posets.posets.FinitePoset.relations"><code class="xref py py-func docutils literal"><span class="pre">relations()</span></code></a> instead.
See <a class="reference external" href="https://trac.sagemath.org/19360">trac ticket #19360</a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.intervals_iterator">
<code class="descname">intervals_iterator</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.intervals_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_iterator" title="sage.combinat.posets.posets.FinitePoset.relations_iterator"><code class="xref py py-func docutils literal"><span class="pre">relations_iterator()</span></code></a> instead.
See <a class="reference external" href="https://trac.sagemath.org/19360">trac ticket #19360</a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.intervals_number">
<code class="descname">intervals_number</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.intervals_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of relations in the poset.</p>
<p>A relation is a pair of elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> such that <span class="math">\(x\leq y\)</span>
in the poset.</p>
<p>Relations are also often called intervals. The number of
intervals is the dimension of the incidence algebra.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_iterator" title="sage.combinat.posets.posets.FinitePoset.relations_iterator"><code class="xref py py-meth docutils literal"><span class="pre">relations_iterator()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations" title="sage.combinat.posets.posets.FinitePoset.relations"><code class="xref py py-meth docutils literal"><span class="pre">relations()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">relations_number</span><span class="p">()</span>
<span class="go">13</span>

<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.tamari_lattices</span> <span class="kn">import</span> <span class="n">TamariLattice</span>
<span class="gp">sage: </span><span class="n">TamariLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">relations_number</span><span class="p">()</span>
<span class="go">68</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">relations_number</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_EL_labelling">
<code class="descname">is_EL_labelling</code><span class="sig-paren">(</span><em>f</em>, <em>return_raising_chains=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_EL_labelling" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if <code class="docutils literal"><span class="pre">f</span></code> is an EL labelling of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>A labelling <span class="math">\(f\)</span> of the edges of the Hasse diagram of a poset
is called an EL labelling (edge lexicographic labelling) if
for any two elements <span class="math">\(u\)</span> and <span class="math">\(v\)</span> with <span class="math">\(u \leq v\)</span>,</p>
<blockquote>
<div><ul class="simple">
<li>there is a unique <span class="math">\(f\)</span>-raising chain from <span class="math">\(u\)</span> to <span class="math">\(v\)</span> in
the Hasse diagram, and this chain is lexicographically
first among all chains from <span class="math">\(u\)</span> to <span class="math">\(v\)</span>.</li>
</ul>
</div></blockquote>
<p>For more details, see <a class="reference internal" href="#bj1980" id="id12">[Bj1980]</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">f</span></code> &#8211; a function taking two elements <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code> in
<code class="docutils literal"><span class="pre">self</span></code> such that <code class="docutils literal"><span class="pre">b</span></code> covers <code class="docutils literal"><span class="pre">a</span></code> and returning elements
in a totally ordered set.</li>
<li><code class="docutils literal"><span class="pre">return_raising_chains</span></code> (optional; default:<code class="docutils literal"><span class="pre">False</span></code>) if
<code class="docutils literal"><span class="pre">True</span></code>, returns the set of all raising chains in <code class="docutils literal"><span class="pre">self</span></code>,
if possible.</li>
</ul>
<p>EXAMPLES:</p>
<p>Let us consider a Boolean poset:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)],[[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)],[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)],[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)],[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)]]],</span><span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">label</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_EL_labelling</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_EL_labelling</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">return_raising_chains</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">{((0, 0), (0, 1)): [1],</span>
<span class="go"> ((0, 0), (1, 0)): [0],</span>
<span class="go"> ((0, 0), (1, 1)): [0, 1],</span>
<span class="go"> ((0, 1), (1, 1)): [0],</span>
<span class="go"> ((1, 0), (1, 1)): [1]}</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="bj1980" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[Bj1980]</a></td><td>Anders Björner,
<em>Shellable and Cohen-Macaulay partially ordered sets</em>,
Trans. Amer. Math. Soc. 260 (1980), 159-183,
<a class="reference external" href="https://dx.doi.org/10.1090/S0002-9947-1980-0570784-2">doi:10.1090/S0002-9947-1980-0570784-2</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_bounded">
<code class="descname">is_bounded</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset is bounded, and <code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
<p>A poset is bounded if it contains both a unique maximal element
and a unique minimal element.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[],</span> <span class="mi">5</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_bounded</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_bounded</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_bottom" title="sage.combinat.posets.posets.FinitePoset.has_bottom"><code class="xref py py-meth docutils literal"><span class="pre">has_bottom()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_top" title="sage.combinat.posets.posets.FinitePoset.has_top"><code class="xref py py-meth docutils literal"><span class="pre">has_top()</span></code></a></p>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">is_bounded</span><span class="p">()</span>  <span class="c1"># Test empty poset</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[]})</span><span class="o">.</span><span class="n">is_bounded</span><span class="p">()</span>  <span class="c1"># Here top == bottom</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">(</span> <span class="nb">len</span><span class="p">([</span><span class="n">P</span> <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">if</span> <span class="n">P</span><span class="o">.</span><span class="n">is_bounded</span><span class="p">()])</span> <span class="o">==</span>
<span class="go">....: Posets(3).cardinality() )</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_chain">
<code class="descname">is_chain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset is totally ordered (&#8220;chain&#8221;), and
<code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">is_chain</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">II</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">II</span><span class="o">.</span><span class="n">is_chain</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">is_chain</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="nb">len</span><span class="p">([</span><span class="n">P</span> <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">P</span><span class="o">.</span><span class="n">is_chain</span><span class="p">()])</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="go">[1, 1, 1, 1, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_chain_of_poset">
<code class="descname">is_chain_of_poset</code><span class="sig-paren">(</span><em>elms</em>, <em>ordered=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_chain_of_poset" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if <span class="math">\(elms\)</span> is a chain of the poset, and <code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">elms</span></code> &#8211; a list or other iterable containing some elements
of the poset</li>
<li><code class="docutils literal"><span class="pre">ordered</span></code> &#8211; a Boolean. If <code class="docutils literal"><span class="pre">True</span></code>, then return <code class="docutils literal"><span class="pre">True</span></code>
only if elements in <span class="math">\(elms\)</span> are strictly increasing in the
poset; this makes no sense if <span class="math">\(elms\)</span> is a set. If <code class="docutils literal"><span class="pre">False</span></code>
(the default), then elements can be repeated and be in any
order.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">([</span><span class="mi">12</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">({</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">12</span><span class="p">})</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">([</span><span class="mi">12</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">ordered</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">ordered</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">ordered</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">([])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">14</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">({</span><span class="mi">10</span><span class="p">})</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">([</span><span class="mi">32</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">element (=32) not in poset</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_connected">
<code class="descname">is_connected</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_connected" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset is connected, and <code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
<p>A poset is connected if it&#8217;s Hasse diagram is connected.</p>
<p>If a poset is not connected, then it can be divided to parts
<span class="math">\(S_1\)</span> and <span class="math">\(S_2\)</span> so that every element of <span class="math">\(S_1\)</span> is incomparable to
every element of <span class="math">\(S_2\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">6</span><span class="p">:[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.connected_components" title="sage.combinat.posets.posets.FinitePoset.connected_components"><code class="xref py py-meth docutils literal"><span class="pre">connected_components()</span></code></a></p>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>  <span class="c1"># Test empty poset</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_eulerian">
<code class="descname">is_eulerian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_eulerian" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset is Eulerian, and <code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
<p>The poset is expected to be graded and bounded.</p>
<p>A poset is Eulerian if every non-trivial interval has the same
number of elements of even rank as of odd rank.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Eulerian_poset">Wikipedia article Eulerian_poset</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="go">....: 4:[7, 8], 5:[7, 8], 6:[7, 8], 7:[9], 8:[9]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span>
<span class="go">....: 4:[7], 5:[7], 6:[7]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Canonical examples of Eulerian posets are the face lattices of
convex polytopes:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">polytopes</span><span class="o">.</span><span class="n">cube</span><span class="p">()</span><span class="o">.</span><span class="n">face_lattice</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">the poset is not bounded</span>
<span class="gp">sage: </span><span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">the poset is not graded</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[]})</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_gequal">
<code class="descname">is_gequal</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_gequal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if <span class="math">\(x\)</span> is greater than or equal to <span class="math">\(y\)</span> in the poset,
and <code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_greater_than" title="sage.combinat.posets.posets.FinitePoset.is_greater_than"><code class="xref py py-meth docutils literal"><span class="pre">is_greater_than()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_lequal" title="sage.combinat.posets.posets.FinitePoset.is_lequal"><code class="xref py py-meth docutils literal"><span class="pre">is_lequal()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_graded">
<code class="descname">is_graded</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_graded" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset is graded, and <code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
<p>A poset is graded if all its maximal chains have the same length.</p>
<p>There are various competing definitions for graded
posets (see <a class="reference external" href="https://en.wikipedia.org/wiki/Graded_poset">Wikipedia article Graded_poset</a>). This definition is from
section 3.1 of Richard Stanley&#8217;s <em>Enumerative Combinatorics,
Vol. 1</em> <a class="reference internal" href="#enumcomb1" id="id13">[EnumComb1]</a>.</p>
<p>Every graded poset is ranked. The converse is true
for bounded posets, including lattices.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>  <span class="c1"># Not even ranked</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_graded</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>  <span class="c1"># Ranked, but not graded</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_graded</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_graded</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_graded</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_ranked" title="sage.combinat.posets.posets.FinitePoset.is_ranked"><code class="xref py py-meth docutils literal"><span class="pre">is_ranked()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.level_sets" title="sage.combinat.posets.posets.FinitePoset.level_sets"><code class="xref py py-meth docutils literal"><span class="pre">level_sets()</span></code></a></p>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">is_graded</span><span class="p">()</span>  <span class="c1"># Test empty poset</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_greater_than">
<code class="descname">is_greater_than</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_greater_than" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if <span class="math">\(x\)</span> is greater than but not equal to <span class="math">\(y\)</span> in the
poset, and <code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>For non-facade posets also <code class="docutils literal"><span class="pre">&gt;</span></code> works:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]},</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">P</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_gequal" title="sage.combinat.posets.posets.FinitePoset.is_gequal"><code class="xref py py-meth docutils literal"><span class="pre">is_gequal()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_less_than" title="sage.combinat.posets.posets.FinitePoset.is_less_than"><code class="xref py py-meth docutils literal"><span class="pre">is_less_than()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_incomparable_chain_free">
<code class="descname">is_incomparable_chain_free</code><span class="sig-paren">(</span><em>m</em>, <em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_incomparable_chain_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset is <span class="math">\((m+n)\)</span>-free, and <code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
<p>A poset is <span class="math">\((m+n)\)</span>-free if there is no incomparable chains of
lengths <span class="math">\(m\)</span> and <span class="math">\(n\)</span>. Three cases have special name:</p>
<ul class="simple">
<li>&#8216;&#8217;interval order&#8217;&#8217; is <span class="math">\((2+2)\)</span>-free</li>
<li>&#8216;&#8217;semiorder&#8217;&#8217; (or &#8216;&#8217;unit interval order&#8217;&#8216;) is <span class="math">\((1+3)\)</span>-free and
<span class="math">\((2+2)\)</span>-free</li>
<li>&#8216;&#8217;weak order&#8217;&#8217; is <span class="math">\((1+2)\)</span>-free.</li>
</ul>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">m</span></code>, <code class="docutils literal"><span class="pre">n</span></code> - positive integers</li>
</ul>
<p>It is also possible to give a list of integer pairs as argument.
See below for an example.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B3</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B3</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B3</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">IP6</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">IntegerPartitions</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">IP6</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">IP6</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A list of pairs as an argument:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B3</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We show how to get an incomparable chain pair:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">chains_1_2</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">incomps</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">isomorphic_subposets</span><span class="p">(</span><span class="n">chains_1_2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">incomps</span><span class="o">.</span><span class="n">list</span><span class="p">()),</span> <span class="n">incomps</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">([1, 2, 3], [[2, 3]])</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Test empty poset</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="p">[</span><span class="nb">len</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))])</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span> <span class="c1"># long time</span>
<span class="go">[1, 1, 2, 5, 14, 42]</span>

<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">2 and pi must be integers.</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">2 and -1 must be positive integers.</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">))))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">(3, 1) is not a tuple of tuples.</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">[3, 1] and [2, 2] must be integers.</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">[3, 1] and 2 must be integers.</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">&#39;([3, 1], [2, 2, 2])&#39; is not a tuple of length-2 tuples.</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li>Eric Rowland (2013-05-28)</li>
</ul>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="enumcomb1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[EnumComb1]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id13">2</a>, <a class="fn-backref" href="#id16">3</a>, <a class="fn-backref" href="#id19">4</a>, <a class="fn-backref" href="#id22">5</a>)</em> Richard P. Stanley,
<em>Enumerative Combinatorics, volume 1</em>,
Second Edition,
Cambridge University Press (2011).
<a class="reference external" href="http://math.mit.edu/~rstan/ec/ec1/">http://math.mit.edu/~rstan/ec/ec1/</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_induced_subposet">
<code class="descname">is_induced_subposet</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_induced_subposet" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset is an induced subposet of <code class="docutils literal"><span class="pre">other</span></code>, and
<code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
<p>A poset <span class="math">\(P\)</span> is an induced subposet of <span class="math">\(Q\)</span> if every element
of <span class="math">\(P\)</span> is an element of <span class="math">\(Q\)</span>, and <span class="math">\(x \le_P y\)</span> iff <span class="math">\(x \le_Q y\)</span>.
Note that &#8220;induced&#8221; here has somewhat different meaning compared
to that of graphs.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">other</span></code>, a poset.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method does not check whether the poset is a
<em>isomorphic</em> (i.e., up to relabeling) subposet of <code class="docutils literal"><span class="pre">other</span></code>,
but only if <code class="docutils literal"><span class="pre">other</span></code> directly contains the poset as an
induced subposet. For isomorphic subposets see
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_isomorphic_subposet" title="sage.combinat.posets.posets.FinitePoset.has_isomorphic_subposet"><code class="xref py py-meth docutils literal"><span class="pre">has_isomorphic_subposet()</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_induced_subposet</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_induced_subposet</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">2</span><span class="p">:[</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">is_induced_subposet</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">is_induced_subposet</span><span class="p">(</span><span class="n">Poset</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_induced_subposet</span><span class="p">(</span><span class="n">Poset</span><span class="p">())</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Bad input:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">is_induced_subposet</span><span class="p">(</span><span class="s1">&#39;junk&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;str&#39; object has no attribute &#39;subposet&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_isomorphic">
<code class="descname">is_isomorphic</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_isomorphic" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if both posets are isomorphic.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span> <span class="n">Q</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_join_semilattice">
<code class="descname">is_join_semilattice</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_join_semilattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset has a join operation, and <code class="docutils literal"><span class="pre">False</span></code>
otherwise.</p>
<p>A join is the least upper bound for given elements, if it exists.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="p">[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_join_semilattice</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Elements 3 and 4 have no common upper bound at all; elements
1 and 2 have upper bounds 3 and 4, but no least upper bound:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_join_semilattice</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_meet_semilattice" title="sage.combinat.posets.posets.FinitePoset.is_meet_semilattice"><code class="xref py py-meth docutils literal"><span class="pre">is_meet_semilattice()</span></code></a>, <a class="reference external" href="../../../../categories/sage/categories/finite_posets.html#sage.categories.finite_posets.FinitePosets.ParentMethods.is_lattice" title="(in Sage Reference Manual: Category Framework v7.3)"><code class="xref py py-meth docutils literal"><span class="pre">is_lattice()</span></code></a></p>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">is_join_semilattice</span><span class="p">()</span>  <span class="c1"># Test empty lattice</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">([</span><span class="n">P</span> <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="k">if</span> <span class="n">P</span><span class="o">.</span><span class="n">is_join_semilattice</span><span class="p">()])</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_lequal">
<code class="descname">is_lequal</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_lequal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if <span class="math">\(x\)</span> is less than or equal to <span class="math">\(y\)</span> in the poset, and
<code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_less_than" title="sage.combinat.posets.posets.FinitePoset.is_less_than"><code class="xref py py-meth docutils literal"><span class="pre">is_less_than()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_gequal" title="sage.combinat.posets.posets.FinitePoset.is_gequal"><code class="xref py py-meth docutils literal"><span class="pre">is_gequal()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_less_than">
<code class="descname">is_less_than</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_less_than" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if <span class="math">\(x\)</span> is less than but not equal to <span class="math">\(y\)</span> in the poset,
and <code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>For non-facade posets also <code class="docutils literal"><span class="pre">&lt;</span></code> works:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]},</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_lequal" title="sage.combinat.posets.posets.FinitePoset.is_lequal"><code class="xref py py-meth docutils literal"><span class="pre">is_lequal()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_greater_than" title="sage.combinat.posets.posets.FinitePoset.is_greater_than"><code class="xref py py-meth docutils literal"><span class="pre">is_greater_than()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_linear_extension">
<code class="descname">is_linear_extension</code><span class="sig-paren">(</span><em>l</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_linear_extension" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether <code class="docutils literal"><span class="pre">l</span></code> is a linear extension of <code class="docutils literal"><span class="pre">self</span></code></p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">l</span></code> &#8211; a list (or iterable) containing all of the elements of <code class="docutils literal"><span class="pre">self</span></code> exactly once</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extension" title="sage.combinat.posets.posets.FinitePoset.linear_extension"><code class="xref py py-meth docutils literal"><span class="pre">linear_extension()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extensions" title="sage.combinat.posets.posets.FinitePoset.linear_extensions"><code class="xref py py-meth docutils literal"><span class="pre">linear_extensions()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Permutations</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">))</span> <span class="k">if</span> <span class="n">P</span><span class="o">.</span><span class="n">is_linear_extension</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
<span class="go">[[1, 2, 3, 4, 6, 12],</span>
<span class="go"> [1, 2, 3, 6, 4, 12],</span>
<span class="go"> [1, 2, 4, 3, 6, 12],</span>
<span class="go"> [1, 3, 2, 4, 6, 12],</span>
<span class="go"> [1, 3, 2, 6, 4, 12]]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">linear_extensions</span><span class="p">())</span>
<span class="go">[[1, 2, 3, 4, 6, 12],</span>
<span class="go"> [1, 2, 3, 6, 4, 12],</span>
<span class="go"> [1, 2, 4, 3, 6, 12],</span>
<span class="go"> [1, 3, 2, 4, 6, 12],</span>
<span class="go"> [1, 3, 2, 6, 4, 12]]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is used and systematically tested in
<code class="xref py py-class docutils literal"><span class="pre">LinearExtensionsOfPosets</span></code></p>
</div>
<p>TESTS:</p>
<p>Check that <a class="reference external" href="https://trac.sagemath.org/15313">trac ticket #15313</a> is fixed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">1337</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">666</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">1337</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_linear_extension</span><span class="p">([</span><span class="s1">&#39;David&#39;</span><span class="p">,</span> <span class="s1">&#39;McNeil&#39;</span><span class="p">,</span> <span class="s1">&#39;La&#39;</span><span class="p">,</span> <span class="s1">&#39;Lamentable&#39;</span><span class="p">,</span> <span class="s1">&#39;Aventure&#39;</span><span class="p">,</span> <span class="s1">&#39;de&#39;</span><span class="p">,</span> <span class="s1">&#39;Simon&#39;</span><span class="p">,</span> <span class="s1">&#39;Wiesenthal&#39;</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_meet_semilattice">
<code class="descname">is_meet_semilattice</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_meet_semilattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset has a meet operation, and
<code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
<p>A meet is the greatest lower bound for given elements, if it exists.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_meet_semilattice</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_meet_semilattice</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_join_semilattice" title="sage.combinat.posets.posets.FinitePoset.is_join_semilattice"><code class="xref py py-meth docutils literal"><span class="pre">is_join_semilattice()</span></code></a>, <a class="reference external" href="../../../../categories/sage/categories/finite_posets.html#sage.categories.finite_posets.FinitePosets.ParentMethods.is_lattice" title="(in Sage Reference Manual: Category Framework v7.3)"><code class="xref py py-meth docutils literal"><span class="pre">is_lattice()</span></code></a></p>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">is_meet_semilattice</span><span class="p">()</span>  <span class="c1"># Test empty lattice</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">([</span><span class="n">P</span> <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="k">if</span> <span class="n">P</span><span class="o">.</span><span class="n">is_meet_semilattice</span><span class="p">()])</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_parent_of">
<code class="descname">is_parent_of</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_parent_of" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if x is an element of the poset.</p>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.posets.posets</span> <span class="kn">import</span> <span class="n">FinitePoset</span>
<span class="gp">sage: </span><span class="n">P5</span> <span class="o">=</span> <span class="n">FinitePoset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">({(</span><span class="mi">5</span><span class="p">,):[(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span> \
<span class="go">        (4,1):[(3,1,1),(2,2,1)], \</span>
<span class="go">        (3,2):[(3,1,1),(2,2,1)], \</span>
<span class="go">        (3,1,1):[(2,1,1,1)], \</span>
<span class="go">        (2,2,1):[(2,1,1,1)], \</span>
<span class="go">        (2,1,1,1):[(1,1,1,1,1)], \</span>
<span class="go">        (1,1,1,1,1):[]}))</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">P5</span><span class="o">.</span><span class="n">list</span><span class="p">()[</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="ow">in</span> <span class="n">P5</span>
<span class="go">True</span>
</pre></div>
</div>
<p>For the sake of speed, an element with the right class and
parent is assumed to be in this parent. This can possibly be
counterfeited by feeding garbage to the constructor:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">P5</span><span class="o">.</span><span class="n">element_class</span><span class="p">(</span><span class="n">P5</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="ow">in</span> <span class="n">P5</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_rank_symmetric">
<code class="descname">is_rank_symmetric</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_rank_symmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset is rank symmetric, and <code class="docutils literal"><span class="pre">False</span></code>
otherwise.</p>
<p>The poset is expected to be graded and connected.</p>
<p>A poset of rank <span class="math">\(h\)</span> (maximal chains have <span class="math">\(h+1\)</span> elements) is rank
symmetric if the number of elements are equal in ranks <span class="math">\(i\)</span> and
<span class="math">\(h-i\)</span> for every <span class="math">\(i\)</span> in <span class="math">\(0, 1, \ldots, h\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_rank_symmetric</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_rank_symmetric</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">is_rank_symmetric</span><span class="p">()</span>  <span class="c1"># Test empty poset</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_ranked">
<code class="descname">is_ranked</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_ranked" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset is ranked, and <code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
<p>A poset is ranked if there is a function <span class="math">\(r\)</span> from  poset elements
to integers so that <span class="math">\(r(x)=r(y)+1\)</span> when <span class="math">\(x\)</span> covers <span class="math">\(y\)</span>.</p>
<p>Informally said a ranked poset can be &#8220;levelized&#8221;: every element is
on a &#8220;level&#8221;, and every cover relation goes only one level up.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span> <span class="p">))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_ranked</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],[],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_ranked</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.rank_function" title="sage.combinat.posets.posets.FinitePoset.rank_function"><code class="xref py py-meth docutils literal"><span class="pre">rank_function()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.rank" title="sage.combinat.posets.posets.FinitePoset.rank"><code class="xref py py-meth docutils literal"><span class="pre">rank()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_graded" title="sage.combinat.posets.posets.FinitePoset.is_graded"><code class="xref py py-meth docutils literal"><span class="pre">is_graded()</span></code></a></p>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">is_ranked</span><span class="p">()</span>  <span class="c1"># Test empty poset</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_series_parallel">
<code class="descname">is_series_parallel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_series_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset is series-parallel, and <code class="docutils literal"><span class="pre">False</span></code>
otherwise.</p>
<p>A poset is <em>series-parallel</em> if it can be built up from one-element
posets using the operations of disjoint union and ordinal
sum. This is also called <em>N-free</em> property: every poset that is not
series-parallel contains a subposet isomorphic to the 4-element
N-shaped poset where <span class="math">\(a &gt; c, d\)</span> and <span class="math">\(b &gt; d\)</span>.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Series-parallel partial order">Wikipedia article Series-parallel partial order</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">VA</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">VA</span><span class="o">.</span><span class="n">is_series_parallel</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">big_N</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">6</span><span class="p">:[</span><span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">big_N</span><span class="o">.</span><span class="n">is_series_parallel</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">is_series_parallel</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_slender">
<code class="descname">is_slender</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_slender" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if the poset is slender, and <code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
<p>A finite graded poset is called slender if every rank 2
interval contains three or four elements, as defined in
<a class="reference internal" href="#stan2009" id="id14">[Stan2009]</a>. (This notion of &#8220;slender&#8221; is unrelated to
the eponymous notion defined by Graetzer and Kelly in
&#8220;The Free <span class="math">\(\mathfrak{m}\)</span>-Lattice on the Poset <span class="math">\(H\)</span>&#8221;,
Order 1 (1984), 47&#8211;65.)</p>
<p>This function <em>does not</em> check if the poset is graded or not.
Instead it just returns <code class="docutils literal"><span class="pre">True</span></code> if the poset does not contain
5 distinct elements <span class="math">\(x\)</span>, <span class="math">\(y\)</span>, <span class="math">\(a\)</span>, <span class="math">\(b\)</span> and <span class="math">\(c\)</span> such that
<span class="math">\(x \lessdot a,b,c \lessdot y\)</span> where <span class="math">\(\lessdot\)</span> is the covering
relation.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_slender</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_slender</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">WeylGroup</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">bruhat_poset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_slender</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">WeylGroup</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">bruhat_poset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_slender</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">is_slender</span><span class="p">()</span>  <span class="c1"># Test empty poset</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets">
<code class="descname">isomorphic_subposets</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of subposets of <span class="math">\(self\)</span> isomorphic to <span class="math">\(other\)</span>.</p>
<p>By subposet we mean <code class="docutils literal"><span class="pre">self.subposet(X)</span></code> which is isomorphic to
<code class="docutils literal"><span class="pre">other</span></code> and where <code class="docutils literal"><span class="pre">X</span></code> is a subset of elements of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">other</span></code> &#8211; a finite poset</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C2</span><span class="o">=</span><span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">C3</span><span class="o">=</span><span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">C3</span><span class="o">.</span><span class="n">isomorphic_subposets</span><span class="p">(</span><span class="n">C2</span><span class="p">):</span>
<span class="go">....:     print(x.cover_relations())</span>
<span class="go">[[&#39;b&#39;, &#39;c&#39;]]</span>
<span class="go">[[&#39;a&#39;, &#39;c&#39;]]</span>
<span class="go">[[&#39;a&#39;, &#39;b&#39;]]</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">N5</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">N5</span><span class="o">.</span><span class="n">isomorphic_subposets</span><span class="p">(</span><span class="n">D</span><span class="p">))</span>
<span class="go">2</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If this function takes too much time, try using
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator" title="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator"><code class="xref py py-meth docutils literal"><span class="pre">isomorphic_subposets_iterator()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator">
<code class="descname">isomorphic_subposets_iterator</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over the subposets of <span class="math">\(self\)</span> isomorphic to
<span class="math">\(other\)</span>.</p>
<p>By subposet we mean <code class="docutils literal"><span class="pre">self.subposet(X)</span></code> which is isomorphic
to <code class="docutils literal"><span class="pre">other</span></code> and where <code class="docutils literal"><span class="pre">X</span></code> is a subset of elements of
<code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">other</span></code> &#8211; a finite poset</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">N5</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">N5</span><span class="o">.</span><span class="n">isomorphic_subposets_iterator</span><span class="p">(</span><span class="n">D</span><span class="p">):</span>
<span class="go">....:     print(P.cover_relations())</span>
<span class="go">[[0, 1], [0, 2], [1, 4], [2, 4]]</span>
<span class="go">[[0, 1], [0, 3], [1, 4], [3, 4]]</span>
<span class="go">[[0, 1], [0, 2], [1, 4], [2, 4]]</span>
<span class="go">[[0, 1], [0, 3], [1, 4], [3, 4]]</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function will return same subposet as many times as
there are automorphism on it. This is due to
<a class="reference external" href="../../../../graphs/sage/graphs/generic_graph.html#sage.graphs.generic_graph.GenericGraph.subgraph_search_iterator" title="(in Sage Reference Manual: Graph Theory v7.3)"><code class="xref py py-meth docutils literal"><span class="pre">subgraph_search_iterator()</span></code></a>
returning labelled subgraphs. On the other hand, this
function does not eat memory like
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets" title="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets"><code class="xref py py-meth docutils literal"><span class="pre">isomorphic_subposets()</span></code></a> does.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.join_matrix">
<code class="descname">join_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.join_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated as a function of posets, moved to lattices.</p>
<p>Convert a poset <span class="math">\(P\)</span> to join-semilattice and use it like
<code class="docutils literal"><span class="pre">JoinSemilattice(P).join_matrix()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.kazhdan_lusztig_polynomial">
<code class="descname">kazhdan_lusztig_polynomial</code><span class="sig-paren">(</span><em>x=None</em>, <em>y=None</em>, <em>q=None</em>, <em>canonical_labels=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.kazhdan_lusztig_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Kazhdan-Lusztig polynomial <span class="math">\(P_{x,y}(q)\)</span> of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>We follow the definition given in <a class="reference internal" href="#epw14" id="id15">[EPW14]</a>. Let <span class="math">\(G\)</span> denote a
graded poset with unique minimal and maximal elements and <span class="math">\(\chi_G\)</span>
denote the characteristic polynomial of <span class="math">\(G\)</span>. Let <span class="math">\(I_x\)</span> and <span class="math">\(F^x\)</span>
denote the principal order ideal and filter of <span class="math">\(x\)</span> respectively.
Define the <em>Kazhdan-Lusztig polynomial</em> of <span class="math">\(G\)</span> as the unique
polynomial <span class="math">\(P_G(q)\)</span> satisfying the following:</p>
<ol class="arabic">
<li><p class="first">If <span class="math">\(\operatorname{rank} G = 0\)</span>, then <span class="math">\(P_G(q) = 1\)</span>.</p>
</li>
<li><p class="first">If <span class="math">\(\operatorname{rank} G &gt; 0\)</span>, then <span class="math">\(\deg P_G(q) &lt;
\frac{1}{2} \operatorname{rank} G\)</span>.</p>
</li>
<li><p class="first">We have</p>
<div class="math">
\[q^{\operatorname{rank} G} P_G(q^{-1})
= \sum_{x \in G} \chi_{I_x}(q) P_{F^x}(q).\]</div>
</li>
</ol>
<p>We then extend this to <span class="math">\(P_{x,y}(q)\)</span> by considering the subposet
corresponding to the (closed) interval <span class="math">\([x, y]\)</span>. We also
define <span class="math">\(P_{\emptyset}(q) = 0\)</span> (so if <span class="math">\(x \not\leq y\)</span>,
then <span class="math">\(P_{x,y}(q) = 0\)</span>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">q</span></code> &#8211; (default: <span class="math">\(q \in \ZZ[q]\)</span>) the indeterminate <span class="math">\(q\)</span></li>
<li><code class="docutils literal"><span class="pre">x</span></code> &#8211; (default: the minimal element) the element <span class="math">\(x\)</span></li>
<li><code class="docutils literal"><span class="pre">y</span></code> &#8211; (default: the maximal element) the element <span class="math">\(y\)</span></li>
<li><code class="docutils literal"><span class="pre">canonical_labels</span></code> &#8211; (optional) for subposets, use the
canonical labeling (this can limit recursive calls for posets
with large amounts of symmetry, but producing the labeling
takes time); if not specified, this is <code class="docutils literal"><span class="pre">True</span></code> if <code class="docutils literal"><span class="pre">x</span></code>
and <code class="docutils literal"><span class="pre">y</span></code> are both not specified and <code class="docutils literal"><span class="pre">False</span></code> otherwise</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">kazhdan_lusztig_polynomial</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">SymmetricGroupWeakOrderPoset</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">kazhdan_lusztig_polynomial</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;2314&#39;</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="s1">&#39;3421&#39;</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">kazhdan_lusztig_polynomial</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">-q + 1</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">kazhdan_lusztig_polynomial</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">))</span>
<span class="go">-t + 1</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="epw14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[EPW14]</a></td><td>Ben Elias, Nicholas Proudfoot, and Max Wakefield.
<em>The Kazhdan-Lusztig polynomial of a matroid</em>. 2014.
<a class="reference external" href="http://arxiv.org/abs/1412.7408">Arxiv 1412.7408</a>.</td></tr>
</tbody>
</table>
<p>AUTHORS:</p>
<ul class="simple">
<li>Travis Scrimshaw (27-12-2014)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.le">
<code class="descname">le</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.le" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if <span class="math">\(x\)</span> is less than or equal to <span class="math">\(y\)</span> in the poset, and
<code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_less_than" title="sage.combinat.posets.posets.FinitePoset.is_less_than"><code class="xref py py-meth docutils literal"><span class="pre">is_less_than()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_gequal" title="sage.combinat.posets.posets.FinitePoset.is_gequal"><code class="xref py py-meth docutils literal"><span class="pre">is_gequal()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.lequal_matrix">
<code class="descname">lequal_matrix</code><span class="sig-paren">(</span><em>ring=Integer Ring</em>, <em>sparse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.lequal_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the matrix whose <code class="docutils literal"><span class="pre">(i,j)</span></code> entry is 1 if
<code class="docutils literal"><span class="pre">self.linear_extension()[i]</span> <span class="pre">&lt;</span> <span class="pre">self.linear_extension()[j]</span></code> and 0
otherwise.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">ring</span></code> &#8211; the ring of coefficients (default: <code class="docutils literal"><span class="pre">ZZ</span></code>)</li>
<li><code class="docutils literal"><span class="pre">sparse</span></code> &#8211; whether the returned matrix is sparse or not
(default: <code class="docutils literal"><span class="pre">True</span></code>)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[]],</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">LEQM</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">lequal_matrix</span><span class="p">();</span> <span class="n">LEQM</span>
<span class="go">[1 1 1 1 1 1 1 1]</span>
<span class="go">[0 1 0 1 0 0 0 1]</span>
<span class="go">[0 0 1 1 1 0 1 1]</span>
<span class="go">[0 0 0 1 0 0 0 1]</span>
<span class="go">[0 0 0 0 1 0 0 1]</span>
<span class="go">[0 0 0 0 0 1 1 1]</span>
<span class="go">[0 0 0 0 0 0 1 1]</span>
<span class="go">[0 0 0 0 0 0 0 1]</span>
<span class="gp">sage: </span><span class="n">LEQM</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">LEQM</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()[</span><span class="mi">5</span><span class="p">]</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We now demonstrate the usage of the optional parameters:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">lequal_matrix</span><span class="p">(</span><span class="n">ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Full MatrixSpace of 8 by 8 dense matrices over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.level_sets">
<code class="descname">level_sets</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.level_sets" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list <code class="docutils literal"><span class="pre">l</span></code> such that <code class="docutils literal"><span class="pre">l[i]</span></code> is the set of minimal
elements of the poset obtained from <code class="docutils literal"><span class="pre">self</span></code> by removing the
elements in <code class="docutils literal"><span class="pre">l[0],</span> <span class="pre">l[1],</span> <span class="pre">...,</span> <span class="pre">l[i-1]</span></code>. (In particular,
<code class="docutils literal"><span class="pre">l[0]</span></code> is the set of minimal elements of <code class="docutils literal"><span class="pre">self</span></code>.)</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">level_sets</span><span class="p">()]</span>
<span class="go">[1, 2, 1]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Q</span><span class="o">.</span><span class="n">level_sets</span><span class="p">()]</span>
<span class="go">[1, 2, 1, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.linear_extension">
<code class="descname">linear_extension</code><span class="sig-paren">(</span><em>linear_extension=None</em>, <em>check=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.linear_extension" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a linear extension of this poset.</p>
<p>A linear extension of a finite poset <span class="math">\(P\)</span> of size <span class="math">\(n\)</span> is a total
ordering <span class="math">\(\pi := \pi_0 \pi_1 \ldots \pi_{n-1}\)</span> of its elements
such that <span class="math">\(i&lt;j\)</span> whenever <span class="math">\(\pi_i &lt; \pi_j\)</span> in the poset <span class="math">\(P\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">linear_extension</span></code> &#8211; (default: <code class="docutils literal"><span class="pre">None</span></code>) a list of the
elements of <code class="docutils literal"><span class="pre">self</span></code></li>
<li><code class="docutils literal"><span class="pre">check</span></code> &#8211; a boolean (default: True);
whether to check that <code class="docutils literal"><span class="pre">linear_extension</span></code> is indeed a
linear extension of <code class="docutils literal"><span class="pre">self</span></code>.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_linear_extension" title="sage.combinat.posets.posets.FinitePoset.is_linear_extension"><code class="xref py py-meth docutils literal"><span class="pre">is_linear_extension()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extensions" title="sage.combinat.posets.posets.FinitePoset.linear_extensions"><code class="xref py py-meth docutils literal"><span class="pre">linear_extensions()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Without optional argument, the default linear extension of the
poset is returned, as a plain list:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()</span>
<span class="go">[1, 3, 5, 15]</span>
</pre></div>
</div>
<p>Otherwise, a full-featured linear extension is constructed
as an element of <code class="docutils literal"><span class="pre">P.linear_extensions()</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">15</span><span class="p">]);</span> <span class="n">l</span>
<span class="go">[1, 5, 3, 15]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.combinat.posets.linear_extensions.LinearExtensionsOfPoset_with_category.element_class&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">l</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">The set of all linear extensions of Finite poset containing 4 elements</span>
</pre></div>
</div>
<p>By default, the linear extension is checked for correctness:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">[1, 3, 15, 5] is not a linear extension of Finite poset containing 4 elements</span>
</pre></div>
</div>
<p>This can be disabled (at your own risks!) with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">[1, 3, 15, 5]</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<ul class="last simple">
<li>Is it acceptable to have those two features for a single method?</li>
<li>In particular, we miss a short idiom to get the default
linear extension</li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.linear_extensions">
<code class="descname">linear_extensions</code><span class="sig-paren">(</span><em>facade=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.linear_extensions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the enumerated set of all the linear extensions of this poset</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">facade</span></code> &#8211; a boolean (default: <code class="docutils literal"><span class="pre">False</span></code>);
whether to return the linear extensions as plain lists</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>The <code class="docutils literal"><span class="pre">facade</span></code> option is not yet fully functional:</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extensions</span><span class="p">(</span><span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span> <span class="n">L</span>
<span class="go">The set of all linear extensions of Finite poset containing 6 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">Cannot convert list to sage.structure.element.Element</span>
</pre></div>
</div>
</div>
</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extension" title="sage.combinat.posets.posets.FinitePoset.linear_extension"><code class="xref py py-meth docutils literal"><span class="pre">linear_extension()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_linear_extension" title="sage.combinat.posets.posets.FinitePoset.is_linear_extension"><code class="xref py py-meth docutils literal"><span class="pre">is_linear_extension()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extensions</span><span class="p">();</span> <span class="n">L</span>
<span class="go">The set of all linear extensions of Finite poset containing 6 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">l</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[1, 2, 3, 4, 6, 12],</span>
<span class="go"> [1, 2, 3, 6, 4, 12],</span>
<span class="go"> [1, 2, 4, 3, 6, 12],</span>
<span class="go"> [1, 3, 2, 4, 6, 12],</span>
<span class="go"> [1, 3, 2, 6, 4, 12]]</span>
</pre></div>
</div>
<p>Each element is aware that it is a linear extension of <span class="math">\(P\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">parent</span><span class="p">())</span>
<span class="go">&lt;class &#39;sage.combinat.posets.linear_extensions.LinearExtensionsOfPoset_with_category&#39;&gt;</span>
</pre></div>
</div>
<p>With <code class="docutils literal"><span class="pre">facade=True</span></code>, the elements of <code class="docutils literal"><span class="pre">L</span></code> are plain lists instead:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extensions</span><span class="p">(</span><span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="go">&lt;type &#39;list&#39;&gt;</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>In Sage &lt;= 4.8, this function used to return a plain list
of lists. To recover the previous functionality, please use:</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">linear_extensions</span><span class="p">(</span><span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">));</span> <span class="n">L</span>
<span class="go">[[1, 2, 3, 4, 6, 12],</span>
<span class="go"> [1, 2, 3, 6, 4, 12],</span>
<span class="go"> [1, 2, 4, 3, 6, 12],</span>
<span class="go"> [1, 3, 2, 4, 6, 12],</span>
<span class="go"> [1, 3, 2, 6, 4, 12]]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;type &#39;list&#39;&gt;</span>
</pre></div>
</div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="p">})</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">linear_extensions</span><span class="p">())</span>
<span class="go">[[0, 1, 2, 3, 4], [0, 1, 2, 4, 3], [0, 2, 1, 3, 4], [0, 2, 1, 4, 3], [0, 2, 4, 1, 3]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.linear_extensions_graph">
<code class="descname">linear_extensions_graph</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.linear_extensions_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the linear extensions graph of the poset.</p>
<p>Vertices of the graph are linear extensions of the poset.
Two vertices are connected by an edge if the linear extensions
differ by only one adjacent transposition.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extensions_graph</span><span class="p">();</span> <span class="n">G</span>
<span class="go">Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">degree_sequence</span><span class="p">()</span>
<span class="go">[3, 2, 2, 2, 1]</span>

<span class="gp">sage: </span><span class="n">chevron</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">6</span><span class="p">:[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">chevron</span><span class="o">.</span><span class="n">linear_extensions_graph</span><span class="p">();</span> <span class="n">G</span>
<span class="go">Graph on 22 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">36</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">linear_extensions_graph</span><span class="p">()</span>
<span class="go">Graph on 1 vertex</span>

<span class="gp">sage: </span><span class="n">A4</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">A4</span><span class="o">.</span><span class="n">linear_extensions_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_regular</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.list">
<code class="descname">list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.list" title="Permalink to this definition">¶</a></dt>
<dd><p>List the elements of the poset. This just returns the result
of <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extension" title="sage.combinat.posets.posets.FinitePoset.linear_extension"><code class="xref py py-meth docutils literal"><span class="pre">linear_extension()</span></code></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="p">},</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">list</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;class &#39;sage.combinat.posets.elements.FinitePoset_with_category.element_class&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.lower_covers">
<code class="descname">lower_covers</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.lower_covers" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of lower covers of the element <code class="docutils literal"><span class="pre">x</span></code>.</p>
<p>A lower cover of <span class="math">\(x\)</span> is an element <span class="math">\(y\)</span> such that <span class="math">\(y &lt; x\)</span> and
there is no element <span class="math">\(z\)</span> so that <span class="math">\(y &lt; z &lt; x\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">lower_covers</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[2, 5]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">lower_covers</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.upper_covers" title="sage.combinat.posets.posets.FinitePoset.upper_covers"><code class="xref py py-meth docutils literal"><span class="pre">upper_covers()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.lower_covers_iterator">
<code class="descname">lower_covers_iterator</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.lower_covers_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over the lower covers of the element <code class="docutils literal"><span class="pre">x</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">l0</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">lower_covers_iterator</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">l0</span><span class="p">)</span>
<span class="go">&lt;type &#39;generator&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">l0</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.lt">
<code class="descname">lt</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.lt" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if <span class="math">\(x\)</span> is less than but not equal to <span class="math">\(y\)</span> in the poset,
and <code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>For non-facade posets also <code class="docutils literal"><span class="pre">&lt;</span></code> works:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]},</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_lequal" title="sage.combinat.posets.posets.FinitePoset.is_lequal"><code class="xref py py-meth docutils literal"><span class="pre">is_lequal()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_greater_than" title="sage.combinat.posets.posets.FinitePoset.is_greater_than"><code class="xref py py-meth docutils literal"><span class="pre">is_greater_than()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.maximal_antichains">
<code class="descname">maximal_antichains</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.maximal_antichains" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximal antichains of the poset.</p>
<p>An antichain <span class="math">\(a\)</span> of poset <span class="math">\(P\)</span> is <em>maximal</em> if there is
no element <span class="math">\(e \in P \setminus a\)</span> such that <span class="math">\(a \cup \{e\}\)</span>
is an antichain.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">=</span><span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;d&#39;</span><span class="p">,</span><span class="s1">&#39;e&#39;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">maximal_antichains</span><span class="p">()</span>
<span class="go">[[&#39;a&#39;], [&#39;b&#39;, &#39;c&#39;], [&#39;c&#39;, &#39;d&#39;, &#39;e&#39;]]</span>

<span class="gp">sage: </span><span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">maximal_antichains</span><span class="p">()</span>
<span class="go">[[0], [1, 2], [1, 3], [4]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains" title="sage.combinat.posets.posets.FinitePoset.antichains"><code class="xref py py-meth docutils literal"><span class="pre">antichains()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_chains" title="sage.combinat.posets.posets.FinitePoset.maximal_chains"><code class="xref py py-meth docutils literal"><span class="pre">maximal_chains()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.maximal_chains">
<code class="descname">maximal_chains</code><span class="sig-paren">(</span><em>partial=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.maximal_chains" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all maximal chains of this poset.</p>
<p>Each chain is listed in increasing order.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">partial</span></code> &#8211; list (optional); if present, find all maximal
chains starting with the elements in partial</li>
</ul>
<p>Returns list of the maximal chains of this poset.</p>
<p>This is used in constructing the order complex for the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">maximal_chains</span><span class="p">()</span>
<span class="go">[[0, 1, 3, 7], [0, 1, 5, 7], [0, 2, 3, 7], [0, 2, 6, 7], [0, 4, 5, 7], [0, 4, 6, 7]]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">maximal_chains</span><span class="p">(</span><span class="n">partial</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">[[0, 2, 3, 7], [0, 2, 6, 7]]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">maximal_chains</span><span class="p">()</span>
<span class="go">[[0, 1, 2, 3, 4, 5]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_antichains" title="sage.combinat.posets.posets.FinitePoset.maximal_antichains"><code class="xref py py-meth docutils literal"><span class="pre">maximal_antichains()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.chains" title="sage.combinat.posets.posets.FinitePoset.chains"><code class="xref py py-meth docutils literal"><span class="pre">chains()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.maximal_elements">
<code class="descname">maximal_elements</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.maximal_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of the maximal elements of the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span><span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">maximal_elements</span><span class="p">()</span>
<span class="go">[4]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.minimal_elements" title="sage.combinat.posets.posets.FinitePoset.minimal_elements"><code class="xref py py-meth docutils literal"><span class="pre">minimal_elements()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.meet_matrix">
<code class="descname">meet_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.meet_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated as a function of posets, moved to lattices.</p>
<p>Convert a poset <span class="math">\(P\)</span> to meet-semilattice and use it like
<code class="docutils literal"><span class="pre">MeetSemilattice(P).join_matrix()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.minimal_elements">
<code class="descname">minimal_elements</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.minimal_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of the minimal elements of the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span><span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">minimal_elements</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">minimal_elements</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">minimal_elements</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_elements" title="sage.combinat.posets.posets.FinitePoset.maximal_elements"><code class="xref py py-meth docutils literal"><span class="pre">maximal_elements()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.mobius_function">
<code class="descname">mobius_function</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.mobius_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.moebius_function" title="sage.combinat.posets.posets.FinitePoset.moebius_function"><code class="xref py py-func docutils literal"><span class="pre">moebius_function()</span></code></a> instead.
See <a class="reference external" href="https://trac.sagemath.org/19855">trac ticket #19855</a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.mobius_function_matrix">
<code class="descname">mobius_function_matrix</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.mobius_function_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.moebius_function_matrix" title="sage.combinat.posets.posets.FinitePoset.moebius_function_matrix"><code class="xref py py-func docutils literal"><span class="pre">moebius_function_matrix()</span></code></a> instead.
See <a class="reference external" href="https://trac.sagemath.org/19855">trac ticket #19855</a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.moebius_function">
<code class="descname">moebius_function</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.moebius_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the Möbius function of the poset on the
elements x and y.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">P</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="nb">sum</span><span class="p">([</span><span class="n">P</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">P</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="nb">sum</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">v</span><span class="p">))</span> \
<span class="go">....:      for v in P])</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">cover_relations_iterator</span><span class="p">():</span>
<span class="go">....:     if P.moebius_function(u,v) != -1:</span>
<span class="go">....:         print(&quot;Bug in moebius_function!&quot;)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[]])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="nb">sum</span><span class="p">([</span><span class="n">Q</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Q</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.moebius_function_matrix">
<code class="descname">moebius_function_matrix</code><span class="sig-paren">(</span><em>ring=Integer Ring</em>, <em>sparse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.moebius_function_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a matrix whose <code class="docutils literal"><span class="pre">(i,j)</span></code> entry is the value of the Möbius
function evaluated at <code class="docutils literal"><span class="pre">self.linear_extension()[i]</span></code> and
<code class="docutils literal"><span class="pre">self.linear_extension()[j]</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">ring</span></code> &#8211; the ring of coefficients (default: <code class="docutils literal"><span class="pre">ZZ</span></code>)</li>
<li><code class="docutils literal"><span class="pre">sparse</span></code> &#8211; whether the returned matrix is sparse or not
(default: <code class="docutils literal"><span class="pre">True</span></code>)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[],[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">moebius_function_matrix</span><span class="p">();</span> <span class="n">M</span>
<span class="go">[ 1 -1 -1 -1  2]</span>
<span class="go">[ 0  1  0  0 -1]</span>
<span class="go">[ 0  0  1  0 -1]</span>
<span class="go">[ 0  0  0  1 -1]</span>
<span class="go">[ 0  0  0  0  1]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="go">-1</span>
</pre></div>
</div>
<p>We now demonstrate the usage of the optional parameters:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">moebius_function_matrix</span><span class="p">(</span><span class="n">ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Full MatrixSpace of 5 by 5 dense matrices over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.open_interval">
<code class="descname">open_interval</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.open_interval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of elements <span class="math">\(z\)</span> such that <span class="math">\(x &lt; z &lt; y\)</span> in the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">open_interval</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="go">[4, 10, 20, 50]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.closed_interval" title="sage.combinat.posets.posets.FinitePoset.closed_interval"><code class="xref py py-meth docutils literal"><span class="pre">closed_interval()</span></code></a></p>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">open_interval</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">open_interval</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">open_interval</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">open_interval</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.order_complex">
<code class="descname">order_complex</code><span class="sig-paren">(</span><em>on_ints=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.order_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the order complex associated to this poset.</p>
<p>The order complex is the simplicial complex with vertices equal
to the elements of the poset, and faces given by the chains.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">on_ints</span></code> &#8211; a boolean (default: False)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_complex</span><span class="p">();</span> <span class="n">S</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3, 4, 5, 6, 7) and 6 facets</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 8, 19, 18, 6]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>      <span class="c1"># S is contractible</span>
<span class="go">{0: 0, 1: 0, 2: 0, 3: 0}</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">subposet</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">order_complex</span><span class="p">()</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>    <span class="c1"># a circle</span>
<span class="go">{0: 0, 1: Z}</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_complex</span><span class="p">()</span>
<span class="go">Simplicial complex with vertex set (1, 3, 5, 15) and facets {(1, 3, 15), (1, 5, 15)}</span>
</pre></div>
</div>
<p>If <code class="docutils literal"><span class="pre">on_ints</span></code>, then the elements of the poset are labelled
<span class="math">\(0,1,\dots\)</span> in the chain complex:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_complex</span><span class="p">(</span><span class="n">on_ints</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3) and facets {(0, 2, 3), (0, 1, 3)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.order_filter">
<code class="descname">order_filter</code><span class="sig-paren">(</span><em>elements</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.order_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the order filter generated by the elements of an
iterable <code class="docutils literal"><span class="pre">elements</span></code>.</p>
<p><span class="math">\(I\)</span> is an order filter if, for any <span class="math">\(x\)</span> in <span class="math">\(I\)</span> and <span class="math">\(y\)</span> such that
<span class="math">\(y \ge x\)</span>, then <span class="math">\(y\)</span> is in <span class="math">\(I\)</span>. This is also called upper set or
upset.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_filter</span><span class="p">([</span><span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">])</span>
<span class="go">[20, 40, 25, 50, 100, 200, 125, 250, 500, 1000]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_ideal" title="sage.combinat.posets.posets.FinitePoset.order_ideal"><code class="xref py py-meth docutils literal"><span class="pre">order_ideal()</span></code></a>, <a class="reference external" href="../../../../categories/sage/categories/posets.html#sage.categories.posets.Posets.ParentMethods.principal_order_filter" title="(in Sage Reference Manual: Category Framework v7.3)"><code class="xref py py-meth docutils literal"><span class="pre">principal_order_filter()</span></code></a>.</p>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">()</span>  <span class="c1"># Test empty poset</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_filter</span><span class="p">([])</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">order_filter</span><span class="p">([])</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.order_ideal">
<code class="descname">order_ideal</code><span class="sig-paren">(</span><em>elements</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.order_ideal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the order ideal generated by the elements of an
iterable <code class="docutils literal"><span class="pre">elements</span></code>.</p>
<p><span class="math">\(I\)</span> is an order ideal if, for any <span class="math">\(x\)</span> in <span class="math">\(I\)</span> and <span class="math">\(y\)</span> such that
<span class="math">\(y \le x\)</span>, then <span class="math">\(y\)</span> is in <span class="math">\(I\)</span>. This is also called lower set or
downset.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal</span><span class="p">([</span><span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">])</span>
<span class="go">[1, 2, 4, 5, 10, 20, 25]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_filter" title="sage.combinat.posets.posets.FinitePoset.order_filter"><code class="xref py py-meth docutils literal"><span class="pre">order_filter()</span></code></a>, <a class="reference external" href="../../../../categories/sage/categories/posets.html#sage.categories.posets.Posets.ParentMethods.principal_order_ideal" title="(in Sage Reference Manual: Category Framework v7.3)"><code class="xref py py-meth docutils literal"><span class="pre">principal_order_ideal()</span></code></a>.</p>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">()</span>  <span class="c1"># Test empty poset</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal</span><span class="p">([])</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">order_ideal</span><span class="p">([])</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.order_polynomial">
<code class="descname">order_polynomial</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.order_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the order polynomial of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>The order polynomial <span class="math">\(\Omega_P(q)\)</span> of a poset <span class="math">\(P\)</span> is defined
as the unique polynomial <span class="math">\(S\)</span> such that for each integer
<span class="math">\(m \geq 1\)</span>, <span class="math">\(S(m)\)</span> is the number of order-preserving maps
from <span class="math">\(P\)</span> to <span class="math">\(\{1,\ldots,m\}\)</span>.</p>
<p>See sections 3.12 and 3.15 of <a class="reference internal" href="#enumcomb1" id="id16">[EnumComb1]</a>, and also
<a class="reference internal" href="#st1986" id="id17">[St1986]</a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_polytope" title="sage.combinat.posets.posets.FinitePoset.order_polytope"><code class="xref py py-meth docutils literal"><span class="pre">order_polytope()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_polynomial</span><span class="p">()</span>
<span class="go">q^3</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_polynomial</span><span class="p">();</span> <span class="n">f</span>
<span class="go">1/6*q^3 + 1/2*q^2 + 1/3*q</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
<span class="go">[0, 1, 4, 10]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.order_polytope">
<code class="descname">order_polytope</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.order_polytope" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the order polytope of the poset <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>The order polytope of a finite poset <span class="math">\(P\)</span> is defined as the subset
of <span class="math">\(\RR^P\)</span> consisting of all maps <span class="math">\(x : P \to \RR\)</span> satisfying</p>
<div class="math">
\[0 \leq x(p) \leq 1 \mbox{ for all } p \in P,\]</div>
<p>and</p>
<div class="math">
\[x(p) \leq x(q) \mbox{ for all } p, q \in P
\mbox{ satisfying } p &lt; q.\]</div>
<p>This polytope was defined and studied in <a class="reference internal" href="#st1986" id="id18">[St1986]</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_polytope</span><span class="p">();</span><span class="n">Q</span>
<span class="go">A 3-dimensional polyhedron in QQ^3 defined as the convex hull of 8 vertices</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_polytope</span><span class="p">();</span><span class="n">Q</span>
<span class="go">A 5-dimensional polyhedron in QQ^5 defined as the convex hull of 8 vertices</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_polytope</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">contains</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">contains</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="st1986" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[St1986]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>, <a class="fn-backref" href="#id17">3</a>, <a class="fn-backref" href="#id18">4</a>)</em> Richard Stanley. <em>Two poset polytopes</em>,
Discrete Comput. Geom. (1986), <a class="reference external" href="https://dx.doi.org/10.1007/BF02187680">doi:10.1007/BF02187680</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.ordinal_product">
<code class="descname">ordinal_product</code><span class="sig-paren">(</span><em>other</em>, <em>labels='pairs'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.ordinal_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ordinal product of <code class="docutils literal"><span class="pre">self</span></code> and <code class="docutils literal"><span class="pre">other</span></code>.</p>
<p>The ordinal product of two posets <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> is a partial
order on the Cartesian product of the underlying sets of <span class="math">\(P\)</span>
and <span class="math">\(Q\)</span>, defined as follows (see <a class="reference internal" href="#enumcomb1" id="id19">[EnumComb1]</a>, p. 284).</p>
<p>In the ordinal product, <span class="math">\((p,q) \leq (p',q')\)</span> if either <span class="math">\(p \leq
p'\)</span> or <span class="math">\(p = p'\)</span> and <span class="math">\(q \leq q'\)</span>.</p>
<p>This construction is not symmetric in <span class="math">\(P\)</span> and <span class="math">\(Q\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">other</span></code> &#8211; a poset</li>
<li><code class="docutils literal"><span class="pre">labels</span></code> &#8211; either <code class="docutils literal"><span class="pre">'integers'</span></code> or <code class="docutils literal"><span class="pre">'pairs'</span></code> (default); how
the resulting poset will be labeled</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.product" title="sage.combinat.posets.posets.FinitePoset.product"><code class="xref py py-meth docutils literal"><span class="pre">product()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_sum" title="sage.combinat.posets.posets.FinitePoset.ordinal_sum"><code class="xref py py-meth docutils literal"><span class="pre">ordinal_sum()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="p">[[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">ordinal_product</span><span class="p">(</span><span class="n">P2</span><span class="p">);</span> <span class="n">P</span>
<span class="go">Finite poset containing 4 elements</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span>
<span class="go">[[(&#39;a&#39;, &#39;c&#39;), (&#39;a&#39;, &#39;d&#39;)], [(&#39;a&#39;, &#39;d&#39;), (&#39;b&#39;, &#39;c&#39;)],</span>
<span class="go">[(&#39;b&#39;, &#39;c&#39;), (&#39;b&#39;, &#39;d&#39;)]]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P1</span><span class="o">.</span><span class="n">ordinal_product</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">the input is not a finite poset</span>
<span class="gp">sage: </span><span class="n">P1</span><span class="o">.</span><span class="n">ordinal_product</span><span class="p">(</span><span class="n">P2</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="s1">&#39;camembert&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">labels must be either &#39;pairs&#39; or &#39;integers&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.ordinal_sum">
<code class="descname">ordinal_sum</code><span class="sig-paren">(</span><em>other</em>, <em>labels='pairs'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.ordinal_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a poset or (semi)lattice isomorphic to ordinal sum of the
poset with <code class="docutils literal"><span class="pre">other</span></code>.</p>
<p>The ordinal sum of <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> is a poset that contains every
element and relation from both <span class="math">\(P\)</span> and <span class="math">\(Q\)</span>, and where every
element of <span class="math">\(P\)</span> is smaller than every element of <span class="math">\(Q\)</span>.</p>
<p>Mathematically, it is only defined when <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> have no
common element; here we force that by giving them different
names in the resulting poset.</p>
<p>The ordinal sum on lattices is lattice; resp. for meet- and
join-semilattices. Hence we check if we can return
(semi)lattice instead of plain poset.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">other</span></code>, a poset.</li>
<li><code class="docutils literal"><span class="pre">labels</span></code> - (defaults to &#8216;pairs&#8217;) If set to &#8216;pairs&#8217;, each
element <code class="docutils literal"><span class="pre">v</span></code> in this poset will be named <code class="docutils literal"><span class="pre">(0,v)</span></code> and each
element <code class="docutils literal"><span class="pre">u</span></code> in <code class="docutils literal"><span class="pre">other</span></code> will be named <code class="docutils literal"><span class="pre">(1,u)</span></code> in the
result. If set to &#8216;integers&#8217;, the elements of the result
will be relabeled with consecutive integers.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,],</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P3</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">ordinal_sum</span><span class="p">(</span><span class="n">P2</span><span class="p">);</span> <span class="n">P3</span>
<span class="go">Finite poset containing 7 elements</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">P1</span><span class="o">.</span><span class="n">maximal_elements</span><span class="p">())</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">P2</span><span class="o">.</span><span class="n">minimal_elements</span><span class="p">())</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">P1</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span><span class="o">+</span><span class="n">P2</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">P3</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span> <span class="c1"># Every element of P2 is greater than elements of P1.</span>
<span class="go">11</span>
<span class="gp">sage: </span><span class="n">P3</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>  <span class="c1"># random</span>
<span class="go">[(0, 1), (0, 2), (0, 4), (0, 3), (1, 2), (1, 3), (1, 1)]</span>
<span class="gp">sage: </span><span class="n">P4</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">ordinal_sum</span><span class="p">(</span><span class="n">P2</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="s1">&#39;integers&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P4</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>  <span class="c1"># random</span>
<span class="go">[0, 1, 2, 3, 5, 6, 4]</span>
</pre></div>
</div>
<p>Return type depends on input types:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">]});</span> <span class="n">P</span>
<span class="go">Finite poset containing 2 elements</span>
<span class="gp">sage: </span><span class="n">JL</span> <span class="o">=</span> <span class="n">JoinSemilattice</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">]});</span> <span class="n">JL</span>
<span class="go">Finite join-semilattice containing 2 elements</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">LatticePoset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">]});</span> <span class="n">L</span>
<span class="go">Finite lattice containing 2 elements</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">ordinal_sum</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="go">Finite poset containing 4 elements</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">ordinal_sum</span><span class="p">(</span><span class="n">JL</span><span class="p">)</span>
<span class="go">Finite join-semilattice containing 4 elements</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">ordinal_sum</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="go">Finite lattice containing 4 elements</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_summands" title="sage.combinat.posets.posets.FinitePoset.ordinal_summands"><code class="xref py py-meth docutils literal"><span class="pre">ordinal_summands()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.disjoint_union" title="sage.combinat.posets.posets.FinitePoset.disjoint_union"><code class="xref py py-meth docutils literal"><span class="pre">disjoint_union()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_product" title="sage.combinat.posets.posets.FinitePoset.ordinal_product"><code class="xref py py-meth docutils literal"><span class="pre">ordinal_product()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.ordinal_summands">
<code class="descname">ordinal_summands</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.ordinal_summands" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ordinal summands of the poset as subposets.</p>
<p>The ordinal summands of a poset <span class="math">\(P\)</span> is the longest list of
non-empty subposets <span class="math">\(P_1, \ldots, P_n\)</span> whose ordinal sum is <span class="math">\(P\)</span>. This
decomposition is unique.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_sum" title="sage.combinat.posets.posets.FinitePoset.ordinal_sum"><code class="xref py py-meth docutils literal"><span class="pre">ordinal_sum()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span>
<span class="go">....: &#39;d&#39;: [&#39;x&#39;, &#39;y&#39;]})</span>
<span class="gp">sage: </span><span class="n">parts</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">ordinal_summands</span><span class="p">();</span> <span class="n">parts</span>
<span class="go">[Finite poset containing 4 elements, Finite poset containing 2 elements]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ordinal_sum</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>ALGORITHM:</p>
<p>Suppose that a poset <span class="math">\(P\)</span> is the ordinal sum of posets <span class="math">\(L\)</span> and <span class="math">\(U\)</span>. Then
<span class="math">\(P\)</span> contains maximal antichains <span class="math">\(l\)</span> and <span class="math">\(u\)</span> such that every element of
<span class="math">\(u\)</span> covers every element of <span class="math">\(l\)</span>; they correspond to maximal elements of
<span class="math">\(L\)</span> and minimal elements of <span class="math">\(U\)</span>.</p>
<p>We consider a linear extension <span class="math">\(x_1,\ldots,x_n\)</span> of the poset&#8217;s
elements.</p>
<p>We keep track of the maximal elements of subposet induced by elements
<span class="math">\(0,\ldots,x_i\)</span> and minimal elements of subposet induced by elements
<span class="math">\(x_{i+1},\ldots,x_n\)</span>, incrementing <span class="math">\(i\)</span> one by one. We then check if
<span class="math">\(l\)</span> and <span class="math">\(u\)</span> fit the previous description.</p>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">ordinal_summands</span><span class="p">()</span>
<span class="go">[Finite poset containing 0 elements]</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[]})</span><span class="o">.</span><span class="n">ordinal_summands</span><span class="p">()</span>
<span class="go">[Finite poset containing 1 elements]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.p_partition_enumerator">
<code class="descname">p_partition_enumerator</code><span class="sig-paren">(</span><em>tup</em>, <em>R</em>, <em>check=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.p_partition_enumerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <span class="math">\(P\)</span>-partition enumerator of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>Given a total order <span class="math">\(\prec\)</span> on the elements of a finite poset <span class="math">\(P\)</span>
(the order of <span class="math">\(P\)</span> and the total order <span class="math">\(\prec\)</span> can be unrelated; in
particular, the latter does not have to extend the former), a
<span class="math">\(P\)</span>-partition enumerator is the quasisymmetric function
<span class="math">\(\sum_f \prod_{p \in P} x_{f(p)}\)</span>, where the first sum is taken over
all <span class="math">\(P\)</span>-partitions <span class="math">\(f\)</span>.</p>
<p>A <span class="math">\(P\)</span>-partition is a function <span class="math">\(f : P \to \{1,2,3,...\}\)</span> satisfying
the following properties for any two elements <span class="math">\(i\)</span> and <span class="math">\(j\)</span> of <span class="math">\(P\)</span>
satisfying <span class="math">\(i &lt;_P j\)</span>:</p>
<ul class="simple">
<li>if <span class="math">\(i \prec j\)</span> then <span class="math">\(f(i) \leq f(j)\)</span>,</li>
<li>if <span class="math">\(j \prec i\)</span> then <span class="math">\(f(i) &lt; f(j)\)</span>.</li>
</ul>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">tup</span></code> &#8211; the tuple containing all elements of <span class="math">\(P\)</span> (each of
them exactly once), in the order dictated by the total order
<span class="math">\(\prec\)</span></li>
<li><code class="docutils literal"><span class="pre">R</span></code> &#8211; a commutative ring</li>
</ul>
<p>OUTPUT:</p>
<p>The <span class="math">\(P\)</span>-partition enumerator of <code class="docutils literal"><span class="pre">self</span></code> according to <code class="docutils literal"><span class="pre">tup</span></code> in the
algebra <span class="math">\(QSym\)</span> of quasisymmetric functions over the base ring <span class="math">\(R\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">FP</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">p_partition_enumerator</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">QQ</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span> <span class="n">FP</span>
<span class="go">2*M[1, 1, 1, 1] + 2*M[1, 2, 1] + M[2, 1, 1] + M[3, 1]</span>

<span class="gp">sage: </span><span class="n">expansion</span> <span class="o">=</span> <span class="n">FP</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">xs</span> <span class="o">=</span> <span class="n">expansion</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">expansion</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">([</span><span class="n">xs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">*</span><span class="n">xs</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">*</span><span class="n">xs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">*</span><span class="n">xs</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="n">b</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">])</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[],[]])</span>
<span class="gp">sage: </span><span class="n">FP</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">p_partition_enumerator</span><span class="p">((),</span> <span class="n">QQ</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span> <span class="n">FP</span>
<span class="go">M[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.plot">
<code class="descname">plot</code><span class="sig-paren">(</span><em>label_elements=True</em>, <em>element_labels=None</em>, <em>layout='acyclic'</em>, <em>cover_labels=None</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Graphic object for the Hasse diagram of the poset.</p>
<p>If the poset is ranked, the plot uses the rank function for
the heights of the elements.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">label_elements</span></code> (default: <code class="docutils literal"><span class="pre">True</span></code>) - whether to display
element labels</li>
<li><code class="docutils literal"><span class="pre">element_labels</span></code> (default: <code class="docutils literal"><span class="pre">None</span></code>) - a dictionary of
element labels</li>
<li><code class="docutils literal"><span class="pre">cover_labels</span></code> - a dictionary, list or function representing labels
of the covers of <code class="docutils literal"><span class="pre">self</span></code>. When set to <code class="docutils literal"><span class="pre">None</span></code> (default) no label is
displayed on the edges of the Hasse Diagram.</li>
<li><code class="docutils literal"><span class="pre">layout</span></code> &#8211; the type of layout used to display the Diagram. Set to
<code class="docutils literal"><span class="pre">'acyclic'</span></code> by default (see <a class="reference external" href="../../../../graphs/sage/graphs/generic_graph.html#sage.graphs.generic_graph.GenericGraph.plot" title="(in Sage Reference Manual: Graph Theory v7.3)"><code class="xref py py-meth docutils literal"><span class="pre">GenericGraph.plot</span></code></a> for more information).</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">All options of <a class="reference external" href="../../../../graphs/sage/graphs/generic_graph.html#sage.graphs.generic_graph.GenericGraph.plot" title="(in Sage Reference Manual: Graph Theory v7.3)"><code class="xref py py-meth docutils literal"><span class="pre">GenericGraph.plot</span></code></a> are also available
through this function.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="p">})</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">label_elements</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">Graphics object consisting of 6 graphics primitives</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="go">Graphics object consisting of 11 graphics primitives</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">plot</span><span class="p">())</span>
<span class="go">&lt;class &#39;sage.plot.graphics.Graphics&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">elm_labs</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="s1">&#39;e&#39;</span><span class="p">}</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">element_labels</span><span class="o">=</span><span class="n">elm_labs</span><span class="p">)</span>
<span class="go">Graphics object consisting of 11 graphics primitives</span>
</pre></div>
</div>
<p>Plot of a ranked poset:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">(</span><span class="s1">&#39;E@ACA@?&#39;</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_ranked</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="go">Graphics object consisting of 12 graphics primitives</span>
</pre></div>
</div>
<p>The keyword <code class="docutils literal"><span class="pre">cover_labels</span></code> can be used to decorate edges:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cover_labels</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
<span class="go">Graphics object consisting of 8 graphics primitives</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cover_labels</span><span class="o">=</span><span class="p">{(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span> <span class="s1">&#39;here&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span> <span class="s1">&#39;there&#39;</span><span class="p">})</span>
<span class="go">Graphics object consisting of 8 graphics primitives</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cover_labels</span><span class="o">=</span><span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;da&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;niet&#39;</span><span class="p">)])</span>
<span class="go">Graphics object consisting of 8 graphics primitives</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>We check that <code class="docutils literal"><span class="pre">label_elements</span></code> and <code class="docutils literal"><span class="pre">element_labels</span></code> are honored:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">get_plot_labels</span><span class="p">(</span><span class="n">P</span><span class="p">):</span> <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">string</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">P</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sage</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">Text</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="p">})</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="p">},</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">get_plot_labels</span><span class="p">(</span><span class="n">P1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">label_elements</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">get_plot_labels</span><span class="p">(</span><span class="n">P1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">label_elements</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="go">[u&#39;0&#39;, u&#39;1&#39;, u&#39;2&#39;, u&#39;3&#39;, u&#39;4&#39;]</span>
<span class="gp">sage: </span><span class="n">element_labels</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span><span class="s1">&#39;e&#39;</span><span class="p">}</span>
<span class="gp">sage: </span><span class="n">get_plot_labels</span><span class="p">(</span><span class="n">P1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">element_labels</span><span class="o">=</span><span class="n">element_labels</span><span class="p">))</span>
<span class="go">[u&#39;a&#39;, u&#39;b&#39;, u&#39;c&#39;, u&#39;d&#39;, u&#39;e&#39;]</span>
<span class="gp">sage: </span><span class="n">get_plot_labels</span><span class="p">(</span><span class="n">P2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">element_labels</span><span class="o">=</span><span class="n">element_labels</span><span class="p">))</span>
<span class="go">[u&#39;a&#39;, u&#39;b&#39;, u&#39;c&#39;, u&#39;d&#39;, u&#39;e&#39;]</span>
</pre></div>
</div>
<p>The following checks that <a class="reference external" href="https://trac.sagemath.org/18936">trac ticket #18936</a> has been fixed and labels still work:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">heights</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span> <span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span> <span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">heights</span><span class="o">=</span><span class="n">heights</span><span class="p">)</span>
<span class="go">Graphics object consisting of 8 graphics primitives</span>
<span class="gp">sage: </span><span class="n">elem_labels</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span> <span class="p">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span> <span class="p">:</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span> <span class="p">:</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">3</span> <span class="p">:</span> <span class="s1">&#39;d&#39;</span><span class="p">}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">element_labels</span><span class="o">=</span><span class="n">elem_labels</span><span class="p">,</span> <span class="n">heights</span><span class="o">=</span><span class="n">heights</span><span class="p">)</span>
<span class="go">Graphics object consisting of 8 graphics primitives</span>
</pre></div>
</div>
<p>Plot of the empy poset:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="go">Graphics object consisting of 0 graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.product">
<code class="descname">product</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Cartesian product of the poset with <code class="docutils literal"><span class="pre">other</span></code>.</p>
<p>The Cartesian (or &#8216;direct&#8217;) product of <span class="math">\(P\)</span> and
<span class="math">\(Q\)</span> is defined by <span class="math">\((p, q) \le (p', q')\)</span> iff <span class="math">\(p \le p'\)</span>
in <span class="math">\(P\)</span> and <span class="math">\(q \le q'\)</span> in <span class="math">\(Q\)</span>.</p>
<p>Product of (semi)lattices are returned as a (semi)lattice.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">PQ</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> <span class="p">;</span> <span class="n">PQ</span>
<span class="go">Finite lattice containing 12 elements</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">PQ</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span>
<span class="go">17</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">PQ</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">Posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>One can also simply use <span class="math">\(*\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">*</span><span class="n">Q</span>
<span class="go">Finite lattice containing 6 elements</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">]})</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">Poset</span><span class="p">())</span>  <span class="c1"># Product with empty poset</span>
<span class="go">Finite poset containing 0 elements</span>
</pre></div>
</div>
<p>We check that <a class="reference external" href="https://trac.sagemath.org/19113">trac ticket #19113</a> is fixed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">LatticePoset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">L</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.promotion">
<code class="descname">promotion</code><span class="sig-paren">(</span><em>i=1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.promotion" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the (extended) promotion on the linear extension
of the poset <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">i</span></code> &#8211; an integer between <span class="math">\(1\)</span> and <span class="math">\(n\)</span> (default: <span class="math">\(1\)</span>)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>an isomorphic poset, with the same default linear extension</li>
</ul>
<p>The extended promotion is defined on a poset <code class="docutils literal"><span class="pre">self</span></code> of size
<span class="math">\(n\)</span> by applying the promotion operator <span class="math">\(\tau_i \tau_{i+1}
\cdots \tau_{n-1}\)</span> to the default linear extension <span class="math">\(\pi\)</span> of <code class="docutils literal"><span class="pre">self</span></code>
(see <a class="reference internal" href="linear_extensions.html#sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.promotion" title="sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.promotion"><code class="xref py py-meth docutils literal"><span class="pre">promotion()</span></code></a>),
and relabeling <code class="docutils literal"><span class="pre">self</span></code> accordingly. For more details see <a class="reference internal" href="#stan2009" id="id20">[Stan2009]</a>.</p>
<p>When the elements of the poset <code class="docutils literal"><span class="pre">self</span></code> are labelled by
<span class="math">\(\{1,2,\ldots,n\}\)</span>, the linear extension is the identity, and
<span class="math">\(i=1\)</span>, the above algorithm corresponds to the promotion
operator on posets defined by Schützenberger as
follows. Remove <span class="math">\(1\)</span> from <code class="docutils literal"><span class="pre">self</span></code> and replace it by the
minimum <span class="math">\(j\)</span> of all labels covering <span class="math">\(1\)</span> in the poset. Then,
remove <span class="math">\(j\)</span> and replace it by the minimum of all labels
covering <span class="math">\(j\)</span>, and so on.  This process ends when a label is a
local maximum. Place the label <span class="math">\(n+1\)</span> at this vertex.  Finally,
decrease all labels by <span class="math">\(1\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]]),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">promotion</span><span class="p">()</span>
<span class="go">Finite poset containing 2 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">promotion</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 5, 6, 4, 7]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">promotion</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="n">Q</span>
<span class="go">Finite poset containing 7 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 6], [2, 3], [2, 5], [3, 7], [5, 7], [6, 4]]</span>
</pre></div>
</div>
<p>Note that if one wants to obtain the promotion defined by
Schützenberger&#8217;s algorithm directly on the poset, one needs
to make sure the linear extension is the identity:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">with_linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">promotion</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="n">Q</span>
<span class="go">Finite poset containing 7 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 6], [2, 3], [2, 4], [3, 5], [4, 5], [6, 7]]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">promotion</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [4, 7], [5, 7]]</span>
</pre></div>
</div>
<p>Here is an example for a poset not labelled by <span class="math">\(\{1, 2, \ldots, n\}\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 5, 6, 10, 15, 30]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [1, 5], [2, 6], [2, 10], [3, 6], [3, 15],</span>
<span class="go"> [5, 10], [5, 15], [6, 30], [10, 30], [15, 30]]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">promotion</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="n">Q</span>
<span class="go">Finite poset containing 8 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [1, 6], [2, 5], [2, 15], [3, 5], [3, 10],</span>
<span class="go"> [5, 30], [6, 10], [6, 15], [10, 30], [15, 30]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extension" title="sage.combinat.posets.posets.FinitePoset.linear_extension"><code class="xref py py-meth docutils literal"><span class="pre">linear_extension()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.with_linear_extension" title="sage.combinat.posets.posets.FinitePoset.with_linear_extension"><code class="xref py py-meth docutils literal"><span class="pre">with_linear_extension()</span></code></a> and the <code class="docutils literal"><span class="pre">linear_extension</span></code> option of <a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><code class="xref py py-func docutils literal"><span class="pre">Poset()</span></code></a></li>
<li><a class="reference internal" href="linear_extensions.html#sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.promotion" title="sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.promotion"><code class="xref py py-meth docutils literal"><span class="pre">promotion()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.evacuation" title="sage.combinat.posets.posets.FinitePoset.evacuation"><code class="xref py py-meth docutils literal"><span class="pre">evacuation()</span></code></a></li>
</ul>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li>Anne Schilling (2012-02-18)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.random_order_ideal">
<code class="descname">random_order_ideal</code><span class="sig-paren">(</span><em>direction='down'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.random_order_ideal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a random order ideal with uniform probability.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">direction</span></code> &#8211; <code class="docutils literal"><span class="pre">'up'</span></code>, <code class="docutils literal"><span class="pre">'down'</span></code> or <code class="docutils literal"><span class="pre">'antichain'</span></code>
(default: <code class="docutils literal"><span class="pre">'down'</span></code>)</li>
</ul>
<p>OUTPUT:</p>
<p>A randomly selected order ideal (or order filter if
<code class="docutils literal"><span class="pre">direction='up'</span></code>, or antichain if <code class="docutils literal"><span class="pre">direction='antichain'</span></code>)
where all order ideals have equal probability of occurring.</p>
<p>ALGORITHM:</p>
<p>Uses the coupling from the past algorithm described in <a class="reference internal" href="#propp1997" id="id21">[Propp1997]</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">random_order_ideal</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">random_order_ideal</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="s1">&#39;up&#39;</span><span class="p">)</span>
<span class="go">[6, 7]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">random_order_ideal</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="s1">&#39;antichain&#39;</span><span class="p">)</span>
<span class="go">[1, 2]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">TamariLattice</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">random_order_ideal</span><span class="p">(</span><span class="s1">&#39;antichain&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_antichain_of_poset</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">random_order_ideal</span><span class="p">(</span><span class="s1">&#39;up&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_order_filter</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">random_order_ideal</span><span class="p">(</span><span class="s1">&#39;down&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_order_ideal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="propp1997" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id21">[Propp1997]</a></td><td>James Propp,
<em>Generating Random Elements of Finite Distributive Lattices</em>,
Electron. J. Combin. 4 (1997), no. 2, The Wilf Festschrift volume,
Research Paper 15.
<a class="reference external" href="http://www.combinatorics.org/ojs/index.php/eljc/article/view/v4i2r15">http://www.combinatorics.org/ojs/index.php/eljc/article/view/v4i2r15</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.random_subposet">
<code class="descname">random_subposet</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.random_subposet" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a random subposet that contains each element with
probability <code class="docutils literal"><span class="pre">p</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">set_random_seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">random_subposet</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[0, 2], [0, 5], [2, 3], [3, 7], [5, 7]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.rank">
<code class="descname">rank</code><span class="sig-paren">(</span><em>element=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the rank of an element <code class="docutils literal"><span class="pre">element</span></code> in the poset <code class="docutils literal"><span class="pre">self</span></code>,
or the rank of the poset if <code class="docutils literal"><span class="pre">element</span></code> is <code class="docutils literal"><span class="pre">None</span></code>.</p>
<p>(The rank of a poset is the length of the longest chain of
elements of the poset.)</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[]],</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[],[]])</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">SymmetricGroupBruhatOrderPoset</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[(</span><span class="n">v</span><span class="p">,</span><span class="n">P</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">P</span><span class="p">]</span>
<span class="go">[(&#39;1234&#39;, 0),</span>
<span class="go"> (&#39;1243&#39;, 1),</span>
<span class="gp">...</span>
<span class="go"> (&#39;4312&#39;, 5),</span>
<span class="go"> (&#39;4321&#39;, 6)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.rank_function">
<code class="descname">rank_function</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.rank_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the (normalized) rank function of the poset,
if it exists.</p>
<p>A <em>rank function</em> of a poset <span class="math">\(P\)</span> is a function <span class="math">\(r\)</span>
that maps elements of <span class="math">\(P\)</span> to integers and satisfies:
<span class="math">\(r(x) = r(y) + 1\)</span> if <span class="math">\(x\)</span> covers <span class="math">\(y\)</span>. The function <span class="math">\(r\)</span>
is normalized such that its minimum value on every
connected component of the Hasse diagram of <span class="math">\(P\)</span> is
<span class="math">\(0\)</span>. This determines the function <span class="math">\(r\)</span> uniquely (when
it exists).</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>a lambda function, if the poset admits a rank function</li>
<li><code class="docutils literal"><span class="pre">None</span></code>, if the poset does not admit a rank function</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rank_function</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">]]),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rank_function</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]]),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">rank_function</span><span class="p">();</span> <span class="n">f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[]])</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">rank_function</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">cover_relations_iterator</span><span class="p">():</span>
<span class="go">....:     if r(v) != r(u) + 1:</span>
<span class="go">....:         print(&quot;Bug in rank_function!&quot;)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[]])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">rank_function</span><span class="p">()</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.relabel">
<code class="descname">relabel</code><span class="sig-paren">(</span><em>relabeling</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.relabel" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of this poset with its elements relabelled.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">relabeling</span></code> &#8211; a function or dictionary</li>
</ul>
<p>This function should map each (non-wrapped) element of
<code class="docutils literal"><span class="pre">self</span></code> to some distinct object.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [2, 4], [2, 6], [3, 6], [4, 12], [6, 12]]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">12</span><span class="o">/</span><span class="n">x</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[12, 6, 4, 3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[12, 6], [12, 4], [6, 3], [6, 2], [4, 2], [3, 1], [2, 1]]</span>
</pre></div>
</div>
<p>Here we relabel the elements of a poset by <span class="math">\(\{0,1,2, ...\}\)</span>, using
a dictionary:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">relabeling</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="o">.</span><span class="n">element</span><span class="p">:</span><span class="n">i</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">P</span><span class="p">)};</span> <span class="n">relabeling</span>
<span class="go">{1: 0, 2: 1, 3: 2, 4: 3, 6: 4, 12: 5}</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">relabeling</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4, 5]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[0, 1], [0, 2], [1, 3], [1, 4], [2, 4], [3, 5], [4, 5]]</span>
</pre></div>
</div>
<p>Mind the <code class="docutils literal"><span class="pre">c.element</span></code>; this is because the relabeling is
applied to the elements of the poset without the wrapping.
Thanks to this convention, the same relabeling function can
be used both for facade or non facade posets:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">12</span><span class="o">/</span><span class="n">x</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[12, 6, 4, 3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[12, 6], [12, 4], [6, 3], [6, 2], [4, 2], [3, 1], [2, 1]]</span>
</pre></div>
</div>
<p>Relabeling a (semi)lattice gives a (semi)lattice:</p>
<blockquote>
<div>sage: P=JoinSemilattice({0:[1]})
sage: type(P.relabel(lambda n: n+1))
&lt;class &#8216;sage.combinat.posets.lattices.FiniteJoinSemilattice_with_category&#8217;&gt;</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As can be seen in the above examples, the default linear
extension of <code class="docutils literal"><span class="pre">Q</span></code> is that of <code class="docutils literal"><span class="pre">P</span></code> after relabeling. In
particular, <code class="docutils literal"><span class="pre">P</span></code> and <code class="docutils literal"><span class="pre">Q</span></code> share the same internal Hasse
diagram.</p>
</div>
<p>TESTS:</p>
<p>The following checks that <a class="reference external" href="https://trac.sagemath.org/14019">trac ticket #14019</a> has been fixed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">2</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">p1</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">relabel</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">p1</span><span class="o">.</span><span class="n">hasse_diagram</span><span class="p">()</span> <span class="o">==</span> <span class="n">p2</span><span class="o">.</span><span class="n">hasse_diagram</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">p1</span> <span class="o">==</span> <span class="n">p2</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">2</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">p1</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">relabel</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">:</span><span class="mi">1</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">p3</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="n">relabel</span><span class="p">({</span><span class="mi">2</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">:</span><span class="mi">3</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">p1</span><span class="o">.</span><span class="n">hasse_diagram</span><span class="p">()</span> <span class="o">==</span> <span class="n">p3</span><span class="o">.</span><span class="n">hasse_diagram</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">p1</span> <span class="o">==</span> <span class="n">p3</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.relations">
<code class="descname">relations</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.relations" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of all relations of the poset.</p>
<p>A relation is a pair of elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> such that <span class="math">\(x \leq y\)</span>
in the poset.</p>
<p>The number of relations is the dimension of the incidence
algebra.</p>
<p>OUTPUT:</p>
<p>A list of pairs (each pair is a list), where the first element
of the pair is less than or equal to the second element.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_number" title="sage.combinat.posets.posets.FinitePoset.relations_number"><code class="xref py py-meth docutils literal"><span class="pre">relations_number()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_iterator" title="sage.combinat.posets.posets.FinitePoset.relations_iterator"><code class="xref py py-meth docutils literal"><span class="pre">relations_iterator()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">relations</span><span class="p">()</span>
<span class="go">[[1, 1], [1, 2], [1, 3], [1, 4], [0, 0], [0, 2], [0, 3],</span>
<span class="go">[0, 4], [2, 2], [2, 3], [2, 4], [3, 3], [3, 4], [4, 4]]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">()</span>  <span class="c1"># Test empty poset</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">relations</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li>Rob Beezer (2011-05-04)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.relations_iterator">
<code class="descname">relations_iterator</code><span class="sig-paren">(</span><em>strict=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.relations_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator for all the relations of the poset.</p>
<p>A relation is a pair of elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> such that <span class="math">\(x \leq y\)</span>
in the poset.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">strict</span></code> &#8211; a boolean (default <code class="docutils literal"><span class="pre">False</span></code>) if <code class="docutils literal"><span class="pre">True</span></code>, returns
an iterator over relations <span class="math">\(x &lt; y\)</span>, excluding all
relations <span class="math">\(x \leq x\)</span>.</li>
</ul>
<p>OUTPUT:</p>
<p>A generator that produces pairs (each pair is a list), where the
first element of the pair is less than or equal to the second element.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_number" title="sage.combinat.posets.posets.FinitePoset.relations_number"><code class="xref py py-meth docutils literal"><span class="pre">relations_number()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations" title="sage.combinat.posets.posets.FinitePoset.relations"><code class="xref py py-meth docutils literal"><span class="pre">relations()</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">relations_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">&lt;type &#39;generator&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">([1, 1], [1, 2])</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">relations_iterator</span><span class="p">(</span><span class="n">strict</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="go">[[0, 1], [0, 2], [0, 4], [0, 3], [1, 4], [2, 3], [2, 4], [3, 4]]</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li>Rob Beezer (2011-05-04)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.relations_number">
<code class="descname">relations_number</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.relations_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of relations in the poset.</p>
<p>A relation is a pair of elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> such that <span class="math">\(x\leq y\)</span>
in the poset.</p>
<p>Relations are also often called intervals. The number of
intervals is the dimension of the incidence algebra.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_iterator" title="sage.combinat.posets.posets.FinitePoset.relations_iterator"><code class="xref py py-meth docutils literal"><span class="pre">relations_iterator()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations" title="sage.combinat.posets.posets.FinitePoset.relations"><code class="xref py py-meth docutils literal"><span class="pre">relations()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">relations_number</span><span class="p">()</span>
<span class="go">13</span>

<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.tamari_lattices</span> <span class="kn">import</span> <span class="n">TamariLattice</span>
<span class="gp">sage: </span><span class="n">TamariLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">relations_number</span><span class="p">()</span>
<span class="go">68</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">relations_number</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.show">
<code class="descname">show</code><span class="sig-paren">(</span><em>label_elements=True</em>, <em>element_labels=None</em>, <em>cover_labels=None</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Displays the Hasse diagram of the poset.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">label_elements</span></code> (default: <code class="docutils literal"><span class="pre">True</span></code>) - whether to display
element labels</li>
<li><code class="docutils literal"><span class="pre">element_labels</span></code> (default: <code class="docutils literal"><span class="pre">None</span></code>) - a dictionary of
element labels</li>
<li><code class="docutils literal"><span class="pre">cover_labels</span></code> - a dictionary, list or function representing labels
of the covers of <code class="docutils literal"><span class="pre">self</span></code>. When set to <code class="docutils literal"><span class="pre">None</span></code> (default) no label is
displayed on the edges of the Hasse Diagram.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>This method also accepts:</p>
<blockquote class="last">
<div><ul class="simple">
<li>All options of <a class="reference external" href="../../../../graphs/sage/graphs/generic_graph.html#sage.graphs.generic_graph.GenericGraph.plot" title="(in Sage Reference Manual: Graph Theory v7.3)"><code class="xref py py-meth docutils literal"><span class="pre">GenericGraph.plot</span></code></a></li>
<li>All options of <a class="reference external" href="../../../../plotting/sage/plot/graphics.html#sage.plot.graphics.Graphics.show" title="(in Sage Reference Manual: 2D Graphics v7.3)"><code class="xref py py-meth docutils literal"><span class="pre">Graphics.show</span></code></a></li>
</ul>
</div></blockquote>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="p">})</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">label_elements</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">Graphics object consisting of 6 graphics primitives</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">elm_labs</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span><span class="s1">&#39;e&#39;</span><span class="p">}</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">element_labels</span><span class="o">=</span><span class="n">elm_labs</span><span class="p">)</span>
</pre></div>
</div>
<p>One more example with cover labels:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">cover_labels</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.subposet">
<code class="descname">subposet</code><span class="sig-paren">(</span><em>elements</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.subposet" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the poset containing elements with partial order induced by
that of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s2">&quot;a&quot;</span><span class="p">:[</span><span class="s2">&quot;c&quot;</span><span class="p">,</span><span class="s2">&quot;d&quot;</span><span class="p">],</span> <span class="s2">&quot;b&quot;</span><span class="p">:[</span><span class="s2">&quot;d&quot;</span><span class="p">,</span><span class="s2">&quot;e&quot;</span><span class="p">],</span> <span class="s2">&quot;c&quot;</span><span class="p">:[</span><span class="s2">&quot;f&quot;</span><span class="p">],</span> <span class="s2">&quot;d&quot;</span><span class="p">:[</span><span class="s2">&quot;f&quot;</span><span class="p">],</span> <span class="s2">&quot;e&quot;</span><span class="p">:[</span><span class="s2">&quot;f&quot;</span><span class="p">]},</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">subposet</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span><span class="s2">&quot;b&quot;</span><span class="p">,</span><span class="s2">&quot;f&quot;</span><span class="p">]);</span> <span class="n">Q</span>
<span class="go">Finite poset containing 3 elements</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[b, f], [a, f]]</span>
</pre></div>
</div>
<p>A subposet of a facade poset is again a facade poset:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s2">&quot;a&quot;</span><span class="p">:[</span><span class="s2">&quot;c&quot;</span><span class="p">,</span><span class="s2">&quot;d&quot;</span><span class="p">],</span> <span class="s2">&quot;b&quot;</span><span class="p">:[</span><span class="s2">&quot;d&quot;</span><span class="p">,</span><span class="s2">&quot;e&quot;</span><span class="p">],</span> <span class="s2">&quot;c&quot;</span><span class="p">:[</span><span class="s2">&quot;f&quot;</span><span class="p">],</span> <span class="s2">&quot;d&quot;</span><span class="p">:[</span><span class="s2">&quot;f&quot;</span><span class="p">],</span> <span class="s2">&quot;e&quot;</span><span class="p">:[</span><span class="s2">&quot;f&quot;</span><span class="p">]},</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">subposet</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span><span class="s2">&quot;b&quot;</span><span class="p">,</span><span class="s2">&quot;f&quot;</span><span class="p">]);</span> <span class="n">Q</span>
<span class="go">Finite poset containing 3 elements</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[&#39;b&#39;, &#39;f&#39;], [&#39;a&#39;, &#39;f&#39;]]</span>
</pre></div>
</div>
<p>One may specified wrapped elements or not:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s2">&quot;a&quot;</span><span class="p">:[</span><span class="s2">&quot;c&quot;</span><span class="p">,</span><span class="s2">&quot;d&quot;</span><span class="p">],</span> <span class="s2">&quot;b&quot;</span><span class="p">:[</span><span class="s2">&quot;d&quot;</span><span class="p">,</span><span class="s2">&quot;e&quot;</span><span class="p">],</span> <span class="s2">&quot;c&quot;</span><span class="p">:[</span><span class="s2">&quot;f&quot;</span><span class="p">],</span> <span class="s2">&quot;d&quot;</span><span class="p">:[</span><span class="s2">&quot;f&quot;</span><span class="p">],</span> <span class="s2">&quot;e&quot;</span><span class="p">:[</span><span class="s2">&quot;f&quot;</span><span class="p">]},</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">subposet</span><span class="p">([</span><span class="n">P</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span><span class="n">P</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">),</span><span class="n">P</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)]);</span> <span class="n">Q</span>
<span class="go">Finite poset containing 3 elements</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[b, f], [a, f]]</span>

<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">above</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">principal_order_filter</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">subposet</span><span class="p">(</span><span class="n">above</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">above_new</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">principal_order_filter</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">list</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">subposet</span><span class="p">(</span><span class="n">above_new</span><span class="p">)</span>
<span class="go">Finite poset containing 4 elements</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">subposet</span><span class="p">((</span><span class="s2">&quot;a&quot;</span><span class="p">,</span><span class="s2">&quot;b&quot;</span><span class="p">,</span><span class="s2">&quot;f&quot;</span><span class="p">))</span>
<span class="go">Finite poset containing 3 elements</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">subposet</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span><span class="s2">&quot;b&quot;</span><span class="p">,</span><span class="s2">&quot;x&quot;</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">&lt;type &#39;str&#39;&gt; is not an element of this poset</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">subposet</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;sage.rings.integer.Integer&#39; object is not iterable</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.to_graph">
<code class="descname">to_graph</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.to_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.cover_relations_graph" title="sage.combinat.posets.posets.FinitePoset.cover_relations_graph"><code class="xref py py-func docutils literal"><span class="pre">cover_relations_graph()</span></code></a> instead.
See <a class="reference external" href="https://trac.sagemath.org/17449">trac ticket #17449</a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.top">
<code class="descname">top</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.top" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unique maximal element of the poset, if it exists.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="mi">4</span><span class="p">:[],</span><span class="mi">5</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">top</span><span class="p">()</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">top</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_top" title="sage.combinat.posets.posets.FinitePoset.has_top"><code class="xref py py-meth docutils literal"><span class="pre">has_top()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.bottom" title="sage.combinat.posets.posets.FinitePoset.bottom"><code class="xref py py-meth docutils literal"><span class="pre">bottom()</span></code></a></p>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">0</span><span class="p">],[]])</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[0]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">top</span><span class="p">()</span> <span class="c1">#Trac #10776</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.unwrap">
<code class="descname">unwrap</code><span class="sig-paren">(</span><em>element</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.unwrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the element <code class="docutils literal"><span class="pre">element</span></code> of the poset <code class="docutils literal"><span class="pre">self</span></code> in
unwrapped form.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">element</span></code> &#8211; an element of <code class="docutils literal"><span class="pre">self</span></code></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">x</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Finite poset containing 4 elements</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Integer Ring</span>
</pre></div>
</div>
<p>For a non facade poset, this is equivalent to using the
<code class="docutils literal"><span class="pre">.element</span></code> attribute:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">x</span><span class="o">.</span><span class="n">element</span>
<span class="go">True</span>
</pre></div>
</div>
<p>For a facade poset, this does nothing:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">x</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This method is useful in code where we don&#8217;t know if <code class="docutils literal"><span class="pre">P</span></code> is
a facade poset or not.</p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.upper_covers">
<code class="descname">upper_covers</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.upper_covers" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of upper covers of the element <code class="docutils literal"><span class="pre">x</span></code>.</p>
<p>An upper cover of <span class="math">\(x\)</span> is an element <span class="math">\(y\)</span> such that <span class="math">\(x &lt; y\)</span> and
there is no element <span class="math">\(z\)</span> so that <span class="math">\(x &lt; z &lt; y\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">upper_covers</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[2, 6]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.lower_covers" title="sage.combinat.posets.posets.FinitePoset.lower_covers"><code class="xref py py-meth docutils literal"><span class="pre">lower_covers()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.upper_covers_iterator">
<code class="descname">upper_covers_iterator</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.upper_covers_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over the upper covers of the element <code class="docutils literal"><span class="pre">x</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">upper_covers_iterator</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">&lt;type &#39;generator&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.width">
<code class="descname">width</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.width" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the width of the poset (the size of its longest antichain).</p>
<p>It is computed through a matching in a bipartite graph; see
<a class="reference external" href="https://en.wikipedia.org/wiki/Dilworth's_theorem">Wikipedia article Dilworth&#8217;s_theorem</a> for more information. The width is
also called Dilworth number.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">width</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">width</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.with_bounds">
<code class="descname">with_bounds</code><span class="sig-paren">(</span><em>labels=('bottom'</em>, <em>'top')</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.with_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the poset with bottom and top elements adjoined.</p>
<p>This functions always adds two new elements to the poset, i.e.
it does not check if the poset already has a bottom or a
top element.</p>
<p>For lattices and semilattices this function returns a lattice.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">labels</span></code> &#8211; A pair of elements to use as a bottom and top
element of the poset. Default is strings <code class="docutils literal"><span class="pre">'bottom'</span></code> and
<code class="docutils literal"><span class="pre">'top'</span></code>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">trafficsign</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">with_bounds</span><span class="p">();</span> <span class="n">trafficsign</span>
<span class="go">Finite poset containing 5 elements</span>
<span class="gp">sage: </span><span class="n">trafficsign</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[&#39;bottom&#39;, 0, 1, 2, &#39;top&#39;]</span>
<span class="gp">sage: </span><span class="n">trafficsign</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">with_bounds</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">trafficsign</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[-1, 0], [0, 1], [0, 2], [1, -2], [2, -2]]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>  <span class="c1"># A lattice</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">with_bounds</span><span class="p">()</span>
<span class="go">Finite lattice containing 7 elements</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">with_bounds</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[&#39;bottom&#39;, &#39;top&#39;]]</span>

<span class="gp">sage: </span><span class="n">LatticePoset</span><span class="p">({})</span><span class="o">.</span><span class="n">with_bounds</span><span class="p">()</span>
<span class="go">Finite lattice containing 2 elements</span>

<span class="gp">sage: </span><span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">with_bounds</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">the poset already has element 4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.with_linear_extension">
<code class="descname">with_linear_extension</code><span class="sig-paren">(</span><em>linear_extension</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.with_linear_extension" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of <code class="docutils literal"><span class="pre">self</span></code> with a different default linear extension.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [2, 4], [2, 6], [3, 6], [4, 12], [6, 12]]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">with_linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">12</span><span class="p">])</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="go">[1, 3, 2, 6, 4, 12]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 3], [1, 2], [3, 6], [2, 6], [2, 4], [6, 12], [4, 12]]</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>We check that we can pass in a list of elements of <code class="docutils literal"><span class="pre">P</span></code> instead:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">with_linear_extension</span><span class="p">([</span><span class="n">P</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">12</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="go">[1, 3, 2, 6, 4, 12]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 3], [1, 2], [3, 6], [2, 6], [2, 4], [6, 12], [4, 12]]</span>
</pre></div>
</div>
<p>We check that this works for facade posets too:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">with_linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">12</span><span class="p">])</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="go">[1, 3, 2, 6, 4, 12]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 3], [1, 2], [3, 6], [2, 6], [2, 4], [6, 12], [4, 12]]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">With the current implementation, this requires relabeling
the internal <a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v7.3)"><code class="xref py py-class docutils literal"><span class="pre">DiGraph</span></code></a> which is <span class="math">\(O(n+m)\)</span>, where <span class="math">\(n\)</span>
is the number of elements and <span class="math">\(m\)</span> the number of cover relations.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.zeta_polynomial">
<code class="descname">zeta_polynomial</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.zeta_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the zeta polynomial of the poset <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>The zeta polynomial of a poset is the unique polynomial <span class="math">\(Z(q)\)</span>
such that for every integer <span class="math">\(m &gt; 1\)</span>, <span class="math">\(Z(m)\)</span> is the number of
weakly increasing sequences <span class="math">\(x_1 \leq x_2 \leq \dots \leq x_{m-1}\)</span>
of elements of the poset.</p>
<p>The polynomial <span class="math">\(Z(q)\)</span> is integral-valued, but generally doesn&#8217;t
have integer coefficients. It can be computed as</p>
<div class="math">
\[Z(q) = \sum_{k \geq 1} \dbinom{q-2}{k-1} c_k,\]</div>
<p>where <span class="math">\(c_k\)</span> is the number of all chains of length <span class="math">\(k\)</span> in the
poset.</p>
<p>For more information, see section 3.12 of <a class="reference internal" href="#enumcomb1" id="id22">[EnumComb1]</a>.</p>
<p>In particular, <span class="math">\(Z(2)\)</span> is the number of vertices and <span class="math">\(Z(3)\)</span> is
the number of intervals.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">zeta_polynomial</span><span class="p">()</span>
<span class="go">q</span>
<span class="gp">sage: </span><span class="n">Posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">zeta_polynomial</span><span class="p">()</span>
<span class="go">1/2*q^2 + 1/2*q</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">zeta_polynomial</span><span class="p">()</span>
<span class="go">1/6*q^3 + q^2 - 1/6*q</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">zeta_polynomial</span><span class="p">()</span>
<span class="go">3/2*q^2 - 1/2*q</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Checking the simplest cases:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">({})</span><span class="o">.</span><span class="n">zeta_polynomial</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[]})</span><span class="o">.</span><span class="n">zeta_polynomial</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[]})</span><span class="o">.</span><span class="n">zeta_polynomial</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.posets.posets.FinitePosets_n">
<em class="property">class </em><code class="descclassname">sage.combinat.posets.posets.</code><code class="descname">FinitePosets_n</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePosets_n" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Sage Reference Manual: Basic Structures v7.3)"><code class="xref py py-class docutils literal"><span class="pre">sage.structure.unique_representation.UniqueRepresentation</span></code></a>, <a class="reference external" href="../../../../structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Sage Reference Manual: Basic Structures v7.3)"><code class="xref py py-class docutils literal"><span class="pre">sage.structure.parent.Parent</span></code></a></p>
<p>The finite enumerated set of all posets on <span class="math">\(n\)</span> elements, up to an isomorphism.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">P</span><span class="p">:</span> <span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span>
<span class="go">[]</span>
<span class="go">[[1, 2]]</span>
<span class="go">[[0, 1], [0, 2]]</span>
<span class="go">[[0, 1], [1, 2]]</span>
<span class="go">[[1, 2], [0, 2]]</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePosets_n.cardinality">
<code class="descname">cardinality</code><span class="sig-paren">(</span><em>from_iterator=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePosets_n.cardinality" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cardinality of this object.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">By default, this returns pre-computed values obtained from
the On-Line Encyclopedia of Integer Sequences (<a class="reference external" href="https://oeis.org/A000112">OEIS sequence A000112</a>).
To override this, pass the argument <code class="docutils literal"><span class="pre">from_iterator=True</span></code>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cardinality</span><span class="p">(</span><span class="n">from_iterator</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.combinat.posets.posets.Poset">
<code class="descclassname">sage.combinat.posets.posets.</code><code class="descname">Poset</code><span class="sig-paren">(</span><em>data=None</em>, <em>element_labels=None</em>, <em>cover_relations=False</em>, <em>linear_extension=False</em>, <em>category=None</em>, <em>facade=None</em>, <em>key=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.Poset" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a finite poset from various forms of input data.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">data</span></code> &#8211; different input are accepted by this constructor:</p>
<ol class="arabic">
<li><p class="first">A two-element list or tuple <code class="docutils literal"><span class="pre">(E,</span> <span class="pre">R)</span></code>, where <code class="docutils literal"><span class="pre">E</span></code> is a
collection of elements of the poset and <code class="docutils literal"><span class="pre">R</span></code> is a collection
of relations <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code>, each represented as a two-element
list/tuple/iterable such as <code class="docutils literal"><span class="pre">[x,</span> <span class="pre">y]</span></code>. The poset is then
the transitive closure of the provided relations. If
<code class="docutils literal"><span class="pre">cover_relations=True</span></code>, then <code class="docutils literal"><span class="pre">R</span></code> is assumed to contain
exactly the cover relations of the poset. If <code class="docutils literal"><span class="pre">E</span></code> is empty,
then <code class="docutils literal"><span class="pre">E</span></code> is taken to be the set of elements appearing in
the relations <code class="docutils literal"><span class="pre">R</span></code>.</p>
</li>
<li><p class="first">A two-element list or tuple <code class="docutils literal"><span class="pre">(E,</span> <span class="pre">f)</span></code>, where <code class="docutils literal"><span class="pre">E</span></code> is the set
of elements of the poset and <code class="docutils literal"><span class="pre">f</span></code> is a function such that,
for any pair <code class="docutils literal"><span class="pre">x,</span> <span class="pre">y</span></code> of elements of <code class="docutils literal"><span class="pre">E</span></code>, <code class="docutils literal"><span class="pre">f(x,</span> <span class="pre">y)</span></code>
returns whether <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code>. If <code class="docutils literal"><span class="pre">cover_relations=True</span></code>, then
<code class="docutils literal"><span class="pre">f(x,</span> <span class="pre">y)</span></code> should instead return whether <code class="docutils literal"><span class="pre">x</span></code> is covered by
<code class="docutils literal"><span class="pre">y</span></code>.</p>
</li>
<li><p class="first">A dictionary, list or tuple of upper covers: <code class="docutils literal"><span class="pre">data[x]</span></code> is
a list of the elements that cover the element <span class="math">\(x\)</span> in the poset.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If data is a list or tuple of length <span class="math">\(2\)</span>, then it is
handled by the above case..</p>
</div>
</li>
<li><p class="first">An acyclic, loop-free and multi-edge free <code class="docutils literal"><span class="pre">DiGraph</span></code>. If
<code class="docutils literal"><span class="pre">cover_relations</span></code> is <code class="docutils literal"><span class="pre">True</span></code>, then the edges of the
digraph are assumed to correspond to the cover relations of
the poset. Otherwise, the cover relations are computed.</p>
</li>
<li><p class="first">A previously constructed poset (the poset itself is returned).</p>
</li>
</ol>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">element_labels</span></code> &#8211; (default: <code class="docutils literal"><span class="pre">None</span></code>); an optional list or
dictionary of objects that label the poset elements.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">cover_relations</span></code> &#8211; a boolean (default: <code class="docutils literal"><span class="pre">False</span></code>); whether the
data can be assumed to describe a directed acyclic graph whose
arrows are cover relations; otherwise, the cover relations are
first computed.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">linear_extension</span></code> &#8211; a boolean (default: <code class="docutils literal"><span class="pre">False</span></code>); whether to
use the provided list of elements as default linear extension
for the poset; otherwise a linear extension is computed. If the data
is given as the pair <code class="docutils literal"><span class="pre">(E,</span> <span class="pre">f)</span></code>, then <code class="docutils literal"><span class="pre">E</span></code> is taken to be the linear
extension.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">facade</span></code> &#8211; a boolean or <code class="docutils literal"><span class="pre">None</span></code> (default); whether the
<a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><code class="xref py py-meth docutils literal"><span class="pre">Poset()</span></code></a>&#8216;s elements should be wrapped to make them aware of the
Poset they belong to.</p>
<ul class="simple">
<li>If <code class="docutils literal"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">True</span></code>, the <a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><code class="xref py py-meth docutils literal"><span class="pre">Poset()</span></code></a>&#8216;s elements are exactly those
given as input.</li>
<li>If <code class="docutils literal"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">False</span></code>, the <a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><code class="xref py py-meth docutils literal"><span class="pre">Poset()</span></code></a>&#8216;s elements will become
<code class="xref py py-class docutils literal"><span class="pre">PosetElement</span></code> objects.</li>
<li>If <code class="docutils literal"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">None</span></code> (default) the expected behaviour is the behaviour
of <code class="docutils literal"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">True</span></code>, unless the opposite can be deduced from the
context (i.e. for instance if a <a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><code class="xref py py-meth docutils literal"><span class="pre">Poset()</span></code></a> is built from another
<a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><code class="xref py py-meth docutils literal"><span class="pre">Poset()</span></code></a>, itself built with <code class="docutils literal"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">False</span></code>)</li>
</ul>
</li>
</ul>
<p>OUTPUT:</p>
<p><code class="docutils literal"><span class="pre">FinitePoset</span></code> &#8211; an instance of the <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><code class="xref py py-class docutils literal"><span class="pre">FinitePoset</span></code></a> class.</p>
<p>If <code class="docutils literal"><span class="pre">category</span></code> is specified, then the poset is created in this
category instead of <a class="reference external" href="../../../../categories/sage/categories/finite_posets.html#sage.categories.finite_posets.FinitePosets" title="(in Sage Reference Manual: Category Framework v7.3)"><code class="xref py py-class docutils literal"><span class="pre">FinitePosets</span></code></a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="poset_examples.html#sage.combinat.posets.poset_examples.Posets" title="sage.combinat.posets.poset_examples.Posets"><code class="xref py py-class docutils literal"><span class="pre">Posets</span></code></a>, <a class="reference external" href="../../../../categories/sage/categories/posets.html#sage.categories.posets.Posets" title="(in Sage Reference Manual: Category Framework v7.3)"><code class="xref py py-class docutils literal"><span class="pre">Posets</span></code></a>,
<a class="reference external" href="../../../../categories/sage/categories/finite_posets.html#sage.categories.finite_posets.FinitePosets" title="(in Sage Reference Manual: Category Framework v7.3)"><code class="xref py py-class docutils literal"><span class="pre">FinitePosets</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<ol class="arabic">
<li><p class="first">Elements and cover relations:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">elms</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">rels</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">((</span><span class="n">elms</span><span class="p">,</span> <span class="n">rels</span><span class="p">),</span> <span class="n">cover_relations</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="go">Finite poset containing 7 elements</span>
</pre></div>
</div>
<p>Elements and non-cover relations:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">elms</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">rels</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">[</span><span class="n">elms</span><span class="p">,</span><span class="n">rels</span><span class="p">]</span> <span class="p">,</span><span class="n">cover_relations</span><span class="o">=</span><span class="bp">False</span><span class="p">);</span> <span class="n">P</span>
<span class="go">Finite poset containing 4 elements</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [2, 3], [3, 4]]</span>
</pre></div>
</div>
</li>
<li><p class="first">Elements and function: the standard permutations of [1, 2, 3, 4]
with the Bruhat order:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">elms</span> <span class="o">=</span> <span class="n">Permutations</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fcn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">,</span><span class="n">q</span> <span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">bruhat_lequal</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">((</span><span class="n">elms</span><span class="p">,</span> <span class="n">fcn</span><span class="p">))</span>
<span class="go">Finite poset containing 24 elements</span>
</pre></div>
</div>
<p>With a function that identifies the cover relations: the set
partitions of <span class="math">\(\{1, 2, 3\}\)</span> ordered by refinement:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">elms</span> <span class="o">=</span> <span class="n">SetPartitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">fcn</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
<span class="go">....:     if len(A) != len(B)+1:</span>
<span class="go">....:         return False</span>
<span class="go">....:     for a in A:</span>
<span class="go">....:         if not any(set(a).issubset(b) for b in B):</span>
<span class="go">....:             return False</span>
<span class="go">....:     return True</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">((</span><span class="n">elms</span><span class="p">,</span> <span class="n">fcn</span><span class="p">),</span> <span class="n">cover_relations</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Finite poset containing 5 elements</span>
</pre></div>
</div>
</li>
<li><p class="first">A dictionary of upper covers:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;c&#39;</span><span class="p">:[</span><span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;d&#39;</span><span class="p">:[]})</span>
<span class="go">Finite poset containing 4 elements</span>
</pre></div>
</div>
<p>A list of upper covers:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[]])</span>
<span class="go">Finite poset containing 5 elements</span>
</pre></div>
</div>
<p>A list of upper covers and a dictionary of labels:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">elm_labs</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="s2">&quot;a&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="s2">&quot;b&quot;</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="s2">&quot;c&quot;</span><span class="p">,</span><span class="mi">3</span><span class="p">:</span><span class="s2">&quot;d&quot;</span><span class="p">,</span><span class="mi">4</span><span class="p">:</span><span class="s2">&quot;e&quot;</span><span class="p">}</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[]],</span> <span class="n">elm_labs</span><span class="p">,</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[a, b, c, d, e]</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The special case where the argument data is a list or tuple of
length 2 is handled by the above cases. So you cannot use this
method to input a 2-element poset.</p>
</div>
</li>
<li><p class="first">An acyclic DiGraph.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">dag</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">(</span><span class="n">dag</span><span class="p">)</span>
<span class="go">Finite poset containing 6 elements</span>
</pre></div>
</div>
<p>Any directed acyclic graph without loops or multiple edges, as long
as <code class="docutils literal"><span class="pre">cover_relations=False</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">dig</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">dig</span><span class="o">.</span><span class="n">allows_multiple_edges</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">dig</span><span class="o">.</span><span class="n">allows_loops</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">dig</span><span class="o">.</span><span class="n">transitive_reduction</span><span class="p">()</span> <span class="o">==</span> <span class="n">dig</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">(</span><span class="n">dig</span><span class="p">,</span> <span class="n">cover_relations</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">Finite poset containing 6 elements</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">(</span><span class="n">dig</span><span class="p">,</span> <span class="n">cover_relations</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Hasse diagram is not transitively reduced.</span>
</pre></div>
</div>
</li>
</ol>
<p class="rubric">Default Linear extension</p>
<p>Every poset <span class="math">\(P\)</span> obtained with <code class="docutils literal"><span class="pre">Poset</span></code> comes equipped with a
default linear extension, which is also used for enumerating
its elements. By default, this linear extension is computed,
and has no particular significance:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 4, 3, 6, 12]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()</span>
<span class="go">[1, 2, 4, 3, 6, 12]</span>
</pre></div>
</div>
<p>You may enforce a specific linear extension using the
<code class="docutils literal"><span class="pre">linear_extension</span></code> option:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
</pre></div>
</div>
<p>Depending on popular request, <code class="docutils literal"><span class="pre">Poset</span></code> might eventually get
modified to always use the provided list of elements as
default linear extension, when it is one.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extensions" title="sage.combinat.posets.posets.FinitePoset.linear_extensions"><code class="xref py py-meth docutils literal"><span class="pre">FinitePoset.linear_extensions()</span></code></a></p>
</div>
<p class="rubric">Facade posets</p>
<p>When <code class="docutils literal"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">False</span></code>, the elements of a poset are wrapped so as to make
them aware that they belong to that poset:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">({</span><span class="s1">&#39;d&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">],</span><span class="s1">&#39;c&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">]}),</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="ow">is</span> <span class="n">P</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This allows for comparing elements according to <span class="math">\(P\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
<p>However, this may have surprising effects:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">my_elements</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">my_elements</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">P</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>and can be annoying when one wants to manipulate the elements of
the poset:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">unsupported operand type(s) for +: &#39;FinitePoset_with_category.element_class&#39; and &#39;FinitePoset_with_category.element_class&#39;</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">element</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">element</span>
<span class="go">&#39;ab&#39;</span>
</pre></div>
</div>
<p>By default, facade posets are constructed instead:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">({</span><span class="s1">&#39;d&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">],</span><span class="s1">&#39;c&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">]}))</span>
</pre></div>
</div>
<p>In this example, the elements of the poset remain plain strings:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">d</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&lt;type &#39;str&#39;&gt;</span>
</pre></div>
</div>
<p>Of course, those strings are not aware of <span class="math">\(P\)</span>. So to compare two
such strings, one needs to query <span class="math">\(P\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>which models the usual mathematical notation <span class="math">\(a &lt;_P b\)</span>.</p>
<p>Most operations seem to still work, but at this point there is no
guarantee whatsoever:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[&#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">principal_order_ideal</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="go">[&#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">principal_order_ideal</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="go">[&#39;d&#39;, &#39;b&#39;]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">principal_order_ideal</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
<span class="go">[&#39;d&#39;]</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p><a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v7.3)"><code class="xref py py-class docutils literal"><span class="pre">DiGraph</span></code></a> is used to construct the poset, and the
vertices of a <a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v7.3)"><code class="xref py py-class docutils literal"><span class="pre">DiGraph</span></code></a> are converted to plain Python
<code class="xref py py-class docutils literal"><span class="pre">int</span></code>&#8216;s if they are <a class="reference external" href="../../../../rings_standard/sage/rings/integer.html#sage.rings.integer.Integer" title="(in Sage Reference Manual: Standard Commutative Rings v7.3)"><code class="xref py py-class docutils literal"><span class="pre">Integer</span></code></a>&#8216;s:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;type &#39;int&#39;&gt;</span>
</pre></div>
</div>
<p>This is worked around by systematically converting back the
vertices of a poset to <a class="reference external" href="../../../../rings_standard/sage/rings/integer.html#sage.rings.integer.Integer" title="(in Sage Reference Manual: Standard Commutative Rings v7.3)"><code class="xref py py-class docutils literal"><span class="pre">Integer</span></code></a>&#8216;s if they are
<code class="xref py py-class docutils literal"><span class="pre">int</span></code>&#8216;s:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span><span class="o">.</span><span class="n">element</span><span class="p">)</span>
<span class="go">&lt;type &#39;sage.rings.integer.Integer&#39;&gt;</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">())</span>
<span class="go">&lt;type &#39;sage.rings.integer.Integer&#39;&gt;</span>
</pre></div>
</div>
<p>This may be abusive:</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">),</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Integer Ring</span>
</pre></div>
</div>
</div>
<p class="rubric">Unique representation</p>
<p>As most parents, <a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><code class="xref py py-class docutils literal"><span class="pre">Poset</span></code></a> have unique representation (see
<a class="reference external" href="../../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Sage Reference Manual: Basic Structures v7.3)"><code class="xref py py-class docutils literal"><span class="pre">UniqueRepresentation</span></code></a>). Namely if two posets are created
from two equal data, then they are not only equal but actually
identical:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">data1</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">]]</span>
<span class="gp">sage: </span><span class="n">data2</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">]]</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">data1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">data2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="o">==</span> <span class="n">P2</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="ow">is</span> <span class="n">P2</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In situations where this behaviour is not desired, one can use the
<code class="docutils literal"><span class="pre">key</span></code> option:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">data2</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;bar&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="ow">is</span> <span class="n">P2</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="o">==</span> <span class="n">P2</span>
<span class="go">False</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">key</span></code> can be any hashable value and is passed down to
<a class="reference external" href="../../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Sage Reference Manual: Basic Structures v7.3)"><code class="xref py py-class docutils literal"><span class="pre">UniqueRepresentation</span></code></a>. It is otherwise ignored by the
poset constructor.</p>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">P</span><span class="p">))</span>
<span class="go">&lt;type &#39;int&#39;&gt;</span>
</pre></div>
</div>
<p>Bad input:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="p">:</span> <span class="n">x</span><span class="o">&lt;</span><span class="n">y</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">element_labels should be a dict or a list if different</span>
<span class="go">from None. (Did you intend data to be equal to a pair ?)</span>
</pre></div>
</div>
<p>Another kind of bad input, digraphs with oriented cycles:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]]))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The graph is not directed acyclic</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.posets.posets.is_poset">
<code class="descclassname">sage.combinat.posets.posets.</code><code class="descname">is_poset</code><span class="sig-paren">(</span><em>dig</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.is_poset" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if a directed graph is acyclic and transitively
reduced, and <code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.posets.posets</span> <span class="kn">import</span> <span class="n">is_poset</span>
<span class="gp">sage: </span><span class="n">dig</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">is_poset</span><span class="p">(</span><span class="n">dig</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">is_poset</span><span class="p">(</span><span class="n">dig</span><span class="o">.</span><span class="n">transitive_reduction</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../../../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference internal" href="#">Finite posets</a><ul>
<li><a class="reference internal" href="#list-of-poset-methods">List of Poset methods</a></li>
<li><a class="reference internal" href="#classes-and-functions">Classes and functions</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="poset_examples.html"
                                  title="previous chapter">A catalog of posets and lattices.</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="../q_analogues.html"
                                  title="next chapter"><span class="math">\(q\)</span>-Analogues</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../../_sources/sage/combinat/posets/posets.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../q_analogues.html" title="\(q\)-Analogues"
             >next</a> |</li>
        <li class="right" >
          <a href="poset_examples.html" title="A catalog of posets and lattices."
             >previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../../index.html">Combinatorics</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../../../module_list.html" >Comprehensive Module list</a> &raquo;</li> 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &copy; Copyright 2005--2016, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.4.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>