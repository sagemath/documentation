
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Finite posets &#8212; Sage Reference Manual v8.9: Combinatorics</title>
    <link rel="stylesheet" href="../../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="\(q\)-Analogues" href="../q_analogues.html" />
    <link rel="prev" title="A catalog of posets and lattices." href="poset_examples.html" />
    <link rel="icon" href="../../../../_static/sageicon.png" type="image/x-icon" />
    <script src="../../../../_static/thebe.js" type="text/javascript"></script>
    <script src="../../../../_static/thebe-sage.js" type="text/javascript"></script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../q_analogues.html" title="\(q\)-Analogues"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="poset_examples.html" title="A catalog of posets and lattices."
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../../index.html">Combinatorics</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../../../module_list.html" accesskey="U">Comprehensive Module list</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="finite-posets">
<span id="sage-combinat-posets-posets"></span><h1>Finite posets<a class="headerlink" href="#finite-posets" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.combinat.posets.posets"></span><p>This module implements finite partially ordered sets. It defines:</p>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><code class="xref py py-class docutils literal notranslate"><span class="pre">FinitePoset</span></code></a></td>
<td>A class for finite posets</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePosets_n" title="sage.combinat.posets.posets.FinitePosets_n"><code class="xref py py-class docutils literal notranslate"><span class="pre">FinitePosets_n</span></code></a></td>
<td>A class for finite posets up to isomorphism (i.e. unlabeled posets)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Poset()</span></code></a></td>
<td>Construct a finite poset from various forms of input data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.is_poset" title="sage.combinat.posets.posets.is_poset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_poset()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if a directed graph is acyclic and transitively reduced.</td>
</tr>
</tbody>
</table>
<div class="section" id="list-of-poset-methods">
<h2>List of Poset methods<a class="headerlink" href="#list-of-poset-methods" title="Permalink to this headline">¶</a></h2>
<p><strong>Comparing, intervals and relations</strong></p>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_less_than" title="sage.combinat.posets.posets.FinitePoset.is_less_than"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_less_than()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <span class="math notranslate nohighlight">\(x\)</span> is strictly less than <span class="math notranslate nohighlight">\(y\)</span> in the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_greater_than" title="sage.combinat.posets.posets.FinitePoset.is_greater_than"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_greater_than()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <span class="math notranslate nohighlight">\(x\)</span> is strictly greater than <span class="math notranslate nohighlight">\(y\)</span> in the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_lequal" title="sage.combinat.posets.posets.FinitePoset.is_lequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_lequal()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <span class="math notranslate nohighlight">\(x\)</span> is less than or equal to <span class="math notranslate nohighlight">\(y\)</span> in the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_gequal" title="sage.combinat.posets.posets.FinitePoset.is_gequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_gequal()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <span class="math notranslate nohighlight">\(x\)</span> is greater than or equal to <span class="math notranslate nohighlight">\(y\)</span> in the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.compare_elements" title="sage.combinat.posets.posets.FinitePoset.compare_elements"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compare_elements()</span></code></a></td>
<td>Compare two element of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.closed_interval" title="sage.combinat.posets.posets.FinitePoset.closed_interval"><code class="xref py py-meth docutils literal notranslate"><span class="pre">closed_interval()</span></code></a></td>
<td>Return the list of elements in a closed interval of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.open_interval" title="sage.combinat.posets.posets.FinitePoset.open_interval"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open_interval()</span></code></a></td>
<td>Return the list of elements in an open interval of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations" title="sage.combinat.posets.posets.FinitePoset.relations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relations()</span></code></a></td>
<td>Return the list of relations in the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_iterator" title="sage.combinat.posets.posets.FinitePoset.relations_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relations_iterator()</span></code></a></td>
<td>Return an iterator over relations in the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_filter" title="sage.combinat.posets.posets.FinitePoset.order_filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_filter()</span></code></a></td>
<td>Return the upper set generated by elements.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_ideal" title="sage.combinat.posets.posets.FinitePoset.order_ideal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_ideal()</span></code></a></td>
<td>Return the lower set generated by elements.</td>
</tr>
</tbody>
</table>
<p><strong>Covering</strong></p>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.covers" title="sage.combinat.posets.posets.FinitePoset.covers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">covers()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">y</span></code> covers <code class="docutils literal notranslate"><span class="pre">x</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.lower_covers" title="sage.combinat.posets.posets.FinitePoset.lower_covers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lower_covers()</span></code></a></td>
<td>Return elements covered by given element.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.upper_covers" title="sage.combinat.posets.posets.FinitePoset.upper_covers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">upper_covers()</span></code></a></td>
<td>Return elements covering given element.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.cover_relations" title="sage.combinat.posets.posets.FinitePoset.cover_relations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cover_relations()</span></code></a></td>
<td>Return the list of cover relations.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.lower_covers_iterator" title="sage.combinat.posets.posets.FinitePoset.lower_covers_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lower_covers_iterator()</span></code></a></td>
<td>Return an iterator over elements covered by given element.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.upper_covers_iterator" title="sage.combinat.posets.posets.FinitePoset.upper_covers_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">upper_covers_iterator()</span></code></a></td>
<td>Return an iterator over elements covering given element.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.cover_relations_iterator" title="sage.combinat.posets.posets.FinitePoset.cover_relations_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cover_relations_iterator()</span></code></a></td>
<td>Return an iterator over cover relations of the poset.</td>
</tr>
</tbody>
</table>
<p><strong>Properties of the poset</strong></p>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.cardinality" title="sage.combinat.posets.posets.FinitePoset.cardinality"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cardinality()</span></code></a></td>
<td>Return the number of elements in the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.height" title="sage.combinat.posets.posets.FinitePoset.height"><code class="xref py py-meth docutils literal notranslate"><span class="pre">height()</span></code></a></td>
<td>Return the number of elements in a longest chain of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.width" title="sage.combinat.posets.posets.FinitePoset.width"><code class="xref py py-meth docutils literal notranslate"><span class="pre">width()</span></code></a></td>
<td>Return the number of elements in a longest antichain of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_number" title="sage.combinat.posets.posets.FinitePoset.relations_number"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relations_number()</span></code></a></td>
<td>Return the number of relations in the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.dimension" title="sage.combinat.posets.posets.FinitePoset.dimension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dimension()</span></code></a></td>
<td>Return the dimension of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.jump_number" title="sage.combinat.posets.posets.FinitePoset.jump_number"><code class="xref py py-meth docutils literal notranslate"><span class="pre">jump_number()</span></code></a></td>
<td>Return the jump number of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_bottom" title="sage.combinat.posets.posets.FinitePoset.has_bottom"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_bottom()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset has a unique minimal element.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_top" title="sage.combinat.posets.posets.FinitePoset.has_top"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_top()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset has a unique maximal element.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="sage.combinat.posets.posets.FinitePoset.is_bounded"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_bounded()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset has both unique minimal and unique maximal element.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_chain" title="sage.combinat.posets.posets.FinitePoset.is_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_chain()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is totally ordered.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_connected" title="sage.combinat.posets.posets.FinitePoset.is_connected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_connected()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is connected.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_graded" title="sage.combinat.posets.posets.FinitePoset.is_graded"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_graded()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if all maximal chains of the poset has same length.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_ranked" title="sage.combinat.posets.posets.FinitePoset.is_ranked"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_ranked()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset has a rank function.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_rank_symmetric" title="sage.combinat.posets.posets.FinitePoset.is_rank_symmetric"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_rank_symmetric()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is rank symmetric.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_series_parallel" title="sage.combinat.posets.posets.FinitePoset.is_series_parallel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_series_parallel()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset can be built by ordinal sums and disjoint unions.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_greedy" title="sage.combinat.posets.posets.FinitePoset.is_greedy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_greedy()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if all greedy linear extensions have equal number of jumps.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_jump_critical" title="sage.combinat.posets.posets.FinitePoset.is_jump_critical"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_jump_critical()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if removal of any element reduces the jump number.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_eulerian" title="sage.combinat.posets.posets.FinitePoset.is_eulerian"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_eulerian()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is Eulerian.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_incomparable_chain_free" title="sage.combinat.posets.posets.FinitePoset.is_incomparable_chain_free"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_incomparable_chain_free()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is (m+n)-free.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_slender" title="sage.combinat.posets.posets.FinitePoset.is_slender"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_slender()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is slender.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_sperner" title="sage.combinat.posets.posets.FinitePoset.is_sperner"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_sperner()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is Sperner.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_join_semilattice" title="sage.combinat.posets.posets.FinitePoset.is_join_semilattice"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_join_semilattice()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> is the poset has a join operation.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_meet_semilattice" title="sage.combinat.posets.posets.FinitePoset.is_meet_semilattice"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_meet_semilattice()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset has a meet operation.</td>
</tr>
</tbody>
</table>
<p><strong>Minimal and maximal elements</strong></p>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.bottom" title="sage.combinat.posets.posets.FinitePoset.bottom"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bottom()</span></code></a></td>
<td>Return the bottom element of the poset, if it exists.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.top" title="sage.combinat.posets.posets.FinitePoset.top"><code class="xref py py-meth docutils literal notranslate"><span class="pre">top()</span></code></a></td>
<td>Return the top element of the poset, if it exists.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_elements" title="sage.combinat.posets.posets.FinitePoset.maximal_elements"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximal_elements()</span></code></a></td>
<td>Return the list of the maximal elements of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.minimal_elements" title="sage.combinat.posets.posets.FinitePoset.minimal_elements"><code class="xref py py-meth docutils literal notranslate"><span class="pre">minimal_elements()</span></code></a></td>
<td>Return the list of the minimal elements of the poset.</td>
</tr>
</tbody>
</table>
<p><strong>New posets from old ones</strong></p>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.disjoint_union" title="sage.combinat.posets.posets.FinitePoset.disjoint_union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">disjoint_union()</span></code></a></td>
<td>Return the disjoint union of the poset with other poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_sum" title="sage.combinat.posets.posets.FinitePoset.ordinal_sum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ordinal_sum()</span></code></a></td>
<td>Return the ordinal sum of the poset with other poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.product" title="sage.combinat.posets.posets.FinitePoset.product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">product()</span></code></a></td>
<td>Return the Cartesian product of the poset with other poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_product" title="sage.combinat.posets.posets.FinitePoset.ordinal_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ordinal_product()</span></code></a></td>
<td>Return the ordinal product of the poset with other poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.rees_product" title="sage.combinat.posets.posets.FinitePoset.rees_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rees_product()</span></code></a></td>
<td>Return the Rees product of the poset with other poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.lexicographic_sum" title="sage.combinat.posets.posets.FinitePoset.lexicographic_sum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lexicographic_sum()</span></code></a></td>
<td>Return the lexicographic sum of posets.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.star_product" title="sage.combinat.posets.posets.FinitePoset.star_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">star_product()</span></code></a></td>
<td>Return the star product of the poset with other poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.with_bounds" title="sage.combinat.posets.posets.FinitePoset.with_bounds"><code class="xref py py-meth docutils literal notranslate"><span class="pre">with_bounds()</span></code></a></td>
<td>Return the poset with bottom and top element adjoined.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.without_bounds" title="sage.combinat.posets.posets.FinitePoset.without_bounds"><code class="xref py py-meth docutils literal notranslate"><span class="pre">without_bounds()</span></code></a></td>
<td>Return the poset with bottom and top element removed.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.dual" title="sage.combinat.posets.posets.FinitePoset.dual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dual()</span></code></a></td>
<td>Return the dual of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.completion_by_cuts" title="sage.combinat.posets.posets.FinitePoset.completion_by_cuts"><code class="xref py py-meth docutils literal notranslate"><span class="pre">completion_by_cuts()</span></code></a></td>
<td>Return the Dedekind-MacNeille completion of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.intervals_poset" title="sage.combinat.posets.posets.FinitePoset.intervals_poset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">intervals_poset()</span></code></a></td>
<td>Return the poset of intervals of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.connected_components" title="sage.combinat.posets.posets.FinitePoset.connected_components"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connected_components()</span></code></a></td>
<td>Return the connected components of the poset as subposets.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.factor" title="sage.combinat.posets.posets.FinitePoset.factor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">factor()</span></code></a></td>
<td>Return the decomposition of the poset as a Cartesian product.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_summands" title="sage.combinat.posets.posets.FinitePoset.ordinal_summands"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ordinal_summands()</span></code></a></td>
<td>Return the ordinal summands of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.subposet" title="sage.combinat.posets.posets.FinitePoset.subposet"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subposet()</span></code></a></td>
<td>Return the subposet containing elements with partial order induced by this poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.random_subposet" title="sage.combinat.posets.posets.FinitePoset.random_subposet"><code class="xref py py-meth docutils literal notranslate"><span class="pre">random_subposet()</span></code></a></td>
<td>Return a random subposet that contains each element with given probability.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relabel" title="sage.combinat.posets.posets.FinitePoset.relabel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relabel()</span></code></a></td>
<td>Return a copy of this poset with its elements relabelled.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.canonical_label" title="sage.combinat.posets.posets.FinitePoset.canonical_label"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_label()</span></code></a></td>
<td>Return copy of the poset canonically (re)labelled to integers.</td>
</tr>
</tbody>
</table>
<p><strong>Chains &amp; antichains</strong></p>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_chain_of_poset" title="sage.combinat.posets.posets.FinitePoset.is_chain_of_poset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_chain_of_poset()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if elements in the given list are comparable.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_antichain_of_poset" title="sage.combinat.posets.posets.FinitePoset.is_antichain_of_poset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_antichain_of_poset()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if elements in the given list are incomparable.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.chains" title="sage.combinat.posets.posets.FinitePoset.chains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">chains()</span></code></a></td>
<td>Return the chains of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains" title="sage.combinat.posets.posets.FinitePoset.antichains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">antichains()</span></code></a></td>
<td>Return the antichains of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_chains" title="sage.combinat.posets.posets.FinitePoset.maximal_chains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximal_chains()</span></code></a></td>
<td>Return the maximal chains of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_antichains" title="sage.combinat.posets.posets.FinitePoset.maximal_antichains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximal_antichains()</span></code></a></td>
<td>Return the maximal antichains of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains_iterator" title="sage.combinat.posets.posets.FinitePoset.antichains_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">antichains_iterator()</span></code></a></td>
<td>Return an iterator over the antichains of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.random_maximal_chain" title="sage.combinat.posets.posets.FinitePoset.random_maximal_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">random_maximal_chain()</span></code></a></td>
<td>Return a random maximal chain.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.random_maximal_antichain" title="sage.combinat.posets.posets.FinitePoset.random_maximal_antichain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">random_maximal_antichain()</span></code></a></td>
<td>Return a random maximal antichain.</td>
</tr>
</tbody>
</table>
<p><strong>Drawing</strong></p>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.show" title="sage.combinat.posets.posets.FinitePoset.show"><code class="xref py py-meth docutils literal notranslate"><span class="pre">show()</span></code></a></td>
<td>Display the Hasse diagram of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.plot" title="sage.combinat.posets.posets.FinitePoset.plot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot()</span></code></a></td>
<td>Return a Graphic object corresponding the Hasse diagram of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.graphviz_string" title="sage.combinat.posets.posets.FinitePoset.graphviz_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graphviz_string()</span></code></a></td>
<td>Return a representation in the DOT language, ready to render in graphviz.</td>
</tr>
</tbody>
</table>
<p><strong>Comparing posets</strong></p>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_isomorphic" title="sage.combinat.posets.posets.FinitePoset.is_isomorphic"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_isomorphic()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if both posets are isomorphic.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_induced_subposet" title="sage.combinat.posets.posets.FinitePoset.is_induced_subposet"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_induced_subposet()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if given poset is an induced subposet of this poset.</td>
</tr>
</tbody>
</table>
<p><strong>Polynomials</strong></p>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.chain_polynomial" title="sage.combinat.posets.posets.FinitePoset.chain_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">chain_polynomial()</span></code></a></td>
<td>Return the chain polynomial of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.characteristic_polynomial" title="sage.combinat.posets.posets.FinitePoset.characteristic_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">characteristic_polynomial()</span></code></a></td>
<td>Return the characteristic polynomial of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.f_polynomial" title="sage.combinat.posets.posets.FinitePoset.f_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">f_polynomial()</span></code></a></td>
<td>Return the f-polynomial of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.flag_f_polynomial" title="sage.combinat.posets.posets.FinitePoset.flag_f_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flag_f_polynomial()</span></code></a></td>
<td>Return the flag f-polynomial of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.h_polynomial" title="sage.combinat.posets.posets.FinitePoset.h_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">h_polynomial()</span></code></a></td>
<td>Return the h-polynomial of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.flag_h_polynomial" title="sage.combinat.posets.posets.FinitePoset.flag_h_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flag_h_polynomial()</span></code></a></td>
<td>Return the flag h-polynomial of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_polynomial" title="sage.combinat.posets.posets.FinitePoset.order_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_polynomial()</span></code></a></td>
<td>Return the order polynomial of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.zeta_polynomial" title="sage.combinat.posets.posets.FinitePoset.zeta_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">zeta_polynomial()</span></code></a></td>
<td>Return the zeta polynomial of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.kazhdan_lusztig_polynomial" title="sage.combinat.posets.posets.FinitePoset.kazhdan_lusztig_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kazhdan_lusztig_polynomial()</span></code></a></td>
<td>Return the Kazhdan-Lusztig polynomial of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.coxeter_polynomial" title="sage.combinat.posets.posets.FinitePoset.coxeter_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coxeter_polynomial()</span></code></a></td>
<td>Return the characteristic polynomial of the Coxeter transformation.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.degree_polynomial" title="sage.combinat.posets.posets.FinitePoset.degree_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">degree_polynomial()</span></code></a></td>
<td>Return the generating polynomial of degrees of vertices in the Hasse diagram.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.p_partition_enumerator" title="sage.combinat.posets.posets.FinitePoset.p_partition_enumerator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">p_partition_enumerator()</span></code></a></td>
<td>Return a <span class="math notranslate nohighlight">\(P\)</span>-partition enumerator of the poset.</td>
</tr>
</tbody>
</table>
<p><strong>Polytopes</strong></p>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.chain_polytope" title="sage.combinat.posets.posets.FinitePoset.chain_polytope"><code class="xref py py-meth docutils literal notranslate"><span class="pre">chain_polytope()</span></code></a></td>
<td>Return the chain polytope of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_polytope" title="sage.combinat.posets.posets.FinitePoset.order_polytope"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_polytope()</span></code></a></td>
<td>Return the order polytope of the poset.</td>
</tr>
</tbody>
</table>
<p><strong>Graphs</strong></p>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.hasse_diagram" title="sage.combinat.posets.posets.FinitePoset.hasse_diagram"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hasse_diagram()</span></code></a></td>
<td>Return the Hasse diagram of the poset as a directed graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.cover_relations_graph" title="sage.combinat.posets.posets.FinitePoset.cover_relations_graph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cover_relations_graph()</span></code></a></td>
<td>Return the (undirected) graph of cover relations.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.comparability_graph" title="sage.combinat.posets.posets.FinitePoset.comparability_graph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">comparability_graph()</span></code></a></td>
<td>Return the comparability graph of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.incomparability_graph" title="sage.combinat.posets.posets.FinitePoset.incomparability_graph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">incomparability_graph()</span></code></a></td>
<td>Return the incomparability graph of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.frank_network" title="sage.combinat.posets.posets.FinitePoset.frank_network"><code class="xref py py-meth docutils literal notranslate"><span class="pre">frank_network()</span></code></a></td>
<td>Return Frank’s network of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extensions_graph" title="sage.combinat.posets.posets.FinitePoset.linear_extensions_graph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">linear_extensions_graph()</span></code></a></td>
<td>Return the linear extensions graph of the poset.</td>
</tr>
</tbody>
</table>
<p><strong>Linear extensions</strong></p>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_linear_extension" title="sage.combinat.posets.posets.FinitePoset.is_linear_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_linear_extension()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the given list is a linear extension of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extension" title="sage.combinat.posets.posets.FinitePoset.linear_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">linear_extension()</span></code></a></td>
<td>Return a linear extension of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extensions" title="sage.combinat.posets.posets.FinitePoset.linear_extensions"><code class="xref py py-meth docutils literal notranslate"><span class="pre">linear_extensions()</span></code></a></td>
<td>Return the enumerated set of all the linear extensions of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.promotion" title="sage.combinat.posets.posets.FinitePoset.promotion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">promotion()</span></code></a></td>
<td>Return the (extended) promotion on the linear extension of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.evacuation" title="sage.combinat.posets.posets.FinitePoset.evacuation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">evacuation()</span></code></a></td>
<td>Return evacuation on the linear extension associated to the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.with_linear_extension" title="sage.combinat.posets.posets.FinitePoset.with_linear_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">with_linear_extension()</span></code></a></td>
<td>Return a copy of <code class="docutils literal notranslate"><span class="pre">self</span></code> with a different default linear extension.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.random_linear_extension" title="sage.combinat.posets.posets.FinitePoset.random_linear_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">random_linear_extension()</span></code></a></td>
<td>Return a random linear extension.</td>
</tr>
</tbody>
</table>
<p><strong>Matrices</strong></p>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.lequal_matrix" title="sage.combinat.posets.posets.FinitePoset.lequal_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lequal_matrix()</span></code></a></td>
<td>Computes the matrix whose <code class="docutils literal notranslate"><span class="pre">(i,j)</span></code> entry is 1 if <code class="docutils literal notranslate"><span class="pre">self.linear_extension()[i]</span> <span class="pre">&lt;</span> <span class="pre">self.linear_extension()[j]</span></code> and 0 otherwise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.moebius_function" title="sage.combinat.posets.posets.FinitePoset.moebius_function"><code class="xref py py-meth docutils literal notranslate"><span class="pre">moebius_function()</span></code></a></td>
<td>Return the value of Möbius function of given elements in the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.moebius_function_matrix" title="sage.combinat.posets.posets.FinitePoset.moebius_function_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">moebius_function_matrix()</span></code></a></td>
<td>Return a matrix whose <code class="docutils literal notranslate"><span class="pre">(i,j)</span></code> entry is the value of the Möbius function evaluated at <code class="docutils literal notranslate"><span class="pre">self.linear_extension()[i]</span></code> and <code class="docutils literal notranslate"><span class="pre">self.linear_extension()[j]</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.coxeter_transformation" title="sage.combinat.posets.posets.FinitePoset.coxeter_transformation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coxeter_transformation()</span></code></a></td>
<td>Return the matrix of the Auslander-Reiten translation acting on the Grothendieck group of the derived category of modules.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.coxeter_smith_form" title="sage.combinat.posets.posets.FinitePoset.coxeter_smith_form"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coxeter_smith_form()</span></code></a></td>
<td>Return the Smith form of the Coxeter transformation.</td>
</tr>
</tbody>
</table>
<p><strong>Miscellanous</strong></p>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.sorted" title="sage.combinat.posets.posets.FinitePoset.sorted"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sorted()</span></code></a></td>
<td>Return given list sorted by the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets" title="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isomorphic_subposets()</span></code></a></td>
<td>Return all subposets isomorphic to another poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator" title="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isomorphic_subposets_iterator()</span></code></a></td>
<td>Return an iterator over the subposets isomorphic to another poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_isomorphic_subposet" title="sage.combinat.posets.posets.FinitePoset.has_isomorphic_subposet"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_isomorphic_subposet()</span></code></a></td>
<td>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset contains a subposet isomorphic to another poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.list" title="sage.combinat.posets.posets.FinitePoset.list"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list()</span></code></a></td>
<td>List the elements of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.cuts" title="sage.combinat.posets.posets.FinitePoset.cuts"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cuts()</span></code></a></td>
<td>Return the cuts of the given poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.dilworth_decomposition" title="sage.combinat.posets.posets.FinitePoset.dilworth_decomposition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dilworth_decomposition()</span></code></a></td>
<td>Return a partition of the points into the minimal number of chains.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.greene_shape" title="sage.combinat.posets.posets.FinitePoset.greene_shape"><code class="xref py py-meth docutils literal notranslate"><span class="pre">greene_shape()</span></code></a></td>
<td>Computes the Greene-Kleitman partition aka Greene shape of the poset <code class="docutils literal notranslate"><span class="pre">self</span></code>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.incidence_algebra" title="sage.combinat.posets.posets.FinitePoset.incidence_algebra"><code class="xref py py-meth docutils literal notranslate"><span class="pre">incidence_algebra()</span></code></a></td>
<td>Return the incidence algebra of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_EL_labelling" title="sage.combinat.posets.posets.FinitePoset.is_EL_labelling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_EL_labelling()</span></code></a></td>
<td>Return whether <code class="docutils literal notranslate"><span class="pre">f</span></code> is an EL labelling of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator" title="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isomorphic_subposets_iterator()</span></code></a></td>
<td>Return an iterator over the subposets isomorphic to another poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets" title="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isomorphic_subposets()</span></code></a></td>
<td>Return all subposets isomorphic to another poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.level_sets" title="sage.combinat.posets.posets.FinitePoset.level_sets"><code class="xref py py-meth docutils literal notranslate"><span class="pre">level_sets()</span></code></a></td>
<td>Return elements grouped by maximal number of cover relations from a minimal element.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_complex" title="sage.combinat.posets.posets.FinitePoset.order_complex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_complex()</span></code></a></td>
<td>Return the order complex associated to this poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.random_order_ideal" title="sage.combinat.posets.posets.FinitePoset.random_order_ideal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">random_order_ideal()</span></code></a></td>
<td>Return a random order ideal of <code class="docutils literal notranslate"><span class="pre">self</span></code> with uniform probability.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.rank" title="sage.combinat.posets.posets.FinitePoset.rank"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rank()</span></code></a></td>
<td>Return the rank of an element, or the rank of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.rank_function" title="sage.combinat.posets.posets.FinitePoset.rank_function"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rank_function()</span></code></a></td>
<td>Return a rank function of the poset, if it exists.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.unwrap" title="sage.combinat.posets.posets.FinitePoset.unwrap"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unwrap()</span></code></a></td>
<td>Unwraps an element of this poset.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="classes-and-functions">
<h2>Classes and functions<a class="headerlink" href="#classes-and-functions" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="sage.combinat.posets.posets.FinitePoset">
<em class="property">class </em><code class="descclassname">sage.combinat.posets.posets.</code><code class="descname">FinitePoset</code><span class="sig-paren">(</span><em>hasse_diagram</em>, <em>elements</em>, <em>category</em>, <em>facade</em>, <em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Sage Reference Manual: Parents and Elements v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.unique_representation.UniqueRepresentation</span></code></a>, <a class="reference external" href="../../../../structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Sage Reference Manual: Parents and Elements v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.parent.Parent</span></code></a></p>
<p>A (finite) <span class="math notranslate nohighlight">\(n\)</span>-element poset constructed from a directed acyclic graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">hasse_diagram</span></code> – an instance of
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><code class="xref py py-class docutils literal notranslate"><span class="pre">FinitePoset</span></code></a>, or a
<a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraph</span></code></a> that is transitively-reduced, acyclic,
loop-free, and multiedge-free.</li>
<li><code class="docutils literal notranslate"><span class="pre">elements</span></code> – an optional list of elements, with <code class="docutils literal notranslate"><span class="pre">element[i]</span></code>
corresponding to vertex <code class="docutils literal notranslate"><span class="pre">i</span></code>. If <code class="docutils literal notranslate"><span class="pre">elements</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, then it is
set to be the vertex set of the digraph. Note that if this option is set,
then <code class="docutils literal notranslate"><span class="pre">elements</span></code> is considered as a specified linear extension of the poset
and the <span class="math notranslate nohighlight">\(linear_extension\)</span> attribute is set.</li>
<li><code class="docutils literal notranslate"><span class="pre">category</span></code> – <a class="reference external" href="../../../../categories/sage/categories/finite_posets.html#sage.categories.finite_posets.FinitePosets" title="(in Sage Reference Manual: Category Framework v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">FinitePosets</span></code></a>, or a subcategory thereof.</li>
<li><code class="docutils literal notranslate"><span class="pre">facade</span></code> – a boolean or <code class="docutils literal notranslate"><span class="pre">None</span></code> (default); whether the
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><code class="xref py py-class docutils literal notranslate"><span class="pre">FinitePoset</span></code></a>’s elements should be
wrapped to make them aware of the Poset they belong to.<ul>
<li>If <code class="docutils literal notranslate"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">True</span></code>, the
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><code class="xref py py-class docutils literal notranslate"><span class="pre">FinitePoset</span></code></a>’s elements are exactly
those given as input.</li>
<li>If <code class="docutils literal notranslate"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">False</span></code>, the
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><code class="xref py py-class docutils literal notranslate"><span class="pre">FinitePoset</span></code></a>’s elements will become
<code class="xref py py-class docutils literal notranslate"><span class="pre">PosetElement</span></code> objects.</li>
<li>If <code class="docutils literal notranslate"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">None</span></code> (default) the expected behaviour is the behaviour
of <code class="docutils literal notranslate"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">True</span></code>, unless the opposite can be deduced from the
context (i.e. for instance if a
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><code class="xref py py-class docutils literal notranslate"><span class="pre">FinitePoset</span></code></a> is built from another
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><code class="xref py py-class docutils literal notranslate"><span class="pre">FinitePoset</span></code></a>, itself built with
<code class="docutils literal notranslate"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">False</span></code>)</li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">key</span></code> – any hashable value (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>).</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">uc</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.posets.posets</span> <span class="kn">import</span> <span class="n">FinitePoset</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">FinitePoset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">(</span><span class="nb">dict</span><span class="p">([[</span><span class="n">i</span><span class="p">,</span><span class="n">uc</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uc</span><span class="p">))])),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">);</span> <span class="n">P</span>
<span class="go">Finite poset containing 6 elements</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[5, 4], [5, 3], [4, 1], [0, 2], [0, 3], [2, 1], [3, 1]]</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of finite enumerated posets</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="vm">__class__</span>
<span class="go">&lt;class &#39;sage.combinat.posets.posets.FinitePoset_with_category&#39;&gt;</span>

<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">combinat</span><span class="o">.</span><span class="n">posets</span><span class="o">.</span><span class="n">posets</span><span class="o">.</span><span class="n">FinitePoset</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">);</span> <span class="n">Q</span>
<span class="go">Finite poset containing 6 elements</span>

<span class="gp">sage: </span><span class="n">Q</span> <span class="ow">is</span> <span class="n">P</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We keep the same underlying Hasse diagram, but change the elements:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">combinat</span><span class="o">.</span><span class="n">posets</span><span class="o">.</span><span class="n">posets</span><span class="o">.</span><span class="n">FinitePoset</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">elements</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">);</span> <span class="n">Q</span>
<span class="go">Finite poset containing 6 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 5], [2, 6], [3, 4], [3, 5], [4, 6], [5, 6]]</span>
</pre></div>
</div>
<p>We test the facade argument:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">],</span><span class="s1">&#39;c&#39;</span><span class="p">:[</span><span class="s1">&#39;d&#39;</span><span class="p">]}),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of finite enumerated posets</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="n">P</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">],</span><span class="s1">&#39;c&#39;</span><span class="p">:[</span><span class="s1">&#39;d&#39;</span><span class="p">]}),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of facade finite enumerated posets</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">str</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">skip</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;_test_an_element&#39;</span><span class="p">])</span> <span class="c1"># is_parent_of is not yet implemented</span>
</pre></div>
</div>
<p>Changing a non facade poset to a facade poset:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">PQ</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">PQ</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of facade finite enumerated posets</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">PQ</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">str</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">PQ</span> <span class="ow">is</span> <span class="n">Q</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Changing a facade poset to a non facade poset:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QP</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">QP</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of finite enumerated posets</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">QP</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="n">QP</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A class that inherits from this class needs to define
<code class="docutils literal notranslate"><span class="pre">Element</span></code>. This is the class of the elements that the inheriting
class contains. For example, for this class, <code class="docutils literal notranslate"><span class="pre">FinitePoset</span></code>,
<code class="docutils literal notranslate"><span class="pre">Element</span></code> is <code class="docutils literal notranslate"><span class="pre">PosetElement</span></code>.  It can also define <code class="docutils literal notranslate"><span class="pre">_dual_class</span></code> which
is the class of dual posets of this
class. E.g. <code class="docutils literal notranslate"><span class="pre">FiniteMeetSemilattice._dual_class</span></code> is
<code class="docutils literal notranslate"><span class="pre">FiniteJoinSemilattice</span></code>.</p>
</div>
<dl class="attribute">
<dt id="sage.combinat.posets.posets.FinitePoset.Element">
<code class="descname">Element</code><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="elements.html#sage.combinat.posets.elements.PosetElement" title="sage.combinat.posets.elements.PosetElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.posets.elements.PosetElement</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.antichains">
<code class="descname">antichains</code><span class="sig-paren">(</span><em>element_constructor=&lt;type 'list'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.antichains" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the antichains of the poset.</p>
<p>An <em>antichain</em> of a poset is a set of elements of the
poset that are pairwise incomparable.</p>
<p>INPUT:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">element_constructor</span></code> – a function taking an iterable as
argument (default: <code class="docutils literal notranslate"><span class="pre">list</span></code>)</li>
</ul>
</div></blockquote>
<p>OUTPUT:</p>
<p>The enumerated set (of type
<a class="reference internal" href="../subsets_pairwise.html#sage.combinat.subsets_pairwise.PairwiseCompatibleSubsets" title="sage.combinat.subsets_pairwise.PairwiseCompatibleSubsets"><code class="xref py py-class docutils literal notranslate"><span class="pre">PairwiseCompatibleSubsets</span></code></a>)
of all antichains of the poset, each of which is given as an
<code class="docutils literal notranslate"><span class="pre">element_constructor.</span></code></p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">antichains</span><span class="p">();</span> <span class="n">A</span>
<span class="go">Set of antichains of Finite lattice containing 5 elements</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[[], [0], [1], [1, 2], [1, 3], [2], [3], [4]]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">8</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">[1, 2]</span>
</pre></div>
</div>
<p>To get the antichains as, say, sets, one may use the
<code class="docutils literal notranslate"><span class="pre">element_constructor</span></code> option:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">antichains</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">set</span><span class="p">))</span>
<span class="go">[set(), {0}, {1}, {2}]</span>
</pre></div>
</div>
<p>To get the antichains of a given size one can currently use:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">elements_of_depth_iterator</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[[1, 2], [1, 3]]</span>
</pre></div>
</div>
<p>Eventually the following syntax will be accepted:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">subset</span><span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># todo: not implemented</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Internally, this uses
<a class="reference internal" href="../subsets_pairwise.html#sage.combinat.subsets_pairwise.PairwiseCompatibleSubsets" title="sage.combinat.subsets_pairwise.PairwiseCompatibleSubsets"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.subsets_pairwise.PairwiseCompatibleSubsets</span></code></a>
and <code class="xref py py-class docutils literal notranslate"><span class="pre">SearchForest</span></code>. At this point, iterating
through this set is about twice slower than using
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains_iterator" title="sage.combinat.posets.posets.FinitePoset.antichains_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">antichains_iterator()</span></code></a> (tested on
<code class="docutils literal notranslate"><span class="pre">posets.AntichainPoset(15)</span></code>). The algorithm is the same
(depth first search through the tree), but
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains_iterator" title="sage.combinat.posets.posets.FinitePoset.antichains_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">antichains_iterator()</span></code></a> manually inlines things which
apparently avoids some infrastructure overhead.</p>
<p class="last">On the other hand, this returns a full featured enumerated
set, with containment testing, etc.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_antichains" title="sage.combinat.posets.posets.FinitePoset.maximal_antichains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximal_antichains()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.chains" title="sage.combinat.posets.posets.FinitePoset.chains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">chains()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.antichains_iterator">
<code class="descname">antichains_iterator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.antichains_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over the antichains of the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">antichains_iterator</span><span class="p">();</span> <span class="n">it</span>
<span class="go">&lt;generator object ...antichains_iterator at ...&gt;</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">([], [4])</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains" title="sage.combinat.posets.posets.FinitePoset.antichains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">antichains()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.bottom">
<code class="descname">bottom</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.bottom" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unique minimal element of the poset, if it exists.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span><span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">bottom</span><span class="p">()</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">bottom</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_bottom" title="sage.combinat.posets.posets.FinitePoset.has_bottom"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_bottom()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.top" title="sage.combinat.posets.posets.FinitePoset.top"><code class="xref py py-meth docutils literal notranslate"><span class="pre">top()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.canonical_label">
<code class="descname">canonical_label</code><span class="sig-paren">(</span><em>algorithm=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.canonical_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unique poset on the labels <span class="math notranslate nohighlight">\(\{0, \ldots, n-1\}\)</span> (where <span class="math notranslate nohighlight">\(n\)</span>
is the number of elements in the poset) that is isomorphic to this
poset and invariant in the isomorphism class.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (optional); a parameter forwarded
to underlying graph function to select the algorithm to use</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
<span class="go">[0, 1, 2, 3, 4, 5]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Canonical labeling of (semi)lattice returns (semi)lattice:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ML</span> <span class="o">=</span> <span class="n">MeetSemilattice</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">()</span>
<span class="go">Finite poset containing 3 elements</span>
<span class="gp">sage: </span><span class="n">ML</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">()</span>
<span class="go">Finite meet-semilattice containing 3 elements</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li>Canonical labeling of directed graphs:
<a class="reference external" href="../../../../graphs/sage/graphs/generic_graph.html#sage.graphs.generic_graph.GenericGraph.canonical_label" title="(in Sage Reference Manual: Graph Theory v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_label()</span></code></a></li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.cardinality">
<code class="descname">cardinality</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.cardinality" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of elements in the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[]])</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">5</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.degree_polynomial" title="sage.combinat.posets.posets.FinitePoset.degree_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">degree_polynomial()</span></code></a> for a more refined invariant</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.chain_polynomial">
<code class="descname">chain_polynomial</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.chain_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chain polynomial of the poset.</p>
<p>The coefficient of <span class="math notranslate nohighlight">\(q^k\)</span> is the number of chains of <span class="math notranslate nohighlight">\(k\)</span>
elements in the poset. List of coefficients of this polynomial
is also called a <em>f-vector</em> of the poset.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is not what has been called the chain polynomial
in <a class="reference internal" href="../../../../references/index.html#st1986" id="id1">[St1986]</a>. The latter is identical with the order
polynomial in SageMath (<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_polynomial" title="sage.combinat.posets.posets.FinitePoset.order_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_polynomial()</span></code></a>).</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.f_polynomial" title="sage.combinat.posets.posets.FinitePoset.f_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">f_polynomial()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_polynomial" title="sage.combinat.posets.posets.FinitePoset.order_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_polynomial()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">chain_polynomial</span><span class="p">();</span> <span class="n">t</span>
<span class="go">q^3 + 3*q^2 + 3*q + 1</span>
<span class="gp">sage: </span><span class="n">t</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">chains</span><span class="p">()))</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">chain_polynomial</span><span class="p">()</span>
<span class="go">6*q^4 + 18*q^3 + 19*q^2 + 8*q + 1</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">chain_polynomial</span><span class="p">()</span>
<span class="go">5*q + 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.chain_polytope">
<code class="descname">chain_polytope</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.chain_polytope" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chain polytope of the poset <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The chain polytope of a finite poset <span class="math notranslate nohighlight">\(P\)</span> is defined as the subset
of <span class="math notranslate nohighlight">\(\RR^P\)</span> consisting of all maps <span class="math notranslate nohighlight">\(x : P \to \RR\)</span> satisfying</p>
<div class="math notranslate nohighlight">
\[x(p) \geq 0 \mbox{ for all } p \in P,\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[x(p_1) + x(p_2) + \ldots + x(p_k) \leq 1
\mbox{ for all chains } p_1 &lt; p_2 &lt; \ldots &lt; p_k
\mbox{ in } P.\]</div>
<p>This polytope was defined and studied in <a class="reference internal" href="../../../../references/index.html#st1986" id="id2">[St1986]</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">chain_polytope</span><span class="p">();</span><span class="n">Q</span>
<span class="go">A 3-dimensional polyhedron in ZZ^3 defined as the convex hull of 8 vertices</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">chain_polytope</span><span class="p">();</span><span class="n">Q</span>
<span class="go">A 5-dimensional polyhedron in ZZ^5 defined as the convex hull of 8 vertices</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.chains">
<code class="descname">chains</code><span class="sig-paren">(</span><em>element_constructor=&lt;type 'list'&gt;</em>, <em>exclude=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.chains" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chains of the poset.</p>
<p>A <em>chain</em> of a poset is a set of elements of the poset
that are pairwise comparable.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">element_constructor</span></code> – a function taking an iterable as
argument (default: <code class="docutils literal notranslate"><span class="pre">list</span></code>)</li>
<li><code class="docutils literal notranslate"><span class="pre">exclude</span></code> – elements of the poset to be excluded
(default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</li>
</ul>
<p>OUTPUT:</p>
<p>The enumerated set (of type
<a class="reference internal" href="../subsets_pairwise.html#sage.combinat.subsets_pairwise.PairwiseCompatibleSubsets" title="sage.combinat.subsets_pairwise.PairwiseCompatibleSubsets"><code class="xref py py-class docutils literal notranslate"><span class="pre">PairwiseCompatibleSubsets</span></code></a>)
of all chains of the poset, each of which is given as an
<code class="docutils literal notranslate"><span class="pre">element_constructor</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">chains</span><span class="p">();</span> <span class="n">C</span>
<span class="go">Set of chains of Finite lattice containing 5 elements</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">[[], [0], [0, 1], [0, 1, 4], [0, 2], [0, 2, 3], [0, 2, 3, 4], [0, 2, 4], [0, 3], [0, 3, 4], [0, 4], [1], [1, 4], [2], [2, 3], [2, 3, 4], [2, 4], [3], [3, 4], [4]]</span>
</pre></div>
</div>
<p>Exclusion of elements, tuple (instead of list) as constructor:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">chains</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">[(), (1,), (1, 2), (1, 2, 4), (1, 4), (1, 5), (2,), (2, 4), (4,), (5,)]</span>
</pre></div>
</div>
<p>To get the chains of a given size one can currently use:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">elements_of_depth_iterator</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[[0, 1], [0, 2], [0, 3], [0, 4], [1, 4], [2, 3], [2, 4], [3, 4]]</span>
</pre></div>
</div>
<p>Eventually the following syntax will be accepted:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">subset</span><span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># todo: not implemented</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_chains" title="sage.combinat.posets.posets.FinitePoset.maximal_chains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximal_chains()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains" title="sage.combinat.posets.posets.FinitePoset.antichains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">antichains()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.characteristic_polynomial">
<code class="descname">characteristic_polynomial</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.characteristic_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the characteristic polynomial of the poset.</p>
<p>The poset is expected to be graded and have a bottom
element.</p>
<p>If <span class="math notranslate nohighlight">\(P\)</span> is a graded poset with rank <span class="math notranslate nohighlight">\(n\)</span> and a unique minimal
element <span class="math notranslate nohighlight">\(\hat{0}\)</span>, then the characteristic polynomial of
<span class="math notranslate nohighlight">\(P\)</span> is defined to be</p>
<div class="math notranslate nohighlight">
\[\sum_{x \in P} \mu(\hat{0}, x) q^{n-\rho(x)} \in \ZZ[q],\]</div>
<p>where <span class="math notranslate nohighlight">\(\rho\)</span> is the rank function, and <span class="math notranslate nohighlight">\(\mu\)</span> is the Möbius
function of <span class="math notranslate nohighlight">\(P\)</span>.</p>
<p>See section 3.10 of <a class="reference internal" href="../../../../references/index.html#enumcomb1" id="id3">[EnumComb1]</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">characteristic_polynomial</span><span class="p">()</span>
<span class="go">q^2 - 3*q + 2</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">characteristic_polynomial</span><span class="p">()</span>
<span class="go">q^4 - 2*q^3 + q</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.closed_interval">
<code class="descname">closed_interval</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.closed_interval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of elements <span class="math notranslate nohighlight">\(z\)</span> such that <span class="math notranslate nohighlight">\(x \le z \le y\)</span> in the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">closed_interval</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="go">[2, 4, 10, 20, 50, 100]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.open_interval" title="sage.combinat.posets.posets.FinitePoset.open_interval"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open_interval()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.comparability_graph">
<code class="descname">comparability_graph</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.comparability_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the comparability graph of the poset.</p>
<p>The comparability graph is an undirected graph where vertices
are the elements of the poset and there is an edge between two
vertices if they are comparable in the poset.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Comparability_graph">Wikipedia article Comparability_graph</a></p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">comparability_graph</span><span class="p">();</span> <span class="n">g</span>
<span class="go">Comparability graph on 4 vertices</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">compare_elements</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.incomparability_graph" title="sage.combinat.posets.posets.FinitePoset.incomparability_graph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">incomparability_graph()</span></code></a>, <a class="reference external" href="../../../../graphs/sage/graphs/comparability.html#module-sage.graphs.comparability" title="(in Sage Reference Manual: Graph Theory v8.9)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.graphs.comparability</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.compare_elements">
<code class="descname">compare_elements</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.compare_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> in the poset.</p>
<ul class="simple">
<li>If <span class="math notranslate nohighlight">\(x &lt; y\)</span>, return <code class="docutils literal notranslate"><span class="pre">-1</span></code>.</li>
<li>If <span class="math notranslate nohighlight">\(x = y\)</span>, return <code class="docutils literal notranslate"><span class="pre">0</span></code>.</li>
<li>If <span class="math notranslate nohighlight">\(x &gt; y\)</span>, return <code class="docutils literal notranslate"><span class="pre">1</span></code>.</li>
<li>If <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> are not comparable, return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">compare_elements</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">compare_elements</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">compare_elements</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">compare_elements</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.completion_by_cuts">
<code class="descname">completion_by_cuts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.completion_by_cuts" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the completion by cuts of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This is the smallest lattice containing the poset. This is also
called the Dedekind-MacNeille completion.</p>
<p>See the <a class="reference external" href="https://en.wikipedia.org/wiki/Dedekind-MacNeille completion">Wikipedia article Dedekind-MacNeille completion</a>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>a finite lattice</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">completion_by_cuts</span><span class="p">()</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">trafficsign</span> <span class="o">=</span> <span class="n">LatticePoset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">completion_by_cuts</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">trafficsign</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">SymmetricGroupBruhatOrderPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">completion_by_cuts</span><span class="p">();</span> <span class="n">Q</span>
<span class="go">Finite lattice containing 7 elements</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.cuts" title="sage.combinat.posets.posets.FinitePoset.cuts"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cuts()</span></code></a>,
<a class="reference external" href="../../../../categories/sage/categories/finite_lattice_posets.html#sage.categories.finite_lattice_posets.FiniteLatticePosets.ParentMethods.irreducibles_poset" title="(in Sage Reference Manual: Category Framework v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">irreducibles_poset()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.connected_components">
<code class="descname">connected_components</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.connected_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the connected components of the poset as subposets.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">parts</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">);</span> <span class="n">parts</span>
<span class="go">[Finite poset containing 3 elements,</span>
<span class="go"> Finite poset containing 5 elements]</span>
<span class="gp">sage: </span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[6, 7], [6, 8]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.disjoint_union" title="sage.combinat.posets.posets.FinitePoset.disjoint_union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">disjoint_union()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_connected" title="sage.combinat.posets.posets.FinitePoset.is_connected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_connected()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.cover_relations">
<code class="descname">cover_relations</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.cover_relations" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of pairs <code class="docutils literal notranslate"><span class="pre">[x,</span> <span class="pre">y]</span></code> of elements of the poset such
that <code class="docutils literal notranslate"><span class="pre">y</span></code> covers <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [0, 2], [2, 3], [3, 4]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.cover_relations_graph">
<code class="descname">cover_relations_graph</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.cover_relations_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the (undirected) graph of cover relations.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">cover_relations_graph</span><span class="p">();</span> <span class="n">G</span>
<span class="go">Graph on 4 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">(True, False)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.hasse_diagram" title="sage.combinat.posets.posets.FinitePoset.hasse_diagram"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hasse_diagram()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.cover_relations_iterator">
<code class="descname">cover_relations_iterator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.cover_relations_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over the cover relations of the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations_iterator</span><span class="p">())</span>
<span class="go">&lt;... &#39;generator&#39;&gt;</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">z</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">cover_relations_iterator</span><span class="p">()]</span>
<span class="go">[[1, 2], [0, 2], [2, 3], [3, 4]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.covers">
<code class="descname">covers</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.covers" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">y</span></code> covers <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>Element <span class="math notranslate nohighlight">\(y\)</span> covers <span class="math notranslate nohighlight">\(x\)</span> if <span class="math notranslate nohighlight">\(x &lt; y\)</span> and there is no <span class="math notranslate nohighlight">\(z\)</span> such that
<span class="math notranslate nohighlight">\(x &lt; z &lt; y\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.coxeter_polynomial">
<code class="descname">coxeter_polynomial</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.coxeter_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Coxeter polynomial of the poset.</p>
<p>OUTPUT:</p>
<p>a polynomial in one variable</p>
<p>The output is the characteristic polynomial of the Coxeter
transformation. This polynomial only depends on the derived
category of modules on the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">coxeter_polynomial</span><span class="p">()</span>
<span class="go">x^5 + x^4 + x + 1</span>

<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">SymmetricGroupWeakOrderPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">coxeter_polynomial</span><span class="p">()</span>
<span class="go">x^6 + x^5 - x^3 + x + 1</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.coxeter_transformation" title="sage.combinat.posets.posets.FinitePoset.coxeter_transformation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coxeter_transformation()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.coxeter_smith_form" title="sage.combinat.posets.posets.FinitePoset.coxeter_smith_form"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coxeter_smith_form()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.coxeter_smith_form">
<code class="descname">coxeter_smith_form</code><span class="sig-paren">(</span><em>algorithm='singular'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.coxeter_smith_form" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Smith normal form of <span class="math notranslate nohighlight">\(x\)</span> minus the Coxeter transformation
matrix.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – optional (default <code class="docutils literal notranslate"><span class="pre">'singular'</span></code>), possible
values are <code class="docutils literal notranslate"><span class="pre">'singular'</span></code>, <code class="docutils literal notranslate"><span class="pre">'sage'</span></code>, <code class="docutils literal notranslate"><span class="pre">'gap'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'pari'</span></code>, <code class="docutils literal notranslate"><span class="pre">'maple'</span></code>, <code class="docutils literal notranslate"><span class="pre">'magma'</span></code>, <code class="docutils literal notranslate"><span class="pre">'fricas'</span></code></li>
</ul>
<p>Beware that speed depends very much on the choice of
algorithm. Sage is rather slow, Singular is faster and Pari is
fast at least for small sizes.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>list of polynomials in one variable, each one dividing the next one</li>
</ul>
<p>The output list is a refinement of the characteristic polynomial of
the Coxeter transformation, which is its product. This list
of polynomials only depends on the derived category of modules
on the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">coxeter_smith_form</span><span class="p">()</span>
<span class="go">[1, 1, 1, 1, x^5 + x^4 + x + 1]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">prod</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">coxeter_smith_form</span><span class="p">())</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">coxeter_polynomial</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.coxeter_transformation" title="sage.combinat.posets.posets.FinitePoset.coxeter_transformation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coxeter_transformation()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">coxeter_matrix()</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.coxeter_transformation">
<code class="descname">coxeter_transformation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.coxeter_transformation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Coxeter transformation of the poset.</p>
<p>OUTPUT:</p>
<p>a square matrix with integer coefficients</p>
<p>The output is the matrix of the Auslander-Reiten translation
acting on the Grothendieck group of the derived category of
modules on the poset, in the basis of simple
modules. This matrix is usually called the Coxeter
transformation.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">coxeter_transformation</span><span class="p">()</span>
<span class="go">[ 0  0  0  0 -1]</span>
<span class="go">[ 0  0  0  1 -1]</span>
<span class="go">[ 0  1  0  0 -1]</span>
<span class="go">[-1  1  1  0 -1]</span>
<span class="go">[-1  1  0  1 -1]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.coxeter_polynomial" title="sage.combinat.posets.posets.FinitePoset.coxeter_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coxeter_polynomial()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.coxeter_smith_form" title="sage.combinat.posets.posets.FinitePoset.coxeter_smith_form"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coxeter_smith_form()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.cuts">
<code class="descname">cuts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.cuts" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of cuts of the poset <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>A cut is a subset <span class="math notranslate nohighlight">\(A\)</span> of <code class="docutils literal notranslate"><span class="pre">self</span></code> such that the set of lower
bounds of the set of upper bounds of <span class="math notranslate nohighlight">\(A\)</span> is exactly <span class="math notranslate nohighlight">\(A\)</span>.</p>
<p>The cuts are computed here using the maximal independent sets in the
auxiliary graph defined as <span class="math notranslate nohighlight">\(P \times [0,1]\)</span> with an edge
from <span class="math notranslate nohighlight">\((x, 0)\)</span> to <span class="math notranslate nohighlight">\((y, 1)\)</span> if
and only if <span class="math notranslate nohighlight">\(x \not\geq_P y\)</span>. See the end of section 4 in <a class="reference internal" href="../../../../references/index.html#jrj94" id="id4">[JRJ94]</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Pc</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">cuts</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">Pc</span><span class="p">]</span>
<span class="go">[[0], [], [0, 1, 2], [2], [1]]</span>
<span class="gp">sage: </span><span class="n">Pc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">frozenset({0})</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.completion_by_cuts" title="sage.combinat.posets.posets.FinitePoset.completion_by_cuts"><code class="xref py py-meth docutils literal notranslate"><span class="pre">completion_by_cuts()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.degree_polynomial">
<code class="descname">degree_polynomial</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.degree_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the generating polynomial of degrees of vertices in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This is the sum</p>
<div class="math notranslate nohighlight">
\[\sum_{v \in P} x^{\operatorname{in}(v)} y^{\operatorname{out}(v)},\]</div>
<p>where <code class="docutils literal notranslate"><span class="pre">in(v)</span></code> and <code class="docutils literal notranslate"><span class="pre">out(v)</span></code> are the number of incoming and
outgoing edges at vertex <span class="math notranslate nohighlight">\(v\)</span> in the Hasse diagram of <span class="math notranslate nohighlight">\(P\)</span>.</p>
<p>Because this polynomial is multiplicative for Cartesian
product of posets, it is useful to help see if the poset can
be isomorphic to a Cartesian product.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">degree_polynomial</span><span class="p">()</span>
<span class="go">x^2 + 3*x*y + y^2</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">degree_polynomial</span><span class="p">()</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">(x + y)^4</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.cardinality" title="sage.combinat.posets.posets.FinitePoset.cardinality"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cardinality()</span></code></a> for the value at <span class="math notranslate nohighlight">\((x, y) = (1, 1)\)</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.dilworth_decomposition">
<code class="descname">dilworth_decomposition</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.dilworth_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a partition of the points into the minimal number of chains.</p>
<p>According to Dilworth’s theorem, the points of a poset can be
partitioned into <span class="math notranslate nohighlight">\(\alpha\)</span> chains, where <span class="math notranslate nohighlight">\(\alpha\)</span> is the cardinality of
its largest antichain. This method returns such a partition.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Dilworth's_theorem">Wikipedia article Dilworth’s_theorem</a>.</p>
<p>ALGORITHM:</p>
<p>We build a bipartite graph in which a vertex <span class="math notranslate nohighlight">\(v\)</span> of the poset is
represented by two vertices <span class="math notranslate nohighlight">\(v^-,v^+\)</span>. For any two <span class="math notranslate nohighlight">\(u,v\)</span> such that
<span class="math notranslate nohighlight">\(u&lt;v\)</span> in the poset we add an edge <span class="math notranslate nohighlight">\(v^+u^-\)</span>.</p>
<p>A matching in this graph is equivalent to a partition of the poset
into chains: indeed, a chain <span class="math notranslate nohighlight">\(v_1...v_k\)</span> gives rise to the matching
<span class="math notranslate nohighlight">\(v_1^+v_2^-,v_2^+v_3^-,...\)</span>, and from a matching one can build the
union of chains.</p>
<p>According to Dilworth’s theorem, the number of chains is equal to
<span class="math notranslate nohighlight">\(\alpha\)</span> (the posets’ width).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">width</span><span class="p">()</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">dilworth_decomposition</span><span class="p">()</span>  <span class="c1"># random</span>
<span class="go">[[7, 6, 4], [11, 3], [12, 8, 0], [13, 9, 1], [14, 10, 2], [15, 5]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.level_sets" title="sage.combinat.posets.posets.FinitePoset.level_sets"><code class="xref py py-meth docutils literal notranslate"><span class="pre">level_sets()</span></code></a> to return elements grouped to antichains.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.dimension">
<code class="descname">dimension</code><span class="sig-paren">(</span><em>certificate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dimension of the Poset.</p>
<p>The (Dushnik-Miller) dimension of a poset is the minimal
number of total orders so that the poset is their
“intersection”.  More precisely, the dimension of a poset
defined on a set <span class="math notranslate nohighlight">\(X\)</span> of points is the smallest integer <span class="math notranslate nohighlight">\(n\)</span>
such that there exist linear extensions <span class="math notranslate nohighlight">\(P_1,...,P_n\)</span> of <span class="math notranslate nohighlight">\(P\)</span>
satisfying:</p>
<div class="math notranslate nohighlight">
\[u\leq_P v\ \text{if and only if }\ \forall i, u\leq_{P_i} v\]</div>
<p>For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Order_dimension">Wikipedia article Order_dimension</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">certificate</span></code> (boolean; default:<code class="docutils literal notranslate"><span class="pre">False</span></code>) – whether to return an
integer (the dimension) or a certificate, i.e. a smallest set of
linear extensions.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The speed of this function greatly improves when more efficient
MILP solvers (e.g. Gurobi, CPLEX) are installed. See
<a class="reference external" href="../../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a> for more information.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Prior to version 8.3 this returned only realizer with
<code class="docutils literal notranslate"><span class="pre">certificate=True</span></code>. Now it returns a pair having a realizer as
the second element. See <a class="reference external" href="https://trac.sagemath.org/25588">trac ticket #25588</a> for details.</p>
</div>
<p>ALGORITHM:</p>
<p>As explained <a class="reference internal" href="../../../../references/index.html#ft00" id="id5">[FT00]</a>, the dimension of a poset is equal to the (weak)
chromatic number of a hypergraph. More precisely:</p>
<blockquote>
<div><p>Let <span class="math notranslate nohighlight">\(inc(P)\)</span> be the set of (ordered) pairs of incomparable elements
of <span class="math notranslate nohighlight">\(P\)</span>, i.e. all <span class="math notranslate nohighlight">\(uv\)</span> and <span class="math notranslate nohighlight">\(vu\)</span> such that <span class="math notranslate nohighlight">\(u\not \leq_P v\)</span> and <span class="math notranslate nohighlight">\(v\not
\leq_P u\)</span>. Any linear extension of <span class="math notranslate nohighlight">\(P\)</span> is a total order on <span class="math notranslate nohighlight">\(X\)</span> that
can be seen as the union of relations from <span class="math notranslate nohighlight">\(P\)</span> along with some
relations from <span class="math notranslate nohighlight">\(inc(P)\)</span>. Thus, the dimension of <span class="math notranslate nohighlight">\(P\)</span> is the smallest
number of linear extensions of <span class="math notranslate nohighlight">\(P\)</span> which <em>cover</em> all points of
<span class="math notranslate nohighlight">\(inc(P)\)</span>.</p>
<p>Consequently, <span class="math notranslate nohighlight">\(dim(P)\)</span> is equal to the chromatic number of the
hypergraph <span class="math notranslate nohighlight">\(\mathcal H_{inc}\)</span>, where <span class="math notranslate nohighlight">\(\mathcal H_{inc}\)</span> is the
hypergraph defined on <span class="math notranslate nohighlight">\(inc(P)\)</span> whose sets are all <span class="math notranslate nohighlight">\(S\subseteq
inc(P)\)</span> such that <span class="math notranslate nohighlight">\(P\cup S\)</span> is not acyclic.</p>
</div></blockquote>
<p>We solve this problem through a <a class="reference external" href="../../../../numerical/sage/numerical/mip.html#module-sage.numerical.mip" title="(in Sage Reference Manual: Numerical Optimization v8.9)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Mixed</span> <span class="pre">Integer</span> <span class="pre">Linear</span> <span class="pre">Program</span></code></a>.</p>
<p>The problem is known to be NP-complete.</p>
<p>EXAMPLES:</p>
<p>We create a poset, compute a set of linear extensions and check
that we get back the poset from them:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="p">[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">dim</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">dimension</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span>  <span class="c1"># random -- architecture-dependent</span>
<span class="go">[[0, 2, 4, 5, 1, 3, 6], [2, 5, 0, 1, 3, 4, 6], [0, 1, 2, 3, 5, 6, 4]]</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">(</span> <span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">all</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">l</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">L</span><span class="p">))</span> <span class="p">)</span> <span class="o">==</span> <span class="n">P</span>
<span class="go">True</span>
</pre></div>
</div>
<p>According to Schnyder’s theorem, the incidence poset (of
height 2) of a graph has dimension <span class="math notranslate nohighlight">\(\leq 3\)</span> if and only if
the graph is planar:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">({(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">):[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()}))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">3</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">({(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">):[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()}))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="c1"># not tested - around 4s with CPLEX</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.disjoint_union">
<code class="descname">disjoint_union</code><span class="sig-paren">(</span><em>other</em>, <em>labels='pairs'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.disjoint_union" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a poset isomorphic to disjoint union (also called direct
sum) of the poset with <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>The disjoint union of <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> is a poset that contains
every element and relation from both <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span>, and where
every element of <span class="math notranslate nohighlight">\(P\)</span> is incomparable to every element of <span class="math notranslate nohighlight">\(Q\)</span>.</p>
<p>Mathematically, it is only defined when <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> have no
common element; here we force that by giving them different
names in the resulting poset.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">other</span></code>, a poset.</li>
<li><code class="docutils literal notranslate"><span class="pre">labels</span></code> - (defaults to ‘pairs’) If set to ‘pairs’, each
element <code class="docutils literal notranslate"><span class="pre">v</span></code> in this poset will be named <code class="docutils literal notranslate"><span class="pre">(0,v)</span></code> and each
element <code class="docutils literal notranslate"><span class="pre">u</span></code> in <code class="docutils literal notranslate"><span class="pre">other</span></code> will be named <code class="docutils literal notranslate"><span class="pre">(1,u)</span></code> in the
result. If set to ‘integers’, the elements of the result
will be relabeled with consecutive integers.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="s1">&#39;b&#39;</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="s1">&#39;d&#39;</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">P2</span><span class="p">);</span> <span class="n">P</span>
<span class="go">Finite poset containing 4 elements</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span>
<span class="go">[[(0, &#39;a&#39;), (0, &#39;b&#39;)], [(1, &#39;c&#39;), (1, &#39;d&#39;)]]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">P2</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="s1">&#39;integers&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[2, 3], [0, 1]]</span>

<span class="gp">sage: </span><span class="n">N5</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">();</span> <span class="n">N5</span>
<span class="go">Finite lattice containing 5 elements</span>
<span class="gp">sage: </span><span class="n">N5</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">N5</span><span class="p">)</span>  <span class="c1"># Union of lattices is not a lattice</span>
<span class="go">Finite poset containing 10 elements</span>
</pre></div>
</div>
<p>We show how to get literally direct sum with elements untouched:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">P2</span><span class="p">)</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span>
<span class="go">[[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.connected_components" title="sage.combinat.posets.posets.FinitePoset.connected_components"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connected_components()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.dual">
<code class="descname">dual</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.dual" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dual poset of the given poset.</p>
<p>In the dual of a poset <span class="math notranslate nohighlight">\(P\)</span> we have <span class="math notranslate nohighlight">\(x \le y\)</span> iff <span class="math notranslate nohighlight">\(y \le x\)</span> in <span class="math notranslate nohighlight">\(P\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [3, 4]]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[4, 3], [3, 1], [2, 1]]</span>
</pre></div>
</div>
<p>Dual of a lattice is a lattice; dual of a meet-semilattice is
join-semilattice and vice versa. Also the dual of a (non-)facade poset
is again (non-)facade:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">MeetSemilattice</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]},</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">dual</span><span class="p">();</span> <span class="n">A</span>
<span class="go">Finite join-semilattice containing 3 elements</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference external" href="../../../../categories/sage/categories/finite_posets.html#sage.categories.finite_posets.FinitePosets.ParentMethods.is_self_dual" title="(in Sage Reference Manual: Category Framework v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_self_dual()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.evacuation">
<code class="descname">evacuation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.evacuation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute evacuation on the linear extension associated
to the poset <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>an isomorphic poset, with the same default linear extension</li>
</ul>
<p>Evacuation is defined on a poset <code class="docutils literal notranslate"><span class="pre">self</span></code> of size <span class="math notranslate nohighlight">\(n\)</span> by
applying the evacuation operator
<span class="math notranslate nohighlight">\((\tau_1 \cdots \tau_{n-1}) (\tau_1 \cdots \tau_{n-2}) \cdots (\tau_1)\)</span>,
to the default linear extension <span class="math notranslate nohighlight">\(\pi\)</span> of <code class="docutils literal notranslate"><span class="pre">self</span></code>
(see <a class="reference internal" href="linear_extensions.html#sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.evacuation" title="sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.evacuation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">evacuation()</span></code></a>),
and relabeling <code class="docutils literal notranslate"><span class="pre">self</span></code> accordingly. For more details see <a class="reference internal" href="../../../../references/index.html#stan2009" id="id6">[Stan2009]</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]]),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">evacuation</span><span class="p">()</span>
<span class="go">Finite poset containing 2 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">evacuation</span><span class="p">()</span> <span class="o">==</span> <span class="n">P</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">evacuation</span><span class="p">();</span> <span class="n">Q</span>
<span class="go">Finite poset containing 7 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [2, 5], [3, 4], [3, 6], [4, 7], [6, 7]]</span>
</pre></div>
</div>
<p>Note that the results depend on the linear extension associated
to the poset:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 5, 6, 4, 7]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">evacuation</span><span class="p">();</span> <span class="n">Q</span>
<span class="go">Finite poset containing 7 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 5], [2, 3], [5, 6], [5, 4], [6, 7], [4, 7]]</span>
</pre></div>
</div>
<p>Here is an example of a poset where the elements are not labelled
by <span class="math notranslate nohighlight">\(\{1,2,\ldots,n\}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 3, 5, 15]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">evacuation</span><span class="p">();</span> <span class="n">Q</span>
<span class="go">Finite poset containing 4 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 3], [1, 5], [3, 15], [5, 15]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extension" title="sage.combinat.posets.posets.FinitePoset.linear_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">linear_extension()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.with_linear_extension" title="sage.combinat.posets.posets.FinitePoset.with_linear_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">with_linear_extension()</span></code></a> and the <code class="docutils literal notranslate"><span class="pre">linear_extension</span></code> option of <a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><code class="xref py py-func docutils literal notranslate"><span class="pre">Poset()</span></code></a></li>
<li><a class="reference internal" href="linear_extensions.html#sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.evacuation" title="sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.evacuation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">evacuation()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.promotion" title="sage.combinat.posets.posets.FinitePoset.promotion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">promotion()</span></code></a></li>
</ul>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li>Anne Schilling (2012-02-18)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.f_polynomial">
<code class="descname">f_polynomial</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.f_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <span class="math notranslate nohighlight">\(f\)</span>-polynomial of the poset.</p>
<p>The poset is expected to be bounded.</p>
<p>This is the <span class="math notranslate nohighlight">\(f\)</span>-polynomial of the order complex of the poset
minus its bounds.</p>
<p>The coefficient of <span class="math notranslate nohighlight">\(q^i\)</span> is the number of chains of
<span class="math notranslate nohighlight">\(i+1\)</span> elements containing both bounds of the poset.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is slightly different from the <code class="docutils literal notranslate"><span class="pre">fPolynomial</span></code>
method in Macaulay2.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">f_polynomial</span><span class="p">()</span>
<span class="go">3*q^2 + q</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">f_polynomial</span><span class="p">()</span>
<span class="go">q^4 + 4*q^3 + 5*q^2 + q</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="sage.combinat.posets.posets.FinitePoset.is_bounded"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_bounded()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.h_polynomial" title="sage.combinat.posets.posets.FinitePoset.h_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">h_polynomial()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_complex" title="sage.combinat.posets.posets.FinitePoset.order_complex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_complex()</span></code></a>,
<a class="reference external" href="../../../../homology/sage/homology/cell_complex.html#sage.homology.cell_complex.GenericCellComplex.f_vector" title="(in Sage Reference Manual: Cell complexes and their homology v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.homology.cell_complex.GenericCellComplex.f_vector()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.factor">
<code class="descname">factor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Factor the poset as a Cartesian product of smaller posets.</p>
<p>This only works for connected posets for the moment.</p>
<p>The decomposition of a connected poset as a Cartesian product
of posets (prime in the sense that they cannot be written as
Cartesian products) is unique up to reordering and
isomorphism.</p>
<p>OUTPUT:</p>
<p>a list of posets</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">P</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">[Finite poset containing 5 elements,</span>
<span class="go">Finite poset containing 5 elements]</span>

<span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P1</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">[Finite lattice containing 3 elements]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">P1</span> <span class="o">*</span> <span class="n">P2</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">[Finite poset containing 7 elements,</span>
<span class="go">Finite poset containing 3 elements]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">TamariLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">P</span><span class="o">*</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">[Finite poset containing 14 elements,</span>
<span class="go">Finite poset containing 14 elements]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.product" title="sage.combinat.posets.posets.FinitePoset.product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">product()</span></code></a></p>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="feig1986" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Feig1986]</td><td>Joan Feigenbaum, <em>Directed Cartesian-Product Graphs
have Unique Factorizations that can be computed in Polynomial Time</em>,
Discrete Applied Mathematics 15 (1986) 105-110
<a class="reference external" href="https://doi.org/10.1016/0166-218X(86)90023-5">doi:10.1016/0166-218X(86)90023-5</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.flag_f_polynomial">
<code class="descname">flag_f_polynomial</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.flag_f_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the flag <span class="math notranslate nohighlight">\(f\)</span>-polynomial of the poset.</p>
<p>The poset is expected to be bounded and ranked.</p>
<p>This is the sum, over all chains containing both bounds,
of a monomial encoding the ranks of the elements of the chain.</p>
<p>More precisely, if <span class="math notranslate nohighlight">\(P\)</span> is a bounded ranked poset, then the
flag <span class="math notranslate nohighlight">\(f\)</span>-polynomial of <span class="math notranslate nohighlight">\(P\)</span> is defined as the polynomial</p>
<div class="math notranslate nohighlight">
\[\begin{split}\sum_{\substack{p_0 &lt; p_1 &lt; \ldots &lt; p_k, \\
                p_0 = \min P, \ p_k = \max P}}
x_{\rho(p_1)} x_{\rho(p_2)} \cdots x_{\rho(p_k)}
\in \ZZ[x_1, x_2, \cdots, x_n]\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\min P\)</span> and <span class="math notranslate nohighlight">\(\max P\)</span> are (respectively) the minimum and
the maximum of <span class="math notranslate nohighlight">\(P\)</span>, where <span class="math notranslate nohighlight">\(\rho\)</span> is the rank function of <span class="math notranslate nohighlight">\(P\)</span>
(normalized to satisfy <span class="math notranslate nohighlight">\(\rho(\min P) = 0\)</span>), and where
<span class="math notranslate nohighlight">\(n\)</span> is the rank of <span class="math notranslate nohighlight">\(\max P\)</span>. (Note that the indeterminate
<span class="math notranslate nohighlight">\(x_0\)</span> doesn’t actually appear in the polynomial.)</p>
<p>For technical reasons, the polynomial is returned in the
slightly larger ring <span class="math notranslate nohighlight">\(\ZZ[x_0, x_1, x_2, \cdots, x_{n+1}]\)</span> by
this method.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/h-vector">Wikipedia article h-vector</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">flag_f_polynomial</span><span class="p">()</span>
<span class="go">3*x1*x2 + x2</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">fl</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">flag_f_polynomial</span><span class="p">();</span> <span class="n">fl</span>
<span class="go">2*x1*x2*x3 + 2*x1*x3 + 2*x2*x3 + x3</span>
<span class="gp">sage: </span><span class="n">q</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span><span class="s1">&#39;q&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fl</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="p">)</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">f_polynomial</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">flag_f_polynomial</span><span class="p">()</span>
<span class="go">3*x1*x2*x3 + 3*x1*x3 + x2*x3 + x3</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="sage.combinat.posets.posets.FinitePoset.is_bounded"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_bounded()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.flag_h_polynomial" title="sage.combinat.posets.posets.FinitePoset.flag_h_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flag_h_polynomial()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.flag_h_polynomial">
<code class="descname">flag_h_polynomial</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.flag_h_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the flag <span class="math notranslate nohighlight">\(h\)</span>-polynomial of the poset.</p>
<p>The poset is expected to be bounded and ranked.</p>
<p>If <span class="math notranslate nohighlight">\(P\)</span> is a bounded ranked poset whose maximal element has
rank <span class="math notranslate nohighlight">\(n\)</span> (where the minimal element is set to have rank <span class="math notranslate nohighlight">\(0\)</span>),
then the flag <span class="math notranslate nohighlight">\(h\)</span>-polynomial of <span class="math notranslate nohighlight">\(P\)</span> is defined as the
polynomial</p>
<div class="math notranslate nohighlight">
\[\prod_{k=1}^n (1-x_k) \cdot f \left(\frac{x_1}{1-x_1},
\frac{x_2}{1-x_2}, \cdots, \frac{x_n}{1-x_n}\right)
\in \ZZ[x_1, x_2, \cdots, x_n],\]</div>
<p>where <span class="math notranslate nohighlight">\(f\)</span> is the flag <span class="math notranslate nohighlight">\(f\)</span>-polynomial of <span class="math notranslate nohighlight">\(P\)</span> (see
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.flag_f_polynomial" title="sage.combinat.posets.posets.FinitePoset.flag_f_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flag_f_polynomial()</span></code></a>).</p>
<p>For technical reasons, the polynomial is returned in the
slightly larger ring <span class="math notranslate nohighlight">\(\QQ[x_0, x_1, x_2, \cdots, x_{n+1}]\)</span> by
this method.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/h-vector">Wikipedia article h-vector</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">flag_h_polynomial</span><span class="p">()</span>
<span class="go">2*x1*x2 + x2</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">fl</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">flag_h_polynomial</span><span class="p">();</span> <span class="n">fl</span>
<span class="go">-x1*x2*x3 + x1*x3 + x2*x3 + x3</span>
<span class="gp">sage: </span><span class="n">q</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span><span class="s1">&#39;q&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fl</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="p">)</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">h_polynomial</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">flag_h_polynomial</span><span class="p">()</span>
<span class="go">2*x1*x3 + x3</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">flag_h_polynomial</span><span class="p">()</span>
<span class="go">x3</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="sage.combinat.posets.posets.FinitePoset.is_bounded"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_bounded()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.flag_f_polynomial" title="sage.combinat.posets.posets.FinitePoset.flag_f_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flag_f_polynomial()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.frank_network">
<code class="descname">frank_network</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.frank_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Frank’s network of the poset.</p>
<p>This is defined in Section 8 of <a class="reference internal" href="../../../../references/index.html#bf1999" id="id7">[BF1999]</a>.</p>
<p>OUTPUT:</p>
<p>A pair <span class="math notranslate nohighlight">\((G, e)\)</span>, where <span class="math notranslate nohighlight">\(G\)</span> is Frank’s network of <span class="math notranslate nohighlight">\(P\)</span> encoded as a
<a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraph</span></code></a>, and <span class="math notranslate nohighlight">\(e\)</span> is the cost function on its edges encoded
as a dictionary (indexed by these edges, which in turn are encoded
as tuples of 2 vertices).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Frank’s network of <span class="math notranslate nohighlight">\(P\)</span> is a certain directed graph with <span class="math notranslate nohighlight">\(2|P| + 2\)</span>
vertices, defined in Section 8 of <a class="reference internal" href="../../../../references/index.html#bf1999" id="id8">[BF1999]</a>. Its set of vertices
consists of two vertices <span class="math notranslate nohighlight">\((0, p)\)</span> and <span class="math notranslate nohighlight">\((1, p)\)</span> for each element
<span class="math notranslate nohighlight">\(p\)</span> of <span class="math notranslate nohighlight">\(P\)</span>, as well as two vertices <span class="math notranslate nohighlight">\((-1, 0)\)</span> and <span class="math notranslate nohighlight">\((2, 0)\)</span>.
(These notations are not the ones used in <a class="reference internal" href="../../../../references/index.html#bf1999" id="id9">[BF1999]</a>; see the table
below for their relation.) The edges are:</p>
<ul class="simple">
<li>for each <span class="math notranslate nohighlight">\(p\)</span> in <span class="math notranslate nohighlight">\(P\)</span>, an edge from <span class="math notranslate nohighlight">\((-1, 0)\)</span> to <span class="math notranslate nohighlight">\((0, p)\)</span>;</li>
<li>for each <span class="math notranslate nohighlight">\(p\)</span> in <span class="math notranslate nohighlight">\(P\)</span>, an edge from <span class="math notranslate nohighlight">\((1, p)\)</span> to <span class="math notranslate nohighlight">\((2, 0)\)</span>;</li>
<li>for each <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(q\)</span> in <span class="math notranslate nohighlight">\(P\)</span> such that <span class="math notranslate nohighlight">\(p \geq q\)</span>, an edge from
<span class="math notranslate nohighlight">\((0, p)\)</span> to <span class="math notranslate nohighlight">\((1, q)\)</span>.</li>
</ul>
<p>We make this digraph into a network in the sense of flow theory as
follows: The vertex <span class="math notranslate nohighlight">\((-1, 0)\)</span> is considered as the source of this
network, and the vertex <span class="math notranslate nohighlight">\((2, 0)\)</span> as the sink. The cost function is
defined to be <span class="math notranslate nohighlight">\(1\)</span> on the edge from <span class="math notranslate nohighlight">\((0, p)\)</span> to <span class="math notranslate nohighlight">\((1, p)\)</span> for each
<span class="math notranslate nohighlight">\(p \in P\)</span>, and to be <span class="math notranslate nohighlight">\(0\)</span> on every other edge. The capacity is <span class="math notranslate nohighlight">\(1\)</span>
on each edge. Here is how to translate this notations into that
used in <a class="reference internal" href="../../../../references/index.html#bf1999" id="id10">[BF1999]</a>:</p>
<div class="last highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">our notations                    [BF1999]</span>
<span class="go">   (-1, 0)                          s</span>
<span class="go">   (0, p)                          x_p</span>
<span class="go">   (1, p)                          y_p</span>
<span class="go">   (2, 0)                           t</span>
<span class="go">    a[e]                           a(e)</span>
</pre></div>
</div>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ps</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">16</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="o">-</span><span class="mi">13</span><span class="p">],[[</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">],[</span><span class="mi">14</span><span class="p">,</span><span class="o">-</span><span class="mi">13</span><span class="p">],[</span><span class="mi">12</span><span class="p">,</span><span class="mi">16</span><span class="p">],[</span><span class="mi">16</span><span class="p">,</span><span class="o">-</span><span class="mi">13</span><span class="p">]]]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span><span class="o">.</span><span class="n">frank_network</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[((-1, 0), (0, -13), None), ((-1, 0), (0, 12), None), ((-1, 0), (0, 14), None), ((-1, 0), (0, 16), None), ((0, -13), (1, -13), None), ((0, -13), (1, 12), None), ((0, -13), (1, 14), None), ((0, -13), (1, 16), None), ((0, 12), (1, 12), None), ((0, 14), (1, 12), None), ((0, 14), (1, 14), None), ((0, 16), (1, 12), None), ((0, 16), (1, 16), None), ((1, -13), (2, 0), None), ((1, 12), (2, 0), None), ((1, 14), (2, 0), None), ((1, 16), (2, 0), None)]</span>
<span class="gp">sage: </span><span class="n">e</span>
<span class="go">{((-1, 0), (0, -13)): 0,</span>
<span class="go"> ((-1, 0), (0, 12)): 0,</span>
<span class="go"> ((-1, 0), (0, 14)): 0,</span>
<span class="go"> ((-1, 0), (0, 16)): 0,</span>
<span class="go"> ((0, -13), (1, -13)): 1,</span>
<span class="go"> ((0, -13), (1, 12)): 0,</span>
<span class="go"> ((0, -13), (1, 14)): 0,</span>
<span class="go"> ((0, -13), (1, 16)): 0,</span>
<span class="go"> ((0, 12), (1, 12)): 1,</span>
<span class="go"> ((0, 14), (1, 12)): 0,</span>
<span class="go"> ((0, 14), (1, 14)): 1,</span>
<span class="go"> ((0, 16), (1, 12)): 0,</span>
<span class="go"> ((0, 16), (1, 16)): 1,</span>
<span class="go"> ((1, -13), (2, 0)): 0,</span>
<span class="go"> ((1, 12), (2, 0)): 0,</span>
<span class="go"> ((1, 14), (2, 0)): 0,</span>
<span class="go"> ((1, 16), (2, 0)): 0}</span>
<span class="gp">sage: </span><span class="n">qs</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]]</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">(</span><span class="n">qs</span><span class="p">)</span><span class="o">.</span><span class="n">frank_network</span><span class="p">()</span>
<span class="go">(Digraph on 20 vertices,</span>
<span class="go"> {((-1, 0), (0, 1)): 0,</span>
<span class="go">  ((-1, 0), (0, 2)): 0,</span>
<span class="go">  ((-1, 0), (0, 3)): 0,</span>
<span class="go">  ((-1, 0), (0, 4)): 0,</span>
<span class="go">  ((-1, 0), (0, 5)): 0,</span>
<span class="go">  ((-1, 0), (0, 6)): 0,</span>
<span class="go">  ((-1, 0), (0, 7)): 0,</span>
<span class="go">  ((-1, 0), (0, 8)): 0,</span>
<span class="go">  ((-1, 0), (0, 9)): 0,</span>
<span class="go">  ((0, 1), (1, 1)): 1,</span>
<span class="go">  ((0, 2), (1, 2)): 1,</span>
<span class="go">  ((0, 3), (1, 1)): 0,</span>
<span class="go">  ((0, 3), (1, 2)): 0,</span>
<span class="go">  ((0, 3), (1, 3)): 1,</span>
<span class="go">  ((0, 4), (1, 1)): 0,</span>
<span class="go">  ((0, 4), (1, 2)): 0,</span>
<span class="go">  ((0, 4), (1, 3)): 0,</span>
<span class="go">  ((0, 4), (1, 4)): 1,</span>
<span class="go">  ((0, 5), (1, 5)): 1,</span>
<span class="go">  ((0, 6), (1, 6)): 1,</span>
<span class="go">  ((0, 7), (1, 5)): 0,</span>
<span class="go">  ((0, 7), (1, 7)): 1,</span>
<span class="go">  ((0, 8), (1, 8)): 1,</span>
<span class="go">  ((0, 9), (1, 1)): 0,</span>
<span class="go">  ((0, 9), (1, 9)): 1,</span>
<span class="go">  ((1, 1), (2, 0)): 0,</span>
<span class="go">  ((1, 2), (2, 0)): 0,</span>
<span class="go">  ((1, 3), (2, 0)): 0,</span>
<span class="go">  ((1, 4), (2, 0)): 0,</span>
<span class="go">  ((1, 5), (2, 0)): 0,</span>
<span class="go">  ((1, 6), (2, 0)): 0,</span>
<span class="go">  ((1, 7), (2, 0)): 0,</span>
<span class="go">  ((1, 8), (2, 0)): 0,</span>
<span class="go">  ((1, 9), (2, 0)): 0})</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li>Darij Grinberg (2013-05-09)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.ge">
<code class="descname">ge</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.ge" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <span class="math notranslate nohighlight">\(x\)</span> is greater than or equal to <span class="math notranslate nohighlight">\(y\)</span> in the poset,
and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_greater_than" title="sage.combinat.posets.posets.FinitePoset.is_greater_than"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_greater_than()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_lequal" title="sage.combinat.posets.posets.FinitePoset.is_lequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_lequal()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.graphviz_string">
<code class="descname">graphviz_string</code><span class="sig-paren">(</span><em>graph_string='graph'</em>, <em>edge_string='--'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.graphviz_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a representation in the DOT language, ready to render in
graphviz.</p>
<p>See <a class="reference external" href="http://www.graphviz.org/doc/info/lang.html">http://www.graphviz.org/doc/info/lang.html</a> for more information
about graphviz.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;d&#39;</span><span class="p">],</span><span class="s1">&#39;c&#39;</span><span class="p">:[</span><span class="s1">&#39;d&#39;</span><span class="p">],</span><span class="s1">&#39;d&#39;</span><span class="p">:[</span><span class="s1">&#39;f&#39;</span><span class="p">],</span><span class="s1">&#39;e&#39;</span><span class="p">:[</span><span class="s1">&#39;f&#39;</span><span class="p">],</span><span class="s1">&#39;f&#39;</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">graphviz_string</span><span class="p">())</span>
<span class="go">graph {</span>
<span class="go">&quot;f&quot;;&quot;d&quot;;&quot;b&quot;;&quot;a&quot;;&quot;c&quot;;&quot;e&quot;;</span>
<span class="go">&quot;f&quot;--&quot;e&quot;;&quot;d&quot;--&quot;c&quot;;&quot;b&quot;--&quot;a&quot;;&quot;d&quot;--&quot;b&quot;;&quot;f&quot;--&quot;d&quot;;</span>
<span class="go">}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.greene_shape">
<code class="descname">greene_shape</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.greene_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Greene-Kleitman partition of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The Greene-Kleitman partition of a finite poset <span class="math notranslate nohighlight">\(P\)</span> is the partition
<span class="math notranslate nohighlight">\((c_1 - c_0, c_2 - c_1, c_3 - c_2, \ldots)\)</span>, where <span class="math notranslate nohighlight">\(c_k\)</span> is the
maximum cardinality of a union of <span class="math notranslate nohighlight">\(k\)</span> chains of <span class="math notranslate nohighlight">\(P\)</span>. Equivalently,
this is the conjugate of the partition <span class="math notranslate nohighlight">\((a_1 - a_0, a_2 - a_1, a_3 -
a_2, \ldots)\)</span>, where <span class="math notranslate nohighlight">\(a_k\)</span> is the maximum cardinality of a union of
<span class="math notranslate nohighlight">\(k\)</span> antichains of <span class="math notranslate nohighlight">\(P\)</span>.</p>
<p>See many sources, e. g., <a class="reference internal" href="../../../../references/index.html#bf1999" id="id11">[BF1999]</a>, for proofs of this equivalence.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">greene_shape</span><span class="p">()</span>
<span class="go">[2, 1]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">greene_shape</span><span class="p">()</span>
<span class="go">[3, 1]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">19</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">22</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">greene_shape</span><span class="p">()</span>
<span class="go">[3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[],[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">greene_shape</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li>Darij Grinberg (2013-05-09)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.gt">
<code class="descname">gt</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.gt" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <span class="math notranslate nohighlight">\(x\)</span> is greater than but not equal to <span class="math notranslate nohighlight">\(y\)</span> in the
poset, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>For non-facade posets also <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> works:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]},</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">P</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_gequal" title="sage.combinat.posets.posets.FinitePoset.is_gequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_gequal()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_less_than" title="sage.combinat.posets.posets.FinitePoset.is_less_than"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_less_than()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.h_polynomial">
<code class="descname">h_polynomial</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.h_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <span class="math notranslate nohighlight">\(h\)</span>-polynomial of a bounded poset <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This is the <span class="math notranslate nohighlight">\(h\)</span>-polynomial of the order complex of the poset
minus its bounds.</p>
<p>This is related to the <span class="math notranslate nohighlight">\(f\)</span>-polynomial by a simple change
of variables:</p>
<div class="math notranslate nohighlight">
\[h(q) = (1-q)^{\deg f} f \left( \frac{q}{1-q} \right),\]</div>
<p>where <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(h\)</span> denote the <span class="math notranslate nohighlight">\(f\)</span>-polynomial and the
<span class="math notranslate nohighlight">\(h\)</span>-polynomial, respectively.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/h-vector">Wikipedia article h-vector</a>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This is slightly different from the <code class="docutils literal notranslate"><span class="pre">hPolynomial</span></code>
method in Macaulay2.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">order_ideals_lattice</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">h_polynomial</span><span class="p">()</span>
<span class="go">q^3 + 4*q^2 + q</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">h_polynomial</span><span class="p">()</span>
<span class="go">2*q^2 + q</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">h_polynomial</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="sage.combinat.posets.posets.FinitePoset.is_bounded"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_bounded()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.f_polynomial" title="sage.combinat.posets.posets.FinitePoset.f_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">f_polynomial()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_complex" title="sage.combinat.posets.posets.FinitePoset.order_complex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_complex()</span></code></a>,
<a class="reference external" href="../../../../homology/sage/homology/simplicial_complex.html#sage.homology.simplicial_complex.SimplicialComplex.h_vector" title="(in Sage Reference Manual: Cell complexes and their homology v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.homology.simplicial_complex.SimplicialComplex.h_vector()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.has_bottom">
<code class="descname">has_bottom</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.has_bottom" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset has a unique minimal element, and
<code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">has_bottom</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">has_bottom</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li>Dual Property: <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_top" title="sage.combinat.posets.posets.FinitePoset.has_top"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_top()</span></code></a></li>
<li>Stronger properties: <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="sage.combinat.posets.posets.FinitePoset.is_bounded"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_bounded()</span></code></a></li>
<li>Other: <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.bottom" title="sage.combinat.posets.posets.FinitePoset.bottom"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bottom()</span></code></a></li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.has_isomorphic_subposet">
<code class="descname">has_isomorphic_subposet</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.has_isomorphic_subposet" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset contains a subposet isomorphic to
<code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>By subposet we mean that there exist a set <code class="docutils literal notranslate"><span class="pre">X</span></code> of elements such
that <code class="docutils literal notranslate"><span class="pre">self.subposet(X)</span></code> is isomorphic to <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">other</span></code> – a finite poset</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">N5</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>

<span class="gp">sage: </span><span class="n">N5</span><span class="o">.</span><span class="n">has_isomorphic_subposet</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">N5</span><span class="o">.</span><span class="n">has_isomorphic_subposet</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="nb">len</span><span class="p">([</span><span class="n">P</span> <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">if</span> <span class="n">P</span><span class="o">.</span><span class="n">has_isomorphic_subposet</span><span class="p">(</span><span class="n">D</span><span class="p">)])</span>
<span class="go">11</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.has_top">
<code class="descname">has_top</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.has_top" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset has a unique maximal element, and
<code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[],</span> <span class="mi">5</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">has_top</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">has_top</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li>Dual Property: <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_bottom" title="sage.combinat.posets.posets.FinitePoset.has_bottom"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_bottom()</span></code></a></li>
<li>Stronger properties: <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="sage.combinat.posets.posets.FinitePoset.is_bounded"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_bounded()</span></code></a></li>
<li>Other: <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.top" title="sage.combinat.posets.posets.FinitePoset.top"><code class="xref py py-meth docutils literal notranslate"><span class="pre">top()</span></code></a></li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.hasse_diagram">
<code class="descname">hasse_diagram</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.hasse_diagram" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Hasse diagram of the poset as a Sage <a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraph</span></code></a>.</p>
<p>The Hasse diagram is a directed graph where vertices are the
elements of the poset and there is an edge from <span class="math notranslate nohighlight">\(u\)</span> to <span class="math notranslate nohighlight">\(v\)</span>
whenever <span class="math notranslate nohighlight">\(v\)</span> covers <span class="math notranslate nohighlight">\(u\)</span> in the poset.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">dot2tex</span></code> is installed, then this sets the Hasse diagram’s latex
options to use the <code class="docutils literal notranslate"><span class="pre">dot2tex</span></code> formatting.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DivisorLattice</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">hasse_diagram</span><span class="p">();</span> <span class="n">H</span>
<span class="go">Digraph on 6 vertices</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [2, 4], [2, 6], [3, 6], [4, 12], [6, 12]]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">[(1, 2), (1, 3), (2, 4), (2, 6), (3, 6), (4, 12), (6, 12)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.height">
<code class="descname">height</code><span class="sig-paren">(</span><em>certificate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.height" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the height (number of elements in a longest chain) of the poset.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) whether to return
a certificate</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>If <code class="docutils literal notranslate"><span class="pre">certificate=True</span></code> return <code class="docutils literal notranslate"><span class="pre">(h,</span> <span class="pre">c)</span></code>, where <code class="docutils literal notranslate"><span class="pre">h</span></code> is the
height and <code class="docutils literal notranslate"><span class="pre">c</span></code> is a chain of maximum cardinality.
If <code class="docutils literal notranslate"><span class="pre">certificate=False</span></code> return only the height.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">height</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">height</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(4, [0, 2, 3, 4])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.incidence_algebra">
<code class="descname">incidence_algebra</code><span class="sig-paren">(</span><em>R</em>, <em>prefix='I'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.incidence_algebra" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the incidence algebra of <code class="docutils literal notranslate"><span class="pre">self</span></code> over <code class="docutils literal notranslate"><span class="pre">R</span></code>.</p>
<p>OUTPUT:</p>
<p>An instance of <a class="reference internal" href="incidence_algebras.html#sage.combinat.posets.incidence_algebras.IncidenceAlgebra" title="sage.combinat.posets.incidence_algebras.IncidenceAlgebra"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.posets.incidence_algebras.IncidenceAlgebra</span></code></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">incidence_algebra</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">Incidence algebra of Finite lattice containing 16 elements</span>
<span class="go"> over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.incomparability_graph">
<code class="descname">incomparability_graph</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.incomparability_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the incomparability graph of the poset.</p>
<p>This is the complement of the comparability graph, i.e. an
undirected graph where vertices are the elements of the poset
and there is an edge between vertices if they are not
comparable in the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">incomparability_graph</span><span class="p">();</span> <span class="n">g</span>
<span class="go">Incomparability graph on 4 vertices</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">compare_elements</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.comparability_graph" title="sage.combinat.posets.posets.FinitePoset.comparability_graph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">comparability_graph()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.interval">
<code class="descname">interval</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.interval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the elements <span class="math notranslate nohighlight">\(z\)</span> such that <span class="math notranslate nohighlight">\(x \le z \le y\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">x</span></code> – any element of the poset</li>
<li><code class="docutils literal notranslate"><span class="pre">y</span></code> – any element of the poset</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">uc</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[]]</span>
<span class="gp">sage: </span><span class="n">dag</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uc</span><span class="p">)),</span><span class="n">uc</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">dag</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">P</span><span class="p">,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">interval</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">dg</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="s2">&quot;a&quot;</span><span class="p">:[</span><span class="s2">&quot;b&quot;</span><span class="p">,</span><span class="s2">&quot;c&quot;</span><span class="p">],</span> <span class="s2">&quot;b&quot;</span><span class="p">:[</span><span class="s2">&quot;d&quot;</span><span class="p">],</span> <span class="s2">&quot;c&quot;</span><span class="p">:[</span><span class="s2">&quot;d&quot;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">dg</span><span class="p">,</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">interval</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
<span class="go">[a, b, c, d]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.intervals_number">
<code class="descname">intervals_number</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.intervals_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of relations in the poset.</p>
<p>A relation is a pair of elements <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> such that <span class="math notranslate nohighlight">\(x\leq y\)</span>
in the poset.</p>
<p>Relations are also often called intervals. The number of
intervals is the dimension of the incidence algebra.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">relations_number</span><span class="p">()</span>
<span class="go">13</span>

<span class="gp">sage: </span><span class="n">posets</span><span class="o">.</span><span class="n">TamariLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">relations_number</span><span class="p">()</span>
<span class="go">68</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_iterator" title="sage.combinat.posets.posets.FinitePoset.relations_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relations_iterator()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations" title="sage.combinat.posets.posets.FinitePoset.relations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relations()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.intervals_poset">
<code class="descname">intervals_poset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.intervals_poset" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the natural partial order on the set of intervals of the poset.</p>
<p>OUTPUT:</p>
<p>a finite poset</p>
<p>The poset of intervals of a poset <span class="math notranslate nohighlight">\(P\)</span> has the set of intervals <span class="math notranslate nohighlight">\([x,y]\)</span>
in <span class="math notranslate nohighlight">\(P\)</span> as elements, endowed with the order relation defined by
<span class="math notranslate nohighlight">\([x_1,y_1] \leq [x_2,y_2]\)</span> if and only if <span class="math notranslate nohighlight">\(x_1 \leq x_2\)</span> and
<span class="math notranslate nohighlight">\(y_1 \leq y_2\)</span>.</p>
<p>This is also called <span class="math notranslate nohighlight">\(P\)</span> to the power <em>2</em>, meaning
the poset of poset-morphisms from the 2-chain to <span class="math notranslate nohighlight">\(P\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(P\)</span> is a lattice, the result is also a lattice.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">intervals_poset</span><span class="p">()</span>
<span class="go">Finite poset containing 3 elements</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">intervals_poset</span><span class="p">()</span>
<span class="go">Finite lattice containing 13 elements</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_EL_labelling">
<code class="descname">is_EL_labelling</code><span class="sig-paren">(</span><em>f</em>, <em>return_raising_chains=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_EL_labelling" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">f</span></code> is an EL labelling of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>A labelling <span class="math notranslate nohighlight">\(f\)</span> of the edges of the Hasse diagram of a poset
is called an EL labelling (edge lexicographic labelling) if
for any two elements <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> with <span class="math notranslate nohighlight">\(u \leq v\)</span>,</p>
<blockquote>
<div><ul class="simple">
<li>there is a unique <span class="math notranslate nohighlight">\(f\)</span>-raising chain from <span class="math notranslate nohighlight">\(u\)</span> to <span class="math notranslate nohighlight">\(v\)</span> in
the Hasse diagram, and this chain is lexicographically
first among all chains from <span class="math notranslate nohighlight">\(u\)</span> to <span class="math notranslate nohighlight">\(v\)</span>.</li>
</ul>
</div></blockquote>
<p>For more details, see <a class="reference internal" href="../../../../references/index.html#bj1980" id="id12">[Bj1980]</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code> – a function taking two elements <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> in
<code class="docutils literal notranslate"><span class="pre">self</span></code> such that <code class="docutils literal notranslate"><span class="pre">b</span></code> covers <code class="docutils literal notranslate"><span class="pre">a</span></code> and returning elements
in a totally ordered set.</li>
<li><code class="docutils literal notranslate"><span class="pre">return_raising_chains</span></code> (optional; default:<code class="docutils literal notranslate"><span class="pre">False</span></code>) if
<code class="docutils literal notranslate"><span class="pre">True</span></code>, returns the set of all raising chains in <code class="docutils literal notranslate"><span class="pre">self</span></code>,
if possible.</li>
</ul>
<p>EXAMPLES:</p>
<p>Let us consider a Boolean poset:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)],[[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)],[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)],[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)],[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)]]],</span><span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">label</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_EL_labelling</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_EL_labelling</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">return_raising_chains</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">{((0, 0), (0, 1)): [1],</span>
<span class="go"> ((0, 0), (1, 0)): [0],</span>
<span class="go"> ((0, 0), (1, 1)): [0, 1],</span>
<span class="go"> ((0, 1), (1, 1)): [0],</span>
<span class="go"> ((1, 0), (1, 1)): [1]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_antichain_of_poset">
<code class="descname">is_antichain_of_poset</code><span class="sig-paren">(</span><em>elms</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_antichain_of_poset" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">elms</span></code> is an antichain of the poset
and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>Set of elements are an <em>antichain</em> of a poset if they are
pairwise incomparable.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_antichain_of_poset</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_antichain_of_poset</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">14</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_bounded">
<code class="descname">is_bounded</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is bounded, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>A poset is bounded if it contains both a unique maximal element
and a unique minimal element.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[],</span> <span class="mi">5</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_bounded</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_bounded</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li>Weaker properties: <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_bottom" title="sage.combinat.posets.posets.FinitePoset.has_bottom"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_bottom()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_top" title="sage.combinat.posets.posets.FinitePoset.has_top"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_top()</span></code></a></li>
<li>Other: <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.with_bounds" title="sage.combinat.posets.posets.FinitePoset.with_bounds"><code class="xref py py-meth docutils literal notranslate"><span class="pre">with_bounds()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.without_bounds" title="sage.combinat.posets.posets.FinitePoset.without_bounds"><code class="xref py py-meth docutils literal notranslate"><span class="pre">without_bounds()</span></code></a></li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_chain">
<code class="descname">is_chain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is totally ordered (“chain”), and
<code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">is_chain</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">II</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">II</span><span class="o">.</span><span class="n">is_chain</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">is_chain</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_chain_of_poset">
<code class="descname">is_chain_of_poset</code><span class="sig-paren">(</span><em>elms</em>, <em>ordered=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_chain_of_poset" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">elms</span></code> is a chain of the poset,
and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>Set of elements are a <em>chain</em> of a poset if they are comparable
to each other.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">elms</span></code> – a list or other iterable containing some elements
of the poset</li>
<li><code class="docutils literal notranslate"><span class="pre">ordered</span></code> – a Boolean. If <code class="docutils literal notranslate"><span class="pre">True</span></code>, then return <code class="docutils literal notranslate"><span class="pre">True</span></code>
only if elements in <code class="docutils literal notranslate"><span class="pre">elms</span></code> are strictly increasing in the
poset; this makes no sense if <code class="docutils literal notranslate"><span class="pre">elms</span></code> is a set. If <code class="docutils literal notranslate"><span class="pre">False</span></code>
(the default), then elements can be repeated and be in any
order.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">([</span><span class="mi">12</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">({</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">12</span><span class="p">})</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">([</span><span class="mi">12</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">ordered</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">ordered</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">ordered</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_connected">
<code class="descname">is_connected</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_connected" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is connected, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>A poset is connected if it’s Hasse diagram is connected.</p>
<p>If a poset is not connected, then it can be divided to parts
<span class="math notranslate nohighlight">\(S_1\)</span> and <span class="math notranslate nohighlight">\(S_2\)</span> so that every element of <span class="math notranslate nohighlight">\(S_1\)</span> is incomparable to
every element of <span class="math notranslate nohighlight">\(S_2\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">6</span><span class="p">:[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.connected_components" title="sage.combinat.posets.posets.FinitePoset.connected_components"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connected_components()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_eulerian">
<code class="descname">is_eulerian</code><span class="sig-paren">(</span><em>k=None</em>, <em>certificate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_eulerian" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is Eulerian, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>The poset is expected to be graded and bounded.</p>
<p>A poset is Eulerian if every non-trivial interval has the same
number of elements of even rank as of odd rank. A poset is
<span class="math notranslate nohighlight">\(k\)</span>-eulerian if every non-trivial interval up to rank <span class="math notranslate nohighlight">\(k\)</span>
is Eulerian.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Eulerian_poset">Wikipedia article Eulerian_poset</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">k</span></code>, an integer – only check if the poset is <span class="math notranslate nohighlight">\(k\)</span>-eulerian.
If <code class="docutils literal notranslate"><span class="pre">None</span></code> (the default), check if the poset is Eulerian.</li>
<li><code class="docutils literal notranslate"><span class="pre">certificate</span></code>, a Boolean – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) whether to return
a certificate</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>If <code class="docutils literal notranslate"><span class="pre">certificate=True</span></code> return either <code class="docutils literal notranslate"><span class="pre">True,</span> <span class="pre">None</span></code> or
<code class="docutils literal notranslate"><span class="pre">False,</span> <span class="pre">(a,</span> <span class="pre">b)</span></code>, where the interval <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span></code> is not
Eulerian. If <code class="docutils literal notranslate"><span class="pre">certificate=False</span></code> return <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">....: </span>           <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="mi">7</span><span class="p">:</span> <span class="p">[</span><span class="mi">9</span><span class="p">],</span> <span class="mi">8</span><span class="p">:</span> <span class="p">[</span><span class="mi">9</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span>
<span class="gp">....: </span>           <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">6</span><span class="p">:[</span><span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Canonical examples of Eulerian posets are the face lattices of
convex polytopes:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">polytopes</span><span class="o">.</span><span class="n">cube</span><span class="p">()</span><span class="o">.</span><span class="n">face_lattice</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A poset that is 3- but not 4-eulerian:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">(</span><span class="s1">&#39;MWW@_?W?@_?W??@??O@_?W?@_?W?@??O??&#39;</span><span class="p">));</span> <span class="n">P</span>
<span class="go">Finite poset containing 14 elements</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Getting an interval that is not Eulerian:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DivisorLattice</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(False, (1, 4))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_gequal">
<code class="descname">is_gequal</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_gequal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <span class="math notranslate nohighlight">\(x\)</span> is greater than or equal to <span class="math notranslate nohighlight">\(y\)</span> in the poset,
and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_greater_than" title="sage.combinat.posets.posets.FinitePoset.is_greater_than"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_greater_than()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_lequal" title="sage.combinat.posets.posets.FinitePoset.is_lequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_lequal()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_graded">
<code class="descname">is_graded</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_graded" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is graded, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>A poset is graded if all its maximal chains have the same length.</p>
<p>There are various competing definitions for graded
posets (see <a class="reference external" href="https://en.wikipedia.org/wiki/Graded_poset">Wikipedia article Graded_poset</a>). This definition is from
section 3.1 of Richard Stanley’s <em>Enumerative Combinatorics,
Vol. 1</em> <a class="reference internal" href="../../../../references/index.html#enumcomb1" id="id13">[EnumComb1]</a>. Some sources call these posets <em>tiered</em>.</p>
<p>Every graded poset is ranked. The converse is true
for bounded posets, including lattices.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>  <span class="c1"># Not even ranked</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_graded</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>  <span class="c1"># Ranked, but not graded</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_graded</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_graded</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_graded</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_ranked" title="sage.combinat.posets.posets.FinitePoset.is_ranked"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_ranked()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.level_sets" title="sage.combinat.posets.posets.FinitePoset.level_sets"><code class="xref py py-meth docutils literal notranslate"><span class="pre">level_sets()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_greater_than">
<code class="descname">is_greater_than</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_greater_than" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <span class="math notranslate nohighlight">\(x\)</span> is greater than but not equal to <span class="math notranslate nohighlight">\(y\)</span> in the
poset, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>For non-facade posets also <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> works:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]},</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">P</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_gequal" title="sage.combinat.posets.posets.FinitePoset.is_gequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_gequal()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_less_than" title="sage.combinat.posets.posets.FinitePoset.is_less_than"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_less_than()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_greedy">
<code class="descname">is_greedy</code><span class="sig-paren">(</span><em>certificate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_greedy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is greedy, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>A poset is <em>greedy</em> if every greedy linear extension
has the same number of jumps.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) whether to return
a certificate</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>If <code class="docutils literal notranslate"><span class="pre">certificate=True</span></code> return either <code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">None)</span></code> or
<code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">(A,</span> <span class="pre">B))</span></code> where <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are greedy linear extension
so that <span class="math notranslate nohighlight">\(B\)</span> has more jumps. If <code class="docutils literal notranslate"><span class="pre">certificate=False</span></code> return
<code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>.</li>
</ul>
<p>EXAMPLES:</p>
<p>This is not a self-dual property:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">W</span><span class="o">.</span><span class="n">is_greedy</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">is_greedy</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Getting a certificate:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">is_greedy</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(False, ([1, 2, 4, 3], [2, 4, 1, 3]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_incomparable_chain_free">
<code class="descname">is_incomparable_chain_free</code><span class="sig-paren">(</span><em>m</em>, <em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_incomparable_chain_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is <span class="math notranslate nohighlight">\((m+n)\)</span>-free, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>A poset is <span class="math notranslate nohighlight">\((m+n)\)</span>-free if there is no incomparable chains of
lengths <span class="math notranslate nohighlight">\(m\)</span> and <span class="math notranslate nohighlight">\(n\)</span>. Three cases have special name
(see <a class="reference internal" href="../../../../references/index.html#enumcomb1" id="id14">[EnumComb1]</a>, exercise 3.15):</p>
<ul class="simple">
<li>‘’interval order’’ is <span class="math notranslate nohighlight">\((2+2)\)</span>-free</li>
<li>‘’semiorder’’ (or ‘’unit interval order’‘) is <span class="math notranslate nohighlight">\((1+3)\)</span>-free and
<span class="math notranslate nohighlight">\((2+2)\)</span>-free</li>
<li>‘’weak order’’ is <span class="math notranslate nohighlight">\((1+2)\)</span>-free.</li>
</ul>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code> - positive integers</li>
</ul>
<p>It is also possible to give a list of integer pairs as argument.
See below for an example.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B3</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B3</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B3</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">IP6</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">IntegerPartitions</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">IP6</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">IP6</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A list of pairs as an argument:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B3</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We show how to get an incomparable chain pair:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">chains_1_2</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">incomps</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">isomorphic_subposets</span><span class="p">(</span><span class="n">chains_1_2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">incomps</span><span class="o">.</span><span class="n">list</span><span class="p">()),</span> <span class="n">incomps</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">([1, 2, 3], [[2, 3]])</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li>Eric Rowland (2013-05-28)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_induced_subposet">
<code class="descname">is_induced_subposet</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_induced_subposet" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is an induced subposet of <code class="docutils literal notranslate"><span class="pre">other</span></code>, and
<code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>A poset <span class="math notranslate nohighlight">\(P\)</span> is an induced subposet of <span class="math notranslate nohighlight">\(Q\)</span> if every element
of <span class="math notranslate nohighlight">\(P\)</span> is an element of <span class="math notranslate nohighlight">\(Q\)</span>, and <span class="math notranslate nohighlight">\(x \le_P y\)</span> iff <span class="math notranslate nohighlight">\(x \le_Q y\)</span>.
Note that “induced” here has somewhat different meaning compared
to that of graphs.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">other</span></code>, a poset.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method does not check whether the poset is a
<em>isomorphic</em> (i.e., up to relabeling) subposet of <code class="docutils literal notranslate"><span class="pre">other</span></code>,
but only if <code class="docutils literal notranslate"><span class="pre">other</span></code> directly contains the poset as an
induced subposet. For isomorphic subposets see
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_isomorphic_subposet" title="sage.combinat.posets.posets.FinitePoset.has_isomorphic_subposet"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_isomorphic_subposet()</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_induced_subposet</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_induced_subposet</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_isomorphic">
<code class="descname">is_isomorphic</code><span class="sig-paren">(</span><em>other</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_isomorphic" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if both posets are isomorphic.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_join_semilattice">
<code class="descname">is_join_semilattice</code><span class="sig-paren">(</span><em>certificate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_join_semilattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset has a join operation, and <code class="docutils literal notranslate"><span class="pre">False</span></code>
otherwise.</p>
<p>A join is the least upper bound for given elements, if it exists.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) whether to return
a certificate</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>If <code class="docutils literal notranslate"><span class="pre">certificate=True</span></code> return either <code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">None)</span></code> or
<code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">(a,</span> <span class="pre">b))</span></code> where elements <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> have no
least upper bound. If <code class="docutils literal notranslate"><span class="pre">certificate=False</span></code> return
<code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="p">[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_join_semilattice</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_join_semilattice</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_join_semilattice</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(False, (2, 1))</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li>Dual property: <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_meet_semilattice" title="sage.combinat.posets.posets.FinitePoset.is_meet_semilattice"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_meet_semilattice()</span></code></a></li>
<li>Stronger properties: <a class="reference external" href="../../../../categories/sage/categories/finite_posets.html#sage.categories.finite_posets.FinitePosets.ParentMethods.is_lattice" title="(in Sage Reference Manual: Category Framework v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_lattice()</span></code></a></li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_jump_critical">
<code class="descname">is_jump_critical</code><span class="sig-paren">(</span><em>certificate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_jump_critical" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is jump-critical, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>A poset <span class="math notranslate nohighlight">\(P\)</span> is <em>jump-critical</em> if every proper subposet has smaller
jump number.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) whether to return
a certificate</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>If <code class="docutils literal notranslate"><span class="pre">certificate=True</span></code> return either <code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">None)</span></code> or
<code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">e)</span></code> so that removing element <span class="math notranslate nohighlight">\(e\)</span> from the poset does not
decrease the jump number. If <code class="docutils literal notranslate"><span class="pre">certificate=False</span></code> return
<code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_jump_critical</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_jump_critical</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_jump_critical</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(False, 3)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.jump_number" title="sage.combinat.posets.posets.FinitePoset.jump_number"><code class="xref py py-meth docutils literal notranslate"><span class="pre">jump_number()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_lequal">
<code class="descname">is_lequal</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_lequal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <span class="math notranslate nohighlight">\(x\)</span> is less than or equal to <span class="math notranslate nohighlight">\(y\)</span> in the poset, and
<code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_less_than" title="sage.combinat.posets.posets.FinitePoset.is_less_than"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_less_than()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_gequal" title="sage.combinat.posets.posets.FinitePoset.is_gequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_gequal()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_less_than">
<code class="descname">is_less_than</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_less_than" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <span class="math notranslate nohighlight">\(x\)</span> is less than but not equal to <span class="math notranslate nohighlight">\(y\)</span> in the poset,
and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>For non-facade posets also <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> works:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]},</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_lequal" title="sage.combinat.posets.posets.FinitePoset.is_lequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_lequal()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_greater_than" title="sage.combinat.posets.posets.FinitePoset.is_greater_than"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_greater_than()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_linear_extension">
<code class="descname">is_linear_extension</code><span class="sig-paren">(</span><em>l</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_linear_extension" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether <code class="docutils literal notranslate"><span class="pre">l</span></code> is a linear extension of <code class="docutils literal notranslate"><span class="pre">self</span></code></p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">l</span></code> – a list (or iterable) containing all of the elements of <code class="docutils literal notranslate"><span class="pre">self</span></code> exactly once</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Permutations</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">))</span> <span class="k">if</span> <span class="n">P</span><span class="o">.</span><span class="n">is_linear_extension</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
<span class="go">[[1, 2, 3, 4, 6, 12],</span>
<span class="go"> [1, 2, 3, 6, 4, 12],</span>
<span class="go"> [1, 2, 4, 3, 6, 12],</span>
<span class="go"> [1, 3, 2, 4, 6, 12],</span>
<span class="go"> [1, 3, 2, 6, 4, 12]]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">linear_extensions</span><span class="p">())</span>
<span class="go">[[1, 2, 3, 4, 6, 12],</span>
<span class="go"> [1, 2, 4, 3, 6, 12],</span>
<span class="go"> [1, 3, 2, 4, 6, 12],</span>
<span class="go"> [1, 3, 2, 6, 4, 12],</span>
<span class="go"> [1, 2, 3, 6, 4, 12]]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is used and systematically tested in
<code class="xref py py-class docutils literal notranslate"><span class="pre">LinearExtensionsOfPosets</span></code></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extension" title="sage.combinat.posets.posets.FinitePoset.linear_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">linear_extension()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extensions" title="sage.combinat.posets.posets.FinitePoset.linear_extensions"><code class="xref py py-meth docutils literal notranslate"><span class="pre">linear_extensions()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_meet_semilattice">
<code class="descname">is_meet_semilattice</code><span class="sig-paren">(</span><em>certificate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_meet_semilattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset has a meet operation, and
<code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>A meet is the greatest lower bound for given elements, if it exists.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) whether to return
a certificate</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>If <code class="docutils literal notranslate"><span class="pre">certificate=True</span></code> return either <code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">None)</span></code> or
<code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">(a,</span> <span class="pre">b))</span></code> where elements <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> have no
greatest lower bound. If <code class="docutils literal notranslate"><span class="pre">certificate=False</span></code> return
<code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_meet_semilattice</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_meet_semilattice</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">IntegerPartitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">is_meet_semilattice</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(False, ((2, 2, 1), (3, 1, 1)))</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li>Dual property: <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_join_semilattice" title="sage.combinat.posets.posets.FinitePoset.is_join_semilattice"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_join_semilattice()</span></code></a></li>
<li>Stronger properties: <a class="reference external" href="../../../../categories/sage/categories/finite_posets.html#sage.categories.finite_posets.FinitePosets.ParentMethods.is_lattice" title="(in Sage Reference Manual: Category Framework v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_lattice()</span></code></a></li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_parent_of">
<code class="descname">is_parent_of</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_parent_of" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">x</span></code> is an element of the poset.</p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_rank_symmetric">
<code class="descname">is_rank_symmetric</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_rank_symmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is rank symmetric, and <code class="docutils literal notranslate"><span class="pre">False</span></code>
otherwise.</p>
<p>The poset is expected to be graded and connected.</p>
<p>A poset of rank <span class="math notranslate nohighlight">\(h\)</span> (maximal chains have <span class="math notranslate nohighlight">\(h+1\)</span> elements) is rank
symmetric if the number of elements are equal in ranks <span class="math notranslate nohighlight">\(i\)</span> and
<span class="math notranslate nohighlight">\(h-i\)</span> for every <span class="math notranslate nohighlight">\(i\)</span> in <span class="math notranslate nohighlight">\(0, 1, \ldots, h\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_rank_symmetric</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_rank_symmetric</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_ranked">
<code class="descname">is_ranked</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_ranked" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is ranked, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>A poset is ranked if there is a function <span class="math notranslate nohighlight">\(r\)</span> from  poset elements
to integers so that <span class="math notranslate nohighlight">\(r(x)=r(y)+1\)</span> when <span class="math notranslate nohighlight">\(x\)</span> covers <span class="math notranslate nohighlight">\(y\)</span>.</p>
<p>Informally said a ranked poset can be “levelized”: every element is
on a “level”, and every cover relation goes only one level up.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span> <span class="p">))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_ranked</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],[],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_ranked</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.rank_function" title="sage.combinat.posets.posets.FinitePoset.rank_function"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rank_function()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.rank" title="sage.combinat.posets.posets.FinitePoset.rank"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rank()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_graded" title="sage.combinat.posets.posets.FinitePoset.is_graded"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_graded()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_series_parallel">
<code class="descname">is_series_parallel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_series_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is series-parallel, and <code class="docutils literal notranslate"><span class="pre">False</span></code>
otherwise.</p>
<p>A poset is <em>series-parallel</em> if it can be built up from one-element
posets using the operations of disjoint union and ordinal
sum. This is also called <em>N-free</em> property: every poset that is not
series-parallel contains a subposet isomorphic to the 4-element
N-shaped poset where <span class="math notranslate nohighlight">\(a &gt; c, d\)</span> and <span class="math notranslate nohighlight">\(b &gt; d\)</span>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Some papers use the term N-free for posets having no
N-shaped poset as a <em>cover-preserving subposet</em>. This definition
is not used here.</p>
</div>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Series-parallel partial order">Wikipedia article Series-parallel partial order</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">VA</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">VA</span><span class="o">.</span><span class="n">is_series_parallel</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">big_N</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">6</span><span class="p">:[</span><span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">big_N</span><span class="o">.</span><span class="n">is_series_parallel</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_slender">
<code class="descname">is_slender</code><span class="sig-paren">(</span><em>certificate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_slender" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is slender, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>A finite graded poset is <em>slender</em> if every rank 2
interval contains three or four elements, as defined in
<a class="reference internal" href="../../../../references/index.html#stan2009" id="id15">[Stan2009]</a>. (This notion of “slender” is unrelated to
the eponymous notion defined by Graetzer and Kelly in
“The Free <span class="math notranslate nohighlight">\(\mathfrak{m}\)</span>-Lattice on the Poset <span class="math notranslate nohighlight">\(H\)</span>”,
Order 1 (1984), 47–65.)</p>
<p>This function <em>does not</em> check if the poset is graded or not.
Instead it just returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset does not contain
5 distinct elements <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>, <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b\)</span> and <span class="math notranslate nohighlight">\(c\)</span> such that
<span class="math notranslate nohighlight">\(x \lessdot a,b,c \lessdot y\)</span> where <span class="math notranslate nohighlight">\(\lessdot\)</span> is the covering
relation.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) whether to return
a certificate</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>If <code class="docutils literal notranslate"><span class="pre">certificate=True</span></code> return either <code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">None)</span></code> or
<code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">(a,</span> <span class="pre">b))</span></code> so that the interval <span class="math notranslate nohighlight">\([a, b]\)</span> has at
least five elements. If <code class="docutils literal notranslate"><span class="pre">certificate=False</span></code> return
<code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_slender</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_slender</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">WeylGroup</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">bruhat_poset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_slender</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">WeylGroup</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">bruhat_poset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_slender</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">IntegerPartitions</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_slender</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(False, ((6,), (3, 2, 1)))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_sperner">
<code class="descname">is_sperner</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_sperner" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is Sperner, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>The poset is expected to be ranked.</p>
<p>A poset is Sperner, if no antichain is larger than the largest
rank level (one of the sets of elements of the same rank) in
the poset.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Sperner_property_of_a_partially_ordered_set">Wikipedia article Sperner_property_of_a_partially_ordered_set</a></p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.width" title="sage.combinat.posets.posets.FinitePoset.width"><code class="xref py py-meth docutils literal notranslate"><span class="pre">width()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.dilworth_decomposition" title="sage.combinat.posets.posets.FinitePoset.dilworth_decomposition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dilworth_decomposition()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">posets</span><span class="o">.</span><span class="n">SetPartitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">is_sperner</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_sperner</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets">
<code class="descname">isomorphic_subposets</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of subposets of <code class="docutils literal notranslate"><span class="pre">self</span></code> isomorphic to <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>By subposet we mean <code class="docutils literal notranslate"><span class="pre">self.subposet(X)</span></code> which is isomorphic to
<code class="docutils literal notranslate"><span class="pre">other</span></code> and where <code class="docutils literal notranslate"><span class="pre">X</span></code> is a subset of elements of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">other</span></code> – a finite poset</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C2</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">C3</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">C3</span><span class="o">.</span><span class="n">isomorphic_subposets</span><span class="p">(</span><span class="n">C2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">L</span><span class="p">:</span> <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[[&#39;a&#39;, &#39;b&#39;]]</span>
<span class="go">[[&#39;a&#39;, &#39;c&#39;]]</span>
<span class="go">[[&#39;b&#39;, &#39;c&#39;]]</span>

<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">N5</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">N5</span><span class="o">.</span><span class="n">isomorphic_subposets</span><span class="p">(</span><span class="n">D</span><span class="p">))</span>
<span class="go">2</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If this function takes too much time, try using
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator" title="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isomorphic_subposets_iterator()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator">
<code class="descname">isomorphic_subposets_iterator</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over the subposets of <code class="docutils literal notranslate"><span class="pre">self</span></code> isomorphic to
<code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>By subposet we mean <code class="docutils literal notranslate"><span class="pre">self.subposet(X)</span></code> which is isomorphic
to <code class="docutils literal notranslate"><span class="pre">other</span></code> and where <code class="docutils literal notranslate"><span class="pre">X</span></code> is a subset of elements of
<code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">other</span></code> – a finite poset</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">N5</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">N5</span><span class="o">.</span><span class="n">isomorphic_subposets_iterator</span><span class="p">(</span><span class="n">D</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">print</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span>
<span class="go">[[0, 1], [0, 2], [1, 4], [2, 4]]</span>
<span class="go">[[0, 1], [0, 3], [1, 4], [3, 4]]</span>
<span class="go">[[0, 1], [0, 2], [1, 4], [2, 4]]</span>
<span class="go">[[0, 1], [0, 3], [1, 4], [3, 4]]</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function will return same subposet as many times as
there are automorphism on it. This is due to
<a class="reference external" href="../../../../graphs/sage/graphs/generic_graph.html#sage.graphs.generic_graph.GenericGraph.subgraph_search_iterator" title="(in Sage Reference Manual: Graph Theory v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subgraph_search_iterator()</span></code></a>
returning labelled subgraphs. On the other hand, this
function does not eat memory like
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets" title="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isomorphic_subposets()</span></code></a> does.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="lattices.html#sage.combinat.posets.lattices.FiniteLatticePoset.isomorphic_sublattices_iterator" title="sage.combinat.posets.lattices.FiniteLatticePoset.isomorphic_sublattices_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.combinat.posets.lattices.FiniteLatticePoset.isomorphic_sublattices_iterator()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.jump_number">
<code class="descname">jump_number</code><span class="sig-paren">(</span><em>certificate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.jump_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the jump number of the poset.</p>
<p>A <em>jump</em> in a linear extension <span class="math notranslate nohighlight">\([e_1, \ldots, e_n]\)</span> of a poset <span class="math notranslate nohighlight">\(P\)</span>
is a pair <span class="math notranslate nohighlight">\((e_i, e_{i+1})\)</span> so that <span class="math notranslate nohighlight">\(e_{i+1}\)</span> does not cover <span class="math notranslate nohighlight">\(e_i\)</span>
in <span class="math notranslate nohighlight">\(P\)</span>. The jump number of a poset is the minimal number of jumps
in linear extensions of a poset.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) Whether to return
a certificate</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>If <code class="docutils literal notranslate"><span class="pre">certificate=True</span></code> return a pair <span class="math notranslate nohighlight">\((n, l)\)</span> where
<span class="math notranslate nohighlight">\(n\)</span> is the jump number and <span class="math notranslate nohighlight">\(l\)</span> is a linear extension
with <span class="math notranslate nohighlight">\(n\)</span> jumps. If <code class="docutils literal notranslate"><span class="pre">certificate=False</span></code> return only
the jump number.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B3</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B3</span><span class="o">.</span><span class="n">jump_number</span><span class="p">()</span>
<span class="go">3</span>

<span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">jump_number</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(1, [1, 4, 2, 3])</span>
</pre></div>
</div>
<p>ALGORITHM:</p>
<p>It is known that every poset has a greedy linear extension –
an extension <span class="math notranslate nohighlight">\([e_1, e_2, \ldots, e_n]\)</span> where every <span class="math notranslate nohighlight">\(e_{i+1}\)</span> is
an upper cover of <span class="math notranslate nohighlight">\(e_i\)</span> if that is possible – with the smallest
possible number of jumps; see <a class="reference internal" href="../../../../references/index.html#sys1987" id="id16">[Sys1987]</a>.</p>
<p>Hence it suffices to test only those. We do that by backtracking.</p>
<p>The problem is proven to be NP-complete.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_jump_critical" title="sage.combinat.posets.posets.FinitePoset.is_jump_critical"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_jump_critical()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.kazhdan_lusztig_polynomial">
<code class="descname">kazhdan_lusztig_polynomial</code><span class="sig-paren">(</span><em>x=None</em>, <em>y=None</em>, <em>q=None</em>, <em>canonical_labels=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.kazhdan_lusztig_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Kazhdan-Lusztig polynomial <span class="math notranslate nohighlight">\(P_{x,y}(q)\)</span> of the poset.</p>
<p>The poset is expected to be ranked.</p>
<p>We follow the definition given in <a class="reference internal" href="../../../../references/index.html#epw14" id="id17">[EPW14]</a>. Let <span class="math notranslate nohighlight">\(G\)</span> denote a
graded poset with unique minimal and maximal elements and <span class="math notranslate nohighlight">\(\chi_G\)</span>
denote the characteristic polynomial of <span class="math notranslate nohighlight">\(G\)</span>. Let <span class="math notranslate nohighlight">\(I_x\)</span> and <span class="math notranslate nohighlight">\(F^x\)</span>
denote the principal order ideal and filter of <span class="math notranslate nohighlight">\(x\)</span> respectively.
Define the <em>Kazhdan-Lusztig polynomial</em> of <span class="math notranslate nohighlight">\(G\)</span> as the unique
polynomial <span class="math notranslate nohighlight">\(P_G(q)\)</span> satisfying the following:</p>
<ol class="arabic">
<li><p class="first">If <span class="math notranslate nohighlight">\(\operatorname{rank} G = 0\)</span>, then <span class="math notranslate nohighlight">\(P_G(q) = 1\)</span>.</p>
</li>
<li><p class="first">If <span class="math notranslate nohighlight">\(\operatorname{rank} G &gt; 0\)</span>, then <span class="math notranslate nohighlight">\(\deg P_G(q) &lt;
\frac{1}{2} \operatorname{rank} G\)</span>.</p>
</li>
<li><p class="first">We have</p>
<div class="math notranslate nohighlight">
\[q^{\operatorname{rank} G} P_G(q^{-1})
= \sum_{x \in G} \chi_{I_x}(q) P_{F^x}(q).\]</div>
</li>
</ol>
<p>We then extend this to <span class="math notranslate nohighlight">\(P_{x,y}(q)\)</span> by considering the subposet
corresponding to the (closed) interval <span class="math notranslate nohighlight">\([x, y]\)</span>. We also
define <span class="math notranslate nohighlight">\(P_{\emptyset}(q) = 0\)</span> (so if <span class="math notranslate nohighlight">\(x \not\leq y\)</span>,
then <span class="math notranslate nohighlight">\(P_{x,y}(q) = 0\)</span>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">q</span></code> – (default: <span class="math notranslate nohighlight">\(q \in \ZZ[q]\)</span>) the indeterminate <span class="math notranslate nohighlight">\(q\)</span></li>
<li><code class="docutils literal notranslate"><span class="pre">x</span></code> – (default: the minimal element) the element <span class="math notranslate nohighlight">\(x\)</span></li>
<li><code class="docutils literal notranslate"><span class="pre">y</span></code> – (default: the maximal element) the element <span class="math notranslate nohighlight">\(y\)</span></li>
<li><code class="docutils literal notranslate"><span class="pre">canonical_labels</span></code> – (optional) for subposets, use the
canonical labeling (this can limit recursive calls for posets
with large amounts of symmetry, but producing the labeling
takes time); if not specified, this is <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">x</span></code>
and <code class="docutils literal notranslate"><span class="pre">y</span></code> are both not specified and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">kazhdan_lusztig_polynomial</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">SymmetricGroupWeakOrderPoset</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">kazhdan_lusztig_polynomial</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;2314&#39;</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="s1">&#39;3421&#39;</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">kazhdan_lusztig_polynomial</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">-q + 1</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">kazhdan_lusztig_polynomial</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">))</span>
<span class="go">-t + 1</span>
</pre></div>
</div>
<p>AUTHORS:</p>
<ul class="simple">
<li>Travis Scrimshaw (27-12-2014)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.le">
<code class="descname">le</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.le" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <span class="math notranslate nohighlight">\(x\)</span> is less than or equal to <span class="math notranslate nohighlight">\(y\)</span> in the poset, and
<code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_less_than" title="sage.combinat.posets.posets.FinitePoset.is_less_than"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_less_than()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_gequal" title="sage.combinat.posets.posets.FinitePoset.is_gequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_gequal()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.lequal_matrix">
<code class="descname">lequal_matrix</code><span class="sig-paren">(</span><em>ring=Integer Ring</em>, <em>sparse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.lequal_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the matrix whose <code class="docutils literal notranslate"><span class="pre">(i,j)</span></code> entry is 1 if
<code class="docutils literal notranslate"><span class="pre">self.linear_extension()[i]</span> <span class="pre">&lt;</span> <span class="pre">self.linear_extension()[j]</span></code> and 0
otherwise.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">ring</span></code> – the ring of coefficients (default: <code class="docutils literal notranslate"><span class="pre">ZZ</span></code>)</li>
<li><code class="docutils literal notranslate"><span class="pre">sparse</span></code> – whether the returned matrix is sparse or not
(default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[]],</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">LEQM</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">lequal_matrix</span><span class="p">();</span> <span class="n">LEQM</span>
<span class="go">[1 1 1 1 1 1 1 1]</span>
<span class="go">[0 1 0 1 0 0 0 1]</span>
<span class="go">[0 0 1 1 1 0 1 1]</span>
<span class="go">[0 0 0 1 0 0 0 1]</span>
<span class="go">[0 0 0 0 1 0 0 1]</span>
<span class="go">[0 0 0 0 0 1 1 1]</span>
<span class="go">[0 0 0 0 0 0 1 1]</span>
<span class="go">[0 0 0 0 0 0 0 1]</span>
<span class="gp">sage: </span><span class="n">LEQM</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">LEQM</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()[</span><span class="mi">5</span><span class="p">]</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We now demonstrate the usage of the optional parameters:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">lequal_matrix</span><span class="p">(</span><span class="n">ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Full MatrixSpace of 8 by 8 dense matrices over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.level_sets">
<code class="descname">level_sets</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.level_sets" title="Permalink to this definition">¶</a></dt>
<dd><p>Return elements grouped by maximal number of cover relations
from a minimal element.</p>
<p>This returns a list of lists <code class="docutils literal notranslate"><span class="pre">l</span></code> such that <code class="docutils literal notranslate"><span class="pre">l[i]</span></code> is the
set of minimal elements of the poset obtained by removing the
elements in <code class="docutils literal notranslate"><span class="pre">l[0],</span> <span class="pre">l[1],</span> <span class="pre">...,</span> <span class="pre">l[i-1]</span></code>. (In particular,
<code class="docutils literal notranslate"><span class="pre">l[0]</span></code> is the set of minimal elements of <code class="docutils literal notranslate"><span class="pre">self</span></code>.)</p>
<p>Every level is an antichain of the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">level_sets</span><span class="p">()</span>
<span class="go">[[0], [1, 2], [3]]</span>

<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">level_sets</span><span class="p">()</span>
<span class="go">[[0], [1, 2], [3], [4]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.dilworth_decomposition" title="sage.combinat.posets.posets.FinitePoset.dilworth_decomposition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dilworth_decomposition()</span></code></a> to return elements grouped
to chains.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.lexicographic_sum">
<code class="descname">lexicographic_sum</code><span class="sig-paren">(</span><em>P</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.lexicographic_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the lexicographic sum using this poset as index.</p>
<p>In the lexicographic sum of posets <span class="math notranslate nohighlight">\(P_t\)</span> by index poset <span class="math notranslate nohighlight">\(T\)</span>
we have <span class="math notranslate nohighlight">\(x \le y\)</span> if either <span class="math notranslate nohighlight">\(x \le y\)</span> in <span class="math notranslate nohighlight">\(P_t\)</span>
for some <span class="math notranslate nohighlight">\(t \in T\)</span>, or <span class="math notranslate nohighlight">\(x \in P_i\)</span>, <span class="math notranslate nohighlight">\(y \in P_j\)</span> and
<span class="math notranslate nohighlight">\(i \le j\)</span> in <span class="math notranslate nohighlight">\(T\)</span>.</p>
<p>Informally said we substitute every element of <span class="math notranslate nohighlight">\(T\)</span> by corresponding
poset <span class="math notranslate nohighlight">\(P_t\)</span>.</p>
<p>Mathematically, it is only defined when all <span class="math notranslate nohighlight">\(P_t\)</span> have no
common element; here we force that by giving them different
names in the resulting poset.</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.disjoint_union" title="sage.combinat.posets.posets.FinitePoset.disjoint_union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">disjoint_union()</span></code></a> and <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_sum" title="sage.combinat.posets.posets.FinitePoset.ordinal_sum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ordinal_sum()</span></code></a> are special cases
of lexicographic sum where the index poset is an (anti)chain.
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_product" title="sage.combinat.posets.posets.FinitePoset.ordinal_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ordinal_product()</span></code></a> is a special case where every <span class="math notranslate nohighlight">\(P_t\)</span> is same
poset.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">P</span></code> – dictionary whose keys are elements of this poset, values are posets</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">(),</span> <span class="mi">2</span><span class="p">:</span> <span class="n">N</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">4</span><span class="p">:</span> <span class="n">posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">4</span><span class="p">)}</span>
<span class="gp">sage: </span><span class="n">NP</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">lexicographic_sum</span><span class="p">(</span><span class="n">P</span><span class="p">);</span> <span class="n">NP</span>
<span class="go">Finite poset containing 16 elements</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">NP</span><span class="o">.</span><span class="n">minimal_elements</span><span class="p">())</span>
<span class="go">[(1, 0), (2, 1), (2, 2)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.linear_extension">
<code class="descname">linear_extension</code><span class="sig-paren">(</span><em>linear_extension=None</em>, <em>check=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.linear_extension" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a linear extension of this poset.</p>
<p>A linear extension of a finite poset <span class="math notranslate nohighlight">\(P\)</span> of size <span class="math notranslate nohighlight">\(n\)</span> is a total
ordering <span class="math notranslate nohighlight">\(\pi := \pi_0 \pi_1 \ldots \pi_{n-1}\)</span> of its elements
such that <span class="math notranslate nohighlight">\(i&lt;j\)</span> whenever <span class="math notranslate nohighlight">\(\pi_i &lt; \pi_j\)</span> in the poset <span class="math notranslate nohighlight">\(P\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">linear_extension</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) a list of the
elements of <code class="docutils literal notranslate"><span class="pre">self</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">check</span></code> – a boolean (default: True);
whether to check that <code class="docutils literal notranslate"><span class="pre">linear_extension</span></code> is indeed a
linear extension of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Without optional argument, the default linear extension of the
poset is returned, as a plain list:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()</span>
<span class="go">[1, 3, 5, 15]</span>
</pre></div>
</div>
<p>Otherwise, a full-featured linear extension is constructed
as an element of <code class="docutils literal notranslate"><span class="pre">P.linear_extensions()</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">15</span><span class="p">]);</span> <span class="n">l</span>
<span class="go">[1, 5, 3, 15]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.combinat.posets.linear_extensions.LinearExtensionsOfPoset_with_category.element_class&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">l</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">The set of all linear extensions of Finite poset containing 4 elements</span>
</pre></div>
</div>
<p>By default, the linear extension is checked for correctness:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: [1, 3, 15, 5] is not a linear extension of Finite poset containing 4 elements</span>
</pre></div>
</div>
<p>This can be disabled (at your own risks!) with:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">[1, 3, 15, 5]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_linear_extension" title="sage.combinat.posets.posets.FinitePoset.is_linear_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_linear_extension()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extensions" title="sage.combinat.posets.posets.FinitePoset.linear_extensions"><code class="xref py py-meth docutils literal notranslate"><span class="pre">linear_extensions()</span></code></a></p>
</div>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<ul class="last simple">
<li>Is it acceptable to have those two features for a single method?</li>
<li>In particular, we miss a short idiom to get the default
linear extension</li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.linear_extensions">
<code class="descname">linear_extensions</code><span class="sig-paren">(</span><em>facade=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.linear_extensions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the enumerated set of all the linear extensions of this poset</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">facade</span></code> – a boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>);
whether to return the linear extensions as plain lists</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>The <code class="docutils literal notranslate"><span class="pre">facade</span></code> option is not yet fully functional:</p>
<div class="last highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extensions</span><span class="p">(</span><span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span> <span class="n">L</span>
<span class="go">The set of all linear extensions of Finite poset containing 6 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: Cannot convert list to sage.structure.element.Element</span>
</pre></div>
</div>
</div>
</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extensions</span><span class="p">();</span> <span class="n">L</span>
<span class="go">The set of all linear extensions of Finite poset containing 6 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">l</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[1, 2, 3, 4, 6, 12],</span>
<span class="go"> [1, 2, 4, 3, 6, 12],</span>
<span class="go"> [1, 3, 2, 4, 6, 12],</span>
<span class="go"> [1, 3, 2, 6, 4, 12],</span>
<span class="go"> [1, 2, 3, 6, 4, 12]]</span>
</pre></div>
</div>
<p>Each element is aware that it is a linear extension of <span class="math notranslate nohighlight">\(P\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">parent</span><span class="p">())</span>
<span class="go">&lt;class &#39;sage.combinat.posets.linear_extensions.LinearExtensionsOfPoset_with_category&#39;&gt;</span>
</pre></div>
</div>
<p>With <code class="docutils literal notranslate"><span class="pre">facade=True</span></code>, the elements of <code class="docutils literal notranslate"><span class="pre">L</span></code> are plain lists instead:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extensions</span><span class="p">(</span><span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="go">&lt;... &#39;list&#39;&gt;</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>In Sage &lt;= 4.8, this function used to return a plain list
of lists. To recover the previous functionality, please use:</p>
<div class="last highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">linear_extensions</span><span class="p">(</span><span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">));</span> <span class="n">L</span>
<span class="go">[[1, 2, 3, 4, 6, 12],</span>
<span class="go"> [1, 2, 4, 3, 6, 12],</span>
<span class="go"> [1, 3, 2, 4, 6, 12],</span>
<span class="go"> [1, 3, 2, 6, 4, 12],</span>
<span class="go"> [1, 2, 3, 6, 4, 12]]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;... &#39;list&#39;&gt;</span>
</pre></div>
</div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extension" title="sage.combinat.posets.posets.FinitePoset.linear_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">linear_extension()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_linear_extension" title="sage.combinat.posets.posets.FinitePoset.is_linear_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_linear_extension()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.linear_extensions_graph">
<code class="descname">linear_extensions_graph</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.linear_extensions_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the linear extensions graph of the poset.</p>
<p>Vertices of the graph are linear extensions of the poset.
Two vertices are connected by an edge if the linear extensions
differ by only one adjacent transposition.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">linear_extensions_graph</span><span class="p">();</span> <span class="n">G</span>
<span class="go">Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]))</span>
<span class="go">[[2, 1, 3, 4], [1, 3, 2, 4], [1, 2, 4, 3]]</span>

<span class="gp">sage: </span><span class="n">chevron</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">chevron</span><span class="o">.</span><span class="n">linear_extensions_graph</span><span class="p">();</span> <span class="n">G</span>
<span class="go">Graph on 22 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">36</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.list">
<code class="descname">list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.list" title="Permalink to this definition">¶</a></dt>
<dd><p>List the elements of the poset. This just returns the result
of <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extension" title="sage.combinat.posets.posets.FinitePoset.linear_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">linear_extension()</span></code></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="p">},</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">list</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;class &#39;sage.combinat.posets.posets.FinitePoset_with_category.element_class&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.lower_covers">
<code class="descname">lower_covers</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.lower_covers" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of lower covers of the element <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>A lower cover of <span class="math notranslate nohighlight">\(x\)</span> is an element <span class="math notranslate nohighlight">\(y\)</span> such that <span class="math notranslate nohighlight">\(y &lt; x\)</span> and
there is no element <span class="math notranslate nohighlight">\(z\)</span> so that <span class="math notranslate nohighlight">\(y &lt; z &lt; x\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">lower_covers</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[2, 5]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">lower_covers</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.upper_covers" title="sage.combinat.posets.posets.FinitePoset.upper_covers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">upper_covers()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.lower_covers_iterator">
<code class="descname">lower_covers_iterator</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.lower_covers_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over the lower covers of the element <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">l0</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">lower_covers_iterator</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">l0</span><span class="p">)</span>
<span class="go">&lt;... &#39;generator&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">l0</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.lt">
<code class="descname">lt</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.lt" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <span class="math notranslate nohighlight">\(x\)</span> is less than but not equal to <span class="math notranslate nohighlight">\(y\)</span> in the poset,
and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>For non-facade posets also <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> works:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]},</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_lequal" title="sage.combinat.posets.posets.FinitePoset.is_lequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_lequal()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_greater_than" title="sage.combinat.posets.posets.FinitePoset.is_greater_than"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_greater_than()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.maximal_antichains">
<code class="descname">maximal_antichains</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.maximal_antichains" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximal antichains of the poset.</p>
<p>An antichain <span class="math notranslate nohighlight">\(a\)</span> of poset <span class="math notranslate nohighlight">\(P\)</span> is <em>maximal</em> if there is
no element <span class="math notranslate nohighlight">\(e \in P \setminus a\)</span> such that <span class="math notranslate nohighlight">\(a \cup \{e\}\)</span>
is an antichain.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">=</span><span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;d&#39;</span><span class="p">,</span><span class="s1">&#39;e&#39;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="n">anti</span><span class="p">)</span> <span class="k">for</span> <span class="n">anti</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">maximal_antichains</span><span class="p">()]</span>
<span class="go">[[&#39;a&#39;], [&#39;b&#39;, &#39;c&#39;], [&#39;c&#39;, &#39;d&#39;, &#39;e&#39;]]</span>

<span class="gp">sage: </span><span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">maximal_antichains</span><span class="p">()</span>
<span class="go">[[0], [1, 2], [1, 3], [4]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains" title="sage.combinat.posets.posets.FinitePoset.antichains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">antichains()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_chains" title="sage.combinat.posets.posets.FinitePoset.maximal_chains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximal_chains()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.maximal_chains">
<code class="descname">maximal_chains</code><span class="sig-paren">(</span><em>partial=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.maximal_chains" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all maximal chains of this poset.</p>
<p>Each chain is listed in increasing order.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">partial</span></code> – list (optional); if present, find all maximal
chains starting with the elements in partial</li>
</ul>
<p>Returns list of the maximal chains of this poset.</p>
<p>This is used in constructing the order complex for the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">maximal_chains</span><span class="p">()</span>
<span class="go">[[0, 1, 3, 7], [0, 1, 5, 7], [0, 2, 3, 7], [0, 2, 6, 7], [0, 4, 5, 7], [0, 4, 6, 7]]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">maximal_chains</span><span class="p">(</span><span class="n">partial</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">[[0, 2, 3, 7], [0, 2, 6, 7]]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">maximal_chains</span><span class="p">()</span>
<span class="go">[[0, 1, 2, 3, 4, 5]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_antichains" title="sage.combinat.posets.posets.FinitePoset.maximal_antichains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximal_antichains()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.chains" title="sage.combinat.posets.posets.FinitePoset.chains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">chains()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.maximal_elements">
<code class="descname">maximal_elements</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.maximal_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of the maximal elements of the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span><span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">maximal_elements</span><span class="p">()</span>
<span class="go">[4]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.minimal_elements" title="sage.combinat.posets.posets.FinitePoset.minimal_elements"><code class="xref py py-meth docutils literal notranslate"><span class="pre">minimal_elements()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.minimal_elements">
<code class="descname">minimal_elements</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.minimal_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of the minimal elements of the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span><span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">minimal_elements</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">minimal_elements</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">minimal_elements</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_elements" title="sage.combinat.posets.posets.FinitePoset.maximal_elements"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximal_elements()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.moebius_function">
<code class="descname">moebius_function</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.moebius_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the value of the Möbius function of the poset on the
elements x and y.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">P</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="nb">sum</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">P</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">v</span><span class="p">))</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">P</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">cover_relations_iterator</span><span class="p">():</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="n">P</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Bug in moebius_function!&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[]])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="nb">sum</span><span class="p">([</span><span class="n">Q</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Q</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.moebius_function_matrix">
<code class="descname">moebius_function_matrix</code><span class="sig-paren">(</span><em>ring=Integer Ring</em>, <em>sparse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.moebius_function_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a matrix whose <code class="docutils literal notranslate"><span class="pre">(i,j)</span></code> entry is the value of the Möbius
function evaluated at <code class="docutils literal notranslate"><span class="pre">self.linear_extension()[i]</span></code> and
<code class="docutils literal notranslate"><span class="pre">self.linear_extension()[j]</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">ring</span></code> – the ring of coefficients (default: <code class="docutils literal notranslate"><span class="pre">ZZ</span></code>)</li>
<li><code class="docutils literal notranslate"><span class="pre">sparse</span></code> – whether the returned matrix is sparse or not
(default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[],[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">moebius_function_matrix</span><span class="p">();</span> <span class="n">M</span>
<span class="go">[ 1 -1 -1 -1  2]</span>
<span class="go">[ 0  1  0  0 -1]</span>
<span class="go">[ 0  0  1  0 -1]</span>
<span class="go">[ 0  0  0  1 -1]</span>
<span class="go">[ 0  0  0  0  1]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="go">-1</span>
</pre></div>
</div>
<p>We now demonstrate the usage of the optional parameters:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">moebius_function_matrix</span><span class="p">(</span><span class="n">ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Full MatrixSpace of 5 by 5 dense matrices over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.open_interval">
<code class="descname">open_interval</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.open_interval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of elements <span class="math notranslate nohighlight">\(z\)</span> such that <span class="math notranslate nohighlight">\(x &lt; z &lt; y\)</span> in the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">open_interval</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="go">[4, 10, 20, 50]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.closed_interval" title="sage.combinat.posets.posets.FinitePoset.closed_interval"><code class="xref py py-meth docutils literal notranslate"><span class="pre">closed_interval()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.order_complex">
<code class="descname">order_complex</code><span class="sig-paren">(</span><em>on_ints=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.order_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the order complex associated to this poset.</p>
<p>The order complex is the simplicial complex with vertices equal
to the elements of the poset, and faces given by the chains.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">on_ints</span></code> – a boolean (default: False)</li>
</ul>
<p>OUTPUT:</p>
<p>an order complex of type <a class="reference external" href="../../../../homology/sage/homology/simplicial_complex.html#sage.homology.simplicial_complex.SimplicialComplex" title="(in Sage Reference Manual: Cell complexes and their homology v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimplicialComplex</span></code></a></p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_complex</span><span class="p">();</span> <span class="n">S</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3, 4, 5, 6, 7) and 6 facets</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 8, 19, 18, 6]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>      <span class="c1"># S is contractible</span>
<span class="go">{0: 0, 1: 0, 2: 0, 3: 0}</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">subposet</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">order_complex</span><span class="p">()</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>    <span class="c1"># a circle</span>
<span class="go">{0: 0, 1: Z}</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_complex</span><span class="p">()</span>
<span class="go">Simplicial complex with vertex set (1, 3, 5, 15) and facets {(1, 3, 15), (1, 5, 15)}</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">on_ints</span></code>, then the elements of the poset are labelled
<span class="math notranslate nohighlight">\(0,1,\dots\)</span> in the chain complex:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_complex</span><span class="p">(</span><span class="n">on_ints</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3) and facets {(0, 1, 3), (0, 2, 3)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.order_filter">
<code class="descname">order_filter</code><span class="sig-paren">(</span><em>elements</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.order_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the order filter generated by the elements of an
iterable <code class="docutils literal notranslate"><span class="pre">elements</span></code>.</p>
<p><span class="math notranslate nohighlight">\(I\)</span> is an order filter if, for any <span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(I\)</span> and <span class="math notranslate nohighlight">\(y\)</span> such that
<span class="math notranslate nohighlight">\(y \ge x\)</span>, then <span class="math notranslate nohighlight">\(y\)</span> is in <span class="math notranslate nohighlight">\(I\)</span>. This is also called upper set or
upset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_filter</span><span class="p">([</span><span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">])</span>
<span class="go">[20, 40, 25, 50, 100, 200, 125, 250, 500, 1000]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_ideal" title="sage.combinat.posets.posets.FinitePoset.order_ideal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_ideal()</span></code></a>, <a class="reference external" href="../../../../categories/sage/categories/posets.html#sage.categories.posets.Posets.ParentMethods.principal_order_filter" title="(in Sage Reference Manual: Category Framework v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">principal_order_filter()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.order_ideal">
<code class="descname">order_ideal</code><span class="sig-paren">(</span><em>elements</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.order_ideal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the order ideal generated by the elements of an
iterable <code class="docutils literal notranslate"><span class="pre">elements</span></code>.</p>
<p><span class="math notranslate nohighlight">\(I\)</span> is an order ideal if, for any <span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(I\)</span> and <span class="math notranslate nohighlight">\(y\)</span> such that
<span class="math notranslate nohighlight">\(y \le x\)</span>, then <span class="math notranslate nohighlight">\(y\)</span> is in <span class="math notranslate nohighlight">\(I\)</span>. This is also called lower set or
downset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal</span><span class="p">([</span><span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">])</span>
<span class="go">[1, 2, 4, 5, 10, 20, 25]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_filter" title="sage.combinat.posets.posets.FinitePoset.order_filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_filter()</span></code></a>, <a class="reference external" href="../../../../categories/sage/categories/posets.html#sage.categories.posets.Posets.ParentMethods.principal_order_ideal" title="(in Sage Reference Manual: Category Framework v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">principal_order_ideal()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.order_ideal_plot">
<code class="descname">order_ideal_plot</code><span class="sig-paren">(</span><em>elements</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.order_ideal_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a plot of the order ideal generated by the elements of an
iterable <code class="docutils literal notranslate"><span class="pre">elements</span></code>.</p>
<p><span class="math notranslate nohighlight">\(I\)</span> is an order ideal if, for any <span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(I\)</span> and <span class="math notranslate nohighlight">\(y\)</span> such that
<span class="math notranslate nohighlight">\(y \le x\)</span>, then <span class="math notranslate nohighlight">\(y\)</span> is in <span class="math notranslate nohighlight">\(I\)</span>. This is also called lower set or
downset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_plot</span><span class="p">([</span><span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">])</span>
<span class="go">Graphics object consisting of 41 graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.order_polynomial">
<code class="descname">order_polynomial</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.order_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the order polynomial of the poset.</p>
<p>The order polynomial <span class="math notranslate nohighlight">\(\Omega_P(q)\)</span> of a poset <span class="math notranslate nohighlight">\(P\)</span> is defined
as the unique polynomial <span class="math notranslate nohighlight">\(S\)</span> such that for each integer
<span class="math notranslate nohighlight">\(m \geq 1\)</span>, <span class="math notranslate nohighlight">\(S(m)\)</span> is the number of order-preserving maps
from <span class="math notranslate nohighlight">\(P\)</span> to <span class="math notranslate nohighlight">\(\{1,\ldots,m\}\)</span>.</p>
<p>See sections 3.12 and 3.15 of <a class="reference internal" href="../../../../references/index.html#enumcomb1" id="id18">[EnumComb1]</a>, and also
<a class="reference internal" href="../../../../references/index.html#st1986" id="id19">[St1986]</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_polynomial</span><span class="p">()</span>
<span class="go">q^3</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_polynomial</span><span class="p">();</span> <span class="n">f</span>
<span class="go">1/6*q^3 + 1/2*q^2 + 1/3*q</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
<span class="go">[0, 1, 4, 10]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_polytope" title="sage.combinat.posets.posets.FinitePoset.order_polytope"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_polytope()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.order_polytope">
<code class="descname">order_polytope</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.order_polytope" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the order polytope of the poset <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The order polytope of a finite poset <span class="math notranslate nohighlight">\(P\)</span> is defined as the subset
of <span class="math notranslate nohighlight">\(\RR^P\)</span> consisting of all maps <span class="math notranslate nohighlight">\(x : P \to \RR\)</span> satisfying</p>
<div class="math notranslate nohighlight">
\[0 \leq x(p) \leq 1 \mbox{ for all } p \in P,\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[x(p) \leq x(q) \mbox{ for all } p, q \in P
\mbox{ satisfying } p &lt; q.\]</div>
<p>This polytope was defined and studied in <a class="reference internal" href="../../../../references/index.html#st1986" id="id20">[St1986]</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_polytope</span><span class="p">();</span><span class="n">Q</span>
<span class="go">A 3-dimensional polyhedron in ZZ^3 defined as the convex hull of 8 vertices</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_polytope</span><span class="p">();</span><span class="n">Q</span>
<span class="go">A 5-dimensional polyhedron in ZZ^5 defined as the convex hull of 8 vertices</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_polytope</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">contains</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">contains</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.ordinal_product">
<code class="descname">ordinal_product</code><span class="sig-paren">(</span><em>other</em>, <em>labels='pairs'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.ordinal_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ordinal product of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>The ordinal product of two posets <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> is a partial
order on the Cartesian product of the underlying sets of <span class="math notranslate nohighlight">\(P\)</span>
and <span class="math notranslate nohighlight">\(Q\)</span>, defined as follows (see <a class="reference internal" href="../../../../references/index.html#enumcomb1" id="id21">[EnumComb1]</a>, p. 284).</p>
<p>In the ordinal product, <span class="math notranslate nohighlight">\((p,q) \leq (p',q')\)</span> if either <span class="math notranslate nohighlight">\(p \leq
p'\)</span> or <span class="math notranslate nohighlight">\(p = p'\)</span> and <span class="math notranslate nohighlight">\(q \leq q'\)</span>.</p>
<p>This construction is not symmetric in <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span>. Informally
said we put a copy of <span class="math notranslate nohighlight">\(Q\)</span> in place of every element of <span class="math notranslate nohighlight">\(P\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">other</span></code> – a poset</li>
<li><code class="docutils literal notranslate"><span class="pre">labels</span></code> – either <code class="docutils literal notranslate"><span class="pre">'integers'</span></code> or <code class="docutils literal notranslate"><span class="pre">'pairs'</span></code> (default); how
the resulting poset will be labeled</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="p">[[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">ordinal_product</span><span class="p">(</span><span class="n">P2</span><span class="p">);</span> <span class="n">P</span>
<span class="go">Finite poset containing 4 elements</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span>
<span class="go">[[(&#39;a&#39;, &#39;c&#39;), (&#39;a&#39;, &#39;d&#39;)], [(&#39;a&#39;, &#39;d&#39;), (&#39;b&#39;, &#39;c&#39;)],</span>
<span class="go">[(&#39;b&#39;, &#39;c&#39;), (&#39;b&#39;, &#39;d&#39;)]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.product" title="sage.combinat.posets.posets.FinitePoset.product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">product()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_sum" title="sage.combinat.posets.posets.FinitePoset.ordinal_sum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ordinal_sum()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.ordinal_sum">
<code class="descname">ordinal_sum</code><span class="sig-paren">(</span><em>other</em>, <em>labels='pairs'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.ordinal_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a poset or (semi)lattice isomorphic to ordinal sum of the
poset with <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>The ordinal sum of <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> is a poset that contains every
element and relation from both <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span>, and where every
element of <span class="math notranslate nohighlight">\(P\)</span> is smaller than any element of <span class="math notranslate nohighlight">\(Q\)</span>.</p>
<p>Mathematically, it is only defined when <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> have no
common element; here we force that by giving them different
names in the resulting poset.</p>
<p>The ordinal sum on lattices is a lattice; resp. for meet- and
join-semilattices.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">other</span></code>, a poset.</li>
<li><code class="docutils literal notranslate"><span class="pre">labels</span></code> - (defaults to ‘pairs’) If set to ‘pairs’, each
element <code class="docutils literal notranslate"><span class="pre">v</span></code> in this poset will be named <code class="docutils literal notranslate"><span class="pre">(0,v)</span></code> and each
element <code class="docutils literal notranslate"><span class="pre">u</span></code> in <code class="docutils literal notranslate"><span class="pre">other</span></code> will be named <code class="docutils literal notranslate"><span class="pre">(1,u)</span></code> in the
result. If set to ‘integers’, the elements of the result
will be relabeled with consecutive integers.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,],</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P3</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">ordinal_sum</span><span class="p">(</span><span class="n">P2</span><span class="p">);</span> <span class="n">P3</span>
<span class="go">Finite poset containing 7 elements</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">P1</span><span class="o">.</span><span class="n">maximal_elements</span><span class="p">())</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">P2</span><span class="o">.</span><span class="n">minimal_elements</span><span class="p">())</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">P1</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span><span class="o">+</span><span class="n">P2</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">P3</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span> <span class="c1"># Every element of P2 is greater than elements of P1.</span>
<span class="go">11</span>
<span class="gp">sage: </span><span class="n">P3</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>  <span class="c1"># random</span>
<span class="go">[(0, 1), (0, 2), (0, 4), (0, 3), (1, 2), (1, 3), (1, 1)]</span>
<span class="gp">sage: </span><span class="n">P4</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">ordinal_sum</span><span class="p">(</span><span class="n">P2</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="s1">&#39;integers&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P4</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>  <span class="c1"># random</span>
<span class="go">[0, 1, 2, 3, 5, 6, 4]</span>
</pre></div>
</div>
<p>Return type depends on input types:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">]});</span> <span class="n">P</span>
<span class="go">Finite poset containing 2 elements</span>
<span class="gp">sage: </span><span class="n">JL</span> <span class="o">=</span> <span class="n">JoinSemilattice</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">]});</span> <span class="n">JL</span>
<span class="go">Finite join-semilattice containing 2 elements</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">LatticePoset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">]});</span> <span class="n">L</span>
<span class="go">Finite lattice containing 2 elements</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">ordinal_sum</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="go">Finite poset containing 4 elements</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">ordinal_sum</span><span class="p">(</span><span class="n">JL</span><span class="p">)</span>
<span class="go">Finite join-semilattice containing 4 elements</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">ordinal_sum</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="go">Finite lattice containing 4 elements</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_summands" title="sage.combinat.posets.posets.FinitePoset.ordinal_summands"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ordinal_summands()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.disjoint_union" title="sage.combinat.posets.posets.FinitePoset.disjoint_union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">disjoint_union()</span></code></a>,
<a class="reference internal" href="lattices.html#sage.combinat.posets.lattices.FiniteLatticePoset.vertical_composition" title="sage.combinat.posets.lattices.FiniteLatticePoset.vertical_composition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.combinat.posets.lattices.FiniteLatticePoset.vertical_composition()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.ordinal_summands">
<code class="descname">ordinal_summands</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.ordinal_summands" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ordinal summands of the poset as subposets.</p>
<p>The ordinal summands of a poset <span class="math notranslate nohighlight">\(P\)</span> is the longest list of
non-empty subposets <span class="math notranslate nohighlight">\(P_1, \ldots, P_n\)</span> whose ordinal sum is <span class="math notranslate nohighlight">\(P\)</span>. This
decomposition is unique.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span>
<span class="gp">....: </span><span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">parts</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">ordinal_summands</span><span class="p">();</span> <span class="n">parts</span>
<span class="go">[Finite poset containing 4 elements, Finite poset containing 2 elements]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ordinal_sum</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_sum" title="sage.combinat.posets.posets.FinitePoset.ordinal_sum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ordinal_sum()</span></code></a></p>
</div>
<p>ALGORITHM:</p>
<p>Suppose that a poset <span class="math notranslate nohighlight">\(P\)</span> is the ordinal sum of posets <span class="math notranslate nohighlight">\(L\)</span> and <span class="math notranslate nohighlight">\(U\)</span>. Then
<span class="math notranslate nohighlight">\(P\)</span> contains maximal antichains <span class="math notranslate nohighlight">\(l\)</span> and <span class="math notranslate nohighlight">\(u\)</span> such that every element of
<span class="math notranslate nohighlight">\(u\)</span> covers every element of <span class="math notranslate nohighlight">\(l\)</span>; they correspond to maximal elements of
<span class="math notranslate nohighlight">\(L\)</span> and minimal elements of <span class="math notranslate nohighlight">\(U\)</span>.</p>
<p>We consider a linear extension <span class="math notranslate nohighlight">\(x_1,\ldots,x_n\)</span> of the poset’s
elements.</p>
<p>We keep track of the maximal elements of subposet induced by elements
<span class="math notranslate nohighlight">\(0,\ldots,x_i\)</span> and minimal elements of subposet induced by elements
<span class="math notranslate nohighlight">\(x_{i+1},\ldots,x_n\)</span>, incrementing <span class="math notranslate nohighlight">\(i\)</span> one by one. We then check if
<span class="math notranslate nohighlight">\(l\)</span> and <span class="math notranslate nohighlight">\(u\)</span> fit the previous description.</p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.p_partition_enumerator">
<code class="descname">p_partition_enumerator</code><span class="sig-paren">(</span><em>tup</em>, <em>R</em>, <em>weights=None</em>, <em>check=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.p_partition_enumerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <span class="math notranslate nohighlight">\(P\)</span>-partition enumerator of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Given a total order <span class="math notranslate nohighlight">\(\prec\)</span> on the elements of a finite poset <span class="math notranslate nohighlight">\(P\)</span>
(the order of <span class="math notranslate nohighlight">\(P\)</span> and the total order <span class="math notranslate nohighlight">\(\prec\)</span> can be unrelated; in
particular, the latter does not have to extend the former), a
<span class="math notranslate nohighlight">\(P\)</span>-partition enumerator is the quasisymmetric function
<span class="math notranslate nohighlight">\(\sum_f \prod_{p \in P} x_{f(p)}\)</span>, where the first sum is taken over
all <span class="math notranslate nohighlight">\(P\)</span>-partitions <span class="math notranslate nohighlight">\(f\)</span>.</p>
<p>A <span class="math notranslate nohighlight">\(P\)</span>-partition is a function <span class="math notranslate nohighlight">\(f : P \to \{1,2,3,...\}\)</span> satisfying
the following properties for any two elements <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> of <span class="math notranslate nohighlight">\(P\)</span>
satisfying <span class="math notranslate nohighlight">\(i &lt;_P j\)</span>:</p>
<ul class="simple">
<li>if <span class="math notranslate nohighlight">\(i \prec j\)</span> then <span class="math notranslate nohighlight">\(f(i) \leq f(j)\)</span>,</li>
<li>if <span class="math notranslate nohighlight">\(j \prec i\)</span> then <span class="math notranslate nohighlight">\(f(i) &lt; f(j)\)</span>.</li>
</ul>
<p>The optional argument <code class="docutils literal notranslate"><span class="pre">weights</span></code> allows constructing a
generalized (“weighted”) version of the <span class="math notranslate nohighlight">\(P\)</span>-partition enumerator.
Namely, <code class="docutils literal notranslate"><span class="pre">weights</span></code> should be a dictionary whose keys are the
elements of <code class="docutils literal notranslate"><span class="pre">P</span></code>.
Then, the generalized <span class="math notranslate nohighlight">\(P\)</span>-partition enumerator corresponding to
weights <code class="docutils literal notranslate"><span class="pre">weights</span></code> is <span class="math notranslate nohighlight">\(\sum_f \prod_{p \in P} x_{f(p)}^{w(p)}\)</span>,
where the sum is again over all <span class="math notranslate nohighlight">\(P\)</span>-partitions <span class="math notranslate nohighlight">\(f\)</span>. Here,
<span class="math notranslate nohighlight">\(w(p)\)</span> is <code class="docutils literal notranslate"><span class="pre">weights[p]</span></code>. The classical <span class="math notranslate nohighlight">\(P\)</span>-partition enumerator
is the particular case obtained when all <span class="math notranslate nohighlight">\(p\)</span> satisfy <span class="math notranslate nohighlight">\(w(p) = 1\)</span>.</p>
<p>In the language of <a class="reference internal" href="../../../../references/index.html#grinb2016a" id="id22">[Grinb2016a]</a>, the generalized <span class="math notranslate nohighlight">\(P\)</span>-partition
enumerator is the quasisymmetric function
<span class="math notranslate nohighlight">\(\Gamma\left(\mathbf{E}, w\right)\)</span>, where <span class="math notranslate nohighlight">\(\mathbf{E}\)</span> is the
special double poset <span class="math notranslate nohighlight">\((P, &lt;_P, \prec)\)</span>, and where
<span class="math notranslate nohighlight">\(w\)</span> is the dictionary <code class="docutils literal notranslate"><span class="pre">weights</span></code> (regarded as a function from
<span class="math notranslate nohighlight">\(P\)</span> to the positive integers).</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">tup</span></code> – the tuple containing all elements of <span class="math notranslate nohighlight">\(P\)</span> (each of
them exactly once), in the order dictated by the total order
<span class="math notranslate nohighlight">\(\prec\)</span></li>
<li><code class="docutils literal notranslate"><span class="pre">R</span></code> – a commutative ring</li>
<li><code class="docutils literal notranslate"><span class="pre">weights</span></code> – (optional) a dictionary of positive integers,
indexed by elements of <span class="math notranslate nohighlight">\(P\)</span>; any missing item will be understood
as <span class="math notranslate nohighlight">\(1\)</span></li>
</ul>
<p>OUTPUT:</p>
<p>The <span class="math notranslate nohighlight">\(P\)</span>-partition enumerator of <code class="docutils literal notranslate"><span class="pre">self</span></code> according to <code class="docutils literal notranslate"><span class="pre">tup</span></code> in the
algebra <span class="math notranslate nohighlight">\(QSym\)</span> of quasisymmetric functions over the base ring <span class="math notranslate nohighlight">\(R\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">FP</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">p_partition_enumerator</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">QQ</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span> <span class="n">FP</span>
<span class="go">2*M[1, 1, 1, 1] + 2*M[1, 2, 1] + M[2, 1, 1] + M[3, 1]</span>

<span class="gp">sage: </span><span class="n">expansion</span> <span class="o">=</span> <span class="n">FP</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">xs</span> <span class="o">=</span> <span class="n">expansion</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">expansion</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">([</span><span class="n">xs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">*</span><span class="n">xs</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">*</span><span class="n">xs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">*</span><span class="n">xs</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="n">b</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">])</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[],[]])</span>
<span class="gp">sage: </span><span class="n">FP</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">p_partition_enumerator</span><span class="p">((),</span> <span class="n">QQ</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span> <span class="n">FP</span>
<span class="go">M[]</span>
</pre></div>
</div>
<p>With the <code class="docutils literal notranslate"><span class="pre">weights</span></code> parameter:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">FP</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">p_partition_enumerator</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">QQ</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="n">check</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span> <span class="n">FP</span>
<span class="go">M[1, 2, 1, 1] + M[1, 3, 1] + M[2, 1, 1, 1] + M[2, 2, 1] + M[3, 1, 1] + M[4, 1]</span>
<span class="gp">sage: </span><span class="n">FP</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">p_partition_enumerator</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">QQ</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="n">check</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span> <span class="n">FP</span>
<span class="go">M[1, 2, 1, 1] + M[1, 3, 1] + M[2, 1, 1, 1] + M[2, 2, 1] + M[3, 1, 1] + M[4, 1]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">FP</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">p_partition_enumerator</span><span class="p">((</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="n">QQ</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">},</span> <span class="n">check</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span> <span class="n">FP</span>
<span class="go">M[3, 5, 7] + M[3, 7, 5] + M[3, 12]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">FP</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">p_partition_enumerator</span><span class="p">((</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="n">QQ</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">},</span> <span class="n">check</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span> <span class="n">FP</span>
<span class="go">M[3, 5, 7] + M[3, 12] + M[5, 3, 7] + M[8, 7]</span>
<span class="gp">sage: </span><span class="n">FP</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">p_partition_enumerator</span><span class="p">((</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">),</span> <span class="n">QQ</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">},</span> <span class="n">check</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span> <span class="n">FP</span>
<span class="go">M[3, 5, 7] + M[3, 12] + M[5, 3, 7] + M[5, 10] + M[8, 7] + M[15]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.plot">
<code class="descname">plot</code><span class="sig-paren">(</span><em>label_elements=True</em>, <em>element_labels=None</em>, <em>layout='acyclic'</em>, <em>cover_labels=None</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Graphic object for the Hasse diagram of the poset.</p>
<p>If the poset is ranked, the plot uses the rank function for
the heights of the elements.</p>
<p>INPUT:</p>
<ul class="simple">
<li>Options to change element look:<ul>
<li><code class="docutils literal notranslate"><span class="pre">element_colors</span></code> - a dictionary where keys are colors and values
are lists of elements</li>
<li><code class="docutils literal notranslate"><span class="pre">element_color</span></code> - a color for elements not set in
<code class="docutils literal notranslate"><span class="pre">element_colors</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">element_shape</span></code> - the shape of elements, like <code class="docutils literal notranslate"><span class="pre">'s'</span></code> for
square; see <a class="reference external" href="https://matplotlib.org/api/markers_api.html">https://matplotlib.org/api/markers_api.html</a> for the list</li>
<li><code class="docutils literal notranslate"><span class="pre">element_size</span></code> (default: 200) - the size of elements</li>
<li><code class="docutils literal notranslate"><span class="pre">label_elements</span></code> (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) - whether to display
element labels</li>
<li><code class="docutils literal notranslate"><span class="pre">element_labels</span></code> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) - a dictionary where keys
are elements and values are labels to show</li>
</ul>
</li>
<li>Options to change cover relation look:<ul>
<li><code class="docutils literal notranslate"><span class="pre">cover_colors</span></code> - a dictionary where keys are colors and values
are lists of cover relations given as pairs of elements</li>
<li><code class="docutils literal notranslate"><span class="pre">cover_color</span></code> - a color for elements not set in
<code class="docutils literal notranslate"><span class="pre">cover_colors</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">cover_style</span></code> - style for cover relations: <code class="docutils literal notranslate"><span class="pre">'solid'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'dashed'</span></code>, <code class="docutils literal notranslate"><span class="pre">'dotted'</span></code> or <code class="docutils literal notranslate"><span class="pre">'dashdot'</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">cover_labels</span></code> - a dictionary, list or function representing
labels of the covers of the poset. When set to <code class="docutils literal notranslate"><span class="pre">None</span></code> (default)
no label is displayed on the edges of the Hasse Diagram.</li>
<li><code class="docutils literal notranslate"><span class="pre">cover_labels_background</span></code> - a background color for cover
relations. The default is “white”. To achieve a transparent
background use “transparent”.</li>
</ul>
</li>
<li>Options to change overall look:<ul>
<li><code class="docutils literal notranslate"><span class="pre">figsize</span></code> (default: 8) - size of the whole plot</li>
<li><code class="docutils literal notranslate"><span class="pre">title</span></code> - a title for the plot</li>
<li><code class="docutils literal notranslate"><span class="pre">fontsize</span></code> - fontsize for the title</li>
<li><code class="docutils literal notranslate"><span class="pre">border</span></code> (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) - whether to draw a border over the
plot</li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">All options of <a class="reference external" href="../../../../graphs/sage/graphs/generic_graph.html#sage.graphs.generic_graph.GenericGraph.plot" title="(in Sage Reference Manual: Graph Theory v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GenericGraph.plot</span></code></a> are also available
through this function.</p>
</div>
<p>EXAMPLES:</p>
<p>This function can be used without any parameters:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D12</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DivisorLattice</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D12</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="go">Graphics object consisting of 14 graphics primitives</span>
</pre></div>
</div>
<p>Just the abstract form of the poset; examples of relabeling:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D12</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">label_elements</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">Graphics object consisting of 8 graphics primitives</span>
<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="mi">12</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
<span class="gp">sage: </span><span class="n">D12</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">element_labels</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
<span class="go">Graphics object consisting of 14 graphics primitives</span>
<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span><span class="nb">str</span><span class="p">(</span><span class="n">factor</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">D12</span><span class="p">}</span>
<span class="gp">sage: </span><span class="n">D12</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">element_labels</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
<span class="go">Graphics object consisting of 14 graphics primitives</span>
</pre></div>
</div>
<p>Some settings for coverings:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="p">{(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span> <span class="n">b</span><span class="o">/</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">D12</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()}</span>
<span class="gp">sage: </span><span class="n">D12</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cover_labels</span><span class="o">=</span><span class="n">d</span><span class="p">,</span> <span class="n">cover_color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">cover_style</span><span class="o">=</span><span class="s1">&#39;dotted&#39;</span><span class="p">)</span>
<span class="go">Graphics object consisting of 21 graphics primitives</span>
</pre></div>
</div>
<p>To emphasize some elements and show some options:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">LatticePoset</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">12</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
<span class="gp">....: </span>                  <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">13</span><span class="p">],</span>
<span class="gp">....: </span>                  <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">12</span><span class="p">],</span> <span class="mi">7</span><span class="p">:</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="mi">8</span><span class="p">:</span> <span class="p">[</span><span class="mi">13</span><span class="p">],</span> <span class="mi">9</span><span class="p">:</span> <span class="p">[</span><span class="mi">13</span><span class="p">],</span>
<span class="gp">....: </span>                  <span class="mi">10</span><span class="p">:</span> <span class="p">[</span><span class="mi">12</span><span class="p">],</span> <span class="mi">11</span><span class="p">:</span> <span class="p">[</span><span class="mi">12</span><span class="p">],</span> <span class="mi">12</span><span class="p">:</span> <span class="p">[</span><span class="mi">13</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">frattini_sublattice</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F_internal</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">L</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">border</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">element_shape</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">,</span>
<span class="gp">....: </span>       <span class="n">element_size</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span> <span class="n">element_color</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span>
<span class="gp">....: </span>       <span class="n">element_colors</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;blue&#39;</span><span class="p">:</span> <span class="n">F</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">:</span> <span class="n">L</span><span class="o">.</span><span class="n">double_irreducibles</span><span class="p">()},</span>
<span class="gp">....: </span>       <span class="n">cover_color</span><span class="o">=</span><span class="s1">&#39;lightgray&#39;</span><span class="p">,</span> <span class="n">cover_colors</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;black&#39;</span><span class="p">:</span> <span class="n">F_internal</span><span class="p">},</span>
<span class="gp">....: </span>       <span class="n">title</span><span class="o">=</span><span class="s1">&#39;The Frattini</span><span class="se">\n</span><span class="s1">sublattice in blue&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="go">Graphics object consisting of 39 graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.product">
<code class="descname">product</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Cartesian product of the poset with <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>The Cartesian (or ‘direct’) product of <span class="math notranslate nohighlight">\(P\)</span> and
<span class="math notranslate nohighlight">\(Q\)</span> is defined by <span class="math notranslate nohighlight">\((p, q) \le (p', q')\)</span> iff <span class="math notranslate nohighlight">\(p \le p'\)</span>
in <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(q \le q'\)</span> in <span class="math notranslate nohighlight">\(Q\)</span>.</p>
<p>Product of (semi)lattices are returned as a (semi)lattice.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">PQ</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> <span class="p">;</span> <span class="n">PQ</span>
<span class="go">Finite lattice containing 12 elements</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">PQ</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span>
<span class="go">17</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">PQ</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>One can also simply use <span class="math notranslate nohighlight">\(*\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">*</span><span class="n">Q</span>
<span class="go">Finite lattice containing 6 elements</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="cartesian_product.html#sage.combinat.posets.cartesian_product.CartesianProductPoset" title="sage.combinat.posets.cartesian_product.CartesianProductPoset"><code class="xref py py-class docutils literal notranslate"><span class="pre">CartesianProductPoset</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.factor" title="sage.combinat.posets.posets.FinitePoset.factor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">factor()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.promotion">
<code class="descname">promotion</code><span class="sig-paren">(</span><em>i=1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.promotion" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the (extended) promotion on the linear extension
of the poset <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">i</span></code> – an integer between <span class="math notranslate nohighlight">\(1\)</span> and <span class="math notranslate nohighlight">\(n\)</span> (default: <span class="math notranslate nohighlight">\(1\)</span>)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>an isomorphic poset, with the same default linear extension</li>
</ul>
<p>The extended promotion is defined on a poset <code class="docutils literal notranslate"><span class="pre">self</span></code> of size
<span class="math notranslate nohighlight">\(n\)</span> by applying the promotion operator <span class="math notranslate nohighlight">\(\tau_i \tau_{i+1}
\cdots \tau_{n-1}\)</span> to the default linear extension <span class="math notranslate nohighlight">\(\pi\)</span> of <code class="docutils literal notranslate"><span class="pre">self</span></code>
(see <a class="reference internal" href="linear_extensions.html#sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.promotion" title="sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.promotion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">promotion()</span></code></a>),
and relabeling <code class="docutils literal notranslate"><span class="pre">self</span></code> accordingly. For more details see <a class="reference internal" href="../../../../references/index.html#stan2009" id="id23">[Stan2009]</a>.</p>
<p>When the elements of the poset <code class="docutils literal notranslate"><span class="pre">self</span></code> are labelled by
<span class="math notranslate nohighlight">\(\{1,2,\ldots,n\}\)</span>, the linear extension is the identity, and
<span class="math notranslate nohighlight">\(i=1\)</span>, the above algorithm corresponds to the promotion
operator on posets defined by Schützenberger as
follows. Remove <span class="math notranslate nohighlight">\(1\)</span> from <code class="docutils literal notranslate"><span class="pre">self</span></code> and replace it by the
minimum <span class="math notranslate nohighlight">\(j\)</span> of all labels covering <span class="math notranslate nohighlight">\(1\)</span> in the poset. Then,
remove <span class="math notranslate nohighlight">\(j\)</span> and replace it by the minimum of all labels
covering <span class="math notranslate nohighlight">\(j\)</span>, and so on.  This process ends when a label is a
local maximum. Place the label <span class="math notranslate nohighlight">\(n+1\)</span> at this vertex.  Finally,
decrease all labels by <span class="math notranslate nohighlight">\(1\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]]),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">promotion</span><span class="p">()</span>
<span class="go">Finite poset containing 2 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">promotion</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 5, 6, 4, 7]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">promotion</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="n">Q</span>
<span class="go">Finite poset containing 7 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 6], [2, 3], [2, 5], [3, 7], [5, 7], [6, 4]]</span>
</pre></div>
</div>
<p>Note that if one wants to obtain the promotion defined by
Schützenberger’s algorithm directly on the poset, one needs
to make sure the linear extension is the identity:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">with_linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">promotion</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="n">Q</span>
<span class="go">Finite poset containing 7 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 6], [2, 3], [2, 4], [3, 5], [4, 5], [6, 7]]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">promotion</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [4, 7], [5, 7]]</span>
</pre></div>
</div>
<p>Here is an example for a poset not labelled by <span class="math notranslate nohighlight">\(\{1, 2, \ldots, n\}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 5, 6, 10, 15, 30]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [1, 5], [2, 6], [2, 10], [3, 6], [3, 15],</span>
<span class="go"> [5, 10], [5, 15], [6, 30], [10, 30], [15, 30]]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">promotion</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="n">Q</span>
<span class="go">Finite poset containing 8 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [1, 6], [2, 5], [2, 15], [3, 5], [3, 10],</span>
<span class="go"> [5, 30], [6, 10], [6, 15], [10, 30], [15, 30]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extension" title="sage.combinat.posets.posets.FinitePoset.linear_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">linear_extension()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.with_linear_extension" title="sage.combinat.posets.posets.FinitePoset.with_linear_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">with_linear_extension()</span></code></a> and the <code class="docutils literal notranslate"><span class="pre">linear_extension</span></code> option of <a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><code class="xref py py-func docutils literal notranslate"><span class="pre">Poset()</span></code></a></li>
<li><a class="reference internal" href="linear_extensions.html#sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.promotion" title="sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.promotion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">promotion()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.evacuation" title="sage.combinat.posets.posets.FinitePoset.evacuation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">evacuation()</span></code></a></li>
</ul>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li>Anne Schilling (2012-02-18)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.random_linear_extension">
<code class="descname">random_linear_extension</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.random_linear_extension" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a random linear extension of the poset.</p>
<p>The distribution is not uniform.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">set_random_seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># results are reproduceable</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">random_linear_extension</span><span class="p">()</span>
<span class="go">[0, 2, 8, 1, 9, 4, 5, 10, 6, 12, 14, 13, 3, 7, 11, 15]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.random_maximal_antichain">
<code class="descname">random_maximal_antichain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.random_maximal_antichain" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a random maximal antichain of the poset.</p>
<p>The distribution is not uniform.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">set_random_seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># results are reproduceable</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">random_maximal_antichain</span><span class="p">()</span>
<span class="go">[1, 8, 2, 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.random_maximal_chain">
<code class="descname">random_maximal_chain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.random_maximal_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a random maximal chain of the poset.</p>
<p>The distribution is not uniform.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">set_random_seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># results are reproduceable</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">random_maximal_chain</span><span class="p">()</span>
<span class="go">[0, 2, 10, 11, 15]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.random_order_ideal">
<code class="descname">random_order_ideal</code><span class="sig-paren">(</span><em>direction='down'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.random_order_ideal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a random order ideal with uniform probability.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">direction</span></code> – <code class="docutils literal notranslate"><span class="pre">'up'</span></code>, <code class="docutils literal notranslate"><span class="pre">'down'</span></code> or <code class="docutils literal notranslate"><span class="pre">'antichain'</span></code>
(default: <code class="docutils literal notranslate"><span class="pre">'down'</span></code>)</li>
</ul>
<p>OUTPUT:</p>
<p>A randomly selected order ideal (or order filter if
<code class="docutils literal notranslate"><span class="pre">direction='up'</span></code>, or antichain if <code class="docutils literal notranslate"><span class="pre">direction='antichain'</span></code>)
where all order ideals have equal probability of occurring.</p>
<p>ALGORITHM:</p>
<p>Uses the coupling from the past algorithm described in <a class="reference internal" href="../../../../references/index.html#propp1997" id="id24">[Propp1997]</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">random_order_ideal</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">random_order_ideal</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="s1">&#39;up&#39;</span><span class="p">)</span>
<span class="go">[6, 7]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">random_order_ideal</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="s1">&#39;antichain&#39;</span><span class="p">)</span>
<span class="go">[1, 2]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">TamariLattice</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">random_order_ideal</span><span class="p">(</span><span class="s1">&#39;antichain&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_antichain_of_poset</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">random_order_ideal</span><span class="p">(</span><span class="s1">&#39;up&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_order_filter</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">random_order_ideal</span><span class="p">(</span><span class="s1">&#39;down&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_order_ideal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.random_subposet">
<code class="descname">random_subposet</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.random_subposet" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a random subposet that contains each element with
probability <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">set_random_seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># Results are reproducible</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">random_subposet</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[0, 2], [0, 5], [2, 3], [3, 7], [5, 7]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.rank">
<code class="descname">rank</code><span class="sig-paren">(</span><em>element=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the rank of an element <code class="docutils literal notranslate"><span class="pre">element</span></code> in the poset <code class="docutils literal notranslate"><span class="pre">self</span></code>,
or the rank of the poset if <code class="docutils literal notranslate"><span class="pre">element</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>(The rank of a poset is the length of the longest chain of
elements of the poset. This is sometimes called the length of a poset.)</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[]],</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[],[]])</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">SymmetricGroupBruhatOrderPoset</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[(</span><span class="n">v</span><span class="p">,</span><span class="n">P</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">P</span><span class="p">]</span>
<span class="go">[(&#39;1234&#39;, 0),</span>
<span class="go"> (&#39;1243&#39;, 1),</span>
<span class="go">...</span>
<span class="go"> (&#39;4312&#39;, 5),</span>
<span class="go"> (&#39;4321&#39;, 6)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.rank_function">
<code class="descname">rank_function</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.rank_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the (normalized) rank function of the poset,
if it exists.</p>
<p>A <em>rank function</em> of a poset <span class="math notranslate nohighlight">\(P\)</span> is a function <span class="math notranslate nohighlight">\(r\)</span>
that maps elements of <span class="math notranslate nohighlight">\(P\)</span> to integers and satisfies:
<span class="math notranslate nohighlight">\(r(x) = r(y) + 1\)</span> if <span class="math notranslate nohighlight">\(x\)</span> covers <span class="math notranslate nohighlight">\(y\)</span>. The function <span class="math notranslate nohighlight">\(r\)</span>
is normalized such that its minimum value on every
connected component of the Hasse diagram of <span class="math notranslate nohighlight">\(P\)</span> is
<span class="math notranslate nohighlight">\(0\)</span>. This determines the function <span class="math notranslate nohighlight">\(r\)</span> uniquely (when
it exists).</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>a lambda function, if the poset admits a rank function</li>
<li><code class="docutils literal notranslate"><span class="pre">None</span></code>, if the poset does not admit a rank function</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rank_function</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">]]),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rank_function</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]]),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">rank_function</span><span class="p">();</span> <span class="n">f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.rees_product">
<code class="descname">rees_product</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.rees_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Rees product of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>This is only defined if both posets are graded.</p>
<p>The underlying set is the set of pairs <span class="math notranslate nohighlight">\((p,q)\)</span> in the Cartesian
product such that <span class="math notranslate nohighlight">\(\operatorname{rk}(p) \geq \operatorname{rk}(q)\)</span>.</p>
<p>This operation was defined by Björner and Welker in <a class="reference internal" href="../../../../references/index.html#bjwe2005" id="id25">[BjWe2005]</a>.
Other references are <a class="reference internal" href="../../../../references/index.html#mbre2011" id="id26">[MBRe2011]</a> and <a class="reference internal" href="../../../../references/index.html#lsw2012" id="id27">[LSW2012]</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B3</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B3t</span> <span class="o">=</span> <span class="n">B3</span><span class="o">.</span><span class="n">subposet</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">C3</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">B3t</span><span class="o">.</span><span class="n">rees_product</span><span class="p">(</span><span class="n">C3</span><span class="p">);</span> <span class="n">D</span>
<span class="go">Finite poset containing 12 elements</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">minimal_elements</span><span class="p">())</span>
<span class="go">[(1, 0), (2, 0), (4, 0)]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">maximal_elements</span><span class="p">())</span>
<span class="go">[(7, 0), (7, 1), (7, 2)]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">with_bounds</span><span class="p">()</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="s1">&#39;bottom&#39;</span><span class="p">,</span><span class="s1">&#39;top&#39;</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.product" title="sage.combinat.posets.posets.FinitePoset.product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">product()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_product" title="sage.combinat.posets.posets.FinitePoset.ordinal_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ordinal_product()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.star_product" title="sage.combinat.posets.posets.FinitePoset.star_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">star_product()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.relabel">
<code class="descname">relabel</code><span class="sig-paren">(</span><em>relabeling=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.relabel" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of this poset with its elements relabeled.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">relabeling</span></code> – a function, dictionary, list or tuple</li>
</ul>
<p>The given function or dictionary must map each (non-wrapped)
element of <code class="docutils literal notranslate"><span class="pre">self</span></code> to some distinct object. The given list or tuple
must be made of distinct objects.</p>
<p>When the input is a list or a tuple, the relabeling uses
the total ordering of the elements of the poset given by
<code class="docutils literal notranslate"><span class="pre">list(self)</span></code>.</p>
<p>If no relabeling is given, the poset is relabeled by integers
from <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(n-1\)</span> according to one of its linear extensions. This means
that <span class="math notranslate nohighlight">\(i&lt;j\)</span> as integers whenever <span class="math notranslate nohighlight">\(i&lt;j\)</span> in the relabeled poset.</p>
<p>EXAMPLES:</p>
<p>Relabeling using a function:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [2, 4], [2, 6], [3, 6], [4, 12], [6, 12]]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[2, 3, 4, 5, 7, 13]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[2, 3], [2, 4], [3, 5], [3, 7], [4, 7], [5, 13], [7, 13]]</span>
</pre></div>
</div>
<p>Relabeling using a dictionary:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">relabeling</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="o">.</span><span class="n">element</span><span class="p">:</span><span class="n">i</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">P</span><span class="p">)}</span>
<span class="gp">sage: </span><span class="n">relabeling</span>
<span class="go">{1: 0, 2: 1, 3: 2, 4: 3, 6: 4, 12: 5}</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">relabeling</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4, 5]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[0, 1], [0, 2], [1, 3], [1, 4], [2, 4], [3, 5], [4, 5]]</span>
</pre></div>
</div>
<p>Mind the <code class="docutils literal notranslate"><span class="pre">c.element</span></code>; this is because the relabeling is
applied to the elements of the poset without the wrapping.
Thanks to this convention, the same relabeling function can
be used both for facade or non facade posets.</p>
<p>Relabeling using a list:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 4]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[0, 1], [0, 2], [1, 4], [2, 3], [3, 4]]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;abcde&#39;</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[&#39;a&#39;, &#39;b&#39;], [&#39;a&#39;, &#39;c&#39;], [&#39;b&#39;, &#39;e&#39;], [&#39;c&#39;, &#39;d&#39;], [&#39;d&#39;, &#39;e&#39;]]</span>
</pre></div>
</div>
<p>Default behaviour is increasing relabeling:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a2</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">a2</span> <span class="o">*</span> <span class="n">a2</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">relabel</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[0, 1], [0, 2], [1, 3], [2, 3]]</span>
</pre></div>
</div>
<p>Relabeling a (semi)lattice gives a (semi)lattice:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">JoinSemilattice</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Finite join-semilattice containing 2 elements</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As can be seen in the above examples, the default linear
extension of <code class="docutils literal notranslate"><span class="pre">Q</span></code> is that of <code class="docutils literal notranslate"><span class="pre">P</span></code> after relabeling. In
particular, <code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span></code> share the same internal Hasse
diagram.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.relations">
<code class="descname">relations</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.relations" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of all relations of the poset.</p>
<p>A relation is a pair of elements <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> such that <span class="math notranslate nohighlight">\(x \leq y\)</span>
in the poset.</p>
<p>The number of relations is the dimension of the incidence
algebra.</p>
<p>OUTPUT:</p>
<p>A list of pairs (each pair is a list), where the first element
of the pair is less than or equal to the second element.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">relations</span><span class="p">()</span>
<span class="go">[[1, 1], [1, 2], [1, 3], [1, 4], [0, 0], [0, 2], [0, 3],</span>
<span class="go">[0, 4], [2, 2], [2, 3], [2, 4], [3, 3], [3, 4], [4, 4]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_number" title="sage.combinat.posets.posets.FinitePoset.relations_number"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relations_number()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_iterator" title="sage.combinat.posets.posets.FinitePoset.relations_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relations_iterator()</span></code></a></p>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li>Rob Beezer (2011-05-04)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.relations_iterator">
<code class="descname">relations_iterator</code><span class="sig-paren">(</span><em>strict=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.relations_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator for all the relations of the poset.</p>
<p>A relation is a pair of elements <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> such that <span class="math notranslate nohighlight">\(x \leq y\)</span>
in the poset.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">strict</span></code> – a boolean (default <code class="docutils literal notranslate"><span class="pre">False</span></code>) if <code class="docutils literal notranslate"><span class="pre">True</span></code>, returns
an iterator over relations <span class="math notranslate nohighlight">\(x &lt; y\)</span>, excluding all
relations <span class="math notranslate nohighlight">\(x \leq x\)</span>.</li>
</ul>
<p>OUTPUT:</p>
<p>A generator that produces pairs (each pair is a list), where the
first element of the pair is less than or equal to the second element.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">relations_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">&lt;... &#39;generator&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">([1, 1], [1, 2])</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">relations_iterator</span><span class="p">(</span><span class="n">strict</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="go">[[0, 1], [0, 2], [0, 4], [0, 3], [1, 4], [2, 3], [2, 4], [3, 4]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_number" title="sage.combinat.posets.posets.FinitePoset.relations_number"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relations_number()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations" title="sage.combinat.posets.posets.FinitePoset.relations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relations()</span></code></a>.</p>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li>Rob Beezer (2011-05-04)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.relations_number">
<code class="descname">relations_number</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.relations_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of relations in the poset.</p>
<p>A relation is a pair of elements <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> such that <span class="math notranslate nohighlight">\(x\leq y\)</span>
in the poset.</p>
<p>Relations are also often called intervals. The number of
intervals is the dimension of the incidence algebra.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">relations_number</span><span class="p">()</span>
<span class="go">13</span>

<span class="gp">sage: </span><span class="n">posets</span><span class="o">.</span><span class="n">TamariLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">relations_number</span><span class="p">()</span>
<span class="go">68</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_iterator" title="sage.combinat.posets.posets.FinitePoset.relations_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relations_iterator()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations" title="sage.combinat.posets.posets.FinitePoset.relations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relations()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.show">
<code class="descname">show</code><span class="sig-paren">(</span><em>label_elements=True</em>, <em>element_labels=None</em>, <em>cover_labels=None</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Displays the Hasse diagram of the poset.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">label_elements</span></code> (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) - whether to display
element labels</li>
<li><code class="docutils literal notranslate"><span class="pre">element_labels</span></code> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) - a dictionary of
element labels</li>
<li><code class="docutils literal notranslate"><span class="pre">cover_labels</span></code> - a dictionary, list or function representing labels
of the covers of <code class="docutils literal notranslate"><span class="pre">self</span></code>. When set to <code class="docutils literal notranslate"><span class="pre">None</span></code> (default) no label is
displayed on the edges of the Hasse Diagram.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>This method also accepts:</p>
<blockquote class="last">
<div><ul class="simple">
<li>All options of <a class="reference external" href="../../../../graphs/sage/graphs/generic_graph.html#sage.graphs.generic_graph.GenericGraph.plot" title="(in Sage Reference Manual: Graph Theory v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GenericGraph.plot</span></code></a></li>
<li>All options of <a class="reference external" href="../../../../plotting/sage/plot/graphics.html#sage.plot.graphics.Graphics.show" title="(in Sage Reference Manual: 2D Graphics v8.9)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graphics.show</span></code></a></li>
</ul>
</div></blockquote>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="p">})</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">label_elements</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">Graphics object consisting of 6 graphics primitives</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">elm_labs</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span><span class="s1">&#39;e&#39;</span><span class="p">}</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">element_labels</span><span class="o">=</span><span class="n">elm_labs</span><span class="p">)</span>
</pre></div>
</div>
<p>One more example with cover labels:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">cover_labels</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.sorted">
<code class="descname">sorted</code><span class="sig-paren">(</span><em>l</em>, <em>allow_incomparable=True</em>, <em>remove_duplicates=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.sorted" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list <span class="math notranslate nohighlight">\(l\)</span> sorted by the poset.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">l</span></code> – a list of elements of the poset</li>
<li><code class="docutils literal notranslate"><span class="pre">allow_incomparable</span></code> – a Boolean. If <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default),
return incomparable elements in some order; if <code class="docutils literal notranslate"><span class="pre">False</span></code>, raise
an error if <code class="docutils literal notranslate"><span class="pre">l</span></code> is not a chain of the poset.</li>
<li><code class="docutils literal notranslate"><span class="pre">remove_duplicates</span></code> - a Boolean. If <code class="docutils literal notranslate"><span class="pre">True</span></code>, remove duplicates
from the output list.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DivisorLattice</span><span class="p">(</span><span class="mi">36</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">sorted</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>  <span class="c1"># Random order for 4 and 6</span>
<span class="go">[1, 1, 2, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">sorted</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span> <span class="n">remove_duplicates</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[1, 2, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">sorted</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span> <span class="n">allow_incomparable</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: the list contains incomparable elements</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">7</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">6</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">sorted</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>  <span class="c1"># Random order for 1 and 5</span>
<span class="go">[7, 1, 5, 4, 4]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">sorted</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="n">remove_duplicates</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[7, 1, 4]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">sorted</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="n">allow_incomparable</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: the list contains incomparable elements</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.star_product">
<code class="descname">star_product</code><span class="sig-paren">(</span><em>other</em>, <em>labels='pairs'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.star_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a poset isomorphic to the star product of the
poset with <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>Both this poset and <code class="docutils literal notranslate"><span class="pre">other</span></code> are expected to be bounded
and have at least two elements.</p>
<p>Let <span class="math notranslate nohighlight">\(P\)</span> be a poset with top element <span class="math notranslate nohighlight">\(\top_P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> be a poset
with bottom element <span class="math notranslate nohighlight">\(\bot_Q\)</span>. The star product of
<span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> is the ordinal sum of <span class="math notranslate nohighlight">\(P \setminus \top_P\)</span> and
<span class="math notranslate nohighlight">\(Q \setminus \bot_Q\)</span>.</p>
<p>Mathematically, it is only defined when <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> have no
common elements; here we force that by giving them different
names in the resulting poset.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">other</span></code> – a poset.</li>
<li><code class="docutils literal notranslate"><span class="pre">labels</span></code> – (defaults to ‘pairs’) If set to ‘pairs’, each
element <code class="docutils literal notranslate"><span class="pre">v</span></code> in this poset will be named <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">v)</span></code> and each
element <code class="docutils literal notranslate"><span class="pre">u</span></code> in <code class="docutils literal notranslate"><span class="pre">other</span></code> will be named <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">u)</span></code> in the
result. If set to ‘integers’, the elements of the result
will be relabeled with consecutive integers.</li>
</ul>
<p>EXAMPLES:</p>
<p>This is mostly used to combine two Eulerian posets to third one,
and makes sense for graded posets only:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B2</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B3</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">B2</span><span class="o">.</span><span class="n">star_product</span><span class="p">(</span><span class="n">B3</span><span class="p">);</span> <span class="n">P</span>
<span class="go">Finite poset containing 10 elements</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We can get elements as pairs or as integers:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ABC</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">XYZ</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">ABC</span><span class="o">.</span><span class="n">star_product</span><span class="p">(</span><span class="n">XYZ</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[(0, &#39;a&#39;), (0, &#39;b&#39;), (1, &#39;y&#39;), (1, &#39;z&#39;)]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">ABC</span><span class="o">.</span><span class="n">star_product</span><span class="p">(</span><span class="n">XYZ</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="s1">&#39;integers&#39;</span><span class="p">))</span>
<span class="go">[0, 1, 2, 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.subposet">
<code class="descname">subposet</code><span class="sig-paren">(</span><em>elements</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.subposet" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the poset containing given elements with partial order
induced by this poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">,</span><span class="s1">&#39;e&#39;</span><span class="p">],</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">],</span>
<span class="gp">....: </span>           <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">],</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">subposet</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">]);</span> <span class="n">Q</span>
<span class="go">Finite poset containing 3 elements</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[&#39;b&#39;, &#39;f&#39;], [&#39;a&#39;, &#39;f&#39;]]</span>
</pre></div>
</div>
<p>A subposet of a non-facade poset is again a non-facade poset:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">(</span><span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">subposet</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">Q</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.top">
<code class="descname">top</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.top" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unique maximal element of the poset, if it exists.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="mi">4</span><span class="p">:[],</span><span class="mi">5</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">top</span><span class="p">()</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">top</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_top" title="sage.combinat.posets.posets.FinitePoset.has_top"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_top()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.bottom" title="sage.combinat.posets.posets.FinitePoset.bottom"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bottom()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.unwrap">
<code class="descname">unwrap</code><span class="sig-paren">(</span><em>element</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.unwrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the element <code class="docutils literal notranslate"><span class="pre">element</span></code> of the poset <code class="docutils literal notranslate"><span class="pre">self</span></code> in
unwrapped form.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">element</span></code> – an element of <code class="docutils literal notranslate"><span class="pre">self</span></code></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">x</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Finite poset containing 4 elements</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Integer Ring</span>
</pre></div>
</div>
<p>For a non facade poset, this is equivalent to using the
<code class="docutils literal notranslate"><span class="pre">.element</span></code> attribute:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">x</span><span class="o">.</span><span class="n">element</span>
<span class="go">True</span>
</pre></div>
</div>
<p>For a facade poset, this does nothing:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">x</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This method is useful in code where we don’t know if <code class="docutils literal notranslate"><span class="pre">P</span></code> is
a facade poset or not.</p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.upper_covers">
<code class="descname">upper_covers</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.upper_covers" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of upper covers of the element <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>An upper cover of <span class="math notranslate nohighlight">\(x\)</span> is an element <span class="math notranslate nohighlight">\(y\)</span> such that <span class="math notranslate nohighlight">\(x &lt; y\)</span> and
there is no element <span class="math notranslate nohighlight">\(z\)</span> so that <span class="math notranslate nohighlight">\(x &lt; z &lt; y\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">upper_covers</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[2, 6]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.lower_covers" title="sage.combinat.posets.posets.FinitePoset.lower_covers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lower_covers()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.upper_covers_iterator">
<code class="descname">upper_covers_iterator</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.upper_covers_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over the upper covers of the element <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">upper_covers_iterator</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">&lt;... &#39;generator&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.width">
<code class="descname">width</code><span class="sig-paren">(</span><em>certificate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.width" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the width of the poset (the size of its longest antichain).</p>
<p>It is computed through a matching in a bipartite graph; see
<a class="reference external" href="https://en.wikipedia.org/wiki/Dilworth's_theorem">Wikipedia article Dilworth’s_theorem</a> for more information. The width is
also called Dilworth number.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) whether to return
a certificate</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>If <code class="docutils literal notranslate"><span class="pre">certificate=True</span></code> return <code class="docutils literal notranslate"><span class="pre">(w,</span> <span class="pre">a)</span></code>, where <span class="math notranslate nohighlight">\(w\)</span> is the
width of a poset and <span class="math notranslate nohighlight">\(a\)</span> is an antichain of maximum cardinality.
If <code class="docutils literal notranslate"><span class="pre">certificate=False</span></code> return only width of the poset.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">width</span><span class="p">()</span>
<span class="go">6</span>

<span class="gp">sage: </span><span class="n">w</span><span class="p">,</span> <span class="n">max_achain</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">width</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">max_achain</span><span class="p">)</span>
<span class="go">[3, 5, 6, 9, 10, 12]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.with_bounds">
<code class="descname">with_bounds</code><span class="sig-paren">(</span><em>labels=('bottom'</em>, <em>'top')</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.with_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the poset with bottom and top elements adjoined.</p>
<p>This function adds top and bottom elements to the poset.
It will always add elements, it does not check if the poset
already has a bottom or a top element.</p>
<p>For lattices and semilattices this function returns a lattice.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">labels</span></code> – A pair of elements to use as a bottom and top
element of the poset. Default is strings <code class="docutils literal notranslate"><span class="pre">'bottom'</span></code> and
<code class="docutils literal notranslate"><span class="pre">'top'</span></code>. Either of them can be <code class="docutils literal notranslate"><span class="pre">None</span></code>, and then a new
bottom or top element will not be added.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">trafficsign</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">with_bounds</span><span class="p">();</span> <span class="n">trafficsign</span>
<span class="go">Finite poset containing 5 elements</span>
<span class="gp">sage: </span><span class="n">trafficsign</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[&#39;bottom&#39;, 0, 1, 2, &#39;top&#39;]</span>
<span class="gp">sage: </span><span class="n">trafficsign</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">with_bounds</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">trafficsign</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[-1, 0], [0, 1], [0, 2], [1, -2], [2, -2]]</span>

<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">with_bounds</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[-1, 0], [0, 1], [0, 2]]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>  <span class="c1"># A lattice</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">with_bounds</span><span class="p">()</span>
<span class="go">Finite lattice containing 7 elements</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">(</span><span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">with_bounds</span><span class="p">()</span>
<span class="go">Finite lattice containing 7 elements</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.without_bounds" title="sage.combinat.posets.posets.FinitePoset.without_bounds"><code class="xref py py-meth docutils literal notranslate"><span class="pre">without_bounds()</span></code></a> for the reverse operation</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.with_linear_extension">
<code class="descname">with_linear_extension</code><span class="sig-paren">(</span><em>linear_extension</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.with_linear_extension" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of <code class="docutils literal notranslate"><span class="pre">self</span></code> with a different default linear extension.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [2, 4], [2, 6], [3, 6], [4, 12], [6, 12]]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">with_linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">12</span><span class="p">])</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="go">[1, 3, 2, 6, 4, 12]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 3], [1, 2], [3, 6], [2, 6], [2, 4], [6, 12], [4, 12]]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">With the current implementation, this requires relabeling
the internal <a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraph</span></code></a> which is <span class="math notranslate nohighlight">\(O(n+m)\)</span>, where <span class="math notranslate nohighlight">\(n\)</span>
is the number of elements and <span class="math notranslate nohighlight">\(m\)</span> the number of cover relations.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.without_bounds">
<code class="descname">without_bounds</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.without_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the poset without its top and bottom elements.</p>
<p>This is useful as an input for the method <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_complex" title="sage.combinat.posets.posets.FinitePoset.order_complex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_complex()</span></code></a>.</p>
<p>If there is either no top or no bottom element, this
raises a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">without_bounds</span><span class="p">();</span> <span class="n">Q</span>
<span class="go">Finite poset containing 3 elements</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[2, 3]]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">without_bounds</span><span class="p">();</span> <span class="n">Q</span>
<span class="go">Finite poset containing 3 elements</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.with_bounds" title="sage.combinat.posets.posets.FinitePoset.with_bounds"><code class="xref py py-meth docutils literal notranslate"><span class="pre">with_bounds()</span></code></a> for the reverse operation</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.zeta_polynomial">
<code class="descname">zeta_polynomial</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.zeta_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the zeta polynomial of the poset.</p>
<p>The zeta polynomial of a poset is the unique polynomial <span class="math notranslate nohighlight">\(Z(q)\)</span>
such that for every integer <span class="math notranslate nohighlight">\(m &gt; 1\)</span>, <span class="math notranslate nohighlight">\(Z(m)\)</span> is the number of
weakly increasing sequences <span class="math notranslate nohighlight">\(x_1 \leq x_2 \leq \dots \leq x_{m-1}\)</span>
of elements of the poset.</p>
<p>The polynomial <span class="math notranslate nohighlight">\(Z(q)\)</span> is integral-valued, but generally does not
have integer coefficients. It can be computed as</p>
<div class="math notranslate nohighlight">
\[Z(q) = \sum_{k \geq 1} \dbinom{q-2}{k-1} c_k,\]</div>
<p>where <span class="math notranslate nohighlight">\(c_k\)</span> is the number of all chains of length <span class="math notranslate nohighlight">\(k\)</span> in the
poset.</p>
<p>For more information, see section 3.12 of <a class="reference internal" href="../../../../references/index.html#enumcomb1" id="id28">[EnumComb1]</a>.</p>
<p>In particular, <span class="math notranslate nohighlight">\(Z(2)\)</span> is the number of vertices and <span class="math notranslate nohighlight">\(Z(3)\)</span> is
the number of intervals.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">zeta_polynomial</span><span class="p">()</span>
<span class="go">q</span>
<span class="gp">sage: </span><span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">zeta_polynomial</span><span class="p">()</span>
<span class="go">1/2*q^2 + 1/2*q</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">zeta_polynomial</span><span class="p">()</span>
<span class="go">1/6*q^3 + q^2 - 1/6*q</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">zeta_polynomial</span><span class="p">()</span>
<span class="go">3/2*q^2 - 1/2*q</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.posets.posets.FinitePosets_n">
<em class="property">class </em><code class="descclassname">sage.combinat.posets.posets.</code><code class="descname">FinitePosets_n</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePosets_n" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Sage Reference Manual: Parents and Elements v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.unique_representation.UniqueRepresentation</span></code></a>, <a class="reference external" href="../../../../structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Sage Reference Manual: Parents and Elements v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.parent.Parent</span></code></a></p>
<p>The finite enumerated set of all posets on <span class="math notranslate nohighlight">\(n\)</span> elements, up to an isomorphism.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">P</span><span class="p">:</span> <span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span>
<span class="go">[]</span>
<span class="go">[[1, 2]]</span>
<span class="go">[[0, 1], [0, 2]]</span>
<span class="go">[[0, 1], [1, 2]]</span>
<span class="go">[[1, 2], [0, 2]]</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePosets_n.cardinality">
<code class="descname">cardinality</code><span class="sig-paren">(</span><em>from_iterator=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePosets_n.cardinality" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cardinality of this object.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">By default, this returns pre-computed values obtained from
the On-Line Encyclopedia of Integer Sequences (<a class="reference external" href="https://oeis.org/A000112">OEIS sequence A000112</a>).
To override this, pass the argument <code class="docutils literal notranslate"><span class="pre">from_iterator=True</span></code>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cardinality</span><span class="p">(</span><span class="n">from_iterator</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.combinat.posets.posets.Poset">
<code class="descclassname">sage.combinat.posets.posets.</code><code class="descname">Poset</code><span class="sig-paren">(</span><em>data=None</em>, <em>element_labels=None</em>, <em>cover_relations=False</em>, <em>linear_extension=False</em>, <em>category=None</em>, <em>facade=None</em>, <em>key=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.Poset" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a finite poset from various forms of input data.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">data</span></code> – different input are accepted by this constructor:</p>
<ol class="arabic">
<li><p class="first">A two-element list or tuple <code class="docutils literal notranslate"><span class="pre">(E,</span> <span class="pre">R)</span></code>, where <code class="docutils literal notranslate"><span class="pre">E</span></code> is a
collection of elements of the poset and <code class="docutils literal notranslate"><span class="pre">R</span></code> is a collection
of relations <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code>, each represented as a two-element
list/tuple/iterable such as <code class="docutils literal notranslate"><span class="pre">[x,</span> <span class="pre">y]</span></code>. The poset is then
the transitive closure of the provided relations. If
<code class="docutils literal notranslate"><span class="pre">cover_relations=True</span></code>, then <code class="docutils literal notranslate"><span class="pre">R</span></code> is assumed to contain
exactly the cover relations of the poset. If <code class="docutils literal notranslate"><span class="pre">E</span></code> is empty,
then <code class="docutils literal notranslate"><span class="pre">E</span></code> is taken to be the set of elements appearing in
the relations <code class="docutils literal notranslate"><span class="pre">R</span></code>.</p>
</li>
<li><p class="first">A two-element list or tuple <code class="docutils literal notranslate"><span class="pre">(E,</span> <span class="pre">f)</span></code>, where <code class="docutils literal notranslate"><span class="pre">E</span></code> is the set
of elements of the poset and <code class="docutils literal notranslate"><span class="pre">f</span></code> is a function such that,
for any pair <code class="docutils literal notranslate"><span class="pre">x,</span> <span class="pre">y</span></code> of elements of <code class="docutils literal notranslate"><span class="pre">E</span></code>, <code class="docutils literal notranslate"><span class="pre">f(x,</span> <span class="pre">y)</span></code>
returns whether <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code>. If <code class="docutils literal notranslate"><span class="pre">cover_relations=True</span></code>, then
<code class="docutils literal notranslate"><span class="pre">f(x,</span> <span class="pre">y)</span></code> should instead return whether <code class="docutils literal notranslate"><span class="pre">x</span></code> is covered by
<code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
</li>
<li><p class="first">A dictionary of upper covers: <code class="docutils literal notranslate"><span class="pre">data[x]</span></code> is
a list of the elements that cover the element <span class="math notranslate nohighlight">\(x\)</span> in the poset.</p>
</li>
<li><p class="first">A list or tuple of upper covers: <code class="docutils literal notranslate"><span class="pre">data[x]</span></code> is
a list of the elements that cover the element <span class="math notranslate nohighlight">\(x\)</span> in the poset.</p>
<p>If the set of elements is not a set of consecutive integers
starting from zero, then:</p>
<ul class="simple">
<li>every element must appear in the data, for example in its own entry.</li>
<li><code class="docutils literal notranslate"><span class="pre">data</span></code> must be ordered in the same way as sorted elements.</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If data is a list or tuple of length <span class="math notranslate nohighlight">\(2\)</span>, then it is
handled by the case 2 above.</p>
</div>
</li>
<li><p class="first">An acyclic, loop-free and multi-edge free <code class="docutils literal notranslate"><span class="pre">DiGraph</span></code>. If
<code class="docutils literal notranslate"><span class="pre">cover_relations</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the edges of the
digraph are assumed to correspond to the cover relations of
the poset. Otherwise, the cover relations are computed.</p>
</li>
<li><p class="first">A previously constructed poset (the poset itself is returned).</p>
</li>
</ol>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">element_labels</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); an optional list or
dictionary of objects that label the poset elements.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">cover_relations</span></code> – a boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether the
data can be assumed to describe a directed acyclic graph whose
arrows are cover relations; otherwise, the cover relations are
first computed.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">linear_extension</span></code> – a boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to
use the provided list of elements as default linear extension
for the poset; otherwise a linear extension is computed. If the data
is given as the pair <code class="docutils literal notranslate"><span class="pre">(E,</span> <span class="pre">f)</span></code>, then <code class="docutils literal notranslate"><span class="pre">E</span></code> is taken to be the linear
extension.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">facade</span></code> – a boolean or <code class="docutils literal notranslate"><span class="pre">None</span></code> (default); whether the
<a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Poset()</span></code></a>’s elements should be wrapped to make them aware of the
Poset they belong to.</p>
<ul class="simple">
<li>If <code class="docutils literal notranslate"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">True</span></code>, the <a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Poset()</span></code></a>’s elements are exactly those
given as input.</li>
<li>If <code class="docutils literal notranslate"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">False</span></code>, the <a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Poset()</span></code></a>’s elements will become
<code class="xref py py-class docutils literal notranslate"><span class="pre">PosetElement</span></code> objects.</li>
<li>If <code class="docutils literal notranslate"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">None</span></code> (default) the expected behaviour is the behaviour
of <code class="docutils literal notranslate"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">True</span></code>, unless the opposite can be deduced from the
context (i.e. for instance if a <a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Poset()</span></code></a> is built from another
<a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Poset()</span></code></a>, itself built with <code class="docutils literal notranslate"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">False</span></code>)</li>
</ul>
</li>
</ul>
<p>OUTPUT:</p>
<p><code class="docutils literal notranslate"><span class="pre">FinitePoset</span></code> – an instance of the <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><code class="xref py py-class docutils literal notranslate"><span class="pre">FinitePoset</span></code></a> class.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">category</span></code> is specified, then the poset is created in this
category instead of <a class="reference external" href="../../../../categories/sage/categories/finite_posets.html#sage.categories.finite_posets.FinitePosets" title="(in Sage Reference Manual: Category Framework v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">FinitePosets</span></code></a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="poset_examples.html#sage.combinat.posets.poset_examples.Posets" title="sage.combinat.posets.poset_examples.Posets"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posets</span></code></a>, <a class="reference external" href="../../../../categories/sage/categories/posets.html#sage.categories.posets.Posets" title="(in Sage Reference Manual: Category Framework v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posets</span></code></a>,
<a class="reference external" href="../../../../categories/sage/categories/finite_posets.html#sage.categories.finite_posets.FinitePosets" title="(in Sage Reference Manual: Category Framework v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">FinitePosets</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<ol class="arabic">
<li><p class="first">Elements and cover relations:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">elms</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">rels</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">((</span><span class="n">elms</span><span class="p">,</span> <span class="n">rels</span><span class="p">),</span> <span class="n">cover_relations</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="go">Finite poset containing 7 elements</span>
</pre></div>
</div>
<p>Elements and non-cover relations:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">elms</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">rels</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">[</span><span class="n">elms</span><span class="p">,</span><span class="n">rels</span><span class="p">]</span> <span class="p">,</span><span class="n">cover_relations</span><span class="o">=</span><span class="bp">False</span><span class="p">);</span> <span class="n">P</span>
<span class="go">Finite poset containing 4 elements</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [2, 3], [3, 4]]</span>
</pre></div>
</div>
</li>
<li><p class="first">Elements and function: the standard permutations of [1, 2, 3, 4]
with the Bruhat order:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">elms</span> <span class="o">=</span> <span class="n">Permutations</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fcn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">,</span><span class="n">q</span> <span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">bruhat_lequal</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">((</span><span class="n">elms</span><span class="p">,</span> <span class="n">fcn</span><span class="p">))</span>
<span class="go">Finite poset containing 24 elements</span>
</pre></div>
</div>
<p>With a function that identifies the cover relations: the set
partitions of <span class="math notranslate nohighlight">\(\{1, 2, 3\}\)</span> ordered by refinement:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">elms</span> <span class="o">=</span> <span class="n">SetPartitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">fcn</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="bp">False</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">B</span><span class="p">):</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="bp">False</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">((</span><span class="n">elms</span><span class="p">,</span> <span class="n">fcn</span><span class="p">),</span> <span class="n">cover_relations</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Finite poset containing 5 elements</span>
</pre></div>
</div>
</li>
<li><p class="first">A dictionary of upper covers:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;c&#39;</span><span class="p">:[</span><span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;d&#39;</span><span class="p">:[]})</span>
<span class="go">Finite poset containing 4 elements</span>
</pre></div>
</div>
</li>
<li><p class="first">A list of upper covers, with range(5) as set of vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[]])</span>
<span class="go">Finite poset containing 5 elements</span>
</pre></div>
</div>
<p>A list of upper covers, with letters as vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">([[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span><span class="s2">&quot;b&quot;</span><span class="p">],[</span><span class="s2">&quot;b&quot;</span><span class="p">,</span><span class="s2">&quot;c&quot;</span><span class="p">],[</span><span class="s2">&quot;c&quot;</span><span class="p">]])</span>
<span class="go">Finite poset containing 3 elements</span>
</pre></div>
</div>
<p>A list of upper covers and a dictionary of labels:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">elm_labs</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="s2">&quot;a&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="s2">&quot;b&quot;</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="s2">&quot;c&quot;</span><span class="p">,</span><span class="mi">3</span><span class="p">:</span><span class="s2">&quot;d&quot;</span><span class="p">,</span><span class="mi">4</span><span class="p">:</span><span class="s2">&quot;e&quot;</span><span class="p">}</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[]],</span> <span class="n">elm_labs</span><span class="p">,</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[a, b, c, d, e]</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The special case where the argument data is a list or tuple of
length 2 is handled by the case 2. So you cannot use this
method to input a 2-element poset.</p>
</div>
</li>
<li><p class="first">An acyclic DiGraph.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">dag</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">(</span><span class="n">dag</span><span class="p">)</span>
<span class="go">Finite poset containing 6 elements</span>
</pre></div>
</div>
<p>Any directed acyclic graph without loops or multiple edges, as long
as <code class="docutils literal notranslate"><span class="pre">cover_relations=False</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">dig</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">dig</span><span class="o">.</span><span class="n">allows_multiple_edges</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">dig</span><span class="o">.</span><span class="n">allows_loops</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">dig</span><span class="o">.</span><span class="n">transitive_reduction</span><span class="p">()</span> <span class="o">==</span> <span class="n">dig</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">(</span><span class="n">dig</span><span class="p">,</span> <span class="n">cover_relations</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">Finite poset containing 6 elements</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">(</span><span class="n">dig</span><span class="p">,</span> <span class="n">cover_relations</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: Hasse diagram is not transitively reduced</span>
</pre></div>
</div>
</li>
</ol>
<p class="rubric">Default Linear extension</p>
<p>Every poset <span class="math notranslate nohighlight">\(P\)</span> obtained with <code class="docutils literal notranslate"><span class="pre">Poset</span></code> comes equipped with a
default linear extension, which is also used for enumerating
its elements. By default, this linear extension is computed,
and has no particular significance:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 4, 3, 6, 12]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()</span>
<span class="go">[1, 2, 4, 3, 6, 12]</span>
</pre></div>
</div>
<p>You may enforce a specific linear extension using the
<code class="docutils literal notranslate"><span class="pre">linear_extension</span></code> option:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
</pre></div>
</div>
<p>Depending on popular request, <code class="docutils literal notranslate"><span class="pre">Poset</span></code> might eventually get
modified to always use the provided list of elements as
default linear extension, when it is one.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extensions" title="sage.combinat.posets.posets.FinitePoset.linear_extensions"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FinitePoset.linear_extensions()</span></code></a></p>
</div>
<p class="rubric">Facade posets</p>
<p>When <code class="docutils literal notranslate"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">False</span></code>, the elements of a poset are wrapped so as to make
them aware that they belong to that poset:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">({</span><span class="s1">&#39;d&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">],</span><span class="s1">&#39;c&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">]}),</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="ow">is</span> <span class="n">P</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This allows for comparing elements according to <span class="math notranslate nohighlight">\(P\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
<p>However, this may have surprising effects:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">my_elements</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">my_elements</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">P</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>and can be annoying when one wants to manipulate the elements of
the poset:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: unsupported operand parent(s) for +: &#39;Finite poset containing 4 elements&#39; and &#39;Finite poset containing 4 elements&#39;</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">element</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">element</span>
<span class="go">&#39;ab&#39;</span>
</pre></div>
</div>
<p>By default, facade posets are constructed instead:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">({</span><span class="s1">&#39;d&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">],</span><span class="s1">&#39;c&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">]}))</span>
</pre></div>
</div>
<p>In this example, the elements of the poset remain plain strings:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">d</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&lt;... &#39;str&#39;&gt;</span>
</pre></div>
</div>
<p>Of course, those strings are not aware of <span class="math notranslate nohighlight">\(P\)</span>. So to compare two
such strings, one needs to query <span class="math notranslate nohighlight">\(P\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>which models the usual mathematical notation <span class="math notranslate nohighlight">\(a &lt;_P b\)</span>.</p>
<p>Most operations seem to still work, but at this point there is no
guarantee whatsoever:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[&#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">principal_order_ideal</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="go">[&#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">principal_order_ideal</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="go">[&#39;d&#39;, &#39;b&#39;]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">principal_order_ideal</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
<span class="go">[&#39;d&#39;]</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p><a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraph</span></code></a> is used to construct the poset, and the
vertices of a <a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraph</span></code></a> are converted to plain Python
<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>’s if they are <a class="reference external" href="../../../../rings_standard/sage/rings/integer.html#sage.rings.integer.Integer" title="(in Sage Reference Manual: Standard Commutative Rings v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a>’s:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;... &#39;int&#39;&gt;</span>
</pre></div>
</div>
<p>This is worked around by systematically converting back the
vertices of a poset to <a class="reference external" href="../../../../rings_standard/sage/rings/integer.html#sage.rings.integer.Integer" title="(in Sage Reference Manual: Standard Commutative Rings v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a>’s if they are
<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>’s:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span><span class="o">.</span><span class="n">element</span><span class="p">)</span>
<span class="go">&lt;... &#39;sage.rings.integer.Integer&#39;&gt;</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">())</span>
<span class="go">&lt;... &#39;sage.rings.integer.Integer&#39;&gt;</span>
</pre></div>
</div>
<p>This may be abusive:</p>
<div class="last highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">),</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Integer Ring</span>
</pre></div>
</div>
</div>
<p class="rubric">Unique representation</p>
<p>As most parents, <a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poset</span></code></a> have unique representation (see
<a class="reference external" href="../../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Sage Reference Manual: Parents and Elements v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueRepresentation</span></code></a>). Namely if two posets are created
from two equal data, then they are not only equal but actually
identical:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">data1</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">]]</span>
<span class="gp">sage: </span><span class="n">data2</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">]]</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">data1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">data2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="o">==</span> <span class="n">P2</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="ow">is</span> <span class="n">P2</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In situations where this behaviour is not desired, one can use the
<code class="docutils literal notranslate"><span class="pre">key</span></code> option:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">data2</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;bar&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="ow">is</span> <span class="n">P2</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="o">==</span> <span class="n">P2</span>
<span class="go">False</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">key</span></code> can be any hashable value and is passed down to
<a class="reference external" href="../../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Sage Reference Manual: Parents and Elements v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueRepresentation</span></code></a>. It is otherwise ignored by the
poset constructor.</p>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.posets.posets.is_poset">
<code class="descclassname">sage.combinat.posets.posets.</code><code class="descname">is_poset</code><span class="sig-paren">(</span><em>dig</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.is_poset" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if a directed graph is acyclic and transitively
reduced, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.posets.posets</span> <span class="kn">import</span> <span class="n">is_poset</span>
<span class="gp">sage: </span><span class="n">dig</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">is_poset</span><span class="p">(</span><span class="n">dig</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">is_poset</span><span class="p">(</span><span class="n">dig</span><span class="o">.</span><span class="n">transitive_reduction</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Finite posets</a><ul>
<li><a class="reference internal" href="#list-of-poset-methods">List of Poset methods</a></li>
<li><a class="reference internal" href="#classes-and-functions">Classes and functions</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="poset_examples.html"
                        title="previous chapter">A catalog of posets and lattices.</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../q_analogues.html"
                        title="next chapter"><span class="math notranslate nohighlight">\(q\)</span>-Analogues</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/sage/combinat/posets/posets.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../q_analogues.html" title="\(q\)-Analogues"
             >next</a> |</li>
        <li class="right" >
          <a href="poset_examples.html" title="A catalog of posets and lattices."
             >previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../../index.html">Combinatorics</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../../../module_list.html" >Comprehensive Module list</a> &#187;</li> 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2019, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>