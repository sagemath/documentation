<!doctype html>
<html class="no-js">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="../../../../genindex.html" /><link rel="search" title="Search" href="../../../../search.html" /><link rel="next" title="\(q\)-Analogues" href="../q_analogues.html" /><link rel="prev" title="Catalog of posets and lattices" href="poset_examples.html" />

    <meta name="generator" content="sphinx-4.4.0, furo 2022.06.21"/>
        <title>Finite posets - Combinatorics</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/styles/furo.css?digest=40978830699223671f4072448e654b5958f38b89" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/custom-furo.css" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  --color-brand-primary: #0f0fff;
  --color-brand-content: #0f0fff;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZGD13B5572"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ZGD13B5572');
</script></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">Combinatorics</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><div class="sidebar-scroll"><a class="sidebar-brand" href="../../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../../../_static/logo_sagemath_black.svg" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../../../_static/logo_sagemath_white.svg" alt="Dark Logo"/>
  </div>
  
      <span class="sidebar-brand-text">Sage 9.7 Reference Manual</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../../search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-home">
  <div class="sidebar-tree">
    <ul><li class="toctree-l1">
      <a class="reference internal" href="../../../index.html">Home - Combinatorics</a>
    </li></ul>
  </div>
</div><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="../../../module_list.html">Comprehensive Module List</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../abstract_tree.html">Abstract Recursive Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../affine_permutation.html">Affine Permutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../algebraic_combinatorics.html">Algebraic combinatorics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../all.html">Combinatorics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../alternating_sign_matrix.html">Alternating Sign Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../backtrack.html">Backtracking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../baxter_permutations.html">Baxter permutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../binary_recurrence_sequences.html">Binary Recurrence Sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../binary_tree.html">Binary Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blob_algebra.html">Blob Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cartesian_product.html">Cartesian Products</a></li>
<li class="toctree-l2"><a class="reference internal" href="../catalog_partitions.html">Enumerated sets of partitions, tableaux, …</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chas/all.html">Combinatorial Hopf algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chas/fsym.html">Poirier-Reutenauer Hopf algebra of standard tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chas/wqsym.html">Word Quasi-symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cluster_algebra_quiver/all.html">Cluster algebras and quivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cluster_algebra_quiver/cluster_seed.html">ClusterSeed</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cluster_algebra_quiver/mutation_class.html">mutation_class</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cluster_algebra_quiver/mutation_type.html">Helper functions for mutation types of quivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cluster_algebra_quiver/quiver.html">Quiver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cluster_algebra_quiver/quiver_mutation_type.html">Quiver mutation types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cluster_complex.html">Cluster complex (or generalized dual associahedron)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../colored_permutations.html">Colored Permutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../combinat.html">Combinatorial Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../combinat_cython.html">Fast computation of combinatorial functions (Cython + mpz)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../combination.html">Combinations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../combinatorial_map.html">Combinatorial maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="../composition.html">Integer compositions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../composition_signed.html">Signed Compositions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../composition_tableau.html">Composition Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../constellation.html">Constellations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../core.html">Cores</a></li>
<li class="toctree-l2"><a class="reference internal" href="../counting.html">Counting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/affine.html">Affine Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/affine_factorization.html">Affine factorization crystal of type <span class="math notranslate nohighlight">\(A\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/affinization.html">Affinization Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/alcove_path.html">Alcove paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/all.html">Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/bkk_crystals.html">Benkart-Kang-Kashiwara crystals for the general-linear Lie superalgebra</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/catalog.html">Catalog Of Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/catalog_elementary_crystals.html">Catalog Of Elementary Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/catalog_infinity_crystals.html">Catalog Of Crystal Models For <span class="math notranslate nohighlight">\(B(\infty)\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/catalog_kirillov_reshetikhin.html">Catalog Of Crystal Models For Kirillov-Reshetikhin Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/crystals.html">An introduction to crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/direct_sum.html">Direct Sum of Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/elementary_crystals.html">Elementary Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/fast_crystals.html">Fast Rank Two Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/fully_commutative_stable_grothendieck.html">Fully commutative stable Grothendieck crystal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/generalized_young_walls.html">Crystals of Generalized Young Walls</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/highest_weight_crystals.html">Highest weight crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/induced_structure.html">Induced Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/infinity_crystals.html"><span class="math notranslate nohighlight">\(\mathcal{B}(\infty)\)</span> Crystals of Tableaux in Nonexceptional Types and <span class="math notranslate nohighlight">\(G_2\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/kac_modules.html">Crystals of Kac modules of the general-linear Lie superalgebra</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/kirillov_reshetikhin.html">Kirillov-Reshetikhin Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/kyoto_path_model.html">Kyoto Path Model for Affine Highest Weight Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/letters.html">Crystals of letters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/littelmann_path.html">Littelmann paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/monomial_crystals.html">Crystals of Modified Nakajima Monomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/multisegments.html">Crystal of Bernstein-Zelevinsky Multisegments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/mv_polytopes.html">Crystal Of Mirković-Vilonen (MV) Polytopes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/pbw_crystal.html"><span class="math notranslate nohighlight">\(\mathcal{B}(\infty)\)</span> Crystal Of PBW Monomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/pbw_datum.html">PBW Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/polyhedral_realization.html">Polyhedral Realization of <span class="math notranslate nohighlight">\(B(\infty)\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/spins.html">Spin Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/star_crystal.html">Star-Crystal Structure On <span class="math notranslate nohighlight">\(B(\infty)\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/tensor_product.html">Tensor Products of Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/tensor_product_element.html">Tensor Products of Crystal Elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cyclic_sieving_phenomenon.html">Cyclic sieving phenomenon</a></li>
<li class="toctree-l2"><a class="reference internal" href="../debruijn_sequence.html">De Bruijn sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../degree_sequences.html">Degree sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../derangements.html">Derangements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../descent_algebra.html">Descent Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/all.html">Combinatorial designs and incidence structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/bibd.html">Balanced Incomplete Block Designs (BIBD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/resolvable_bibd.html">Resolvable Balanced Incomplete Block Design (RBIBD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/group_divisible_designs.html">Group-Divisible Designs (GDD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/block_design.html">Block designs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/covering_design.html">Covering designs: coverings of <span class="math notranslate nohighlight">\(t\)</span>-element subsets of a <span class="math notranslate nohighlight">\(v\)</span>-set by <span class="math notranslate nohighlight">\(k\)</span>-sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/database.html">Database of small combinatorial designs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/design_catalog.html">Catalog of designs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/designs_pyx.html">Cython functions for combinatorial designs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/difference_family.html">Difference families</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/difference_matrices.html">Difference Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/evenly_distributed_sets.html">Evenly distributed sets in finite fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/ext_rep.html">External Representations of Block Designs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/gen_quadrangles_with_spread.html">Database of generalised quadrangles with spread</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/incidence_structures.html">Incidence structures (i.e. hypergraphs, i.e. set systems)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/latin_squares.html">Mutually Orthogonal Latin Squares (MOLS)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/orthogonal_arrays.html">Orthogonal arrays (OA)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/orthogonal_arrays_build_recursive.html">Orthogonal arrays (build recursive constructions)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/orthogonal_arrays_find_recursive.html">Orthogonal arrays (find recursive constructions)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/steiner_quadruple_systems.html">Steiner Quadruple Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/subhypergraph_search.html">Hypergraph isomorphic copy search</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/twographs.html">Two-graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../diagram_algebras.html">Diagram and Partition Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dlx.html">Exact Cover Problem via Dancing Links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dyck_word.html">Dyck Words</a></li>
<li class="toctree-l2"><a class="reference internal" href="../e_one_star.html">Substitutions over unit cube faces (Rauzy fractals)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../enumerated_sets.html">Enumerated sets and combinatorial objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../enumeration_mod_permgroup.html">Tools for enumeration modulo the action of a permutation group</a></li>
<li class="toctree-l2"><a class="reference internal" href="../expnums.html">Compute Bell and Uppuluri-Carpenter numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../family.html">Families</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fast_vector_partitions.html">Brent Yorgey’s fast algorithm for integer vector (multiset) partitions.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fully_commutative_elements.html">Fully commutative elements of Coxeter groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="../finite_state_machine.html">Finite state machines, automata, transducers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../finite_state_machine_generators.html">Common Automata and Transducers (Finite State Machines Generators)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fqsym.html">Free Quasi-symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../free_module.html">Free modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../free_dendriform_algebra.html">Free Dendriform Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="../free_prelie_algebra.html">Free Pre-Lie Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fully_packed_loop.html">Fully packed loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gelfand_tsetlin_patterns.html">Gelfand-Tsetlin Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../graph_path.html">Paths in Directed Acyclic Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gray_codes.html">Gray codes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../growth.html">Growth diagrams and dual graded graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../grossman_larson_algebras.html">Grossman-Larson Hopf Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hall_polynomial.html">Hall Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hillman_grassl.html">The Hillman-Grassl correspondence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integer_lists/base.html">Enumerated set of lists of integers with constraints: base classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integer_lists/lists.html">Enumerated set of lists of integers with constraints: front-end</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integer_lists/invlex.html">Enumerated set of lists of integers with constraints, in inverse lexicographic order</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integer_matrices.html">Counting, generating, and manipulating non-negative integer matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integer_vector.html">(Non-negative) Integer vectors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integer_vector_weighted.html">Weighted Integer Vectors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integer_vectors_mod_permgroup.html">Integer vectors modulo the action of a permutation group</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interval_posets.html">Tamari Interval-posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../k_regular_sequence.html"><span class="math notranslate nohighlight">\(k\)</span>-regular Sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../k_tableau.html">Strong and weak tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kazhdan_lusztig.html">Kazhdan-Lusztig Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../knutson_tao_puzzles.html">Knutson-Tao Puzzles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../matrices/all.html">Combinatorics on matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../matrices/dancing_links.html">Dancing Links internal pyx code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../matrices/dlxcpp.html">Dancing links C++ wrapper</a></li>
<li class="toctree-l2"><a class="reference internal" href="../matrices/hadamard_matrix.html">Hadamard matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../matrices/latin.html">Latin Squares</a></li>
<li class="toctree-l2"><a class="reference internal" href="../misc.html">Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="../multiset_partition_into_sets_ordered.html">Ordered Multiset Partitions into Sets and the Minimaj Crystal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ncsf_qsym/all.html">Non-commutative symmetric functions and quasi-symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ncsf_qsym/combinatorics.html">Common combinatorial tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ncsf_qsym/generic_basis_code.html">Generic code for bases</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ncsf_qsym/ncsf.html">Non-Commutative Symmetric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ncsf_qsym/qsym.html">Quasisymmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ncsf_qsym/tutorial.html">Introduction to Quasisymmetric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ncsym/all.html">Symmetric functions in non-commuting variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ncsym/bases.html">Bases for <span class="math notranslate nohighlight">\(NCSym\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../ncsym/dual.html">Dual Symmetric Functions in Non-Commuting Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ncsym/ncsym.html">Symmetric Functions in Non-Commuting Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../necklace.html">Necklaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../non_decreasing_parking_function.html">Non-Decreasing Parking Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nu_dyck_word.html"><span class="math notranslate nohighlight">\(\nu\)</span>-Dyck Words</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nu_tamari_lattice.html"><span class="math notranslate nohighlight">\(\nu\)</span>-Tamari lattice</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ordered_tree.html">Ordered Rooted Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../output.html">Output functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallelogram_polyomino.html">Parallelogram Polyominoes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parking_functions.html">Parking Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../path_tableaux/catalog.html">Catalog of Path Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../path_tableaux/dyck_path.html">Dyck Paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="../path_tableaux/frieze.html">Frieze Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../path_tableaux/path_tableau.html">Path Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../path_tableaux/semistandard.html">Semistandard Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../plane_partition.html">Plane Partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../partition.html">Integer partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../partition_algebra.html">Partition/Diagram Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="../partition_kleshchev.html">Kleshchev partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../partition_shifting_algebras.html">Partition Shifting Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="../partition_tuple.html">Partition tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../partitions.html">Iterators over the partitions of an integer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../perfect_matching.html">Perfect matchings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../permutation.html">Permutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../permutation_cython.html">Permutations (Cython file)</a></li>
<li class="toctree-l2"><a class="reference internal" href="all.html">Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="cartesian_product.html">Cartesian products of Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="d_complete.html">D-Complete Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="mobile.html">Mobile posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="elements.html">Elements of posets, lattices, semilattices, etc.</a></li>
<li class="toctree-l2"><a class="reference internal" href="forest.html">Forest Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="hasse_diagram.html">Hasse diagrams of posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="incidence_algebras.html">Incidence Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="lattices.html">Finite lattices and semilattices</a></li>
<li class="toctree-l2"><a class="reference internal" href="linear_extensions.html">Linear Extensions of Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="moebius_algebra.html">Möbius Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="poset_examples.html">Catalog of posets and lattices</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">Finite posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../q_analogues.html"><span class="math notranslate nohighlight">\(q\)</span>-Analogues</a></li>
<li class="toctree-l2"><a class="reference internal" href="../q_bernoulli.html"><span class="math notranslate nohighlight">\(q\)</span>-Bernoulli Numbers and Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../quickref.html">Combinatorics quickref</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ranker.html">Rankers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../recognizable_series.html">Recognizable Series</a></li>
<li class="toctree-l2"><a class="reference internal" href="../restricted_growth.html">Restricted growth arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ribbon.html">Ribbons</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ribbon_shaped_tableau.html">Ribbon Shaped Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ribbon_tableau.html">Ribbon Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/all.html">Rigged configurations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/bij_abstract_class.html">Abstract classes for the rigged configuration bijections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/bij_infinity.html">Bijection between rigged configurations for <span class="math notranslate nohighlight">\(B(\infty)\)</span> and marginally large tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/bij_type_A.html">Bijection classes for type <span class="math notranslate nohighlight">\(A_n^{(1)}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/bij_type_A2_dual.html">Bijection classes for type <span class="math notranslate nohighlight">\(A_{2n}^{(2)\dagger}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/bij_type_A2_even.html">Bijection classes for type <span class="math notranslate nohighlight">\(A_{2n}^{(2)}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/bij_type_A2_odd.html">Bijection classes for type <span class="math notranslate nohighlight">\(A_{2n-1}^{(2)}\)</span>.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/bij_type_B.html">Bijection classes for type <span class="math notranslate nohighlight">\(B_n^{(1)}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/bij_type_C.html">Bijection classes for type <span class="math notranslate nohighlight">\(C_n^{(1)}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/bij_type_D.html">Bijection classes for type <span class="math notranslate nohighlight">\(D_n^{(1)}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/bij_type_D_twisted.html">Bijection classes for type <span class="math notranslate nohighlight">\(D_{n+1}^{(2)}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/bij_type_D_tri.html">Bijection classes for type <span class="math notranslate nohighlight">\(D_4^{(3)}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/bijection.html">Bijection between rigged configurations and KR tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/kleber_tree.html">Kleber Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/kr_tableaux.html">Kirillov-Reshetikhin Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/rc_crystal.html">Crystal of Rigged Configurations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/rc_infinity.html">Rigged Configurations of <span class="math notranslate nohighlight">\(\mathcal{B}(\infty)\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/rigged_configuration_element.html">Rigged Configuration Elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/rigged_configurations.html">Rigged Configurations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/rigged_partition.html">Rigged Partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/tensor_product_kr_tableaux.html">Tensor Product of Kirillov-Reshetikhin Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/tensor_product_kr_tableaux_element.html">Tensor Product of Kirillov-Reshetikhin Tableaux Elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/all.html">Root Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/ambient_space.html">Ambient lattices and ambient spaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/associahedron.html">Associahedron</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/braid_move_calculator.html">Braid Move Calculator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/braid_orbit.html">Braid Orbit</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/branching_rules.html">Branching Rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/cartan_matrix.html">Cartan matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/cartan_type.html">Cartan types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/coxeter_group.html">Coxeter Groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/coxeter_matrix.html">Coxeter Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/coxeter_type.html">Coxeter Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/dynkin_diagram.html">Dynkin diagrams</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/hecke_algebra_representation.html">Hecke algebra representations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/integrable_representations.html">Integrable Representations of Affine Lie Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/non_symmetric_macdonald_polynomials.html">Nonsymmetric Macdonald polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/pieri_factors.html">Pieri Factors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/plot.html">Tutorial: visualizing root systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/reflection_group_complex.html">Finite complex reflection groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/reflection_group_real.html">Finite real reflection groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/root_lattice_realization_algebras.html">Group algebras of root lattice realizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/root_lattice_realizations.html">Root lattice realizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/root_space.html">Root lattices and root spaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/root_system.html">Root systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_super_A.html">Root system data for super type A</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_A.html">Root system data for type A</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_A_affine.html">Root system data for (untwisted) type A affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_A_infinity.html">Root system data for type A infinity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_B.html">Root system data for type B</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_BC_affine.html">Root system data for type BC affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_B_affine.html">Root system data for (untwisted) type B affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_C.html">Root system data for type C</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_C_affine.html">Root system data for (untwisted) type C affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_D.html">Root system data for type D</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_D_affine.html">Root system data for (untwisted) type D affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_E.html">Root system data for type E</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_E_affine.html">Root system data for (untwisted) type E affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_F.html">Root system data for type F</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_F_affine.html">Root system data for (untwisted) type F affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_G.html">Root system data for type G</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_G_affine.html">Root system data for (untwisted) type G affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_H.html">Root system data for type H</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_I.html">Root system data for type I</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_Q.html">Root system data for type Q</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_affine.html">Root system data for affine Cartan types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_dual.html">Root system data for dual Cartan types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/extended_affine_weyl_group.html">Extended Affine Weyl Groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/fundamental_group.html">Fundamental Group of an Extended Affine Weyl Group</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_folded.html">Root system data for folded Cartan types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_marked.html">Root system data for Cartan types with marked nodes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_reducible.html">Root system data for reducible Cartan types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_relabel.html">Root system data for relabelled Cartan types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/weight_lattice_realizations.html">Weight lattice realizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/weight_space.html">Weight lattices and weight spaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/weyl_characters.html">Weyl Character Rings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/fusion_ring.html">Fusion Rings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/weyl_group.html">Weyl Groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rooted_tree.html">Rooted (Unordered) Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rsk.html">Robinson-Schensted-Knuth correspondence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../schubert_polynomial.html">Schubert Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../set_partition.html">Set Partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../set_partition_ordered.html">Ordered Set Partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sf/all.html">Symmetric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sf/character.html">Characters of the symmetric group as bases of the symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sf/classical.html">Classical symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sf/dual.html">Generic dual bases symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sf/elementary.html">Elementary symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sf/hall_littlewood.html">Hall-Littlewood Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sf/hecke.html">Hecke Character Basis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sf/homogeneous.html">Homogeneous symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sf/jack.html">Jack Symmetric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sf/k_dual.html">Quotient of symmetric function space by ideal generated by Hall-Littlewood symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sf/kfpoly.html">Kostka-Foulkes Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sf/llt.html">LLT symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sf/macdonald.html">Macdonald Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sf/monomial.html">Monomial symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sf/multiplicative.html">Multiplicative symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sf/new_kschur.html"><span class="math notranslate nohighlight">\(k\)</span>-Schur Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sf/ns_macdonald.html">Non-symmetric Macdonald Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sf/orthogonal.html">Orthogonal Symmetric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sf/orthotriang.html">Symmetric functions defined by orthogonality and triangularity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sf/powersum.html">Power sum symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sf/schur.html">Schur symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sf/symplectic.html">Symplectic Symmetric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sf/sf.html">Symmetric functions, with their multiple realizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sf/sfa.html">Symmetric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sf/witt.html">Witt symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../shard_order.html">Shard intersection order</a></li>
<li class="toctree-l2"><a class="reference internal" href="../shifted_primed_tableau.html">Shifted primed tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../shuffle.html">Shuffle product of iterables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sidon_sets.html">Sidon sets and their generalizations, Sidon <span class="math notranslate nohighlight">\(g\)</span>-sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../similarity_class_type.html">Similarity class types of matrices with entries in a finite field</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sine_gordon.html">sine-Gordon Y-system plotter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../six_vertex_model.html">Six Vertex Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../skew_partition.html">Skew Partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../skew_tableau.html">Skew Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sloane_functions.html">Functions that compute some of the sequences in Sloane’s tables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/all.html">Combinatorial species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/characteristic_species.html">Characteristic Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/composition_species.html">Composition species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/cycle_species.html">Cycle Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/empty_species.html">Empty Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/functorial_composition_species.html">Functorial composition species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/generating_series.html">Generating Series</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/library.html">Examples of Combinatorial Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/linear_order_species.html">Linear-order Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/misc.html">Miscellaneous Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/partition_species.html">Partition Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/permutation_species.html">Permutation species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/product_species.html">Product species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/recursive_species.html">Recursive Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/series.html">Lazy Power Series</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/series_order.html">Series Order</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/set_species.html">Set Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/species.html">Combinatorial Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/stream.html">Streams or Infinite Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/structure.html">Species structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/subset_species.html">Subset Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/sum_species.html">Sum species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subset.html">Subsets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsets_hereditary.html">Subsets satisfying a hereditary property</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsets_pairwise.html">Subsets whose elements satisfy a predicate pairwise</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subword.html">Subwords</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subword_complex.html">Subword complex</a></li>
<li class="toctree-l2"><a class="reference internal" href="../super_tableau.html">Super Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../superpartition.html">Super Partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../symmetric_group_algebra.html">Symmetric Group Algebra</a></li>
<li class="toctree-l2"><a class="reference internal" href="../symmetric_group_representations.html">Representations of the Symmetric Group</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tableau.html">Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tableau_residues.html">Residue sequences of tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tableau_tuple.html">TableauTuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tamari_lattices.html">Generalized Tamari lattices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tiling.html">Tiling Solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tools.html">Transitive ideal closure tool</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tuple.html">Tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.html">Introduction to combinatorics in Sage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vector_partition.html">Vector Partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/abstract_word.html">Abstract word (finite or infinite)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words.html">Combinatorics on words</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/alphabet.html">Alphabet</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/finite_word.html">Finite word</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/infinite_word.html">Infinite word</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/lyndon_word.html">Lyndon words</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/morphism.html">Word morphisms/substitutions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/paths.html">Word paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/shuffle_product.html">Shuffle product of words</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/suffix_trees.html">Suffix Tries and Suffix Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/word.html">Word classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/word_char.html">Fast word datatype using an array of unsigned char</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/word_datatypes.html">Datatypes for finite words</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/word_generators.html">Common words</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/word_infinite_datatypes.html">Datatypes for words defined by iterators and callables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/word_options.html">User-customizable options for words</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/words.html">Set of words</a></li>
<li class="toctree-l2"><a class="reference internal" href="../yang_baxter_graph.html">Yang-Baxter Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../rings/cfinite_sequence.html">C-Finite Sequences</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="finite-posets">
<span id="sage-combinat-posets-posets"></span><h1>Finite posets<a class="headerlink" href="#finite-posets" title="Permalink to this headline">#</a></h1>
<span class="target" id="module-sage.combinat.posets.posets"></span><p>This module implements finite partially ordered sets. It defines:</p>
<div class="table-wrapper colwidths-given contentstable docutils container">
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><code class="xref py py-class docutils literal notranslate"><span class="pre">FinitePoset</span></code></a></p></td>
<td><p>A class for finite posets</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePosets_n" title="sage.combinat.posets.posets.FinitePosets_n"><code class="xref py py-class docutils literal notranslate"><span class="pre">FinitePosets_n</span></code></a></p></td>
<td><p>A class for finite posets up to isomorphism (i.e. unlabeled posets)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Poset()</span></code></a></p></td>
<td><p>Construct a finite poset from various forms of input data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.is_poset" title="sage.combinat.posets.posets.is_poset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_poset()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if a directed graph is acyclic and transitively reduced.</p></td>
</tr>
</tbody>
</table>
</div>
<section id="list-of-poset-methods">
<h2>List of Poset methods<a class="headerlink" href="#list-of-poset-methods" title="Permalink to this headline">#</a></h2>
<p><strong>Comparing, intervals and relations</strong></p>
<div class="table-wrapper colwidths-given contentstable docutils container">
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_less_than" title="sage.combinat.posets.posets.FinitePoset.is_less_than"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_less_than()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <span class="math notranslate nohighlight">\(x\)</span> is strictly less than <span class="math notranslate nohighlight">\(y\)</span> in the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_greater_than" title="sage.combinat.posets.posets.FinitePoset.is_greater_than"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_greater_than()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <span class="math notranslate nohighlight">\(x\)</span> is strictly greater than <span class="math notranslate nohighlight">\(y\)</span> in the poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_lequal" title="sage.combinat.posets.posets.FinitePoset.is_lequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_lequal()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <span class="math notranslate nohighlight">\(x\)</span> is less than or equal to <span class="math notranslate nohighlight">\(y\)</span> in the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_gequal" title="sage.combinat.posets.posets.FinitePoset.is_gequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_gequal()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <span class="math notranslate nohighlight">\(x\)</span> is greater than or equal to <span class="math notranslate nohighlight">\(y\)</span> in the poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.compare_elements" title="sage.combinat.posets.posets.FinitePoset.compare_elements"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compare_elements()</span></code></a></p></td>
<td><p>Compare two element of the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.closed_interval" title="sage.combinat.posets.posets.FinitePoset.closed_interval"><code class="xref py py-meth docutils literal notranslate"><span class="pre">closed_interval()</span></code></a></p></td>
<td><p>Return the list of elements in a closed interval of the poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.open_interval" title="sage.combinat.posets.posets.FinitePoset.open_interval"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open_interval()</span></code></a></p></td>
<td><p>Return the list of elements in an open interval of the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations" title="sage.combinat.posets.posets.FinitePoset.relations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relations()</span></code></a></p></td>
<td><p>Return the list of relations in the poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_iterator" title="sage.combinat.posets.posets.FinitePoset.relations_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relations_iterator()</span></code></a></p></td>
<td><p>Return an iterator over relations in the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_filter" title="sage.combinat.posets.posets.FinitePoset.order_filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_filter()</span></code></a></p></td>
<td><p>Return the upper set generated by elements.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_ideal" title="sage.combinat.posets.posets.FinitePoset.order_ideal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_ideal()</span></code></a></p></td>
<td><p>Return the lower set generated by elements.</p></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Covering</strong></p>
<div class="table-wrapper colwidths-given contentstable docutils container">
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.covers" title="sage.combinat.posets.posets.FinitePoset.covers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">covers()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">y</span></code> covers <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.lower_covers" title="sage.combinat.posets.posets.FinitePoset.lower_covers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lower_covers()</span></code></a></p></td>
<td><p>Return elements covered by given element.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.upper_covers" title="sage.combinat.posets.posets.FinitePoset.upper_covers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">upper_covers()</span></code></a></p></td>
<td><p>Return elements covering given element.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.cover_relations" title="sage.combinat.posets.posets.FinitePoset.cover_relations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cover_relations()</span></code></a></p></td>
<td><p>Return the list of cover relations.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.lower_covers_iterator" title="sage.combinat.posets.posets.FinitePoset.lower_covers_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lower_covers_iterator()</span></code></a></p></td>
<td><p>Return an iterator over elements covered by given element.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.upper_covers_iterator" title="sage.combinat.posets.posets.FinitePoset.upper_covers_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">upper_covers_iterator()</span></code></a></p></td>
<td><p>Return an iterator over elements covering given element.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.cover_relations_iterator" title="sage.combinat.posets.posets.FinitePoset.cover_relations_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cover_relations_iterator()</span></code></a></p></td>
<td><p>Return an iterator over cover relations of the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.common_upper_covers" title="sage.combinat.posets.posets.FinitePoset.common_upper_covers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">common_upper_covers()</span></code></a></p></td>
<td><p>Return the list of all common upper covers of the given elements.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.common_lower_covers" title="sage.combinat.posets.posets.FinitePoset.common_lower_covers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">common_lower_covers()</span></code></a></p></td>
<td><p>Return the list of all common lower covers of the given elements.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.meet" title="sage.combinat.posets.posets.FinitePoset.meet"><code class="xref py py-meth docutils literal notranslate"><span class="pre">meet()</span></code></a></p></td>
<td><p>Return the meet of given elements if it exists; <code class="docutils literal notranslate"><span class="pre">None</span></code> otherwise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.join" title="sage.combinat.posets.posets.FinitePoset.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code></a></p></td>
<td><p>Return the join of given elements if it exists; <code class="docutils literal notranslate"><span class="pre">None</span></code> otherwise.</p></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Properties of the poset</strong></p>
<div class="table-wrapper colwidths-given contentstable docutils container">
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.cardinality" title="sage.combinat.posets.posets.FinitePoset.cardinality"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cardinality()</span></code></a></p></td>
<td><p>Return the number of elements in the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.height" title="sage.combinat.posets.posets.FinitePoset.height"><code class="xref py py-meth docutils literal notranslate"><span class="pre">height()</span></code></a></p></td>
<td><p>Return the number of elements in a longest chain of the poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.width" title="sage.combinat.posets.posets.FinitePoset.width"><code class="xref py py-meth docutils literal notranslate"><span class="pre">width()</span></code></a></p></td>
<td><p>Return the number of elements in a longest antichain of the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_number" title="sage.combinat.posets.posets.FinitePoset.relations_number"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relations_number()</span></code></a></p></td>
<td><p>Return the number of relations in the poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.dimension" title="sage.combinat.posets.posets.FinitePoset.dimension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dimension()</span></code></a></p></td>
<td><p>Return the dimension of the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.jump_number" title="sage.combinat.posets.posets.FinitePoset.jump_number"><code class="xref py py-meth docutils literal notranslate"><span class="pre">jump_number()</span></code></a></p></td>
<td><p>Return the jump number of the poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.magnitude" title="sage.combinat.posets.posets.FinitePoset.magnitude"><code class="xref py py-meth docutils literal notranslate"><span class="pre">magnitude()</span></code></a></p></td>
<td><p>Return the magnitude of the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_bottom" title="sage.combinat.posets.posets.FinitePoset.has_bottom"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_bottom()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset has a unique minimal element.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_top" title="sage.combinat.posets.posets.FinitePoset.has_top"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_top()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset has a unique maximal element.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="sage.combinat.posets.posets.FinitePoset.is_bounded"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_bounded()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset has both unique minimal and unique maximal element.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_chain" title="sage.combinat.posets.posets.FinitePoset.is_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_chain()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is totally ordered.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_connected" title="sage.combinat.posets.posets.FinitePoset.is_connected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_connected()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is connected.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_graded" title="sage.combinat.posets.posets.FinitePoset.is_graded"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_graded()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if all maximal chains of the poset has same length.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_ranked" title="sage.combinat.posets.posets.FinitePoset.is_ranked"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_ranked()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset has a rank function.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_rank_symmetric" title="sage.combinat.posets.posets.FinitePoset.is_rank_symmetric"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_rank_symmetric()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is rank symmetric.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_series_parallel" title="sage.combinat.posets.posets.FinitePoset.is_series_parallel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_series_parallel()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset can be built by ordinal sums and disjoint unions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_greedy" title="sage.combinat.posets.posets.FinitePoset.is_greedy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_greedy()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if all greedy linear extensions have equal number of jumps.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_jump_critical" title="sage.combinat.posets.posets.FinitePoset.is_jump_critical"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_jump_critical()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if removal of any element reduces the jump number.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_eulerian" title="sage.combinat.posets.posets.FinitePoset.is_eulerian"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_eulerian()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is Eulerian.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_incomparable_chain_free" title="sage.combinat.posets.posets.FinitePoset.is_incomparable_chain_free"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_incomparable_chain_free()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is (m+n)-free.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_slender" title="sage.combinat.posets.posets.FinitePoset.is_slender"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_slender()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is slender.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_sperner" title="sage.combinat.posets.posets.FinitePoset.is_sperner"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_sperner()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is Sperner.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_join_semilattice" title="sage.combinat.posets.posets.FinitePoset.is_join_semilattice"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_join_semilattice()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> is the poset has a join operation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_meet_semilattice" title="sage.combinat.posets.posets.FinitePoset.is_meet_semilattice"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_meet_semilattice()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset has a meet operation.</p></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Minimal and maximal elements</strong></p>
<div class="table-wrapper colwidths-given contentstable docutils container">
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.bottom" title="sage.combinat.posets.posets.FinitePoset.bottom"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bottom()</span></code></a></p></td>
<td><p>Return the bottom element of the poset, if it exists.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.top" title="sage.combinat.posets.posets.FinitePoset.top"><code class="xref py py-meth docutils literal notranslate"><span class="pre">top()</span></code></a></p></td>
<td><p>Return the top element of the poset, if it exists.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_elements" title="sage.combinat.posets.posets.FinitePoset.maximal_elements"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximal_elements()</span></code></a></p></td>
<td><p>Return the list of the maximal elements of the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.minimal_elements" title="sage.combinat.posets.posets.FinitePoset.minimal_elements"><code class="xref py py-meth docutils literal notranslate"><span class="pre">minimal_elements()</span></code></a></p></td>
<td><p>Return the list of the minimal elements of the poset.</p></td>
</tr>
</tbody>
</table>
</div>
<p><strong>New posets from old ones</strong></p>
<div class="table-wrapper colwidths-given contentstable docutils container">
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.disjoint_union" title="sage.combinat.posets.posets.FinitePoset.disjoint_union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">disjoint_union()</span></code></a></p></td>
<td><p>Return the disjoint union of the poset with other poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_sum" title="sage.combinat.posets.posets.FinitePoset.ordinal_sum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ordinal_sum()</span></code></a></p></td>
<td><p>Return the ordinal sum of the poset with other poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.product" title="sage.combinat.posets.posets.FinitePoset.product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">product()</span></code></a></p></td>
<td><p>Return the Cartesian product of the poset with other poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_product" title="sage.combinat.posets.posets.FinitePoset.ordinal_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ordinal_product()</span></code></a></p></td>
<td><p>Return the ordinal product of the poset with other poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.rees_product" title="sage.combinat.posets.posets.FinitePoset.rees_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rees_product()</span></code></a></p></td>
<td><p>Return the Rees product of the poset with other poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.lexicographic_sum" title="sage.combinat.posets.posets.FinitePoset.lexicographic_sum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lexicographic_sum()</span></code></a></p></td>
<td><p>Return the lexicographic sum of posets.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.star_product" title="sage.combinat.posets.posets.FinitePoset.star_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">star_product()</span></code></a></p></td>
<td><p>Return the star product of the poset with other poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.with_bounds" title="sage.combinat.posets.posets.FinitePoset.with_bounds"><code class="xref py py-meth docutils literal notranslate"><span class="pre">with_bounds()</span></code></a></p></td>
<td><p>Return the poset with bottom and top element adjoined.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.without_bounds" title="sage.combinat.posets.posets.FinitePoset.without_bounds"><code class="xref py py-meth docutils literal notranslate"><span class="pre">without_bounds()</span></code></a></p></td>
<td><p>Return the poset with bottom and top element removed.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.dual" title="sage.combinat.posets.posets.FinitePoset.dual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dual()</span></code></a></p></td>
<td><p>Return the dual of the poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.completion_by_cuts" title="sage.combinat.posets.posets.FinitePoset.completion_by_cuts"><code class="xref py py-meth docutils literal notranslate"><span class="pre">completion_by_cuts()</span></code></a></p></td>
<td><p>Return the Dedekind-MacNeille completion of the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.intervals_poset" title="sage.combinat.posets.posets.FinitePoset.intervals_poset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">intervals_poset()</span></code></a></p></td>
<td><p>Return the poset of intervals of the poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.connected_components" title="sage.combinat.posets.posets.FinitePoset.connected_components"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connected_components()</span></code></a></p></td>
<td><p>Return the connected components of the poset as subposets.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.factor" title="sage.combinat.posets.posets.FinitePoset.factor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">factor()</span></code></a></p></td>
<td><p>Return the decomposition of the poset as a Cartesian product.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_summands" title="sage.combinat.posets.posets.FinitePoset.ordinal_summands"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ordinal_summands()</span></code></a></p></td>
<td><p>Return the ordinal summands of the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.subposet" title="sage.combinat.posets.posets.FinitePoset.subposet"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subposet()</span></code></a></p></td>
<td><p>Return the subposet containing elements with partial order induced by this poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.random_subposet" title="sage.combinat.posets.posets.FinitePoset.random_subposet"><code class="xref py py-meth docutils literal notranslate"><span class="pre">random_subposet()</span></code></a></p></td>
<td><p>Return a random subposet that contains each element with given probability.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relabel" title="sage.combinat.posets.posets.FinitePoset.relabel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relabel()</span></code></a></p></td>
<td><p>Return a copy of this poset with its elements relabelled.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.canonical_label" title="sage.combinat.posets.posets.FinitePoset.canonical_label"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_label()</span></code></a></p></td>
<td><p>Return copy of the poset canonically (re)labelled to integers.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.slant_sum" title="sage.combinat.posets.posets.FinitePoset.slant_sum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">slant_sum()</span></code></a></p></td>
<td><p>Return the slant sum poset of two posets.</p></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Chains, antichains &amp; linear intervals</strong></p>
<div class="table-wrapper colwidths-given contentstable docutils container">
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_chain_of_poset" title="sage.combinat.posets.posets.FinitePoset.is_chain_of_poset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_chain_of_poset()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if elements in the given list are comparable.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_antichain_of_poset" title="sage.combinat.posets.posets.FinitePoset.is_antichain_of_poset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_antichain_of_poset()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if elements in the given list are incomparable.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_linear_interval" title="sage.combinat.posets.posets.FinitePoset.is_linear_interval"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_linear_interval()</span></code></a></p></td>
<td><p>Return whether the given interval is a total order.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.chains" title="sage.combinat.posets.posets.FinitePoset.chains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">chains()</span></code></a></p></td>
<td><p>Return the chains of the poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains" title="sage.combinat.posets.posets.FinitePoset.antichains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">antichains()</span></code></a></p></td>
<td><p>Return the antichains of the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_chains" title="sage.combinat.posets.posets.FinitePoset.maximal_chains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximal_chains()</span></code></a></p></td>
<td><p>Return the maximal chains of the poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_antichains" title="sage.combinat.posets.posets.FinitePoset.maximal_antichains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximal_antichains()</span></code></a></p></td>
<td><p>Return the maximal antichains of the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_chains_iterator" title="sage.combinat.posets.posets.FinitePoset.maximal_chains_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximal_chains_iterator()</span></code></a></p></td>
<td><p>Return an iterator over the maximal chains of the poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_chain_length" title="sage.combinat.posets.posets.FinitePoset.maximal_chain_length"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximal_chain_length()</span></code></a></p></td>
<td><p>Return the maximum length of maximal chains of the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains_iterator" title="sage.combinat.posets.posets.FinitePoset.antichains_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">antichains_iterator()</span></code></a></p></td>
<td><p>Return an iterator over the antichains of the poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.random_maximal_chain" title="sage.combinat.posets.posets.FinitePoset.random_maximal_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">random_maximal_chain()</span></code></a></p></td>
<td><p>Return a random maximal chain.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.random_maximal_antichain" title="sage.combinat.posets.posets.FinitePoset.random_maximal_antichain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">random_maximal_antichain()</span></code></a></p></td>
<td><p>Return a random maximal antichain.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_intervals_count" title="sage.combinat.posets.posets.FinitePoset.linear_intervals_count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">linear_intervals_count()</span></code></a></p></td>
<td><p>Return the enumeration of linear intervals in the poset.</p></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Drawing</strong></p>
<div class="table-wrapper colwidths-given contentstable docutils container">
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.show" title="sage.combinat.posets.posets.FinitePoset.show"><code class="xref py py-meth docutils literal notranslate"><span class="pre">show()</span></code></a></p></td>
<td><p>Display the Hasse diagram of the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.plot" title="sage.combinat.posets.posets.FinitePoset.plot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot()</span></code></a></p></td>
<td><p>Return a Graphic object corresponding the Hasse diagram of the poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.graphviz_string" title="sage.combinat.posets.posets.FinitePoset.graphviz_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graphviz_string()</span></code></a></p></td>
<td><p>Return a representation in the DOT language, ready to render in graphviz.</p></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Comparing posets</strong></p>
<div class="table-wrapper colwidths-given contentstable docutils container">
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_isomorphic" title="sage.combinat.posets.posets.FinitePoset.is_isomorphic"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_isomorphic()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if both posets are isomorphic.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_induced_subposet" title="sage.combinat.posets.posets.FinitePoset.is_induced_subposet"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_induced_subposet()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if given poset is an induced subposet of this poset.</p></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Polynomials</strong></p>
<div class="table-wrapper colwidths-given contentstable docutils container">
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.chain_polynomial" title="sage.combinat.posets.posets.FinitePoset.chain_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">chain_polynomial()</span></code></a></p></td>
<td><p>Return the chain polynomial of the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.characteristic_polynomial" title="sage.combinat.posets.posets.FinitePoset.characteristic_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">characteristic_polynomial()</span></code></a></p></td>
<td><p>Return the characteristic polynomial of the poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.f_polynomial" title="sage.combinat.posets.posets.FinitePoset.f_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">f_polynomial()</span></code></a></p></td>
<td><p>Return the f-polynomial of the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.flag_f_polynomial" title="sage.combinat.posets.posets.FinitePoset.flag_f_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flag_f_polynomial()</span></code></a></p></td>
<td><p>Return the flag f-polynomial of the poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.h_polynomial" title="sage.combinat.posets.posets.FinitePoset.h_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">h_polynomial()</span></code></a></p></td>
<td><p>Return the h-polynomial of the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.flag_h_polynomial" title="sage.combinat.posets.posets.FinitePoset.flag_h_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flag_h_polynomial()</span></code></a></p></td>
<td><p>Return the flag h-polynomial of the poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_polynomial" title="sage.combinat.posets.posets.FinitePoset.order_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_polynomial()</span></code></a></p></td>
<td><p>Return the order polynomial of the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.zeta_polynomial" title="sage.combinat.posets.posets.FinitePoset.zeta_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">zeta_polynomial()</span></code></a></p></td>
<td><p>Return the zeta polynomial of the poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.kazhdan_lusztig_polynomial" title="sage.combinat.posets.posets.FinitePoset.kazhdan_lusztig_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kazhdan_lusztig_polynomial()</span></code></a></p></td>
<td><p>Return the Kazhdan-Lusztig polynomial of the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.coxeter_polynomial" title="sage.combinat.posets.posets.FinitePoset.coxeter_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coxeter_polynomial()</span></code></a></p></td>
<td><p>Return the characteristic polynomial of the Coxeter transformation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.degree_polynomial" title="sage.combinat.posets.posets.FinitePoset.degree_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">degree_polynomial()</span></code></a></p></td>
<td><p>Return the generating polynomial of degrees of vertices in the Hasse diagram.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.p_partition_enumerator" title="sage.combinat.posets.posets.FinitePoset.p_partition_enumerator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">p_partition_enumerator()</span></code></a></p></td>
<td><p>Return a <span class="math notranslate nohighlight">\(P\)</span>-partition enumerator of the poset.</p></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Polytopes</strong></p>
<div class="table-wrapper colwidths-given contentstable docutils container">
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.chain_polytope" title="sage.combinat.posets.posets.FinitePoset.chain_polytope"><code class="xref py py-meth docutils literal notranslate"><span class="pre">chain_polytope()</span></code></a></p></td>
<td><p>Return the chain polytope of the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_polytope" title="sage.combinat.posets.posets.FinitePoset.order_polytope"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_polytope()</span></code></a></p></td>
<td><p>Return the order polytope of the poset.</p></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Graphs</strong></p>
<div class="table-wrapper colwidths-given contentstable docutils container">
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.hasse_diagram" title="sage.combinat.posets.posets.FinitePoset.hasse_diagram"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hasse_diagram()</span></code></a></p></td>
<td><p>Return the Hasse diagram of the poset as a directed graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.cover_relations_graph" title="sage.combinat.posets.posets.FinitePoset.cover_relations_graph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cover_relations_graph()</span></code></a></p></td>
<td><p>Return the (undirected) graph of cover relations.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.comparability_graph" title="sage.combinat.posets.posets.FinitePoset.comparability_graph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">comparability_graph()</span></code></a></p></td>
<td><p>Return the comparability graph of the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.incomparability_graph" title="sage.combinat.posets.posets.FinitePoset.incomparability_graph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">incomparability_graph()</span></code></a></p></td>
<td><p>Return the incomparability graph of the poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.frank_network" title="sage.combinat.posets.posets.FinitePoset.frank_network"><code class="xref py py-meth docutils literal notranslate"><span class="pre">frank_network()</span></code></a></p></td>
<td><p>Return Frank’s network of the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extensions_graph" title="sage.combinat.posets.posets.FinitePoset.linear_extensions_graph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">linear_extensions_graph()</span></code></a></p></td>
<td><p>Return the linear extensions graph of the poset.</p></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Linear extensions</strong></p>
<div class="table-wrapper colwidths-given contentstable docutils container">
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_linear_extension" title="sage.combinat.posets.posets.FinitePoset.is_linear_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_linear_extension()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the given list is a linear extension of the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extension" title="sage.combinat.posets.posets.FinitePoset.linear_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">linear_extension()</span></code></a></p></td>
<td><p>Return a linear extension of the poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extensions" title="sage.combinat.posets.posets.FinitePoset.linear_extensions"><code class="xref py py-meth docutils literal notranslate"><span class="pre">linear_extensions()</span></code></a></p></td>
<td><p>Return the enumerated set of all the linear extensions of the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.promotion" title="sage.combinat.posets.posets.FinitePoset.promotion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">promotion()</span></code></a></p></td>
<td><p>Return the (extended) promotion on the linear extension of the poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.evacuation" title="sage.combinat.posets.posets.FinitePoset.evacuation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">evacuation()</span></code></a></p></td>
<td><p>Return evacuation on the linear extension associated to the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.with_linear_extension" title="sage.combinat.posets.posets.FinitePoset.with_linear_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">with_linear_extension()</span></code></a></p></td>
<td><p>Return a copy of <code class="docutils literal notranslate"><span class="pre">self</span></code> with a different default linear extension.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.random_linear_extension" title="sage.combinat.posets.posets.FinitePoset.random_linear_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">random_linear_extension()</span></code></a></p></td>
<td><p>Return a random linear extension.</p></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Matrices</strong></p>
<div class="table-wrapper colwidths-given contentstable docutils container">
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.lequal_matrix" title="sage.combinat.posets.posets.FinitePoset.lequal_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lequal_matrix()</span></code></a></p></td>
<td><p>Computes the matrix whose <code class="docutils literal notranslate"><span class="pre">(i,j)</span></code> entry is 1 if <code class="docutils literal notranslate"><span class="pre">self.linear_extension()[i]</span> <span class="pre">&lt;</span> <span class="pre">self.linear_extension()[j]</span></code> and 0 otherwise.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.moebius_function" title="sage.combinat.posets.posets.FinitePoset.moebius_function"><code class="xref py py-meth docutils literal notranslate"><span class="pre">moebius_function()</span></code></a></p></td>
<td><p>Return the value of Möbius function of given elements in the poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.moebius_function_matrix" title="sage.combinat.posets.posets.FinitePoset.moebius_function_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">moebius_function_matrix()</span></code></a></p></td>
<td><p>Return a matrix whose <code class="docutils literal notranslate"><span class="pre">(i,j)</span></code> entry is the value of the Möbius function evaluated at <code class="docutils literal notranslate"><span class="pre">self.linear_extension()[i]</span></code> and <code class="docutils literal notranslate"><span class="pre">self.linear_extension()[j]</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.coxeter_transformation" title="sage.combinat.posets.posets.FinitePoset.coxeter_transformation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coxeter_transformation()</span></code></a></p></td>
<td><p>Return the matrix of the Auslander-Reiten translation acting on the Grothendieck group of the derived category of modules.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.coxeter_smith_form" title="sage.combinat.posets.posets.FinitePoset.coxeter_smith_form"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coxeter_smith_form()</span></code></a></p></td>
<td><p>Return the Smith form of the Coxeter transformation.</p></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Miscellaneous</strong></p>
<div class="table-wrapper colwidths-given contentstable docutils container">
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.sorted" title="sage.combinat.posets.posets.FinitePoset.sorted"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sorted()</span></code></a></p></td>
<td><p>Return given list sorted by the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets" title="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isomorphic_subposets()</span></code></a></p></td>
<td><p>Return all subposets isomorphic to another poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator" title="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isomorphic_subposets_iterator()</span></code></a></p></td>
<td><p>Return an iterator over the subposets isomorphic to another poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_isomorphic_subposet" title="sage.combinat.posets.posets.FinitePoset.has_isomorphic_subposet"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_isomorphic_subposet()</span></code></a></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset contains a subposet isomorphic to another poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.list" title="sage.combinat.posets.posets.FinitePoset.list"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list()</span></code></a></p></td>
<td><p>List the elements of the poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.cuts" title="sage.combinat.posets.posets.FinitePoset.cuts"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cuts()</span></code></a></p></td>
<td><p>Return the cuts of the given poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.dilworth_decomposition" title="sage.combinat.posets.posets.FinitePoset.dilworth_decomposition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dilworth_decomposition()</span></code></a></p></td>
<td><p>Return a partition of the points into the minimal number of chains.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.greene_shape" title="sage.combinat.posets.posets.FinitePoset.greene_shape"><code class="xref py py-meth docutils literal notranslate"><span class="pre">greene_shape()</span></code></a></p></td>
<td><p>Computes the Greene-Kleitman partition aka Greene shape of the poset <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.incidence_algebra" title="sage.combinat.posets.posets.FinitePoset.incidence_algebra"><code class="xref py py-meth docutils literal notranslate"><span class="pre">incidence_algebra()</span></code></a></p></td>
<td><p>Return the incidence algebra of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_EL_labelling" title="sage.combinat.posets.posets.FinitePoset.is_EL_labelling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_EL_labelling()</span></code></a></p></td>
<td><p>Return whether <code class="docutils literal notranslate"><span class="pre">f</span></code> is an EL labelling of the poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator" title="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isomorphic_subposets_iterator()</span></code></a></p></td>
<td><p>Return an iterator over the subposets isomorphic to another poset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets" title="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isomorphic_subposets()</span></code></a></p></td>
<td><p>Return all subposets isomorphic to another poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.level_sets" title="sage.combinat.posets.posets.FinitePoset.level_sets"><code class="xref py py-meth docutils literal notranslate"><span class="pre">level_sets()</span></code></a></p></td>
<td><p>Return elements grouped by maximal number of cover relations from a minimal element.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_complex" title="sage.combinat.posets.posets.FinitePoset.order_complex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_complex()</span></code></a></p></td>
<td><p>Return the order complex associated to this poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.random_order_ideal" title="sage.combinat.posets.posets.FinitePoset.random_order_ideal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">random_order_ideal()</span></code></a></p></td>
<td><p>Return a random order ideal of <code class="docutils literal notranslate"><span class="pre">self</span></code> with uniform probability.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.rank" title="sage.combinat.posets.posets.FinitePoset.rank"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rank()</span></code></a></p></td>
<td><p>Return the rank of an element, or the rank of the poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.rank_function" title="sage.combinat.posets.posets.FinitePoset.rank_function"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rank_function()</span></code></a></p></td>
<td><p>Return a rank function of the poset, if it exists.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.unwrap" title="sage.combinat.posets.posets.FinitePoset.unwrap"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unwrap()</span></code></a></p></td>
<td><p>Unwraps an element of this poset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.atkinson" title="sage.combinat.posets.posets.FinitePoset.atkinson"><code class="xref py py-meth docutils literal notranslate"><span class="pre">atkinson()</span></code></a></p></td>
<td><p>Return the <span class="math notranslate nohighlight">\(a\)</span>-spectrum of a poset whose undirected Hasse diagram is a forest.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.spectrum" title="sage.combinat.posets.posets.FinitePoset.spectrum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spectrum()</span></code></a></p></td>
<td><p>Return the <span class="math notranslate nohighlight">\(a\)</span>-spectrum of this poset.</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="classes-and-functions">
<h2>Classes and functions<a class="headerlink" href="#classes-and-functions" title="Permalink to this headline">#</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.combinat.posets.posets.</span></span><span class="sig-name descname"><span class="pre">FinitePoset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hasse_diagram</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elements</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">category</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">facade</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Parents and Elements v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.unique_representation.UniqueRepresentation</span></code></a>, <a class="reference external" href="../../../../structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Parents and Elements v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.parent.Parent</span></code></a></p>
<p>A (finite) <span class="math notranslate nohighlight">\(n\)</span>-element poset constructed from a directed acyclic graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hasse_diagram</span></code> – an instance of
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><code class="xref py py-class docutils literal notranslate"><span class="pre">FinitePoset</span></code></a>, or a
<a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Graph Theory v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraph</span></code></a> that is transitively-reduced, acyclic,
loop-free, and multiedge-free.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elements</span></code> – an optional list of elements, with <code class="docutils literal notranslate"><span class="pre">element[i]</span></code>
corresponding to vertex <code class="docutils literal notranslate"><span class="pre">i</span></code>. If <code class="docutils literal notranslate"><span class="pre">elements</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, then it is
set to be the vertex set of the digraph. Note that if this option is set,
then <code class="docutils literal notranslate"><span class="pre">elements</span></code> is considered as a specified linear extension of the poset
and the <span class="math notranslate nohighlight">\(linear_extension\)</span> attribute is set.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">category</span></code> – <a class="reference external" href="../../../../categories/sage/categories/finite_posets.html#sage.categories.finite_posets.FinitePosets" title="(in Category Framework v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">FinitePosets</span></code></a>, or a subcategory thereof.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">facade</span></code> – a boolean or <code class="docutils literal notranslate"><span class="pre">None</span></code> (default); whether the
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><code class="xref py py-class docutils literal notranslate"><span class="pre">FinitePoset</span></code></a>’s elements should be
wrapped to make them aware of the Poset they belong to.</p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">True</span></code>, the
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><code class="xref py py-class docutils literal notranslate"><span class="pre">FinitePoset</span></code></a>’s elements are exactly
those given as input.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">False</span></code>, the
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><code class="xref py py-class docutils literal notranslate"><span class="pre">FinitePoset</span></code></a>’s elements will become
<code class="xref py py-class docutils literal notranslate"><span class="pre">PosetElement</span></code> objects.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">None</span></code> (default) the expected behaviour is the behaviour
of <code class="docutils literal notranslate"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">True</span></code>, unless the opposite can be deduced from the
context (i.e. for instance if a
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><code class="xref py py-class docutils literal notranslate"><span class="pre">FinitePoset</span></code></a> is built from another
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><code class="xref py py-class docutils literal notranslate"><span class="pre">FinitePoset</span></code></a>, itself built with
<code class="docutils literal notranslate"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">False</span></code>)</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">key</span></code> – any hashable value (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">uc</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.posets.posets</span> <span class="kn">import</span> <span class="n">FinitePoset</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">FinitePoset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">(</span><span class="nb">dict</span><span class="p">([[</span><span class="n">i</span><span class="p">,</span><span class="n">uc</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uc</span><span class="p">))])),</span> <span class="n">facade</span><span class="o">=</span><span class="kc">False</span><span class="p">);</span> <span class="n">P</span>
<span class="go">Finite poset containing 6 elements</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[5, 4], [5, 3], [4, 1], [0, 2], [0, 3], [2, 1], [3, 1]]</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of finite enumerated posets</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="vm">__class__</span>
<span class="go">&lt;class &#39;sage.combinat.posets.posets.FinitePoset_with_category&#39;&gt;</span>

<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">combinat</span><span class="o">.</span><span class="n">posets</span><span class="o">.</span><span class="n">posets</span><span class="o">.</span><span class="n">FinitePoset</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">facade</span> <span class="o">=</span> <span class="kc">False</span><span class="p">);</span> <span class="n">Q</span>
<span class="go">Finite poset containing 6 elements</span>

<span class="gp">sage: </span><span class="n">Q</span> <span class="ow">is</span> <span class="n">P</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We keep the same underlying Hasse diagram, but change the elements:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">combinat</span><span class="o">.</span><span class="n">posets</span><span class="o">.</span><span class="n">posets</span><span class="o">.</span><span class="n">FinitePoset</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">elements</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="n">facade</span><span class="o">=</span><span class="kc">False</span><span class="p">);</span> <span class="n">Q</span>
<span class="go">Finite poset containing 6 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 5], [2, 6], [3, 4], [3, 5], [4, 6], [5, 6]]</span>
</pre></div>
</div>
<p>We test the facade argument:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">],</span><span class="s1">&#39;c&#39;</span><span class="p">:[</span><span class="s1">&#39;d&#39;</span><span class="p">]}),</span> <span class="n">facade</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of finite enumerated posets</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="n">P</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">],</span><span class="s1">&#39;c&#39;</span><span class="p">:[</span><span class="s1">&#39;d&#39;</span><span class="p">]}),</span> <span class="n">facade</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of facade finite enumerated posets</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">str</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">skip</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;_test_an_element&#39;</span><span class="p">])</span> <span class="c1"># is_parent_of is not yet implemented</span>
</pre></div>
</div>
<p>Changing a non facade poset to a facade poset:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">PQ</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">facade</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">PQ</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of facade finite enumerated posets</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">PQ</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">str</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">PQ</span> <span class="ow">is</span> <span class="n">Q</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Changing a facade poset to a non facade poset:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QP</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">facade</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">QP</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of finite enumerated posets</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">QP</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="n">QP</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Conversion to some other software is possible:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">TamariLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">libgap</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>  <span class="c1"># optional - gap_packages</span>
<span class="go">&lt;A poset on 5 points&gt;</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span><span class="mi">2</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">macaulay2</span><span class="p">(</span><span class="s1">&#39;needsPackage &quot;Posets&quot;&#39;</span><span class="p">)</span>   <span class="c1"># optional - macaulay2</span>
<span class="go">Posets</span>
<span class="gp">sage: </span><span class="n">macaulay2</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>   <span class="c1"># optional - macaulay2</span>
<span class="go">Relation Matrix: | 1 1 |</span>
<span class="go">                 | 0 1 |</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A class that inherits from this class needs to define
<code class="docutils literal notranslate"><span class="pre">Element</span></code>. This is the class of the elements that the inheriting
class contains. For example, for this class, <code class="docutils literal notranslate"><span class="pre">FinitePoset</span></code>,
<code class="docutils literal notranslate"><span class="pre">Element</span></code> is <code class="docutils literal notranslate"><span class="pre">PosetElement</span></code>.  It can also define <code class="docutils literal notranslate"><span class="pre">_dual_class</span></code> which
is the class of dual posets of this
class. E.g. <code class="docutils literal notranslate"><span class="pre">FiniteMeetSemilattice._dual_class</span></code> is
<code class="docutils literal notranslate"><span class="pre">FiniteJoinSemilattice</span></code>.</p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.Element">
<span class="sig-name descname"><span class="pre">Element</span></span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.Element" title="Permalink to this definition">#</a></dt>
<dd><p>alias of <a class="reference internal" href="elements.html#sage.combinat.posets.elements.PosetElement" title="sage.combinat.posets.elements.PosetElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.posets.elements.PosetElement</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.antichains">
<span class="sig-name descname"><span class="pre">antichains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element_constructor=&lt;class</span> <span class="pre">'list'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.antichains" title="Permalink to this definition">#</a></dt>
<dd><p>Return the antichains of the poset.</p>
<p>An <em>antichain</em> of a poset is a set of elements of the
poset that are pairwise incomparable.</p>
<p>INPUT:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">element_constructor</span></code> – a function taking an iterable as
argument (default: <code class="docutils literal notranslate"><span class="pre">list</span></code>)</p></li>
</ul>
</div></blockquote>
<p>OUTPUT:</p>
<p>The enumerated set (of type
<a class="reference internal" href="../subsets_pairwise.html#sage.combinat.subsets_pairwise.PairwiseCompatibleSubsets" title="sage.combinat.subsets_pairwise.PairwiseCompatibleSubsets"><code class="xref py py-class docutils literal notranslate"><span class="pre">PairwiseCompatibleSubsets</span></code></a>)
of all antichains of the poset, each of which is given as an
<code class="docutils literal notranslate"><span class="pre">element_constructor.</span></code></p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">antichains</span><span class="p">();</span> <span class="n">A</span>
<span class="go">Set of antichains of Finite lattice containing 5 elements</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[[], [0], [1], [1, 2], [1, 3], [2], [3], [4]]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">8</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">[1, 2]</span>
</pre></div>
</div>
<p>To get the antichains as, say, sets, one may use the
<code class="docutils literal notranslate"><span class="pre">element_constructor</span></code> option:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">antichains</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">set</span><span class="p">))</span>
<span class="go">[set(), {0}, {1}, {2}]</span>
</pre></div>
</div>
<p>To get the antichains of a given size one can currently use:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">elements_of_depth_iterator</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[[1, 2], [1, 3]]</span>
</pre></div>
</div>
<p>Eventually the following syntax will be accepted:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">subset</span><span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># todo: not implemented</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Internally, this uses
<a class="reference internal" href="../subsets_pairwise.html#sage.combinat.subsets_pairwise.PairwiseCompatibleSubsets" title="sage.combinat.subsets_pairwise.PairwiseCompatibleSubsets"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.subsets_pairwise.PairwiseCompatibleSubsets</span></code></a>
and <code class="xref py py-class docutils literal notranslate"><span class="pre">RecursivelyEnumeratedSet_forest</span></code>. At this point, iterating
through this set is about twice slower than using
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains_iterator" title="sage.combinat.posets.posets.FinitePoset.antichains_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">antichains_iterator()</span></code></a> (tested on
<code class="docutils literal notranslate"><span class="pre">posets.AntichainPoset(15)</span></code>). The algorithm is the same
(depth first search through the tree), but
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains_iterator" title="sage.combinat.posets.posets.FinitePoset.antichains_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">antichains_iterator()</span></code></a> manually inlines things which
apparently avoids some infrastructure overhead.</p>
<p>On the other hand, this returns a full featured enumerated
set, with containment testing, etc.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_antichains" title="sage.combinat.posets.posets.FinitePoset.maximal_antichains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximal_antichains()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.chains" title="sage.combinat.posets.posets.FinitePoset.chains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">chains()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.antichains_iterator">
<span class="sig-name descname"><span class="pre">antichains_iterator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.antichains_iterator" title="Permalink to this definition">#</a></dt>
<dd><p>Return an iterator over the antichains of the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">antichains_iterator</span><span class="p">();</span> <span class="n">it</span>
<span class="go">&lt;generator object ...antichains_iterator at ...&gt;</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">([], [4])</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains" title="sage.combinat.posets.posets.FinitePoset.antichains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">antichains()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.atkinson">
<span class="sig-name descname"><span class="pre">atkinson</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.atkinson" title="Permalink to this definition">#</a></dt>
<dd><p>Return the <span class="math notranslate nohighlight">\(a\)</span>-spectrum of a poset whose Hasse diagram is
cycle-free as an undirected graph.</p>
<p>Given an element <span class="math notranslate nohighlight">\(a\)</span> in a poset <span class="math notranslate nohighlight">\(P\)</span>, the <span class="math notranslate nohighlight">\(a\)</span>-spectrum is the list of
integers whose <span class="math notranslate nohighlight">\(i\)</span>-th term contains the number of linear extensions of
<span class="math notranslate nohighlight">\(P\)</span> with element <span class="math notranslate nohighlight">\(a\)</span> located in the i-th position.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">self</span></code> – a poset whose Hasse diagram is a forest</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a</span></code> – an element of the poset</p></li>
</ul>
<p>OUTPUT:</p>
<p>The <span class="math notranslate nohighlight">\(a\)</span>-spectrum of this poset, returned as a list.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">atkinson</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[2, 2, 0, 0, 0]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">atkinson</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">[0, 10, 18, 24, 28, 30, 30]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">atkinson</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[362880, 362880, 362880, 362880, 362880, 362880, 362880, 362880, 362880, 362880]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is the implementation of the algorithm from <a class="reference internal" href="../../../../references/index.html#at1990" id="id1"><span>[At1990]</span></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.bottom">
<span class="sig-name descname"><span class="pre">bottom</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.bottom" title="Permalink to this definition">#</a></dt>
<dd><p>Return the unique minimal element of the poset, if it exists.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span><span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">bottom</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">bottom</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_bottom" title="sage.combinat.posets.posets.FinitePoset.has_bottom"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_bottom()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.top" title="sage.combinat.posets.posets.FinitePoset.top"><code class="xref py py-meth docutils literal notranslate"><span class="pre">top()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.canonical_label">
<span class="sig-name descname"><span class="pre">canonical_label</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.canonical_label" title="Permalink to this definition">#</a></dt>
<dd><p>Return the unique poset on the labels <span class="math notranslate nohighlight">\(\{0, \ldots, n-1\}\)</span> (where <span class="math notranslate nohighlight">\(n\)</span>
is the number of elements in the poset) that is isomorphic to this
poset and invariant in the isomorphism class.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (optional); a parameter forwarded
to underlying graph function to select the algorithm to use</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
<span class="go">[0, 1, 2, 3, 4, 5]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Canonical labeling of (semi)lattice returns (semi)lattice:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ML</span> <span class="o">=</span> <span class="n">MeetSemilattice</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">()</span>
<span class="go">Finite poset containing 3 elements</span>
<span class="gp">sage: </span><span class="n">ML</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">()</span>
<span class="go">Finite meet-semilattice containing 3 elements</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p>Canonical labeling of directed graphs:
<a class="reference external" href="../../../../graphs/sage/graphs/generic_graph.html#sage.graphs.generic_graph.GenericGraph.canonical_label" title="(in Graph Theory v9.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_label()</span></code></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.cardinality">
<span class="sig-name descname"><span class="pre">cardinality</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.cardinality" title="Permalink to this definition">#</a></dt>
<dd><p>Return the number of elements in the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[]])</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">5</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.degree_polynomial" title="sage.combinat.posets.posets.FinitePoset.degree_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">degree_polynomial()</span></code></a> for a more refined invariant</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.chain_polynomial">
<span class="sig-name descname"><span class="pre">chain_polynomial</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.chain_polynomial" title="Permalink to this definition">#</a></dt>
<dd><p>Return the chain polynomial of the poset.</p>
<p>The coefficient of <span class="math notranslate nohighlight">\(q^k\)</span> is the number of chains of <span class="math notranslate nohighlight">\(k\)</span>
elements in the poset. List of coefficients of this polynomial
is also called a <em>f-vector</em> of the poset.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is not what has been called the chain polynomial
in <a class="reference internal" href="../../../../references/index.html#st1986" id="id2"><span>[St1986]</span></a>. The latter is identical with the order
polynomial in SageMath (<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_polynomial" title="sage.combinat.posets.posets.FinitePoset.order_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_polynomial()</span></code></a>).</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.f_polynomial" title="sage.combinat.posets.posets.FinitePoset.f_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">f_polynomial()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_polynomial" title="sage.combinat.posets.posets.FinitePoset.order_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_polynomial()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">chain_polynomial</span><span class="p">();</span> <span class="n">t</span>
<span class="go">q^3 + 3*q^2 + 3*q + 1</span>
<span class="gp">sage: </span><span class="n">t</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">chains</span><span class="p">()))</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">chain_polynomial</span><span class="p">()</span>
<span class="go">6*q^4 + 18*q^3 + 19*q^2 + 8*q + 1</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">chain_polynomial</span><span class="p">()</span>
<span class="go">5*q + 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.chain_polytope">
<span class="sig-name descname"><span class="pre">chain_polytope</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.chain_polytope" title="Permalink to this definition">#</a></dt>
<dd><p>Return the chain polytope of the poset <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The chain polytope of a finite poset <span class="math notranslate nohighlight">\(P\)</span> is defined as the subset
of <span class="math notranslate nohighlight">\(\RR^P\)</span> consisting of all maps <span class="math notranslate nohighlight">\(x : P \to \RR\)</span> satisfying</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[x(p) \geq 0 \mbox{ for all } p \in P,\]</div>
</div>
<p>and</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[x(p_1) + x(p_2) + \ldots + x(p_k) \leq 1
\mbox{ for all chains } p_1 &lt; p_2 &lt; \ldots &lt; p_k
\mbox{ in } P.\]</div>
</div>
<p>This polytope was defined and studied in <a class="reference internal" href="../../../../references/index.html#st1986" id="id3"><span>[St1986]</span></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">chain_polytope</span><span class="p">();</span><span class="n">Q</span>
<span class="go">A 3-dimensional polyhedron in ZZ^3 defined as the convex hull of 8 vertices</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">chain_polytope</span><span class="p">();</span><span class="n">Q</span>
<span class="go">A 5-dimensional polyhedron in ZZ^5 defined as the convex hull of 8 vertices</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.chains">
<span class="sig-name descname"><span class="pre">chains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element_constructor=&lt;class</span> <span class="pre">'list'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude=None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.chains" title="Permalink to this definition">#</a></dt>
<dd><p>Return the chains of the poset.</p>
<p>A <em>chain</em> of a poset is an increasing sequence of
distinct elements of the poset.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">element_constructor</span></code> – a function taking an iterable as
argument (optional, default: <code class="docutils literal notranslate"><span class="pre">list</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">exclude</span></code> – elements of the poset to be excluded
(optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
</ul>
<p>OUTPUT:</p>
<p>The enumerated set (of type
<a class="reference internal" href="../subsets_pairwise.html#sage.combinat.subsets_pairwise.PairwiseCompatibleSubsets" title="sage.combinat.subsets_pairwise.PairwiseCompatibleSubsets"><code class="xref py py-class docutils literal notranslate"><span class="pre">PairwiseCompatibleSubsets</span></code></a>)
of all chains of the poset, each of which is given as an
<code class="docutils literal notranslate"><span class="pre">element_constructor</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">chains</span><span class="p">();</span> <span class="n">C</span>
<span class="go">Set of chains of Finite lattice containing 5 elements</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">[[], [0], [0, 1], [0, 1, 4], [0, 2], [0, 2, 3], [0, 2, 3, 4], [0, 2, 4], [0, 3], [0, 3, 4], [0, 4], [1], [1, 4], [2], [2, 3], [2, 3, 4], [2, 4], [3], [3, 4], [4]]</span>
</pre></div>
</div>
<p>Exclusion of elements, tuple (instead of list) as constructor:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">chains</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">[(), (1,), (1, 2), (1, 2, 4), (1, 4), (1, 5), (2,), (2, 4), (4,), (5,)]</span>
</pre></div>
</div>
<p>To get the chains of a given size one can currently use:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">elements_of_depth_iterator</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[[0, 1], [0, 2], [0, 3], [0, 4], [1, 4], [2, 3], [2, 4], [3, 4]]</span>
</pre></div>
</div>
<p>Eventually the following syntax will be accepted:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">subset</span><span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># todo: not implemented</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_chains" title="sage.combinat.posets.posets.FinitePoset.maximal_chains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximal_chains()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains" title="sage.combinat.posets.posets.FinitePoset.antichains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">antichains()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.characteristic_polynomial">
<span class="sig-name descname"><span class="pre">characteristic_polynomial</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.characteristic_polynomial" title="Permalink to this definition">#</a></dt>
<dd><p>Return the characteristic polynomial of the poset.</p>
<p>The poset is expected to be graded and have a bottom
element.</p>
<p>If <span class="math notranslate nohighlight">\(P\)</span> is a graded poset with rank <span class="math notranslate nohighlight">\(n\)</span> and a unique minimal
element <span class="math notranslate nohighlight">\(\hat{0}\)</span>, then the characteristic polynomial of
<span class="math notranslate nohighlight">\(P\)</span> is defined to be</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\sum_{x \in P} \mu(\hat{0}, x) q^{n-\rho(x)} \in \ZZ[q],\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(\rho\)</span> is the rank function, and <span class="math notranslate nohighlight">\(\mu\)</span> is the Möbius
function of <span class="math notranslate nohighlight">\(P\)</span>.</p>
<p>See section 3.10 of <a class="reference internal" href="../../../../references/index.html#enumcomb1" id="id4"><span>[EnumComb1]</span></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">characteristic_polynomial</span><span class="p">()</span>
<span class="go">q^2 - 3*q + 2</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">characteristic_polynomial</span><span class="p">()</span>
<span class="go">q^4 - 2*q^3 + q</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.closed_interval">
<span class="sig-name descname"><span class="pre">closed_interval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.closed_interval" title="Permalink to this definition">#</a></dt>
<dd><p>Return the list of elements <span class="math notranslate nohighlight">\(z\)</span> such that <span class="math notranslate nohighlight">\(x \le z \le y\)</span> in the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">closed_interval</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="go">[2, 4, 10, 20, 50, 100]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.open_interval" title="sage.combinat.posets.posets.FinitePoset.open_interval"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open_interval()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.common_lower_covers">
<span class="sig-name descname"><span class="pre">common_lower_covers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elmts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.common_lower_covers" title="Permalink to this definition">#</a></dt>
<dd><p>Return all of the common lower covers of the elements <code class="docutils literal notranslate"><span class="pre">elmts</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">common_lower_covers</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">[0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.common_upper_covers">
<span class="sig-name descname"><span class="pre">common_upper_covers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elmts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.common_upper_covers" title="Permalink to this definition">#</a></dt>
<dd><p>Return all of the common upper covers of the elements <code class="docutils literal notranslate"><span class="pre">elmts</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">common_upper_covers</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">[3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.comparability_graph">
<span class="sig-name descname"><span class="pre">comparability_graph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.comparability_graph" title="Permalink to this definition">#</a></dt>
<dd><p>Return the comparability graph of the poset.</p>
<p>The comparability graph is an undirected graph where vertices
are the elements of the poset and there is an edge between two
vertices if they are comparable in the poset.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Comparability_graph">Wikipedia article Comparability_graph</a></p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">comparability_graph</span><span class="p">();</span> <span class="n">g</span>
<span class="go">Comparability graph on 4 vertices</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">compare_elements</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.incomparability_graph" title="sage.combinat.posets.posets.FinitePoset.incomparability_graph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">incomparability_graph()</span></code></a>, <a class="reference external" href="../../../../graphs/sage/graphs/comparability.html#module-sage.graphs.comparability" title="(in Graph Theory v9.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.graphs.comparability</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.compare_elements">
<span class="sig-name descname"><span class="pre">compare_elements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.compare_elements" title="Permalink to this definition">#</a></dt>
<dd><p>Compare <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> in the poset.</p>
<ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(x &lt; y\)</span>, return <code class="docutils literal notranslate"><span class="pre">-1</span></code>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(x = y\)</span>, return <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(x &gt; y\)</span>, return <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> are not comparable, return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">compare_elements</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">compare_elements</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">compare_elements</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">compare_elements</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.completion_by_cuts">
<span class="sig-name descname"><span class="pre">completion_by_cuts</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.completion_by_cuts" title="Permalink to this definition">#</a></dt>
<dd><p>Return the completion by cuts of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This is the smallest lattice containing the poset. This is also
called the Dedekind-MacNeille completion.</p>
<p>See the <a class="reference external" href="https://en.wikipedia.org/wiki/Dedekind-MacNeille completion">Wikipedia article Dedekind-MacNeille completion</a>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>a finite lattice</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">completion_by_cuts</span><span class="p">()</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">trafficsign</span> <span class="o">=</span> <span class="n">LatticePoset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">completion_by_cuts</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">trafficsign</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">SymmetricGroupBruhatOrderPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">completion_by_cuts</span><span class="p">();</span> <span class="n">Q</span>
<span class="go">Finite lattice containing 7 elements</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.cuts" title="sage.combinat.posets.posets.FinitePoset.cuts"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cuts()</span></code></a>,
<a class="reference external" href="../../../../categories/sage/categories/finite_lattice_posets.html#sage.categories.finite_lattice_posets.FiniteLatticePosets.ParentMethods.irreducibles_poset" title="(in Category Framework v9.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">irreducibles_poset()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.connected_components">
<span class="sig-name descname"><span class="pre">connected_components</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.connected_components" title="Permalink to this definition">#</a></dt>
<dd><p>Return the connected components of the poset as subposets.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">parts</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">);</span> <span class="n">parts</span>
<span class="go">[Finite poset containing 3 elements,</span>
<span class="go"> Finite poset containing 5 elements]</span>
<span class="gp">sage: </span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[6, 7], [6, 8]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.disjoint_union" title="sage.combinat.posets.posets.FinitePoset.disjoint_union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">disjoint_union()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_connected" title="sage.combinat.posets.posets.FinitePoset.is_connected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_connected()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.cover_relations">
<span class="sig-name descname"><span class="pre">cover_relations</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.cover_relations" title="Permalink to this definition">#</a></dt>
<dd><p>Return the list of pairs <code class="docutils literal notranslate"><span class="pre">[x,</span> <span class="pre">y]</span></code> of elements of the poset such
that <code class="docutils literal notranslate"><span class="pre">y</span></code> covers <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [0, 2], [2, 3], [3, 4]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.cover_relations_graph">
<span class="sig-name descname"><span class="pre">cover_relations_graph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.cover_relations_graph" title="Permalink to this definition">#</a></dt>
<dd><p>Return the (undirected) graph of cover relations.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">cover_relations_graph</span><span class="p">();</span> <span class="n">G</span>
<span class="go">Graph on 4 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">(True, False)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.hasse_diagram" title="sage.combinat.posets.posets.FinitePoset.hasse_diagram"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hasse_diagram()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.cover_relations_iterator">
<span class="sig-name descname"><span class="pre">cover_relations_iterator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.cover_relations_iterator" title="Permalink to this definition">#</a></dt>
<dd><p>Return an iterator over the cover relations of the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations_iterator</span><span class="p">())</span>
<span class="go">&lt;class &#39;generator&#39;&gt;</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">z</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">cover_relations_iterator</span><span class="p">()]</span>
<span class="go">[[1, 2], [0, 2], [2, 3], [3, 4]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.covers">
<span class="sig-name descname"><span class="pre">covers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.covers" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">y</span></code> covers <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>Element <span class="math notranslate nohighlight">\(y\)</span> covers <span class="math notranslate nohighlight">\(x\)</span> if <span class="math notranslate nohighlight">\(x &lt; y\)</span> and there is no <span class="math notranslate nohighlight">\(z\)</span> such that
<span class="math notranslate nohighlight">\(x &lt; z &lt; y\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.coxeter_polynomial">
<span class="sig-name descname"><span class="pre">coxeter_polynomial</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.coxeter_polynomial" title="Permalink to this definition">#</a></dt>
<dd><p>Return the Coxeter polynomial of the poset.</p>
<p>OUTPUT:</p>
<p>a polynomial in one variable</p>
<p>The output is the characteristic polynomial of the Coxeter
transformation. This polynomial only depends on the derived
category of modules on the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">coxeter_polynomial</span><span class="p">()</span>
<span class="go">x^5 + x^4 + x + 1</span>

<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">SymmetricGroupWeakOrderPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">coxeter_polynomial</span><span class="p">()</span>
<span class="go">x^6 + x^5 - x^3 + x + 1</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.coxeter_transformation" title="sage.combinat.posets.posets.FinitePoset.coxeter_transformation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coxeter_transformation()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.coxeter_smith_form" title="sage.combinat.posets.posets.FinitePoset.coxeter_smith_form"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coxeter_smith_form()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.coxeter_smith_form">
<span class="sig-name descname"><span class="pre">coxeter_smith_form</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'singular'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.coxeter_smith_form" title="Permalink to this definition">#</a></dt>
<dd><p>Return the Smith normal form of <span class="math notranslate nohighlight">\(x\)</span> minus the Coxeter transformation
matrix.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – optional (default <code class="docutils literal notranslate"><span class="pre">'singular'</span></code>), possible
values are <code class="docutils literal notranslate"><span class="pre">'singular'</span></code>, <code class="docutils literal notranslate"><span class="pre">'sage'</span></code>, <code class="docutils literal notranslate"><span class="pre">'gap'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'pari'</span></code>, <code class="docutils literal notranslate"><span class="pre">'maple'</span></code>, <code class="docutils literal notranslate"><span class="pre">'magma'</span></code>, <code class="docutils literal notranslate"><span class="pre">'fricas'</span></code></p></li>
</ul>
<p>Beware that speed depends very much on the choice of
algorithm. Sage is rather slow, Singular is faster and Pari is
fast at least for small sizes.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>list of polynomials in one variable, each one dividing the next one</p></li>
</ul>
<p>The output list is a refinement of the characteristic polynomial of
the Coxeter transformation, which is its product. This list
of polynomials only depends on the derived category of modules
on the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">coxeter_smith_form</span><span class="p">()</span>
<span class="go">[1, 1, 1, 1, x^5 + x^4 + x + 1]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">prod</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">coxeter_smith_form</span><span class="p">())</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">coxeter_polynomial</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.coxeter_transformation" title="sage.combinat.posets.posets.FinitePoset.coxeter_transformation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coxeter_transformation()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">coxeter_matrix()</span></code></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.coxeter_transformation">
<span class="sig-name descname"><span class="pre">coxeter_transformation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.coxeter_transformation" title="Permalink to this definition">#</a></dt>
<dd><p>Return the Coxeter transformation of the poset.</p>
<p>OUTPUT:</p>
<p>a square matrix with integer coefficients</p>
<p>The output is the matrix of the Auslander-Reiten translation
acting on the Grothendieck group of the derived category of
modules on the poset, in the basis of simple
modules. This matrix is usually called the Coxeter
transformation.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">coxeter_transformation</span><span class="p">()</span>
<span class="go">[ 0  0  0  0 -1]</span>
<span class="go">[ 0  0  0  1 -1]</span>
<span class="go">[ 0  1  0  0 -1]</span>
<span class="go">[-1  1  1  0 -1]</span>
<span class="go">[-1  1  0  1 -1]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.coxeter_polynomial" title="sage.combinat.posets.posets.FinitePoset.coxeter_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coxeter_polynomial()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.coxeter_smith_form" title="sage.combinat.posets.posets.FinitePoset.coxeter_smith_form"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coxeter_smith_form()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.cuts">
<span class="sig-name descname"><span class="pre">cuts</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.cuts" title="Permalink to this definition">#</a></dt>
<dd><p>Return the list of cuts of the poset <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>A cut is a subset <span class="math notranslate nohighlight">\(A\)</span> of <code class="docutils literal notranslate"><span class="pre">self</span></code> such that the set of lower
bounds of the set of upper bounds of <span class="math notranslate nohighlight">\(A\)</span> is exactly <span class="math notranslate nohighlight">\(A\)</span>.</p>
<p>The cuts are computed here using the maximal independent sets in the
auxiliary graph defined as <span class="math notranslate nohighlight">\(P \times [0,1]\)</span> with an edge
from <span class="math notranslate nohighlight">\((x, 0)\)</span> to <span class="math notranslate nohighlight">\((y, 1)\)</span> if
and only if <span class="math notranslate nohighlight">\(x \not\geq_P y\)</span>. See the end of section 4 in <a class="reference internal" href="../../../../references/index.html#jrj94" id="id5"><span>[JRJ94]</span></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Pc</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">cuts</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Pc</span> <span class="c1"># random</span>
<span class="go">[frozenset({0}),</span>
<span class="go"> frozenset(),</span>
<span class="go"> frozenset({0, 1, 2}),</span>
<span class="go"> frozenset({2}),</span>
<span class="go"> frozenset({1})]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">Pc</span><span class="p">)</span>
<span class="go">[[], [0], [0, 1, 2], [1], [2]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.completion_by_cuts" title="sage.combinat.posets.posets.FinitePoset.completion_by_cuts"><code class="xref py py-meth docutils literal notranslate"><span class="pre">completion_by_cuts()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.degree_polynomial">
<span class="sig-name descname"><span class="pre">degree_polynomial</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.degree_polynomial" title="Permalink to this definition">#</a></dt>
<dd><p>Return the generating polynomial of degrees of vertices in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This is the sum</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\sum_{v \in P} x^{\operatorname{in}(v)} y^{\operatorname{out}(v)},\]</div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">in(v)</span></code> and <code class="docutils literal notranslate"><span class="pre">out(v)</span></code> are the number of incoming and
outgoing edges at vertex <span class="math notranslate nohighlight">\(v\)</span> in the Hasse diagram of <span class="math notranslate nohighlight">\(P\)</span>.</p>
<p>Because this polynomial is multiplicative for Cartesian
product of posets, it is useful to help see if the poset can
be isomorphic to a Cartesian product.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">degree_polynomial</span><span class="p">()</span>
<span class="go">x^2 + 3*x*y + y^2</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">degree_polynomial</span><span class="p">()</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">(x + y)^4</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.cardinality" title="sage.combinat.posets.posets.FinitePoset.cardinality"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cardinality()</span></code></a> for the value at <span class="math notranslate nohighlight">\((x, y) = (1, 1)\)</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.diamonds">
<span class="sig-name descname"><span class="pre">diamonds</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.diamonds" title="Permalink to this definition">#</a></dt>
<dd><p>Return the list of diamonds of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>A diamond is the following subgraph of the Hasse diagram:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">  z</span>
<span class="go"> / \</span>
<span class="go">x   y</span>
<span class="go"> \ /</span>
<span class="go">  w</span>
</pre></div>
</div>
<p>Thus each edge represents a cover relation in the Hasse diagram.
We represent this as the tuple <span class="math notranslate nohighlight">\((w, x, y, z)\)</span>.</p>
<p>OUTPUT:</p>
<p>A tuple with</p>
<ul class="simple">
<li><p>a list of all diamonds in the Hasse Diagram,</p></li>
<li><p>a boolean checking that every <span class="math notranslate nohighlight">\(w,x,y\)</span> that form a <code class="docutils literal notranslate"><span class="pre">V</span></code>, there is a
unique element <span class="math notranslate nohighlight">\(z\)</span>, which completes the diamond.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">diamonds</span><span class="p">()</span>
<span class="go">([(0, 1, 2, 3)], True)</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">YoungDiagramPoset</span><span class="p">(</span><span class="n">Partition</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">diamonds</span><span class="p">()</span>
<span class="go">([((0, 0), (0, 1), (1, 0), (1, 1)), ((1, 0), (1, 1), (2, 0), (2, 1))], False)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.dilworth_decomposition">
<span class="sig-name descname"><span class="pre">dilworth_decomposition</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.dilworth_decomposition" title="Permalink to this definition">#</a></dt>
<dd><p>Return a partition of the points into the minimal number of chains.</p>
<p>According to Dilworth’s theorem, the points of a poset can be
partitioned into <span class="math notranslate nohighlight">\(\alpha\)</span> chains, where <span class="math notranslate nohighlight">\(\alpha\)</span> is the cardinality of
its largest antichain. This method returns such a partition.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Dilworth%27s_theorem">Wikipedia article Dilworth%27s_theorem</a>.</p>
<p>ALGORITHM:</p>
<p>We build a bipartite graph in which a vertex <span class="math notranslate nohighlight">\(v\)</span> of the poset is
represented by two vertices <span class="math notranslate nohighlight">\(v^-,v^+\)</span>. For any two <span class="math notranslate nohighlight">\(u,v\)</span> such that
<span class="math notranslate nohighlight">\(u&lt;v\)</span> in the poset we add an edge <span class="math notranslate nohighlight">\(v^+u^-\)</span>.</p>
<p>A matching in this graph is equivalent to a partition of the poset
into chains: indeed, a chain <span class="math notranslate nohighlight">\(v_1...v_k\)</span> gives rise to the matching
<span class="math notranslate nohighlight">\(v_1^+v_2^-,v_2^+v_3^-,...\)</span>, and from a matching one can build the
union of chains.</p>
<p>According to Dilworth’s theorem, the number of chains is equal to
<span class="math notranslate nohighlight">\(\alpha\)</span> (the posets’ width).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">width</span><span class="p">()</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">dilworth_decomposition</span><span class="p">()</span>  <span class="c1"># random</span>
<span class="go">[[7, 6, 4], [11, 3], [12, 8, 0], [13, 9, 1], [14, 10, 2], [15, 5]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.level_sets" title="sage.combinat.posets.posets.FinitePoset.level_sets"><code class="xref py py-meth docutils literal notranslate"><span class="pre">level_sets()</span></code></a> to return elements grouped to antichains.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.dimension">
<span class="sig-name descname"><span class="pre">dimension</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">certificate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.dimension" title="Permalink to this definition">#</a></dt>
<dd><p>Return the dimension of the Poset.</p>
<p>The (Dushnik-Miller) dimension of a poset is the minimal
number of total orders so that the poset is their
“intersection”.  More precisely, the dimension of a poset
defined on a set <span class="math notranslate nohighlight">\(X\)</span> of points is the smallest integer <span class="math notranslate nohighlight">\(n\)</span>
such that there exist linear extensions <span class="math notranslate nohighlight">\(P_1,...,P_n\)</span> of <span class="math notranslate nohighlight">\(P\)</span>
satisfying:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[u\leq_P v\ \text{if and only if }\ \forall i, u\leq_{P_i} v\]</div>
</div>
<p>For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Order_dimension">Wikipedia article Order_dimension</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> (boolean; default:<code class="docutils literal notranslate"><span class="pre">False</span></code>) – whether to return an
integer (the dimension) or a certificate, i.e. a smallest set of
linear extensions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) Specify a Mixed Integer Linear Programming
(MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For
more information on MILP solvers and which default solver is used, see
the method
<a class="reference external" href="../../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Numerical Optimization v9.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a>
of the class
<a class="reference external" href="../../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Numerical Optimization v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – parameter for use with MILP solvers over an
inexact base ring; see <a class="reference external" href="../../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Numerical Optimization v9.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The speed of this function greatly improves when more efficient
MILP solvers (e.g. Gurobi, CPLEX) are installed. See
<a class="reference external" href="../../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Numerical Optimization v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a> for more information.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Prior to version 8.3 this returned only realizer with
<code class="docutils literal notranslate"><span class="pre">certificate=True</span></code>. Now it returns a pair having a realizer as
the second element. See <a class="reference external" href="https://trac.sagemath.org/25588">trac ticket #25588</a> for details.</p>
</div>
<p>ALGORITHM:</p>
<p>As explained <a class="reference internal" href="../../../../references/index.html#ft00" id="id6"><span>[FT00]</span></a>, the dimension of a poset is equal to the (weak)
chromatic number of a hypergraph. More precisely:</p>
<blockquote>
<div><p>Let <span class="math notranslate nohighlight">\(inc(P)\)</span> be the set of (ordered) pairs of incomparable elements
of <span class="math notranslate nohighlight">\(P\)</span>, i.e. all <span class="math notranslate nohighlight">\(uv\)</span> and <span class="math notranslate nohighlight">\(vu\)</span> such that <span class="math notranslate nohighlight">\(u\not \leq_P v\)</span> and <span class="math notranslate nohighlight">\(v\not
\leq_P u\)</span>. Any linear extension of <span class="math notranslate nohighlight">\(P\)</span> is a total order on <span class="math notranslate nohighlight">\(X\)</span> that
can be seen as the union of relations from <span class="math notranslate nohighlight">\(P\)</span> along with some
relations from <span class="math notranslate nohighlight">\(inc(P)\)</span>. Thus, the dimension of <span class="math notranslate nohighlight">\(P\)</span> is the smallest
number of linear extensions of <span class="math notranslate nohighlight">\(P\)</span> which <em>cover</em> all points of
<span class="math notranslate nohighlight">\(inc(P)\)</span>.</p>
<p>Consequently, <span class="math notranslate nohighlight">\(dim(P)\)</span> is equal to the chromatic number of the
hypergraph <span class="math notranslate nohighlight">\(\mathcal H_{inc}\)</span>, where <span class="math notranslate nohighlight">\(\mathcal H_{inc}\)</span> is the
hypergraph defined on <span class="math notranslate nohighlight">\(inc(P)\)</span> whose sets are all <span class="math notranslate nohighlight">\(S\subseteq
inc(P)\)</span> such that <span class="math notranslate nohighlight">\(P\cup S\)</span> is not acyclic.</p>
</div></blockquote>
<p>We solve this problem through a <a class="reference external" href="../../../../numerical/sage/numerical/mip.html#module-sage.numerical.mip" title="(in Numerical Optimization v9.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Mixed</span> <span class="pre">Integer</span> <span class="pre">Linear</span> <span class="pre">Program</span></code></a>.</p>
<p>The problem is known to be NP-complete.</p>
<p>EXAMPLES:</p>
<p>We create a poset, compute a set of linear extensions and check
that we get back the poset from them:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="p">[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">dim</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">dimension</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span>  <span class="c1"># random -- architecture-dependent</span>
<span class="go">[[0, 2, 4, 5, 1, 3, 6], [2, 5, 0, 1, 3, 4, 6], [0, 1, 2, 3, 5, 6, 4]]</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">(</span> <span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">all</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">l</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">L</span><span class="p">))</span> <span class="p">)</span> <span class="o">==</span> <span class="n">P</span>
<span class="go">True</span>
</pre></div>
</div>
<p>According to Schnyder’s theorem, the incidence poset (of
height 2) of a graph has dimension <span class="math notranslate nohighlight">\(\leq 3\)</span> if and only if
the graph is planar:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">({(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">):[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)}))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">3</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">({(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">):[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)}))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="c1"># not tested - around 4s with CPLEX</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.disjoint_union">
<span class="sig-name descname"><span class="pre">disjoint_union</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pairs'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.disjoint_union" title="Permalink to this definition">#</a></dt>
<dd><p>Return a poset isomorphic to disjoint union (also called direct
sum) of the poset with <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>The disjoint union of <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> is a poset that contains
every element and relation from both <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span>, and where
every element of <span class="math notranslate nohighlight">\(P\)</span> is incomparable to every element of <span class="math notranslate nohighlight">\(Q\)</span>.</p>
<p>Mathematically, it is only defined when <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> have no
common element; here we force that by giving them different
names in the resulting poset.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">other</span></code>, a poset.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">labels</span></code> - (defaults to ‘pairs’) If set to ‘pairs’, each
element <code class="docutils literal notranslate"><span class="pre">v</span></code> in this poset will be named <code class="docutils literal notranslate"><span class="pre">(0,v)</span></code> and each
element <code class="docutils literal notranslate"><span class="pre">u</span></code> in <code class="docutils literal notranslate"><span class="pre">other</span></code> will be named <code class="docutils literal notranslate"><span class="pre">(1,u)</span></code> in the
result. If set to ‘integers’, the elements of the result
will be relabeled with consecutive integers.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="s1">&#39;b&#39;</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="s1">&#39;d&#39;</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">P2</span><span class="p">);</span> <span class="n">P</span>
<span class="go">Finite poset containing 4 elements</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span>
<span class="go">[[(0, &#39;a&#39;), (0, &#39;b&#39;)], [(1, &#39;c&#39;), (1, &#39;d&#39;)]]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">P2</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="s1">&#39;integers&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[2, 3], [0, 1]]</span>

<span class="gp">sage: </span><span class="n">N5</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">();</span> <span class="n">N5</span>
<span class="go">Finite lattice containing 5 elements</span>
<span class="gp">sage: </span><span class="n">N5</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">N5</span><span class="p">)</span>  <span class="c1"># Union of lattices is not a lattice</span>
<span class="go">Finite poset containing 10 elements</span>
</pre></div>
</div>
<p>We show how to get literally direct sum with elements untouched:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">P2</span><span class="p">)</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span>
<span class="go">[[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.connected_components" title="sage.combinat.posets.posets.FinitePoset.connected_components"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connected_components()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.dual">
<span class="sig-name descname"><span class="pre">dual</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.dual" title="Permalink to this definition">#</a></dt>
<dd><p>Return the dual poset of the given poset.</p>
<p>In the dual of a poset <span class="math notranslate nohighlight">\(P\)</span> we have <span class="math notranslate nohighlight">\(x \le y\)</span> iff <span class="math notranslate nohighlight">\(y \le x\)</span> in <span class="math notranslate nohighlight">\(P\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [3, 4]]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[4, 3], [3, 1], [2, 1]]</span>
</pre></div>
</div>
<p>Dual of a lattice is a lattice; dual of a meet-semilattice is
join-semilattice and vice versa. Also the dual of a (non-)facade poset
is again (non-)facade:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">MeetSemilattice</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]},</span> <span class="n">facade</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">dual</span><span class="p">();</span> <span class="n">A</span>
<span class="go">Finite join-semilattice containing 3 elements</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="../../../../categories/sage/categories/finite_posets.html#sage.categories.finite_posets.FinitePosets.ParentMethods.is_self_dual" title="(in Category Framework v9.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_self_dual()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.evacuation">
<span class="sig-name descname"><span class="pre">evacuation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.evacuation" title="Permalink to this definition">#</a></dt>
<dd><p>Compute evacuation on the linear extension associated
to the poset <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>an isomorphic poset, with the same default linear extension</p></li>
</ul>
<p>Evacuation is defined on a poset <code class="docutils literal notranslate"><span class="pre">self</span></code> of size <span class="math notranslate nohighlight">\(n\)</span> by
applying the evacuation operator
<span class="math notranslate nohighlight">\((\tau_1 \cdots \tau_{n-1}) (\tau_1 \cdots \tau_{n-2}) \cdots (\tau_1)\)</span>,
to the default linear extension <span class="math notranslate nohighlight">\(\pi\)</span> of <code class="docutils literal notranslate"><span class="pre">self</span></code>
(see <a class="reference internal" href="linear_extensions.html#sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.evacuation" title="sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.evacuation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">evacuation()</span></code></a>),
and relabeling <code class="docutils literal notranslate"><span class="pre">self</span></code> accordingly. For more details see <a class="reference internal" href="../../../../references/index.html#stan2009" id="id7"><span>[Stan2009]</span></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]]),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">facade</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">evacuation</span><span class="p">()</span>
<span class="go">Finite poset containing 2 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">evacuation</span><span class="p">()</span> <span class="o">==</span> <span class="n">P</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">facade</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">evacuation</span><span class="p">();</span> <span class="n">Q</span>
<span class="go">Finite poset containing 7 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [2, 5], [3, 4], [3, 6], [4, 7], [6, 7]]</span>
</pre></div>
</div>
<p>Note that the results depend on the linear extension associated
to the poset:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 5, 6, 4, 7]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">evacuation</span><span class="p">();</span> <span class="n">Q</span>
<span class="go">Finite poset containing 7 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 5], [2, 3], [5, 6], [5, 4], [6, 7], [4, 7]]</span>
</pre></div>
</div>
<p>Here is an example of a poset where the elements are not labelled
by <span class="math notranslate nohighlight">\(\{1,2,\ldots,n\}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 3, 5, 15]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">evacuation</span><span class="p">();</span> <span class="n">Q</span>
<span class="go">Finite poset containing 4 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 3], [1, 5], [3, 15], [5, 15]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extension" title="sage.combinat.posets.posets.FinitePoset.linear_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">linear_extension()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.with_linear_extension" title="sage.combinat.posets.posets.FinitePoset.with_linear_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">with_linear_extension()</span></code></a> and the <code class="docutils literal notranslate"><span class="pre">linear_extension</span></code> option of <a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><code class="xref py py-func docutils literal notranslate"><span class="pre">Poset()</span></code></a></p></li>
<li><p><a class="reference internal" href="linear_extensions.html#sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.evacuation" title="sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.evacuation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">evacuation()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.promotion" title="sage.combinat.posets.posets.FinitePoset.promotion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">promotion()</span></code></a></p></li>
</ul>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li><p>Anne Schilling (2012-02-18)</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.f_polynomial">
<span class="sig-name descname"><span class="pre">f_polynomial</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.f_polynomial" title="Permalink to this definition">#</a></dt>
<dd><p>Return the <span class="math notranslate nohighlight">\(f\)</span>-polynomial of the poset.</p>
<p>The poset is expected to be bounded.</p>
<p>This is the <span class="math notranslate nohighlight">\(f\)</span>-polynomial of the order complex of the poset
minus its bounds.</p>
<p>The coefficient of <span class="math notranslate nohighlight">\(q^i\)</span> is the number of chains of
<span class="math notranslate nohighlight">\(i+1\)</span> elements containing both bounds of the poset.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is slightly different from the <code class="docutils literal notranslate"><span class="pre">fPolynomial</span></code>
method in Macaulay2.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">f_polynomial</span><span class="p">()</span>
<span class="go">3*q^2 + q</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">f_polynomial</span><span class="p">()</span>
<span class="go">q^4 + 4*q^3 + 5*q^2 + q</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="sage.combinat.posets.posets.FinitePoset.is_bounded"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_bounded()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.h_polynomial" title="sage.combinat.posets.posets.FinitePoset.h_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">h_polynomial()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_complex" title="sage.combinat.posets.posets.FinitePoset.order_complex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_complex()</span></code></a>,
<a class="reference external" href="../../../../topology/sage/topology/cell_complex.html#sage.topology.cell_complex.GenericCellComplex.f_vector" title="(in Topology v9.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.topology.cell_complex.GenericCellComplex.f_vector()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.factor">
<span class="sig-name descname"><span class="pre">factor</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.factor" title="Permalink to this definition">#</a></dt>
<dd><p>Factor the poset as a Cartesian product of smaller posets.</p>
<p>This only works for connected posets for the moment.</p>
<p>The decomposition of a connected poset as a Cartesian product
of posets (prime in the sense that they cannot be written as
Cartesian products) is unique up to reordering and
isomorphism.</p>
<p>OUTPUT:</p>
<p>a list of posets</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">P</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">[Finite poset containing 5 elements,</span>
<span class="go">Finite poset containing 5 elements]</span>

<span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P1</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">[Finite lattice containing 3 elements]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">P1</span> <span class="o">*</span> <span class="n">P2</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">[Finite poset containing 7 elements,</span>
<span class="go">Finite poset containing 3 elements]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">TamariLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">P</span><span class="o">*</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">[Finite poset containing 14 elements,</span>
<span class="go">Finite poset containing 14 elements]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.product" title="sage.combinat.posets.posets.FinitePoset.product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">product()</span></code></a></p>
</div>
<p>REFERENCES:</p>
<dl class="citation">
<dt class="label" id="feig1986"><span class="brackets">Feig1986</span></dt>
<dd><p>Joan Feigenbaum, <em>Directed Cartesian-Product Graphs
have Unique Factorizations that can be computed in Polynomial Time</em>,
Discrete Applied Mathematics 15 (1986) 105-110
<a class="reference external" href="https://doi.org/10.1016/0166-218X(86)90023-5">doi:10.1016/0166-218X(86)90023-5</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.flag_f_polynomial">
<span class="sig-name descname"><span class="pre">flag_f_polynomial</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.flag_f_polynomial" title="Permalink to this definition">#</a></dt>
<dd><p>Return the flag <span class="math notranslate nohighlight">\(f\)</span>-polynomial of the poset.</p>
<p>The poset is expected to be bounded and ranked.</p>
<p>This is the sum, over all chains containing both bounds,
of a monomial encoding the ranks of the elements of the chain.</p>
<p>More precisely, if <span class="math notranslate nohighlight">\(P\)</span> is a bounded ranked poset, then the
flag <span class="math notranslate nohighlight">\(f\)</span>-polynomial of <span class="math notranslate nohighlight">\(P\)</span> is defined as the polynomial</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\begin{split}\sum_{\substack{p_0 &lt; p_1 &lt; \ldots &lt; p_k, \\
                p_0 = \min P, \ p_k = \max P}}
x_{\rho(p_1)} x_{\rho(p_2)} \cdots x_{\rho(p_k)}
\in \ZZ[x_1, x_2, \cdots, x_n],\end{split}\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(\min P\)</span> and <span class="math notranslate nohighlight">\(\max P\)</span> are (respectively) the minimum and
the maximum of <span class="math notranslate nohighlight">\(P\)</span>, where <span class="math notranslate nohighlight">\(\rho\)</span> is the rank function of <span class="math notranslate nohighlight">\(P\)</span>
(normalized to satisfy <span class="math notranslate nohighlight">\(\rho(\min P) = 0\)</span>), and where
<span class="math notranslate nohighlight">\(n\)</span> is the rank of <span class="math notranslate nohighlight">\(\max P\)</span>. (Note that the indeterminate
<span class="math notranslate nohighlight">\(x_0\)</span> does not actually appear in the polynomial.)</p>
<p>For technical reasons, the polynomial is returned in the
slightly larger ring <span class="math notranslate nohighlight">\(\ZZ[x_0, x_1, x_2, \cdots, x_{n+1}]\)</span> by
this method.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/h-vector">Wikipedia article h-vector</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">flag_f_polynomial</span><span class="p">()</span>
<span class="go">3*x1*x2 + x2</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">fl</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">flag_f_polynomial</span><span class="p">();</span> <span class="n">fl</span>
<span class="go">2*x1*x2*x3 + 2*x1*x3 + 2*x2*x3 + x3</span>
<span class="gp">sage: </span><span class="n">q</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span><span class="s1">&#39;q&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fl</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="p">)</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">f_polynomial</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">flag_f_polynomial</span><span class="p">()</span>
<span class="go">3*x1*x2*x3 + 3*x1*x3 + x2*x3 + x3</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="sage.combinat.posets.posets.FinitePoset.is_bounded"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_bounded()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.flag_h_polynomial" title="sage.combinat.posets.posets.FinitePoset.flag_h_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flag_h_polynomial()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.flag_h_polynomial">
<span class="sig-name descname"><span class="pre">flag_h_polynomial</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.flag_h_polynomial" title="Permalink to this definition">#</a></dt>
<dd><p>Return the flag <span class="math notranslate nohighlight">\(h\)</span>-polynomial of the poset.</p>
<p>The poset is expected to be bounded and ranked.</p>
<p>If <span class="math notranslate nohighlight">\(P\)</span> is a bounded ranked poset whose maximal element has
rank <span class="math notranslate nohighlight">\(n\)</span> (where the minimal element is set to have rank <span class="math notranslate nohighlight">\(0\)</span>),
then the flag <span class="math notranslate nohighlight">\(h\)</span>-polynomial of <span class="math notranslate nohighlight">\(P\)</span> is defined as the
polynomial</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\prod_{k=1}^n (1-x_k) \cdot f \left(\frac{x_1}{1-x_1},
\frac{x_2}{1-x_2}, \cdots, \frac{x_n}{1-x_n}\right)
\in \ZZ[x_1, x_2, \cdots, x_n],\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(f\)</span> is the flag <span class="math notranslate nohighlight">\(f\)</span>-polynomial of <span class="math notranslate nohighlight">\(P\)</span> (see
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.flag_f_polynomial" title="sage.combinat.posets.posets.FinitePoset.flag_f_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flag_f_polynomial()</span></code></a>).</p>
<p>For technical reasons, the polynomial is returned in the
slightly larger ring <span class="math notranslate nohighlight">\(\QQ[x_0, x_1, x_2, \cdots, x_{n+1}]\)</span> by
this method.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/h-vector">Wikipedia article h-vector</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">flag_h_polynomial</span><span class="p">()</span>
<span class="go">2*x1*x2 + x2</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">fl</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">flag_h_polynomial</span><span class="p">();</span> <span class="n">fl</span>
<span class="go">-x1*x2*x3 + x1*x3 + x2*x3 + x3</span>
<span class="gp">sage: </span><span class="n">q</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span><span class="s1">&#39;q&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fl</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="p">)</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">h_polynomial</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">flag_h_polynomial</span><span class="p">()</span>
<span class="go">2*x1*x3 + x3</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">flag_h_polynomial</span><span class="p">()</span>
<span class="go">x3</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="sage.combinat.posets.posets.FinitePoset.is_bounded"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_bounded()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.flag_f_polynomial" title="sage.combinat.posets.posets.FinitePoset.flag_f_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flag_f_polynomial()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.frank_network">
<span class="sig-name descname"><span class="pre">frank_network</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.frank_network" title="Permalink to this definition">#</a></dt>
<dd><p>Return Frank’s network of the poset.</p>
<p>This is defined in Section 8 of <a class="reference internal" href="../../../../references/index.html#bf1999" id="id8"><span>[BF1999]</span></a>.</p>
<p>OUTPUT:</p>
<p>A pair <span class="math notranslate nohighlight">\((G, e)\)</span>, where <span class="math notranslate nohighlight">\(G\)</span> is Frank’s network of <span class="math notranslate nohighlight">\(P\)</span> encoded as a
<a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Graph Theory v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraph</span></code></a>, and <span class="math notranslate nohighlight">\(e\)</span> is the cost function on its edges encoded
as a dictionary (indexed by these edges, which in turn are encoded
as tuples of 2 vertices).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Frank’s network of <span class="math notranslate nohighlight">\(P\)</span> is a certain directed graph with <span class="math notranslate nohighlight">\(2|P| + 2\)</span>
vertices, defined in Section 8 of <a class="reference internal" href="../../../../references/index.html#bf1999" id="id9"><span>[BF1999]</span></a>. Its set of vertices
consists of two vertices <span class="math notranslate nohighlight">\((0, p)\)</span> and <span class="math notranslate nohighlight">\((1, p)\)</span> for each element
<span class="math notranslate nohighlight">\(p\)</span> of <span class="math notranslate nohighlight">\(P\)</span>, as well as two vertices <span class="math notranslate nohighlight">\((-1, 0)\)</span> and <span class="math notranslate nohighlight">\((2, 0)\)</span>.
(These notations are not the ones used in <a class="reference internal" href="../../../../references/index.html#bf1999" id="id10"><span>[BF1999]</span></a>; see the table
below for their relation.) The edges are:</p>
<ul class="simple">
<li><p>for each <span class="math notranslate nohighlight">\(p\)</span> in <span class="math notranslate nohighlight">\(P\)</span>, an edge from <span class="math notranslate nohighlight">\((-1, 0)\)</span> to <span class="math notranslate nohighlight">\((0, p)\)</span>;</p></li>
<li><p>for each <span class="math notranslate nohighlight">\(p\)</span> in <span class="math notranslate nohighlight">\(P\)</span>, an edge from <span class="math notranslate nohighlight">\((1, p)\)</span> to <span class="math notranslate nohighlight">\((2, 0)\)</span>;</p></li>
<li><p>for each <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(q\)</span> in <span class="math notranslate nohighlight">\(P\)</span> such that <span class="math notranslate nohighlight">\(p \geq q\)</span>, an edge from
<span class="math notranslate nohighlight">\((0, p)\)</span> to <span class="math notranslate nohighlight">\((1, q)\)</span>.</p></li>
</ul>
<p>We make this digraph into a network in the sense of flow theory as
follows: The vertex <span class="math notranslate nohighlight">\((-1, 0)\)</span> is considered as the source of this
network, and the vertex <span class="math notranslate nohighlight">\((2, 0)\)</span> as the sink. The cost function is
defined to be <span class="math notranslate nohighlight">\(1\)</span> on the edge from <span class="math notranslate nohighlight">\((0, p)\)</span> to <span class="math notranslate nohighlight">\((1, p)\)</span> for each
<span class="math notranslate nohighlight">\(p \in P\)</span>, and to be <span class="math notranslate nohighlight">\(0\)</span> on every other edge. The capacity is <span class="math notranslate nohighlight">\(1\)</span>
on each edge. Here is how to translate this notations into that
used in <a class="reference internal" href="../../../../references/index.html#bf1999" id="id11"><span>[BF1999]</span></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">our notations                    [BF1999]</span>
<span class="go">   (-1, 0)                          s</span>
<span class="go">   (0, p)                          x_p</span>
<span class="go">   (1, p)                          y_p</span>
<span class="go">   (2, 0)                           t</span>
<span class="go">    a[e]                           a(e)</span>
</pre></div>
</div>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ps</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">16</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="o">-</span><span class="mi">13</span><span class="p">],[[</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">],[</span><span class="mi">14</span><span class="p">,</span><span class="o">-</span><span class="mi">13</span><span class="p">],[</span><span class="mi">12</span><span class="p">,</span><span class="mi">16</span><span class="p">],[</span><span class="mi">16</span><span class="p">,</span><span class="o">-</span><span class="mi">13</span><span class="p">]]]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span><span class="o">.</span><span class="n">frank_network</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[((-1, 0), (0, -13), None), ((-1, 0), (0, 12), None), ((-1, 0), (0, 14), None), ((-1, 0), (0, 16), None), ((0, -13), (1, -13), None), ((0, -13), (1, 12), None), ((0, -13), (1, 14), None), ((0, -13), (1, 16), None), ((0, 12), (1, 12), None), ((0, 14), (1, 12), None), ((0, 14), (1, 14), None), ((0, 16), (1, 12), None), ((0, 16), (1, 16), None), ((1, -13), (2, 0), None), ((1, 12), (2, 0), None), ((1, 14), (2, 0), None), ((1, 16), (2, 0), None)]</span>
<span class="gp">sage: </span><span class="n">e</span>
<span class="go">{((-1, 0), (0, -13)): 0,</span>
<span class="go"> ((-1, 0), (0, 12)): 0,</span>
<span class="go"> ((-1, 0), (0, 14)): 0,</span>
<span class="go"> ((-1, 0), (0, 16)): 0,</span>
<span class="go"> ((0, -13), (1, -13)): 1,</span>
<span class="go"> ((0, -13), (1, 12)): 0,</span>
<span class="go"> ((0, -13), (1, 14)): 0,</span>
<span class="go"> ((0, -13), (1, 16)): 0,</span>
<span class="go"> ((0, 12), (1, 12)): 1,</span>
<span class="go"> ((0, 14), (1, 12)): 0,</span>
<span class="go"> ((0, 14), (1, 14)): 1,</span>
<span class="go"> ((0, 16), (1, 12)): 0,</span>
<span class="go"> ((0, 16), (1, 16)): 1,</span>
<span class="go"> ((1, -13), (2, 0)): 0,</span>
<span class="go"> ((1, 12), (2, 0)): 0,</span>
<span class="go"> ((1, 14), (2, 0)): 0,</span>
<span class="go"> ((1, 16), (2, 0)): 0}</span>
<span class="gp">sage: </span><span class="n">qs</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]]</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">(</span><span class="n">qs</span><span class="p">)</span><span class="o">.</span><span class="n">frank_network</span><span class="p">()</span>
<span class="go">(Digraph on 20 vertices,</span>
<span class="go"> {((-1, 0), (0, 1)): 0,</span>
<span class="go">  ((-1, 0), (0, 2)): 0,</span>
<span class="go">  ((-1, 0), (0, 3)): 0,</span>
<span class="go">  ((-1, 0), (0, 4)): 0,</span>
<span class="go">  ((-1, 0), (0, 5)): 0,</span>
<span class="go">  ((-1, 0), (0, 6)): 0,</span>
<span class="go">  ((-1, 0), (0, 7)): 0,</span>
<span class="go">  ((-1, 0), (0, 8)): 0,</span>
<span class="go">  ((-1, 0), (0, 9)): 0,</span>
<span class="go">  ((0, 1), (1, 1)): 1,</span>
<span class="go">  ((0, 2), (1, 2)): 1,</span>
<span class="go">  ((0, 3), (1, 1)): 0,</span>
<span class="go">  ((0, 3), (1, 2)): 0,</span>
<span class="go">  ((0, 3), (1, 3)): 1,</span>
<span class="go">  ((0, 4), (1, 1)): 0,</span>
<span class="go">  ((0, 4), (1, 2)): 0,</span>
<span class="go">  ((0, 4), (1, 3)): 0,</span>
<span class="go">  ((0, 4), (1, 4)): 1,</span>
<span class="go">  ((0, 5), (1, 5)): 1,</span>
<span class="go">  ((0, 6), (1, 6)): 1,</span>
<span class="go">  ((0, 7), (1, 5)): 0,</span>
<span class="go">  ((0, 7), (1, 7)): 1,</span>
<span class="go">  ((0, 8), (1, 8)): 1,</span>
<span class="go">  ((0, 9), (1, 1)): 0,</span>
<span class="go">  ((0, 9), (1, 9)): 1,</span>
<span class="go">  ((1, 1), (2, 0)): 0,</span>
<span class="go">  ((1, 2), (2, 0)): 0,</span>
<span class="go">  ((1, 3), (2, 0)): 0,</span>
<span class="go">  ((1, 4), (2, 0)): 0,</span>
<span class="go">  ((1, 5), (2, 0)): 0,</span>
<span class="go">  ((1, 6), (2, 0)): 0,</span>
<span class="go">  ((1, 7), (2, 0)): 0,</span>
<span class="go">  ((1, 8), (2, 0)): 0,</span>
<span class="go">  ((1, 9), (2, 0)): 0})</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li><p>Darij Grinberg (2013-05-09)</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.ge">
<span class="sig-name descname"><span class="pre">ge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.ge" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <span class="math notranslate nohighlight">\(x\)</span> is greater than or equal to <span class="math notranslate nohighlight">\(y\)</span> in the poset,
and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_greater_than" title="sage.combinat.posets.posets.FinitePoset.is_greater_than"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_greater_than()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_lequal" title="sage.combinat.posets.posets.FinitePoset.is_lequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_lequal()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.graphviz_string">
<span class="sig-name descname"><span class="pre">graphviz_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph_string</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'graph'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_string</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'--'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.graphviz_string" title="Permalink to this definition">#</a></dt>
<dd><p>Return a representation in the DOT language, ready to render in
graphviz.</p>
<p>See <a class="reference external" href="http://www.graphviz.org/doc/info/lang.html">http://www.graphviz.org/doc/info/lang.html</a> for more information
about graphviz.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;d&#39;</span><span class="p">],</span><span class="s1">&#39;c&#39;</span><span class="p">:[</span><span class="s1">&#39;d&#39;</span><span class="p">],</span><span class="s1">&#39;d&#39;</span><span class="p">:[</span><span class="s1">&#39;f&#39;</span><span class="p">],</span><span class="s1">&#39;e&#39;</span><span class="p">:[</span><span class="s1">&#39;f&#39;</span><span class="p">],</span><span class="s1">&#39;f&#39;</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">graphviz_string</span><span class="p">())</span>
<span class="go">graph {</span>
<span class="go">&quot;f&quot;;&quot;d&quot;;&quot;b&quot;;&quot;a&quot;;&quot;c&quot;;&quot;e&quot;;</span>
<span class="go">&quot;f&quot;--&quot;e&quot;;&quot;d&quot;--&quot;c&quot;;&quot;b&quot;--&quot;a&quot;;&quot;d&quot;--&quot;b&quot;;&quot;f&quot;--&quot;d&quot;;</span>
<span class="go">}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.greene_shape">
<span class="sig-name descname"><span class="pre">greene_shape</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.greene_shape" title="Permalink to this definition">#</a></dt>
<dd><p>Return the Greene-Kleitman partition of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The Greene-Kleitman partition of a finite poset <span class="math notranslate nohighlight">\(P\)</span> is the partition
<span class="math notranslate nohighlight">\((c_1 - c_0, c_2 - c_1, c_3 - c_2, \ldots)\)</span>, where <span class="math notranslate nohighlight">\(c_k\)</span> is the
maximum cardinality of a union of <span class="math notranslate nohighlight">\(k\)</span> chains of <span class="math notranslate nohighlight">\(P\)</span>. Equivalently,
this is the conjugate of the partition <span class="math notranslate nohighlight">\((a_1 - a_0, a_2 - a_1, a_3 -
a_2, \ldots)\)</span>, where <span class="math notranslate nohighlight">\(a_k\)</span> is the maximum cardinality of a union of
<span class="math notranslate nohighlight">\(k\)</span> antichains of <span class="math notranslate nohighlight">\(P\)</span>.</p>
<p>See many sources, e. g., <a class="reference internal" href="../../../../references/index.html#bf1999" id="id12"><span>[BF1999]</span></a>, for proofs of this equivalence.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">greene_shape</span><span class="p">()</span>
<span class="go">[2, 1]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">greene_shape</span><span class="p">()</span>
<span class="go">[3, 1]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">19</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">22</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">greene_shape</span><span class="p">()</span>
<span class="go">[3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[],[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">greene_shape</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li><p>Darij Grinberg (2013-05-09)</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.gt">
<span class="sig-name descname"><span class="pre">gt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.gt" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <span class="math notranslate nohighlight">\(x\)</span> is greater than but not equal to <span class="math notranslate nohighlight">\(y\)</span> in the
poset, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>For non-facade posets also <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> works:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]},</span> <span class="n">facade</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">P</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_gequal" title="sage.combinat.posets.posets.FinitePoset.is_gequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_gequal()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_less_than" title="sage.combinat.posets.posets.FinitePoset.is_less_than"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_less_than()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.h_polynomial">
<span class="sig-name descname"><span class="pre">h_polynomial</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.h_polynomial" title="Permalink to this definition">#</a></dt>
<dd><p>Return the <span class="math notranslate nohighlight">\(h\)</span>-polynomial of a bounded poset <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This is the <span class="math notranslate nohighlight">\(h\)</span>-polynomial of the order complex of the poset
minus its bounds.</p>
<p>This is related to the <span class="math notranslate nohighlight">\(f\)</span>-polynomial by a simple change
of variables:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[h(q) = (1-q)^{\deg f} f \left( \frac{q}{1-q} \right),\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(h\)</span> denote the <span class="math notranslate nohighlight">\(f\)</span>-polynomial and the
<span class="math notranslate nohighlight">\(h\)</span>-polynomial, respectively.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/h-vector">Wikipedia article h-vector</a>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is slightly different from the <code class="docutils literal notranslate"><span class="pre">hPolynomial</span></code>
method in Macaulay2.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">order_ideals_lattice</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">h_polynomial</span><span class="p">()</span>
<span class="go">q^3 + 4*q^2 + q</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">h_polynomial</span><span class="p">()</span>
<span class="go">2*q^2 + q</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">h_polynomial</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="sage.combinat.posets.posets.FinitePoset.is_bounded"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_bounded()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.f_polynomial" title="sage.combinat.posets.posets.FinitePoset.f_polynomial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">f_polynomial()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_complex" title="sage.combinat.posets.posets.FinitePoset.order_complex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_complex()</span></code></a>,
<a class="reference external" href="../../../../topology/sage/topology/simplicial_complex.html#sage.topology.simplicial_complex.SimplicialComplex.h_vector" title="(in Topology v9.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.topology.simplicial_complex.SimplicialComplex.h_vector()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.has_bottom">
<span class="sig-name descname"><span class="pre">has_bottom</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.has_bottom" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset has a unique minimal element, and
<code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">has_bottom</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">has_bottom</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p>Dual Property: <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_top" title="sage.combinat.posets.posets.FinitePoset.has_top"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_top()</span></code></a></p></li>
<li><p>Stronger properties: <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="sage.combinat.posets.posets.FinitePoset.is_bounded"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_bounded()</span></code></a></p></li>
<li><p>Other: <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.bottom" title="sage.combinat.posets.posets.FinitePoset.bottom"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bottom()</span></code></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.has_isomorphic_subposet">
<span class="sig-name descname"><span class="pre">has_isomorphic_subposet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.has_isomorphic_subposet" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset contains a subposet isomorphic to
<code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>By subposet we mean that there exist a set <code class="docutils literal notranslate"><span class="pre">X</span></code> of elements such
that <code class="docutils literal notranslate"><span class="pre">self.subposet(X)</span></code> is isomorphic to <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">other</span></code> – a finite poset</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">N5</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>

<span class="gp">sage: </span><span class="n">N5</span><span class="o">.</span><span class="n">has_isomorphic_subposet</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">N5</span><span class="o">.</span><span class="n">has_isomorphic_subposet</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="nb">len</span><span class="p">([</span><span class="n">P</span> <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">if</span> <span class="n">P</span><span class="o">.</span><span class="n">has_isomorphic_subposet</span><span class="p">(</span><span class="n">D</span><span class="p">)])</span>
<span class="go">11</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.has_top">
<span class="sig-name descname"><span class="pre">has_top</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.has_top" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset has a unique maximal element, and
<code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[],</span> <span class="mi">5</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">has_top</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">has_top</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p>Dual Property: <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_bottom" title="sage.combinat.posets.posets.FinitePoset.has_bottom"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_bottom()</span></code></a></p></li>
<li><p>Stronger properties: <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="sage.combinat.posets.posets.FinitePoset.is_bounded"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_bounded()</span></code></a></p></li>
<li><p>Other: <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.top" title="sage.combinat.posets.posets.FinitePoset.top"><code class="xref py py-meth docutils literal notranslate"><span class="pre">top()</span></code></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.hasse_diagram">
<span class="sig-name descname"><span class="pre">hasse_diagram</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.hasse_diagram" title="Permalink to this definition">#</a></dt>
<dd><p>Return the Hasse diagram of the poset as a Sage <a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Graph Theory v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraph</span></code></a>.</p>
<p>The Hasse diagram is a directed graph where vertices are the
elements of the poset and there is an edge from <span class="math notranslate nohighlight">\(u\)</span> to <span class="math notranslate nohighlight">\(v\)</span>
whenever <span class="math notranslate nohighlight">\(v\)</span> covers <span class="math notranslate nohighlight">\(u\)</span> in the poset.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">dot2tex</span></code> is installed, then this sets the Hasse diagram’s latex
options to use the <code class="docutils literal notranslate"><span class="pre">dot2tex</span></code> formatting.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DivisorLattice</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">hasse_diagram</span><span class="p">();</span> <span class="n">H</span>
<span class="go">Digraph on 6 vertices</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [2, 4], [2, 6], [3, 6], [4, 12], [6, 12]]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(1, 2), (1, 3), (2, 4), (2, 6), (3, 6), (4, 12), (6, 12)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.height">
<span class="sig-name descname"><span class="pre">height</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.height" title="Permalink to this definition">#</a></dt>
<dd><p>Return the height (number of elements in a longest chain) of the poset.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) whether to return
a certificate</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">certificate=True</span></code> return <code class="docutils literal notranslate"><span class="pre">(h,</span> <span class="pre">c)</span></code>, where <code class="docutils literal notranslate"><span class="pre">h</span></code> is the
height and <code class="docutils literal notranslate"><span class="pre">c</span></code> is a chain of maximum cardinality.
If <code class="docutils literal notranslate"><span class="pre">certificate=False</span></code> return only the height.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">height</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">height</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(4, [0, 2, 3, 4])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.incidence_algebra">
<span class="sig-name descname"><span class="pre">incidence_algebra</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'I'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.incidence_algebra" title="Permalink to this definition">#</a></dt>
<dd><p>Return the incidence algebra of <code class="docutils literal notranslate"><span class="pre">self</span></code> over <code class="docutils literal notranslate"><span class="pre">R</span></code>.</p>
<p>OUTPUT:</p>
<p>An instance of <a class="reference internal" href="incidence_algebras.html#sage.combinat.posets.incidence_algebras.IncidenceAlgebra" title="sage.combinat.posets.incidence_algebras.IncidenceAlgebra"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.posets.incidence_algebras.IncidenceAlgebra</span></code></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">incidence_algebra</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">Incidence algebra of Finite lattice containing 16 elements</span>
<span class="go"> over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.incomparability_graph">
<span class="sig-name descname"><span class="pre">incomparability_graph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.incomparability_graph" title="Permalink to this definition">#</a></dt>
<dd><p>Return the incomparability graph of the poset.</p>
<p>This is the complement of the comparability graph, i.e. an
undirected graph where vertices are the elements of the poset
and there is an edge between vertices if they are not
comparable in the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">incomparability_graph</span><span class="p">();</span> <span class="n">g</span>
<span class="go">Incomparability graph on 4 vertices</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">compare_elements</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.comparability_graph" title="sage.combinat.posets.posets.FinitePoset.comparability_graph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">comparability_graph()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.interval">
<span class="sig-name descname"><span class="pre">interval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.interval" title="Permalink to this definition">#</a></dt>
<dd><p>Return a list of the elements <span class="math notranslate nohighlight">\(z\)</span> such that <span class="math notranslate nohighlight">\(x \le z \le y\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – any element of the poset</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">y</span></code> – any element of the poset</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">uc</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[]]</span>
<span class="gp">sage: </span><span class="n">dag</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uc</span><span class="p">)),</span><span class="n">uc</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">dag</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">P</span><span class="p">,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">interval</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">dg</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="s2">&quot;a&quot;</span><span class="p">:[</span><span class="s2">&quot;b&quot;</span><span class="p">,</span><span class="s2">&quot;c&quot;</span><span class="p">],</span> <span class="s2">&quot;b&quot;</span><span class="p">:[</span><span class="s2">&quot;d&quot;</span><span class="p">],</span> <span class="s2">&quot;c&quot;</span><span class="p">:[</span><span class="s2">&quot;d&quot;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">dg</span><span class="p">,</span> <span class="n">facade</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">interval</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
<span class="go">[a, b, c, d]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.intervals_number">
<span class="sig-name descname"><span class="pre">intervals_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.intervals_number" title="Permalink to this definition">#</a></dt>
<dd><p>Return the number of relations in the poset.</p>
<p>A relation is a pair of elements <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> such that <span class="math notranslate nohighlight">\(x\leq y\)</span>
in the poset.</p>
<p>Relations are also often called intervals. The number of
intervals is the dimension of the incidence algebra.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">relations_number</span><span class="p">()</span>
<span class="go">13</span>

<span class="gp">sage: </span><span class="n">posets</span><span class="o">.</span><span class="n">TamariLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">relations_number</span><span class="p">()</span>
<span class="go">68</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_iterator" title="sage.combinat.posets.posets.FinitePoset.relations_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relations_iterator()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations" title="sage.combinat.posets.posets.FinitePoset.relations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relations()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.intervals_poset">
<span class="sig-name descname"><span class="pre">intervals_poset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.intervals_poset" title="Permalink to this definition">#</a></dt>
<dd><p>Return the natural partial order on the set of intervals of the poset.</p>
<p>OUTPUT:</p>
<p>a finite poset</p>
<p>The poset of intervals of a poset <span class="math notranslate nohighlight">\(P\)</span> has the set of intervals <span class="math notranslate nohighlight">\([x,y]\)</span>
in <span class="math notranslate nohighlight">\(P\)</span> as elements, endowed with the order relation defined by
<span class="math notranslate nohighlight">\([x_1,y_1] \leq [x_2,y_2]\)</span> if and only if <span class="math notranslate nohighlight">\(x_1 \leq x_2\)</span> and
<span class="math notranslate nohighlight">\(y_1 \leq y_2\)</span>.</p>
<p>This is also called <span class="math notranslate nohighlight">\(P\)</span> to the power <em>2</em>, meaning
the poset of poset-morphisms from the 2-chain to <span class="math notranslate nohighlight">\(P\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(P\)</span> is a lattice, the result is also a lattice.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">intervals_poset</span><span class="p">()</span>
<span class="go">Finite poset containing 3 elements</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">intervals_poset</span><span class="p">()</span>
<span class="go">Finite lattice containing 13 elements</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.is_EL_labelling">
<span class="sig-name descname"><span class="pre">is_EL_labelling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_raising_chains</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_EL_labelling" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">f</span></code> is an EL labelling of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>A labelling <span class="math notranslate nohighlight">\(f\)</span> of the edges of the Hasse diagram of a poset
is called an EL labelling (edge lexicographic labelling) if
for any two elements <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> with <span class="math notranslate nohighlight">\(u \leq v\)</span>,</p>
<blockquote>
<div><ul class="simple">
<li><p>there is a unique <span class="math notranslate nohighlight">\(f\)</span>-raising chain from <span class="math notranslate nohighlight">\(u\)</span> to <span class="math notranslate nohighlight">\(v\)</span> in
the Hasse diagram, and this chain is lexicographically
first among all chains from <span class="math notranslate nohighlight">\(u\)</span> to <span class="math notranslate nohighlight">\(v\)</span>.</p></li>
</ul>
</div></blockquote>
<p>For more details, see <a class="reference internal" href="../../../../references/index.html#bj1980" id="id13"><span>[Bj1980]</span></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">f</span></code> – a function taking two elements <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> in
<code class="docutils literal notranslate"><span class="pre">self</span></code> such that <code class="docutils literal notranslate"><span class="pre">b</span></code> covers <code class="docutils literal notranslate"><span class="pre">a</span></code> and returning elements
in a totally ordered set.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">return_raising_chains</span></code> (optional; default:<code class="docutils literal notranslate"><span class="pre">False</span></code>) if
<code class="docutils literal notranslate"><span class="pre">True</span></code>, returns the set of all raising chains in <code class="docutils literal notranslate"><span class="pre">self</span></code>,
if possible.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>Let us consider a Boolean poset:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)],[[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)],[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)],[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)],[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)]]],</span><span class="n">facade</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">label</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_EL_labelling</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_EL_labelling</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">return_raising_chains</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{((0, 0), (0, 1)): [1],</span>
<span class="go"> ((0, 0), (1, 0)): [0],</span>
<span class="go"> ((0, 0), (1, 1)): [0, 1],</span>
<span class="go"> ((0, 1), (1, 1)): [0],</span>
<span class="go"> ((1, 0), (1, 1)): [1]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.is_antichain_of_poset">
<span class="sig-name descname"><span class="pre">is_antichain_of_poset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elms</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_antichain_of_poset" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">elms</span></code> is an antichain of the poset
and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>Set of elements are an <em>antichain</em> of a poset if they are
pairwise incomparable.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_antichain_of_poset</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_antichain_of_poset</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">14</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.is_bounded">
<span class="sig-name descname"><span class="pre">is_bounded</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is bounded, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>A poset is bounded if it contains both a unique maximal element
and a unique minimal element.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[],</span> <span class="mi">5</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_bounded</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_bounded</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p>Weaker properties: <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_bottom" title="sage.combinat.posets.posets.FinitePoset.has_bottom"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_bottom()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_top" title="sage.combinat.posets.posets.FinitePoset.has_top"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_top()</span></code></a></p></li>
<li><p>Other: <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.with_bounds" title="sage.combinat.posets.posets.FinitePoset.with_bounds"><code class="xref py py-meth docutils literal notranslate"><span class="pre">with_bounds()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.without_bounds" title="sage.combinat.posets.posets.FinitePoset.without_bounds"><code class="xref py py-meth docutils literal notranslate"><span class="pre">without_bounds()</span></code></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.is_chain">
<span class="sig-name descname"><span class="pre">is_chain</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_chain" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is totally ordered (“chain”), and
<code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">is_chain</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">II</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">II</span><span class="o">.</span><span class="n">is_chain</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">is_chain</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.is_chain_of_poset">
<span class="sig-name descname"><span class="pre">is_chain_of_poset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ordered</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_chain_of_poset" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">elms</span></code> is a chain of the poset,
and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>Set of elements are a <em>chain</em> of a poset if they are comparable
to each other.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">elms</span></code> – a list or other iterable containing some elements
of the poset</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ordered</span></code> – a Boolean. If <code class="docutils literal notranslate"><span class="pre">True</span></code>, then return <code class="docutils literal notranslate"><span class="pre">True</span></code>
only if elements in <code class="docutils literal notranslate"><span class="pre">elms</span></code> are strictly increasing in the
poset; this makes no sense if <code class="docutils literal notranslate"><span class="pre">elms</span></code> is a set. If <code class="docutils literal notranslate"><span class="pre">False</span></code>
(the default), then elements can be repeated and be in any
order.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">([</span><span class="mi">12</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">({</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">12</span><span class="p">})</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">([</span><span class="mi">12</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">ordered</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">ordered</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">ordered</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.is_connected">
<span class="sig-name descname"><span class="pre">is_connected</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_connected" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is connected, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>A poset is connected if its Hasse diagram is connected.</p>
<p>If a poset is not connected, then it can be divided to parts
<span class="math notranslate nohighlight">\(S_1\)</span> and <span class="math notranslate nohighlight">\(S_2\)</span> so that every element of <span class="math notranslate nohighlight">\(S_1\)</span> is incomparable to
every element of <span class="math notranslate nohighlight">\(S_2\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">6</span><span class="p">:[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.connected_components" title="sage.combinat.posets.posets.FinitePoset.connected_components"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connected_components()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.is_d_complete">
<span class="sig-name descname"><span class="pre">is_d_complete</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_d_complete" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if a poset is d-complete and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="d_complete.html#module-sage.combinat.posets.d_complete" title="sage.combinat.posets.d_complete"><code class="xref py py-mod docutils literal notranslate"><span class="pre">d_complete</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.posets.posets</span> <span class="kn">import</span> <span class="n">FinitePoset</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_d_complete</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.posets.poset_examples</span> <span class="kn">import</span> <span class="n">Posets</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">DoubleTailedDiamond</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_d_complete</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">is_d_complete</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">is_d_complete</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">YoungDiagramPoset</span><span class="p">(</span><span class="n">Partition</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">dual</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_d_complete</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.is_eulerian">
<span class="sig-name descname"><span class="pre">is_eulerian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_eulerian" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is Eulerian, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>The poset is expected to be graded and bounded.</p>
<p>A poset is Eulerian if every non-trivial interval has the same
number of elements of even rank as of odd rank. A poset is
<span class="math notranslate nohighlight">\(k\)</span>-eulerian if every non-trivial interval up to rank <span class="math notranslate nohighlight">\(k\)</span>
is Eulerian.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Eulerian_poset">Wikipedia article Eulerian_poset</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code>, an integer – only check if the poset is <span class="math notranslate nohighlight">\(k\)</span>-eulerian.
If <code class="docutils literal notranslate"><span class="pre">None</span></code> (the default), check if the poset is Eulerian.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code>, a Boolean – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) whether to return
a certificate</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">certificate=True</span></code> return either <code class="docutils literal notranslate"><span class="pre">True,</span> <span class="pre">None</span></code> or
<code class="docutils literal notranslate"><span class="pre">False,</span> <span class="pre">(a,</span> <span class="pre">b)</span></code>, where the interval <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span></code> is not
Eulerian. If <code class="docutils literal notranslate"><span class="pre">certificate=False</span></code> return <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">....: </span>           <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="mi">7</span><span class="p">:</span> <span class="p">[</span><span class="mi">9</span><span class="p">],</span> <span class="mi">8</span><span class="p">:</span> <span class="p">[</span><span class="mi">9</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span>
<span class="gp">....: </span>           <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">6</span><span class="p">:[</span><span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Canonical examples of Eulerian posets are the face lattices of
convex polytopes:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">polytopes</span><span class="o">.</span><span class="n">cube</span><span class="p">()</span><span class="o">.</span><span class="n">face_lattice</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A poset that is 3- but not 4-eulerian:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">(</span><span class="s1">&#39;MWW@_?W?@_?W??@??O@_?W?@_?W?@??O??&#39;</span><span class="p">));</span> <span class="n">P</span>
<span class="go">Finite poset containing 14 elements</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Getting an interval that is not Eulerian:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DivisorLattice</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(False, (1, 4))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.is_gequal">
<span class="sig-name descname"><span class="pre">is_gequal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_gequal" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <span class="math notranslate nohighlight">\(x\)</span> is greater than or equal to <span class="math notranslate nohighlight">\(y\)</span> in the poset,
and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_greater_than" title="sage.combinat.posets.posets.FinitePoset.is_greater_than"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_greater_than()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_lequal" title="sage.combinat.posets.posets.FinitePoset.is_lequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_lequal()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.is_graded">
<span class="sig-name descname"><span class="pre">is_graded</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_graded" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is graded, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>A poset is graded if all its maximal chains have the same length.</p>
<p>There are various competing definitions for graded
posets (see <a class="reference external" href="https://en.wikipedia.org/wiki/Graded_poset">Wikipedia article Graded_poset</a>). This definition is from
section 3.1 of Richard Stanley’s <em>Enumerative Combinatorics,
Vol. 1</em> <a class="reference internal" href="../../../../references/index.html#enumcomb1" id="id14"><span>[EnumComb1]</span></a>. Some sources call these posets <em>tiered</em>.</p>
<p>Every graded poset is ranked. The converse is true
for bounded posets, including lattices.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>  <span class="c1"># Not even ranked</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_graded</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>  <span class="c1"># Ranked, but not graded</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_graded</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_graded</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_graded</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_ranked" title="sage.combinat.posets.posets.FinitePoset.is_ranked"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_ranked()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.level_sets" title="sage.combinat.posets.posets.FinitePoset.level_sets"><code class="xref py py-meth docutils literal notranslate"><span class="pre">level_sets()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.is_greater_than">
<span class="sig-name descname"><span class="pre">is_greater_than</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_greater_than" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <span class="math notranslate nohighlight">\(x\)</span> is greater than but not equal to <span class="math notranslate nohighlight">\(y\)</span> in the
poset, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>For non-facade posets also <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> works:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]},</span> <span class="n">facade</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">P</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_gequal" title="sage.combinat.posets.posets.FinitePoset.is_gequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_gequal()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_less_than" title="sage.combinat.posets.posets.FinitePoset.is_less_than"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_less_than()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.is_greedy">
<span class="sig-name descname"><span class="pre">is_greedy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_greedy" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is greedy, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>A poset is <em>greedy</em> if every greedy linear extension
has the same number of jumps.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) whether to return
a certificate</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">certificate=True</span></code> return either <code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">None)</span></code> or
<code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">(A,</span> <span class="pre">B))</span></code> where <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are greedy linear extension
so that <span class="math notranslate nohighlight">\(B\)</span> has more jumps. If <code class="docutils literal notranslate"><span class="pre">certificate=False</span></code> return
<code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>This is not a self-dual property:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">W</span><span class="o">.</span><span class="n">is_greedy</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">is_greedy</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Getting a certificate:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">is_greedy</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(False, ([1, 2, 4, 3], [2, 4, 1, 3]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.is_incomparable_chain_free">
<span class="sig-name descname"><span class="pre">is_incomparable_chain_free</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_incomparable_chain_free" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is <span class="math notranslate nohighlight">\((m+n)\)</span>-free, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>A poset is <span class="math notranslate nohighlight">\((m+n)\)</span>-free if there is no incomparable chains of
lengths <span class="math notranslate nohighlight">\(m\)</span> and <span class="math notranslate nohighlight">\(n\)</span>. Three cases have special name
(see <a class="reference internal" href="../../../../references/index.html#enumcomb1" id="id15"><span>[EnumComb1]</span></a>, exercise 3.15):</p>
<ul class="simple">
<li><p>‘’interval order’’ is <span class="math notranslate nohighlight">\((2+2)\)</span>-free</p></li>
<li><p>‘’semiorder’’ (or ‘’unit interval order’’) is <span class="math notranslate nohighlight">\((1+3)\)</span>-free and
<span class="math notranslate nohighlight">\((2+2)\)</span>-free</p></li>
<li><p>‘’weak order’’ is <span class="math notranslate nohighlight">\((1+2)\)</span>-free.</p></li>
</ul>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code> - positive integers</p></li>
</ul>
<p>It is also possible to give a list of integer pairs as argument.
See below for an example.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B3</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B3</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B3</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">IP6</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">IntegerPartitions</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">IP6</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">IP6</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A list of pairs as an argument:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B3</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We show how to get an incomparable chain pair:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">chains_1_2</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">incomps</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">isomorphic_subposets</span><span class="p">(</span><span class="n">chains_1_2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">incomps</span><span class="o">.</span><span class="n">list</span><span class="p">()),</span> <span class="n">incomps</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">([1, 2, 3], [[2, 3]])</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li><p>Eric Rowland (2013-05-28)</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.is_induced_subposet">
<span class="sig-name descname"><span class="pre">is_induced_subposet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_induced_subposet" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is an induced subposet of <code class="docutils literal notranslate"><span class="pre">other</span></code>, and
<code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>A poset <span class="math notranslate nohighlight">\(P\)</span> is an induced subposet of <span class="math notranslate nohighlight">\(Q\)</span> if every element
of <span class="math notranslate nohighlight">\(P\)</span> is an element of <span class="math notranslate nohighlight">\(Q\)</span>, and <span class="math notranslate nohighlight">\(x \le_P y\)</span> iff <span class="math notranslate nohighlight">\(x \le_Q y\)</span>.
Note that “induced” here has somewhat different meaning compared
to that of graphs.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">other</span></code>, a poset.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method does not check whether the poset is a
<em>isomorphic</em> (i.e., up to relabeling) subposet of <code class="docutils literal notranslate"><span class="pre">other</span></code>,
but only if <code class="docutils literal notranslate"><span class="pre">other</span></code> directly contains the poset as an
induced subposet. For isomorphic subposets see
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_isomorphic_subposet" title="sage.combinat.posets.posets.FinitePoset.has_isomorphic_subposet"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_isomorphic_subposet()</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_induced_subposet</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_induced_subposet</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.is_isomorphic">
<span class="sig-name descname"><span class="pre">is_isomorphic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_isomorphic" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if both posets are isomorphic.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.is_join_semilattice">
<span class="sig-name descname"><span class="pre">is_join_semilattice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_join_semilattice" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset has a join operation, and <code class="docutils literal notranslate"><span class="pre">False</span></code>
otherwise.</p>
<p>A join is the least upper bound for given elements, if it exists.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) whether to return
a certificate</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">certificate=True</span></code> return either <code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">None)</span></code> or
<code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">(a,</span> <span class="pre">b))</span></code> where elements <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> have no
least upper bound. If <code class="docutils literal notranslate"><span class="pre">certificate=False</span></code> return
<code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="p">[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_join_semilattice</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_join_semilattice</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_join_semilattice</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(False, (2, 1))</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p>Dual property: <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_meet_semilattice" title="sage.combinat.posets.posets.FinitePoset.is_meet_semilattice"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_meet_semilattice()</span></code></a></p></li>
<li><p>Stronger properties: <a class="reference external" href="../../../../categories/sage/categories/finite_posets.html#sage.categories.finite_posets.FinitePosets.ParentMethods.is_lattice" title="(in Category Framework v9.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_lattice()</span></code></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.is_jump_critical">
<span class="sig-name descname"><span class="pre">is_jump_critical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_jump_critical" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is jump-critical, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>A poset <span class="math notranslate nohighlight">\(P\)</span> is <em>jump-critical</em> if every proper subposet has smaller
jump number.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) whether to return
a certificate</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">certificate=True</span></code> return either <code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">None)</span></code> or
<code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">e)</span></code> so that removing element <span class="math notranslate nohighlight">\(e\)</span> from the poset does not
decrease the jump number. If <code class="docutils literal notranslate"><span class="pre">certificate=False</span></code> return
<code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_jump_critical</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_jump_critical</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_jump_critical</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(False, 3)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.jump_number" title="sage.combinat.posets.posets.FinitePoset.jump_number"><code class="xref py py-meth docutils literal notranslate"><span class="pre">jump_number()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.is_lequal">
<span class="sig-name descname"><span class="pre">is_lequal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_lequal" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <span class="math notranslate nohighlight">\(x\)</span> is less than or equal to <span class="math notranslate nohighlight">\(y\)</span> in the poset, and
<code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_less_than" title="sage.combinat.posets.posets.FinitePoset.is_less_than"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_less_than()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_gequal" title="sage.combinat.posets.posets.FinitePoset.is_gequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_gequal()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.is_less_than">
<span class="sig-name descname"><span class="pre">is_less_than</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_less_than" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <span class="math notranslate nohighlight">\(x\)</span> is less than but not equal to <span class="math notranslate nohighlight">\(y\)</span> in the poset,
and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>For non-facade posets also <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> works:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]},</span> <span class="n">facade</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_lequal" title="sage.combinat.posets.posets.FinitePoset.is_lequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_lequal()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_greater_than" title="sage.combinat.posets.posets.FinitePoset.is_greater_than"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_greater_than()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.is_linear_extension">
<span class="sig-name descname"><span class="pre">is_linear_extension</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_linear_extension" title="Permalink to this definition">#</a></dt>
<dd><p>Return whether <code class="docutils literal notranslate"><span class="pre">l</span></code> is a linear extension of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">l</span></code> – a list (or iterable) containing all of the elements of <code class="docutils literal notranslate"><span class="pre">self</span></code> exactly once</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">linear_extension</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Permutations</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">))</span> <span class="k">if</span> <span class="n">P</span><span class="o">.</span><span class="n">is_linear_extension</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
<span class="go">[[1, 2, 3, 4, 6, 12],</span>
<span class="go"> [1, 2, 3, 6, 4, 12],</span>
<span class="go"> [1, 2, 4, 3, 6, 12],</span>
<span class="go"> [1, 3, 2, 4, 6, 12],</span>
<span class="go"> [1, 3, 2, 6, 4, 12]]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">linear_extensions</span><span class="p">())</span>
<span class="go">[[1, 2, 3, 4, 6, 12],</span>
<span class="go"> [1, 2, 4, 3, 6, 12],</span>
<span class="go"> [1, 3, 2, 4, 6, 12],</span>
<span class="go"> [1, 3, 2, 6, 4, 12],</span>
<span class="go"> [1, 2, 3, 6, 4, 12]]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is used and systematically tested in
<code class="xref py py-class docutils literal notranslate"><span class="pre">LinearExtensionsOfPosets</span></code></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extension" title="sage.combinat.posets.posets.FinitePoset.linear_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">linear_extension()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extensions" title="sage.combinat.posets.posets.FinitePoset.linear_extensions"><code class="xref py py-meth docutils literal notranslate"><span class="pre">linear_extensions()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.is_linear_interval">
<span class="sig-name descname"><span class="pre">is_linear_interval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_linear_interval" title="Permalink to this definition">#</a></dt>
<dd><p>Return whether the interval <code class="docutils literal notranslate"><span class="pre">[x,</span> <span class="pre">y]</span></code> is linear.</p>
<p>This means that this interval is a total order.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_linear_interval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_linear_interval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_linear_interval</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.is_meet_semilattice">
<span class="sig-name descname"><span class="pre">is_meet_semilattice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_meet_semilattice" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset has a meet operation, and
<code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>A meet is the greatest lower bound for given elements, if it exists.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) whether to return
a certificate</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">certificate=True</span></code> return either <code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">None)</span></code> or
<code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">(a,</span> <span class="pre">b))</span></code> where elements <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> have no
greatest lower bound. If <code class="docutils literal notranslate"><span class="pre">certificate=False</span></code> return
<code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_meet_semilattice</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_meet_semilattice</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">IntegerPartitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">is_meet_semilattice</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(False, ((2, 2, 1), (3, 1, 1)))</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p>Dual property: <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_join_semilattice" title="sage.combinat.posets.posets.FinitePoset.is_join_semilattice"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_join_semilattice()</span></code></a></p></li>
<li><p>Stronger properties: <a class="reference external" href="../../../../categories/sage/categories/finite_posets.html#sage.categories.finite_posets.FinitePosets.ParentMethods.is_lattice" title="(in Category Framework v9.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_lattice()</span></code></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.is_parent_of">
<span class="sig-name descname"><span class="pre">is_parent_of</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_parent_of" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">x</span></code> is an element of the poset.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.is_rank_symmetric">
<span class="sig-name descname"><span class="pre">is_rank_symmetric</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_rank_symmetric" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is rank symmetric, and <code class="docutils literal notranslate"><span class="pre">False</span></code>
otherwise.</p>
<p>The poset is expected to be graded and connected.</p>
<p>A poset of rank <span class="math notranslate nohighlight">\(h\)</span> (maximal chains have <span class="math notranslate nohighlight">\(h+1\)</span> elements) is rank
symmetric if the number of elements are equal in ranks <span class="math notranslate nohighlight">\(i\)</span> and
<span class="math notranslate nohighlight">\(h-i\)</span> for every <span class="math notranslate nohighlight">\(i\)</span> in <span class="math notranslate nohighlight">\(0, 1, \ldots, h\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_rank_symmetric</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_rank_symmetric</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.is_ranked">
<span class="sig-name descname"><span class="pre">is_ranked</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_ranked" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is ranked, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>A poset is ranked if there is a function <span class="math notranslate nohighlight">\(r\)</span> from  poset elements
to integers so that <span class="math notranslate nohighlight">\(r(x)=r(y)+1\)</span> when <span class="math notranslate nohighlight">\(x\)</span> covers <span class="math notranslate nohighlight">\(y\)</span>.</p>
<p>Informally said a ranked poset can be “levelized”: every element is
on a “level”, and every cover relation goes only one level up.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span> <span class="p">))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_ranked</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],[],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_ranked</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.rank_function" title="sage.combinat.posets.posets.FinitePoset.rank_function"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rank_function()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.rank" title="sage.combinat.posets.posets.FinitePoset.rank"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rank()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_graded" title="sage.combinat.posets.posets.FinitePoset.is_graded"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_graded()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.is_series_parallel">
<span class="sig-name descname"><span class="pre">is_series_parallel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_series_parallel" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is series-parallel, and <code class="docutils literal notranslate"><span class="pre">False</span></code>
otherwise.</p>
<p>A poset is <em>series-parallel</em> if it can be built up from one-element
posets using the operations of disjoint union and ordinal
sum. This is also called <em>N-free</em> property: every poset that is not
series-parallel contains a subposet isomorphic to the 4-element
N-shaped poset where <span class="math notranslate nohighlight">\(a &gt; c, d\)</span> and <span class="math notranslate nohighlight">\(b &gt; d\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Some papers use the term N-free for posets having no
N-shaped poset as a <em>cover-preserving subposet</em>. This definition
is not used here.</p>
</div>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Series-parallel partial order">Wikipedia article Series-parallel partial order</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">VA</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">VA</span><span class="o">.</span><span class="n">is_series_parallel</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">big_N</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">6</span><span class="p">:[</span><span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">big_N</span><span class="o">.</span><span class="n">is_series_parallel</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.is_slender">
<span class="sig-name descname"><span class="pre">is_slender</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_slender" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is slender, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>A finite graded poset is <em>slender</em> if every rank 2
interval contains three or four elements, as defined in
<a class="reference internal" href="../../../../references/index.html#stan2009" id="id16"><span>[Stan2009]</span></a>. (This notion of “slender” is unrelated to
the eponymous notion defined by Graetzer and Kelly in
“The Free <span class="math notranslate nohighlight">\(\mathfrak{m}\)</span>-Lattice on the Poset <span class="math notranslate nohighlight">\(H\)</span>”,
Order 1 (1984), 47–65.)</p>
<p>This function <em>does not</em> check if the poset is graded or not.
Instead it just returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset does not contain
5 distinct elements <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>, <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b\)</span> and <span class="math notranslate nohighlight">\(c\)</span> such that
<span class="math notranslate nohighlight">\(x \lessdot a,b,c \lessdot y\)</span> where <span class="math notranslate nohighlight">\(\lessdot\)</span> is the covering
relation.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) whether to return
a certificate</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">certificate=True</span></code> return either <code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">None)</span></code> or
<code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">(a,</span> <span class="pre">b))</span></code> so that the interval <span class="math notranslate nohighlight">\([a, b]\)</span> has at
least five elements. If <code class="docutils literal notranslate"><span class="pre">certificate=False</span></code> return
<code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_slender</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_slender</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">WeylGroup</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">bruhat_poset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_slender</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">WeylGroup</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">bruhat_poset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_slender</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">IntegerPartitions</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_slender</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(False, ((6,), (3, 2, 1)))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.is_sperner">
<span class="sig-name descname"><span class="pre">is_sperner</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_sperner" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the poset is Sperner, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>The poset is expected to be ranked.</p>
<p>A poset is Sperner, if no antichain is larger than the largest
rank level (one of the sets of elements of the same rank) in
the poset.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Sperner_property_of_a_partially_ordered_set">Wikipedia article Sperner_property_of_a_partially_ordered_set</a></p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.width" title="sage.combinat.posets.posets.FinitePoset.width"><code class="xref py py-meth docutils literal notranslate"><span class="pre">width()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.dilworth_decomposition" title="sage.combinat.posets.posets.FinitePoset.dilworth_decomposition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dilworth_decomposition()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">posets</span><span class="o">.</span><span class="n">SetPartitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">is_sperner</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_sperner</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets">
<span class="sig-name descname"><span class="pre">isomorphic_subposets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets" title="Permalink to this definition">#</a></dt>
<dd><p>Return a list of subposets of <code class="docutils literal notranslate"><span class="pre">self</span></code> isomorphic to <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>By subposet we mean <code class="docutils literal notranslate"><span class="pre">self.subposet(X)</span></code> which is isomorphic to
<code class="docutils literal notranslate"><span class="pre">other</span></code> and where <code class="docutils literal notranslate"><span class="pre">X</span></code> is a subset of elements of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">other</span></code> – a finite poset</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C2</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">C3</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">C3</span><span class="o">.</span><span class="n">isomorphic_subposets</span><span class="p">(</span><span class="n">C2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">L</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[[&#39;a&#39;, &#39;b&#39;]]</span>
<span class="go">[[&#39;a&#39;, &#39;c&#39;]]</span>
<span class="go">[[&#39;b&#39;, &#39;c&#39;]]</span>

<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">N5</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">N5</span><span class="o">.</span><span class="n">isomorphic_subposets</span><span class="p">(</span><span class="n">D</span><span class="p">))</span>
<span class="go">2</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If this function takes too much time, try using
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator" title="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isomorphic_subposets_iterator()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator">
<span class="sig-name descname"><span class="pre">isomorphic_subposets_iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator" title="Permalink to this definition">#</a></dt>
<dd><p>Return an iterator over the subposets of <code class="docutils literal notranslate"><span class="pre">self</span></code> isomorphic to
<code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>By subposet we mean <code class="docutils literal notranslate"><span class="pre">self.subposet(X)</span></code> which is isomorphic
to <code class="docutils literal notranslate"><span class="pre">other</span></code> and where <code class="docutils literal notranslate"><span class="pre">X</span></code> is a subset of elements of
<code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">other</span></code> – a finite poset</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">N5</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">N5</span><span class="o">.</span><span class="n">isomorphic_subposets_iterator</span><span class="p">(</span><span class="n">D</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span>
<span class="go">[[0, 1], [0, 2], [1, 4], [2, 4]]</span>
<span class="go">[[0, 1], [0, 3], [1, 4], [3, 4]]</span>
<span class="go">[[0, 1], [0, 2], [1, 4], [2, 4]]</span>
<span class="go">[[0, 1], [0, 3], [1, 4], [3, 4]]</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function will return same subposet as many times as
there are automorphism on it. This is due to
<a class="reference external" href="../../../../graphs/sage/graphs/generic_graph.html#sage.graphs.generic_graph.GenericGraph.subgraph_search_iterator" title="(in Graph Theory v9.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subgraph_search_iterator()</span></code></a>
returning labelled subgraphs. On the other hand, this
function does not eat memory like
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets" title="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isomorphic_subposets()</span></code></a> does.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="lattices.html#sage.combinat.posets.lattices.FiniteLatticePoset.isomorphic_sublattices_iterator" title="sage.combinat.posets.lattices.FiniteLatticePoset.isomorphic_sublattices_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.combinat.posets.lattices.FiniteLatticePoset.isomorphic_sublattices_iterator()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.join">
<span class="sig-name descname"><span class="pre">join</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.join" title="Permalink to this definition">#</a></dt>
<dd><p>Return the join of two elements <code class="docutils literal notranslate"><span class="pre">x,</span> <span class="pre">y</span></code> in the poset if the join
exists; and <code class="docutils literal notranslate"><span class="pre">None</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;e&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;f&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;g&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span>
<span class="gp">....: </span>           <span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="s1">&#39;c&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="go">&#39;a&#39;</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="go">&#39;a&#39;</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="go">&#39;a&#39;</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="go">&#39;b&#39;</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">)</span>
<span class="go">&#39;a&#39;</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.jump_number">
<span class="sig-name descname"><span class="pre">jump_number</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.jump_number" title="Permalink to this definition">#</a></dt>
<dd><p>Return the jump number of the poset.</p>
<p>A <em>jump</em> in a linear extension <span class="math notranslate nohighlight">\([e_1, \ldots, e_n]\)</span> of a poset <span class="math notranslate nohighlight">\(P\)</span>
is a pair <span class="math notranslate nohighlight">\((e_i, e_{i+1})\)</span> so that <span class="math notranslate nohighlight">\(e_{i+1}\)</span> does not cover <span class="math notranslate nohighlight">\(e_i\)</span>
in <span class="math notranslate nohighlight">\(P\)</span>. The jump number of a poset is the minimal number of jumps
in linear extensions of a poset.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) Whether to return
a certificate</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">certificate=True</span></code> return a pair <span class="math notranslate nohighlight">\((n, l)\)</span> where
<span class="math notranslate nohighlight">\(n\)</span> is the jump number and <span class="math notranslate nohighlight">\(l\)</span> is a linear extension
with <span class="math notranslate nohighlight">\(n\)</span> jumps. If <code class="docutils literal notranslate"><span class="pre">certificate=False</span></code> return only
the jump number.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B3</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B3</span><span class="o">.</span><span class="n">jump_number</span><span class="p">()</span>
<span class="go">3</span>

<span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">jump_number</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(1, [1, 4, 2, 3])</span>
</pre></div>
</div>
<p>ALGORITHM:</p>
<p>It is known that every poset has a greedy linear extension –
an extension <span class="math notranslate nohighlight">\([e_1, e_2, \ldots, e_n]\)</span> where every <span class="math notranslate nohighlight">\(e_{i+1}\)</span> is
an upper cover of <span class="math notranslate nohighlight">\(e_i\)</span> if that is possible – with the smallest
possible number of jumps; see <a class="reference internal" href="../../../../references/index.html#sys1987" id="id17"><span>[Sys1987]</span></a>.</p>
<p>Hence it suffices to test only those. We do that by backtracking.</p>
<p>The problem is proven to be NP-complete.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_jump_critical" title="sage.combinat.posets.posets.FinitePoset.is_jump_critical"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_jump_critical()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.kazhdan_lusztig_polynomial">
<span class="sig-name descname"><span class="pre">kazhdan_lusztig_polynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">canonical_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.kazhdan_lusztig_polynomial" title="Permalink to this definition">#</a></dt>
<dd><p>Return the Kazhdan-Lusztig polynomial <span class="math notranslate nohighlight">\(P_{x,y}(q)\)</span> of the poset.</p>
<p>The poset is expected to be ranked.</p>
<p>We follow the definition given in <a class="reference internal" href="../../../../references/index.html#epw14" id="id18"><span>[EPW14]</span></a>. Let <span class="math notranslate nohighlight">\(G\)</span> denote a
graded poset with unique minimal and maximal elements and <span class="math notranslate nohighlight">\(\chi_G\)</span>
denote the characteristic polynomial of <span class="math notranslate nohighlight">\(G\)</span>. Let <span class="math notranslate nohighlight">\(I_x\)</span> and <span class="math notranslate nohighlight">\(F^x\)</span>
denote the principal order ideal and filter of <span class="math notranslate nohighlight">\(x\)</span> respectively.
Define the <em>Kazhdan-Lusztig polynomial</em> of <span class="math notranslate nohighlight">\(G\)</span> as the unique
polynomial <span class="math notranslate nohighlight">\(P_G(q)\)</span> satisfying the following:</p>
<ol class="arabic">
<li><p>If <span class="math notranslate nohighlight">\(\operatorname{rank} G = 0\)</span>, then <span class="math notranslate nohighlight">\(P_G(q) = 1\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(\operatorname{rank} G &gt; 0\)</span>, then <span class="math notranslate nohighlight">\(\deg P_G(q) &lt;
\frac{1}{2} \operatorname{rank} G\)</span>.</p></li>
<li><p>We have</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[q^{\operatorname{rank} G} P_G(q^{-1})
= \sum_{x \in G} \chi_{I_x}(q) P_{F^x}(q).\]</div>
</div>
</li>
</ol>
<p>We then extend this to <span class="math notranslate nohighlight">\(P_{x,y}(q)\)</span> by considering the subposet
corresponding to the (closed) interval <span class="math notranslate nohighlight">\([x, y]\)</span>. We also
define <span class="math notranslate nohighlight">\(P_{\emptyset}(q) = 0\)</span> (so if <span class="math notranslate nohighlight">\(x \not\leq y\)</span>,
then <span class="math notranslate nohighlight">\(P_{x,y}(q) = 0\)</span>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code> – (default: <span class="math notranslate nohighlight">\(q \in \ZZ[q]\)</span>) the indeterminate <span class="math notranslate nohighlight">\(q\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – (default: the minimal element) the element <span class="math notranslate nohighlight">\(x\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">y</span></code> – (default: the maximal element) the element <span class="math notranslate nohighlight">\(y\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">canonical_labels</span></code> – (optional) for subposets, use the
canonical labeling (this can limit recursive calls for posets
with large amounts of symmetry, but producing the labeling
takes time); if not specified, this is <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">x</span></code>
and <code class="docutils literal notranslate"><span class="pre">y</span></code> are both not specified and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">kazhdan_lusztig_polynomial</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">SymmetricGroupWeakOrderPoset</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">kazhdan_lusztig_polynomial</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;2314&#39;</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="s1">&#39;3421&#39;</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">kazhdan_lusztig_polynomial</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">-q + 1</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">kazhdan_lusztig_polynomial</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">))</span>
<span class="go">-t + 1</span>
</pre></div>
</div>
<p>AUTHORS:</p>
<ul class="simple">
<li><p>Travis Scrimshaw (27-12-2014)</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.le">
<span class="sig-name descname"><span class="pre">le</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.le" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <span class="math notranslate nohighlight">\(x\)</span> is less than or equal to <span class="math notranslate nohighlight">\(y\)</span> in the poset, and
<code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_less_than" title="sage.combinat.posets.posets.FinitePoset.is_less_than"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_less_than()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_gequal" title="sage.combinat.posets.posets.FinitePoset.is_gequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_gequal()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.lequal_matrix">
<span class="sig-name descname"><span class="pre">lequal_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring=Integer</span> <span class="pre">Ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.lequal_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the matrix whose <code class="docutils literal notranslate"><span class="pre">(i,j)</span></code> entry is 1 if
<code class="docutils literal notranslate"><span class="pre">self.linear_extension()[i]</span> <span class="pre">&lt;</span> <span class="pre">self.linear_extension()[j]</span></code> and 0
otherwise.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ring</span></code> – the ring of coefficients (default: <code class="docutils literal notranslate"><span class="pre">ZZ</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sparse</span></code> – whether the returned matrix is sparse or not
(default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[]],</span> <span class="n">facade</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">LEQM</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">lequal_matrix</span><span class="p">();</span> <span class="n">LEQM</span>
<span class="go">[1 1 1 1 1 1 1 1]</span>
<span class="go">[0 1 0 1 0 0 0 1]</span>
<span class="go">[0 0 1 1 1 0 1 1]</span>
<span class="go">[0 0 0 1 0 0 0 1]</span>
<span class="go">[0 0 0 0 1 0 0 1]</span>
<span class="go">[0 0 0 0 0 1 1 1]</span>
<span class="go">[0 0 0 0 0 0 1 1]</span>
<span class="go">[0 0 0 0 0 0 0 1]</span>
<span class="gp">sage: </span><span class="n">LEQM</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">LEQM</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()[</span><span class="mi">5</span><span class="p">]</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We now demonstrate the usage of the optional parameters:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">lequal_matrix</span><span class="p">(</span><span class="n">ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Full MatrixSpace of 8 by 8 dense matrices over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.level_sets">
<span class="sig-name descname"><span class="pre">level_sets</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.level_sets" title="Permalink to this definition">#</a></dt>
<dd><p>Return elements grouped by maximal number of cover relations
from a minimal element.</p>
<p>This returns a list of lists <code class="docutils literal notranslate"><span class="pre">l</span></code> such that <code class="docutils literal notranslate"><span class="pre">l[i]</span></code> is the
set of minimal elements of the poset obtained by removing the
elements in <code class="docutils literal notranslate"><span class="pre">l[0],</span> <span class="pre">l[1],</span> <span class="pre">...,</span> <span class="pre">l[i-1]</span></code>. (In particular,
<code class="docutils literal notranslate"><span class="pre">l[0]</span></code> is the set of minimal elements of <code class="docutils literal notranslate"><span class="pre">self</span></code>.)</p>
<p>Every level is an antichain of the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">level_sets</span><span class="p">()</span>
<span class="go">[[0], [1, 2], [3]]</span>

<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">level_sets</span><span class="p">()</span>
<span class="go">[[0], [1, 2], [3], [4]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.dilworth_decomposition" title="sage.combinat.posets.posets.FinitePoset.dilworth_decomposition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dilworth_decomposition()</span></code></a> to return elements grouped
to chains.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.lexicographic_sum">
<span class="sig-name descname"><span class="pre">lexicographic_sum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">P</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.lexicographic_sum" title="Permalink to this definition">#</a></dt>
<dd><p>Return the lexicographic sum using this poset as index.</p>
<p>In the lexicographic sum of posets <span class="math notranslate nohighlight">\(P_t\)</span> by index poset <span class="math notranslate nohighlight">\(T\)</span>
we have <span class="math notranslate nohighlight">\(x \le y\)</span> if either <span class="math notranslate nohighlight">\(x \le y\)</span> in <span class="math notranslate nohighlight">\(P_t\)</span>
for some <span class="math notranslate nohighlight">\(t \in T\)</span>, or <span class="math notranslate nohighlight">\(x \in P_i\)</span>, <span class="math notranslate nohighlight">\(y \in P_j\)</span> and
<span class="math notranslate nohighlight">\(i \le j\)</span> in <span class="math notranslate nohighlight">\(T\)</span>.</p>
<p>Informally said we substitute every element of <span class="math notranslate nohighlight">\(T\)</span> by corresponding
poset <span class="math notranslate nohighlight">\(P_t\)</span>.</p>
<p>Mathematically, it is only defined when all <span class="math notranslate nohighlight">\(P_t\)</span> have no
common element; here we force that by giving them different
names in the resulting poset.</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.disjoint_union" title="sage.combinat.posets.posets.FinitePoset.disjoint_union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">disjoint_union()</span></code></a> and <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_sum" title="sage.combinat.posets.posets.FinitePoset.ordinal_sum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ordinal_sum()</span></code></a> are special cases
of lexicographic sum where the index poset is an (anti)chain.
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_product" title="sage.combinat.posets.posets.FinitePoset.ordinal_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ordinal_product()</span></code></a> is a special case where every <span class="math notranslate nohighlight">\(P_t\)</span> is same
poset.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">P</span></code> – dictionary whose keys are elements of this poset, values are posets</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">(),</span> <span class="mi">2</span><span class="p">:</span> <span class="n">N</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">4</span><span class="p">:</span> <span class="n">posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">4</span><span class="p">)}</span>
<span class="gp">sage: </span><span class="n">NP</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">lexicographic_sum</span><span class="p">(</span><span class="n">P</span><span class="p">);</span> <span class="n">NP</span>
<span class="go">Finite poset containing 16 elements</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">NP</span><span class="o">.</span><span class="n">minimal_elements</span><span class="p">())</span>
<span class="go">[(1, 0), (2, 1), (2, 2)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.linear_extension">
<span class="sig-name descname"><span class="pre">linear_extension</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">linear_extension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.linear_extension" title="Permalink to this definition">#</a></dt>
<dd><p>Return a linear extension of this poset.</p>
<p>A linear extension of a finite poset <span class="math notranslate nohighlight">\(P\)</span> of size <span class="math notranslate nohighlight">\(n\)</span> is a total
ordering <span class="math notranslate nohighlight">\(\pi := \pi_0 \pi_1 \ldots \pi_{n-1}\)</span> of its elements
such that <span class="math notranslate nohighlight">\(i&lt;j\)</span> whenever <span class="math notranslate nohighlight">\(\pi_i &lt; \pi_j\)</span> in the poset <span class="math notranslate nohighlight">\(P\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">linear_extension</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) a list of the
elements of <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – a boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>);
whether to check that <code class="docutils literal notranslate"><span class="pre">linear_extension</span></code> is indeed a
linear extension of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Without optional argument, the default linear extension of the
poset is returned, as a plain list:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()</span>
<span class="go">[1, 3, 5, 15]</span>
</pre></div>
</div>
<p>Otherwise, a full-featured linear extension is constructed
as an element of <code class="docutils literal notranslate"><span class="pre">P.linear_extensions()</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">15</span><span class="p">]);</span> <span class="n">l</span>
<span class="go">[1, 5, 3, 15]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.combinat.posets.linear_extensions.LinearExtensionsOfPoset_with_category.element_class&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">l</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">The set of all linear extensions of Finite poset containing 4 elements</span>
</pre></div>
</div>
<p>By default, the linear extension is checked for correctness:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: [1, 3, 15, 5] is not a linear extension of Finite poset containing 4 elements</span>
</pre></div>
</div>
<p>This can be disabled (at your own risks!) with:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[1, 3, 15, 5]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_linear_extension" title="sage.combinat.posets.posets.FinitePoset.is_linear_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_linear_extension()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extensions" title="sage.combinat.posets.posets.FinitePoset.linear_extensions"><code class="xref py py-meth docutils literal notranslate"><span class="pre">linear_extensions()</span></code></a></p>
</div>
<div class="admonition-todo admonition" id="id19">
<p class="admonition-title">Todo</p>
<ul class="simple">
<li><p>Is it acceptable to have those two features for a single method?</p></li>
<li><p>In particular, we miss a short idiom to get the default
linear extension</p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.linear_extensions">
<span class="sig-name descname"><span class="pre">linear_extensions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">facade</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.linear_extensions" title="Permalink to this definition">#</a></dt>
<dd><p>Return the enumerated set of all the linear extensions of this poset.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">facade</span></code> – a boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>);
whether to return the linear extensions as plain lists</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The <code class="docutils literal notranslate"><span class="pre">facade</span></code> option is not yet fully functional:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extensions</span><span class="p">(</span><span class="n">facade</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">L</span>
<span class="go">The set of all linear extensions of Finite poset containing 6 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: Cannot convert list to sage.structure.element.Element</span>
</pre></div>
</div>
</div>
</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extensions</span><span class="p">();</span> <span class="n">L</span>
<span class="go">The set of all linear extensions of Finite poset containing 6 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">l</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[1, 2, 3, 4, 6, 12],</span>
<span class="go"> [1, 2, 4, 3, 6, 12],</span>
<span class="go"> [1, 3, 2, 4, 6, 12],</span>
<span class="go"> [1, 3, 2, 6, 4, 12],</span>
<span class="go"> [1, 2, 3, 6, 4, 12]]</span>
</pre></div>
</div>
<p>Each element is aware that it is a linear extension of <span class="math notranslate nohighlight">\(P\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">parent</span><span class="p">())</span>
<span class="go">&lt;class &#39;sage.combinat.posets.linear_extensions.LinearExtensionsOfPoset_with_category&#39;&gt;</span>
</pre></div>
</div>
<p>With <code class="docutils literal notranslate"><span class="pre">facade=True</span></code>, the elements of <code class="docutils literal notranslate"><span class="pre">L</span></code> are plain lists instead:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extensions</span><span class="p">(</span><span class="n">facade</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="go">&lt;class &#39;list&#39;&gt;</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In Sage &lt;= 4.8, this function used to return a plain list
of lists. To recover the previous functionality, please use:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">linear_extensions</span><span class="p">(</span><span class="n">facade</span><span class="o">=</span><span class="kc">True</span><span class="p">));</span> <span class="n">L</span>
<span class="go">[[1, 2, 3, 4, 6, 12],</span>
<span class="go"> [1, 2, 4, 3, 6, 12],</span>
<span class="go"> [1, 3, 2, 4, 6, 12],</span>
<span class="go"> [1, 3, 2, 6, 4, 12],</span>
<span class="go"> [1, 2, 3, 6, 4, 12]]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;class &#39;list&#39;&gt;</span>
</pre></div>
</div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extension" title="sage.combinat.posets.posets.FinitePoset.linear_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">linear_extension()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_linear_extension" title="sage.combinat.posets.posets.FinitePoset.is_linear_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_linear_extension()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.linear_extensions_graph">
<span class="sig-name descname"><span class="pre">linear_extensions_graph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.linear_extensions_graph" title="Permalink to this definition">#</a></dt>
<dd><p>Return the linear extensions graph of the poset.</p>
<p>Vertices of the graph are linear extensions of the poset.
Two vertices are connected by an edge if the linear extensions
differ by only one adjacent transposition.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">linear_extensions_graph</span><span class="p">();</span> <span class="n">G</span>
<span class="go">Graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]))</span>
<span class="go">[[2, 1, 3, 4], [1, 3, 2, 4], [1, 2, 4, 3]]</span>

<span class="gp">sage: </span><span class="n">chevron</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">chevron</span><span class="o">.</span><span class="n">linear_extensions_graph</span><span class="p">();</span> <span class="n">G</span>
<span class="go">Graph on 22 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">36</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.linear_intervals_count">
<span class="sig-name descname"><span class="pre">linear_intervals_count</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.linear_intervals_count" title="Permalink to this definition">#</a></dt>
<dd><p>Return the enumeration of linear intervals w.r.t. their cardinality.</p>
<p>An interval is linear if it is a total order.</p>
<p>OUTPUT: list of integers</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_linear_interval" title="sage.combinat.posets.posets.FinitePoset.is_linear_interval"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_linear_interval()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">linear_intervals_count</span><span class="p">()</span>
<span class="go">[5, 5, 2]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">TamariLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">linear_intervals_count</span><span class="p">()</span>
<span class="go">[14, 21, 12, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.list">
<span class="sig-name descname"><span class="pre">list</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.list" title="Permalink to this definition">#</a></dt>
<dd><p>List the elements of the poset. This just returns the result
of <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extension" title="sage.combinat.posets.posets.FinitePoset.linear_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">linear_extension()</span></code></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="p">},</span> <span class="n">facade</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">list</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;class &#39;sage.combinat.posets.posets.FinitePoset_with_category.element_class&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.lower_covers">
<span class="sig-name descname"><span class="pre">lower_covers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.lower_covers" title="Permalink to this definition">#</a></dt>
<dd><p>Return the list of lower covers of the element <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>A lower cover of <span class="math notranslate nohighlight">\(x\)</span> is an element <span class="math notranslate nohighlight">\(y\)</span> such that <span class="math notranslate nohighlight">\(y &lt; x\)</span> and
there is no element <span class="math notranslate nohighlight">\(z\)</span> so that <span class="math notranslate nohighlight">\(y &lt; z &lt; x\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">lower_covers</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[2, 5]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">lower_covers</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.upper_covers" title="sage.combinat.posets.posets.FinitePoset.upper_covers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">upper_covers()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.lower_covers_iterator">
<span class="sig-name descname"><span class="pre">lower_covers_iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.lower_covers_iterator" title="Permalink to this definition">#</a></dt>
<dd><p>Return an iterator over the lower covers of the element <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">l0</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">lower_covers_iterator</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">l0</span><span class="p">)</span>
<span class="go">&lt;class &#39;generator&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">l0</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.lt">
<span class="sig-name descname"><span class="pre">lt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.lt" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <span class="math notranslate nohighlight">\(x\)</span> is less than but not equal to <span class="math notranslate nohighlight">\(y\)</span> in the poset,
and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>For non-facade posets also <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> works:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]},</span> <span class="n">facade</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_lequal" title="sage.combinat.posets.posets.FinitePoset.is_lequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_lequal()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_greater_than" title="sage.combinat.posets.posets.FinitePoset.is_greater_than"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_greater_than()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.magnitude">
<span class="sig-name descname"><span class="pre">magnitude</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.magnitude" title="Permalink to this definition">#</a></dt>
<dd><p>Return the magnitude of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The magnitude is an integer defined as the sum of all Möbius
numbers, and can be seen as some kind of Euler characteristic of
the poset. It is additive under disjoint union and multiplicative
under Cartesian product.</p>
<p>REFERENCES:</p>
<ul class="simple">
<li><p>[Lein2008] Tom Leinster, <em>The Euler Characteristic of a Category</em>,
Documenta Mathematica, Vol. 13 (2008), 21-49
<a class="reference external" href="https://www.math.uni-bielefeld.de/documenta/vol-13/02.html">https://www.math.uni-bielefeld.de/documenta/vol-13/02.html</a></p></li>
<li><p><a class="reference external" href="https://golem.ph.utexas.edu/category/2011/06/the_magnitude_of_an_enriched_c.html">https://golem.ph.utexas.edu/category/2011/06/the_magnitude_of_an_enriched_c.html</a></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">magnitude</span><span class="p">()</span>
<span class="go">1</span>

<span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">SymmetricGroup</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">noncrossing_partition_lattice</span><span class="p">()</span><span class="o">.</span><span class="n">without_bounds</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">magnitude</span><span class="p">()</span>
<span class="go">-4</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">TamariLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">without_bounds</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">magnitude</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_complex" title="sage.combinat.posets.posets.FinitePoset.order_complex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_complex()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.maximal_antichains">
<span class="sig-name descname"><span class="pre">maximal_antichains</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.maximal_antichains" title="Permalink to this definition">#</a></dt>
<dd><p>Return the maximal antichains of the poset.</p>
<p>An antichain <span class="math notranslate nohighlight">\(a\)</span> of poset <span class="math notranslate nohighlight">\(P\)</span> is <em>maximal</em> if there is
no element <span class="math notranslate nohighlight">\(e \in P \setminus a\)</span> such that <span class="math notranslate nohighlight">\(a \cup \{e\}\)</span>
is an antichain.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;d&#39;</span><span class="p">,</span><span class="s1">&#39;e&#39;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="n">anti</span><span class="p">)</span> <span class="k">for</span> <span class="n">anti</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">maximal_antichains</span><span class="p">()]</span>
<span class="go">[[&#39;a&#39;], [&#39;b&#39;, &#39;c&#39;], [&#39;c&#39;, &#39;d&#39;, &#39;e&#39;]]</span>

<span class="gp">sage: </span><span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">maximal_antichains</span><span class="p">()</span>
<span class="go">[[0], [1, 2], [1, 3], [4]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains" title="sage.combinat.posets.posets.FinitePoset.antichains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">antichains()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_chains" title="sage.combinat.posets.posets.FinitePoset.maximal_chains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximal_chains()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.maximal_chain_length">
<span class="sig-name descname"><span class="pre">maximal_chain_length</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.maximal_chain_length" title="Permalink to this definition">#</a></dt>
<dd><p>Return the maximum length of a maximal chain in the poset.</p>
<p>The length here is the number of vertices.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">TamariLattice</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">maximal_chain_length</span><span class="p">()</span>
<span class="go">11</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_chains" title="sage.combinat.posets.posets.FinitePoset.maximal_chains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximal_chains()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_chains_iterator" title="sage.combinat.posets.posets.FinitePoset.maximal_chains_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximal_chains_iterator()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.maximal_chains">
<span class="sig-name descname"><span class="pre">maximal_chains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">partial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.maximal_chains" title="Permalink to this definition">#</a></dt>
<dd><p>Return all maximal chains of this poset.</p>
<p>Each chain is listed in increasing order.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">partial</span></code> – list (optional); if given, the list
<code class="docutils literal notranslate"><span class="pre">partial</span></code> is assumed to be the start of a maximal chain,
and the function will find all maximal chains starting with
the elements in <code class="docutils literal notranslate"><span class="pre">partial</span></code></p></li>
</ul>
<p>This is used in constructing the order complex for the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">maximal_chains</span><span class="p">()</span>
<span class="go">[[0, 1, 3, 7], [0, 1, 5, 7], [0, 2, 3, 7], [0, 2, 6, 7], [0, 4, 5, 7], [0, 4, 6, 7]]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">maximal_chains</span><span class="p">(</span><span class="n">partial</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">[[0, 2, 3, 7], [0, 2, 6, 7]]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">maximal_chains</span><span class="p">()</span>
<span class="go">[[0, 1, 2, 3, 4, 5]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_antichains" title="sage.combinat.posets.posets.FinitePoset.maximal_antichains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximal_antichains()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.chains" title="sage.combinat.posets.posets.FinitePoset.chains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">chains()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.maximal_chains_iterator">
<span class="sig-name descname"><span class="pre">maximal_chains_iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">partial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.maximal_chains_iterator" title="Permalink to this definition">#</a></dt>
<dd><p>Return an iterator over maximal chains.</p>
<p>Each chain is listed in increasing order.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">partial</span></code> – list (optional); if given, the list
<code class="docutils literal notranslate"><span class="pre">partial</span></code> is assumed to be the start of a maximal chain,
and the function will yield all maximal chains starting with
the elements in <code class="docutils literal notranslate"><span class="pre">partial</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">maximal_chains_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">[0, 1, 3, 7]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains_iterator" title="sage.combinat.posets.posets.FinitePoset.antichains_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">antichains_iterator()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.maximal_elements">
<span class="sig-name descname"><span class="pre">maximal_elements</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.maximal_elements" title="Permalink to this definition">#</a></dt>
<dd><p>Return the list of the maximal elements of the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span><span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">maximal_elements</span><span class="p">()</span>
<span class="go">[4]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.minimal_elements" title="sage.combinat.posets.posets.FinitePoset.minimal_elements"><code class="xref py py-meth docutils literal notranslate"><span class="pre">minimal_elements()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.meet">
<span class="sig-name descname"><span class="pre">meet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.meet" title="Permalink to this definition">#</a></dt>
<dd><p>Return the meet of two elements <code class="docutils literal notranslate"><span class="pre">x,</span> <span class="pre">y</span></code> in the poset if the meet
exists; and <code class="docutils literal notranslate"><span class="pre">None</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">meet</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">],</span> <span class="s1">&#39;c&#39;</span><span class="p">:[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">],</span>
<span class="gp">....: </span>           <span class="s1">&#39;d&#39;</span><span class="p">:[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">meet</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="go">&#39;a&#39;</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">meet</span><span class="p">(</span><span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="go">&#39;a&#39;</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">meet</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="go">&#39;a&#39;</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">meet</span><span class="p">(</span><span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="go">&#39;b&#39;</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">meet</span><span class="p">(</span><span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">)</span>
<span class="go">&#39;a&#39;</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">meet</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">meet</span><span class="p">(</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.minimal_elements">
<span class="sig-name descname"><span class="pre">minimal_elements</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.minimal_elements" title="Permalink to this definition">#</a></dt>
<dd><p>Return the list of the minimal elements of the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span><span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">minimal_elements</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">minimal_elements</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">minimal_elements</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_elements" title="sage.combinat.posets.posets.FinitePoset.maximal_elements"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximal_elements()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.moebius_function">
<span class="sig-name descname"><span class="pre">moebius_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.moebius_function" title="Permalink to this definition">#</a></dt>
<dd><p>Return the value of the Möbius function of the poset on the
elements x and y.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">P</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="nb">sum</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">P</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">v</span><span class="p">))</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">P</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">cover_relations_iterator</span><span class="p">():</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="n">P</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Bug in moebius_function!&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[]])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="nb">sum</span><span class="p">([</span><span class="n">Q</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Q</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.moebius_function_matrix">
<span class="sig-name descname"><span class="pre">moebius_function_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ring=Integer</span> <span class="pre">Ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.moebius_function_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Return a matrix whose <code class="docutils literal notranslate"><span class="pre">(i,j)</span></code> entry is the value of the Möbius
function evaluated at <code class="docutils literal notranslate"><span class="pre">self.linear_extension()[i]</span></code> and
<code class="docutils literal notranslate"><span class="pre">self.linear_extension()[j]</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ring</span></code> – the ring of coefficients (default: <code class="docutils literal notranslate"><span class="pre">ZZ</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sparse</span></code> – whether the returned matrix is sparse or not
(default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[],[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">moebius_function_matrix</span><span class="p">();</span> <span class="n">M</span>
<span class="go">[ 1 -1 -1 -1  2]</span>
<span class="go">[ 0  1  0  0 -1]</span>
<span class="go">[ 0  0  1  0 -1]</span>
<span class="go">[ 0  0  0  1 -1]</span>
<span class="go">[ 0  0  0  0  1]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="go">-1</span>
</pre></div>
</div>
<p>We now demonstrate the usage of the optional parameters:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">moebius_function_matrix</span><span class="p">(</span><span class="n">ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Full MatrixSpace of 5 by 5 dense matrices over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.open_interval">
<span class="sig-name descname"><span class="pre">open_interval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.open_interval" title="Permalink to this definition">#</a></dt>
<dd><p>Return the list of elements <span class="math notranslate nohighlight">\(z\)</span> such that <span class="math notranslate nohighlight">\(x &lt; z &lt; y\)</span> in the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">open_interval</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="go">[4, 10, 20, 50]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.closed_interval" title="sage.combinat.posets.posets.FinitePoset.closed_interval"><code class="xref py py-meth docutils literal notranslate"><span class="pre">closed_interval()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.order_complex">
<span class="sig-name descname"><span class="pre">order_complex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">on_ints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.order_complex" title="Permalink to this definition">#</a></dt>
<dd><p>Return the order complex associated to this poset.</p>
<p>The order complex is the simplicial complex with vertices equal
to the elements of the poset, and faces given by the chains.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">on_ints</span></code> – a boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p></li>
</ul>
<p>OUTPUT:</p>
<p>an order complex of type <a class="reference external" href="../../../../topology/sage/topology/simplicial_complex.html#sage.topology.simplicial_complex.SimplicialComplex" title="(in Topology v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimplicialComplex</span></code></a></p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_complex</span><span class="p">();</span> <span class="n">S</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3, 4, 5, 6, 7) and 6 facets</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 8, 19, 18, 6]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>      <span class="c1"># S is contractible</span>
<span class="go">{0: 0, 1: 0, 2: 0, 3: 0}</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">subposet</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">order_complex</span><span class="p">()</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>    <span class="c1"># a circle</span>
<span class="go">{0: 0, 1: Z}</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_complex</span><span class="p">()</span>
<span class="go">Simplicial complex with vertex set (1, 3, 5, 15) and facets {(1, 3, 15), (1, 5, 15)}</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">on_ints</span></code>, then the elements of the poset are labelled
<span class="math notranslate nohighlight">\(0,1,\dots\)</span> in the chain complex:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_complex</span><span class="p">(</span><span class="n">on_ints</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3) and facets {(0, 1, 3), (0, 2, 3)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.order_filter">
<span class="sig-name descname"><span class="pre">order_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elements</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.order_filter" title="Permalink to this definition">#</a></dt>
<dd><p>Return the order filter generated by the elements of an
iterable <code class="docutils literal notranslate"><span class="pre">elements</span></code>.</p>
<p><span class="math notranslate nohighlight">\(I\)</span> is an order filter if, for any <span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(I\)</span> and <span class="math notranslate nohighlight">\(y\)</span> such that
<span class="math notranslate nohighlight">\(y \ge x\)</span>, then <span class="math notranslate nohighlight">\(y\)</span> is in <span class="math notranslate nohighlight">\(I\)</span>. This is also called upper set or
upset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_filter</span><span class="p">([</span><span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">])</span>
<span class="go">[20, 40, 25, 50, 100, 200, 125, 250, 500, 1000]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_ideal" title="sage.combinat.posets.posets.FinitePoset.order_ideal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_ideal()</span></code></a>, <a class="reference external" href="../../../../categories/sage/categories/posets.html#sage.categories.posets.Posets.ParentMethods.principal_order_filter" title="(in Category Framework v9.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">principal_order_filter()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.order_ideal">
<span class="sig-name descname"><span class="pre">order_ideal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elements</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.order_ideal" title="Permalink to this definition">#</a></dt>
<dd><p>Return the order ideal generated by the elements of an
iterable <code class="docutils literal notranslate"><span class="pre">elements</span></code>.</p>
<p><span class="math notranslate nohighlight">\(I\)</span> is an order ideal if, for any <span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(I\)</span> and <span class="math notranslate nohighlight">\(y\)</span> such that
<span class="math notranslate nohighlight">\(y \le x\)</span>, then <span class="math notranslate nohighlight">\(y\)</span> is in <span class="math notranslate nohighlight">\(I\)</span>. This is also called lower set or
downset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal</span><span class="p">([</span><span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">])</span>
<span class="go">[1, 2, 4, 5, 10, 20, 25]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_filter" title="sage.combinat.posets.posets.FinitePoset.order_filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_filter()</span></code></a>, <a class="reference external" href="../../../../categories/sage/categories/posets.html#sage.categories.posets.Posets.ParentMethods.principal_order_ideal" title="(in Category Framework v9.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">principal_order_ideal()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.order_ideal_cardinality">
<span class="sig-name descname"><span class="pre">order_ideal_cardinality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elements</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.order_ideal_cardinality" title="Permalink to this definition">#</a></dt>
<dd><p>Return the cardinality of the order ideal generated by <code class="docutils literal notranslate"><span class="pre">elements</span></code>.</p>
<p>The elements <span class="math notranslate nohighlight">\(I\)</span> is an order ideal if, for any <span class="math notranslate nohighlight">\(x \in I\)</span> and <span class="math notranslate nohighlight">\(y\)</span>
such that <span class="math notranslate nohighlight">\(y \le x\)</span>, then <span class="math notranslate nohighlight">\(y \in I\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_cardinality</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="go">10</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.order_ideal_plot">
<span class="sig-name descname"><span class="pre">order_ideal_plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elements</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.order_ideal_plot" title="Permalink to this definition">#</a></dt>
<dd><p>Return a plot of the order ideal generated by the elements of an
iterable <code class="docutils literal notranslate"><span class="pre">elements</span></code>.</p>
<p><span class="math notranslate nohighlight">\(I\)</span> is an order ideal if, for any <span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(I\)</span> and <span class="math notranslate nohighlight">\(y\)</span> such that
<span class="math notranslate nohighlight">\(y \le x\)</span>, then <span class="math notranslate nohighlight">\(y\)</span> is in <span class="math notranslate nohighlight">\(I\)</span>. This is also called lower set or
downset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_plot</span><span class="p">([</span><span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">])</span>
<span class="go">Graphics object consisting of 41 graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.order_polynomial">
<span class="sig-name descname"><span class="pre">order_polynomial</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.order_polynomial" title="Permalink to this definition">#</a></dt>
<dd><p>Return the order polynomial of the poset.</p>
<p>The order polynomial <span class="math notranslate nohighlight">\(\Omega_P(q)\)</span> of a poset <span class="math notranslate nohighlight">\(P\)</span> is defined
as the unique polynomial <span class="math notranslate nohighlight">\(S\)</span> such that for each integer
<span class="math notranslate nohighlight">\(m \geq 1\)</span>, <span class="math notranslate nohighlight">\(S(m)\)</span> is the number of order-preserving maps
from <span class="math notranslate nohighlight">\(P\)</span> to <span class="math notranslate nohighlight">\(\{1,\ldots,m\}\)</span>.</p>
<p>See sections 3.12 and 3.15 of <a class="reference internal" href="../../../../references/index.html#enumcomb1" id="id20"><span>[EnumComb1]</span></a>, and also
<a class="reference internal" href="../../../../references/index.html#st1986" id="id21"><span>[St1986]</span></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_polynomial</span><span class="p">()</span>
<span class="go">q^3</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_polynomial</span><span class="p">();</span> <span class="n">f</span>
<span class="go">1/6*q^3 + 1/2*q^2 + 1/3*q</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
<span class="go">[0, 1, 4, 10]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_polytope" title="sage.combinat.posets.posets.FinitePoset.order_polytope"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_polytope()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.order_polytope">
<span class="sig-name descname"><span class="pre">order_polytope</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.order_polytope" title="Permalink to this definition">#</a></dt>
<dd><p>Return the order polytope of the poset <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The order polytope of a finite poset <span class="math notranslate nohighlight">\(P\)</span> is defined as the subset
of <span class="math notranslate nohighlight">\(\RR^P\)</span> consisting of all maps <span class="math notranslate nohighlight">\(x : P \to \RR\)</span> satisfying</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[0 \leq x(p) \leq 1 \mbox{ for all } p \in P,\]</div>
</div>
<p>and</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[x(p) \leq x(q) \mbox{ for all } p, q \in P
\mbox{ satisfying } p &lt; q.\]</div>
</div>
<p>This polytope was defined and studied in <a class="reference internal" href="../../../../references/index.html#st1986" id="id22"><span>[St1986]</span></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_polytope</span><span class="p">();</span><span class="n">Q</span>
<span class="go">A 3-dimensional polyhedron in ZZ^3 defined as the convex hull of 8 vertices</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_polytope</span><span class="p">();</span><span class="n">Q</span>
<span class="go">A 5-dimensional polyhedron in ZZ^5 defined as the convex hull of 8 vertices</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_polytope</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">contains</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">contains</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.ordinal_product">
<span class="sig-name descname"><span class="pre">ordinal_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pairs'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.ordinal_product" title="Permalink to this definition">#</a></dt>
<dd><p>Return the ordinal product of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>The ordinal product of two posets <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> is a partial
order on the Cartesian product of the underlying sets of <span class="math notranslate nohighlight">\(P\)</span>
and <span class="math notranslate nohighlight">\(Q\)</span>, defined as follows (see <a class="reference internal" href="../../../../references/index.html#enumcomb1" id="id23"><span>[EnumComb1]</span></a>, p. 284).</p>
<p>In the ordinal product, <span class="math notranslate nohighlight">\((p,q) \leq (p',q')\)</span> if either <span class="math notranslate nohighlight">\(p \leq
p'\)</span> or <span class="math notranslate nohighlight">\(p = p'\)</span> and <span class="math notranslate nohighlight">\(q \leq q'\)</span>.</p>
<p>This construction is not symmetric in <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span>. Informally
said we put a copy of <span class="math notranslate nohighlight">\(Q\)</span> in place of every element of <span class="math notranslate nohighlight">\(P\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">other</span></code> – a poset</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">labels</span></code> – either <code class="docutils literal notranslate"><span class="pre">'integers'</span></code> or <code class="docutils literal notranslate"><span class="pre">'pairs'</span></code> (default); how
the resulting poset will be labeled</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="p">[[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">ordinal_product</span><span class="p">(</span><span class="n">P2</span><span class="p">);</span> <span class="n">P</span>
<span class="go">Finite poset containing 4 elements</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span>
<span class="go">[[(&#39;a&#39;, &#39;c&#39;), (&#39;a&#39;, &#39;d&#39;)], [(&#39;a&#39;, &#39;d&#39;), (&#39;b&#39;, &#39;c&#39;)],</span>
<span class="go">[(&#39;b&#39;, &#39;c&#39;), (&#39;b&#39;, &#39;d&#39;)]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.product" title="sage.combinat.posets.posets.FinitePoset.product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">product()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_sum" title="sage.combinat.posets.posets.FinitePoset.ordinal_sum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ordinal_sum()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.ordinal_sum">
<span class="sig-name descname"><span class="pre">ordinal_sum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pairs'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.ordinal_sum" title="Permalink to this definition">#</a></dt>
<dd><p>Return a poset or (semi)lattice isomorphic to ordinal sum of the
poset with <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>The ordinal sum of <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> is a poset that contains every
element and relation from both <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span>, and where every
element of <span class="math notranslate nohighlight">\(P\)</span> is smaller than any element of <span class="math notranslate nohighlight">\(Q\)</span>.</p>
<p>Mathematically, it is only defined when <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> have no
common element; here we force that by giving them different
names in the resulting poset.</p>
<p>The ordinal sum on lattices is a lattice; resp. for meet- and
join-semilattices.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">other</span></code>, a poset.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">labels</span></code> - (defaults to ‘pairs’) If set to ‘pairs’, each
element <code class="docutils literal notranslate"><span class="pre">v</span></code> in this poset will be named <code class="docutils literal notranslate"><span class="pre">(0,v)</span></code> and each
element <code class="docutils literal notranslate"><span class="pre">u</span></code> in <code class="docutils literal notranslate"><span class="pre">other</span></code> will be named <code class="docutils literal notranslate"><span class="pre">(1,u)</span></code> in the
result. If set to ‘integers’, the elements of the result
will be relabeled with consecutive integers.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,],</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P3</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">ordinal_sum</span><span class="p">(</span><span class="n">P2</span><span class="p">);</span> <span class="n">P3</span>
<span class="go">Finite poset containing 7 elements</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">P1</span><span class="o">.</span><span class="n">maximal_elements</span><span class="p">())</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">P2</span><span class="o">.</span><span class="n">minimal_elements</span><span class="p">())</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">P1</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span><span class="o">+</span><span class="n">P2</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">P3</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span> <span class="c1"># Every element of P2 is greater than elements of P1.</span>
<span class="go">11</span>
<span class="gp">sage: </span><span class="n">P3</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>  <span class="c1"># random</span>
<span class="go">[(0, 1), (0, 2), (0, 4), (0, 3), (1, 2), (1, 3), (1, 1)]</span>
<span class="gp">sage: </span><span class="n">P4</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">ordinal_sum</span><span class="p">(</span><span class="n">P2</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="s1">&#39;integers&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P4</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>  <span class="c1"># random</span>
<span class="go">[0, 1, 2, 3, 5, 6, 4]</span>
</pre></div>
</div>
<p>Return type depends on input types:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">]});</span> <span class="n">P</span>
<span class="go">Finite poset containing 2 elements</span>
<span class="gp">sage: </span><span class="n">JL</span> <span class="o">=</span> <span class="n">JoinSemilattice</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">]});</span> <span class="n">JL</span>
<span class="go">Finite join-semilattice containing 2 elements</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">LatticePoset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">]});</span> <span class="n">L</span>
<span class="go">Finite lattice containing 2 elements</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">ordinal_sum</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="go">Finite poset containing 4 elements</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">ordinal_sum</span><span class="p">(</span><span class="n">JL</span><span class="p">)</span>
<span class="go">Finite join-semilattice containing 4 elements</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">ordinal_sum</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="go">Finite lattice containing 4 elements</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_summands" title="sage.combinat.posets.posets.FinitePoset.ordinal_summands"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ordinal_summands()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.disjoint_union" title="sage.combinat.posets.posets.FinitePoset.disjoint_union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">disjoint_union()</span></code></a>,
<a class="reference internal" href="lattices.html#sage.combinat.posets.lattices.FiniteLatticePoset.vertical_composition" title="sage.combinat.posets.lattices.FiniteLatticePoset.vertical_composition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.combinat.posets.lattices.FiniteLatticePoset.vertical_composition()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.ordinal_summands">
<span class="sig-name descname"><span class="pre">ordinal_summands</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.ordinal_summands" title="Permalink to this definition">#</a></dt>
<dd><p>Return the ordinal summands of the poset as subposets.</p>
<p>The ordinal summands of a poset <span class="math notranslate nohighlight">\(P\)</span> is the longest list of
non-empty subposets <span class="math notranslate nohighlight">\(P_1, \ldots, P_n\)</span> whose ordinal sum is <span class="math notranslate nohighlight">\(P\)</span>. This
decomposition is unique.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span>
<span class="gp">....: </span><span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">parts</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">ordinal_summands</span><span class="p">();</span> <span class="n">parts</span>
<span class="go">[Finite poset containing 4 elements, Finite poset containing 2 elements]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ordinal_sum</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_sum" title="sage.combinat.posets.posets.FinitePoset.ordinal_sum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ordinal_sum()</span></code></a></p>
</div>
<p>ALGORITHM:</p>
<p>Suppose that a poset <span class="math notranslate nohighlight">\(P\)</span> is the ordinal sum of posets <span class="math notranslate nohighlight">\(L\)</span> and <span class="math notranslate nohighlight">\(U\)</span>. Then
<span class="math notranslate nohighlight">\(P\)</span> contains maximal antichains <span class="math notranslate nohighlight">\(l\)</span> and <span class="math notranslate nohighlight">\(u\)</span> such that every element of
<span class="math notranslate nohighlight">\(u\)</span> covers every element of <span class="math notranslate nohighlight">\(l\)</span>; they correspond to maximal elements of
<span class="math notranslate nohighlight">\(L\)</span> and minimal elements of <span class="math notranslate nohighlight">\(U\)</span>.</p>
<p>We consider a linear extension <span class="math notranslate nohighlight">\(x_1,\ldots,x_n\)</span> of the poset’s
elements.</p>
<p>We keep track of the maximal elements of subposet induced by elements
<span class="math notranslate nohighlight">\(0,\ldots,x_i\)</span> and minimal elements of subposet induced by elements
<span class="math notranslate nohighlight">\(x_{i+1},\ldots,x_n\)</span>, incrementing <span class="math notranslate nohighlight">\(i\)</span> one by one. We then check if
<span class="math notranslate nohighlight">\(l\)</span> and <span class="math notranslate nohighlight">\(u\)</span> fit the previous description.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.p_partition_enumerator">
<span class="sig-name descname"><span class="pre">p_partition_enumerator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tup</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.p_partition_enumerator" title="Permalink to this definition">#</a></dt>
<dd><p>Return a <span class="math notranslate nohighlight">\(P\)</span>-partition enumerator of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Given a total order <span class="math notranslate nohighlight">\(\prec\)</span> on the elements of a finite poset <span class="math notranslate nohighlight">\(P\)</span>
(the order of <span class="math notranslate nohighlight">\(P\)</span> and the total order <span class="math notranslate nohighlight">\(\prec\)</span> can be unrelated; in
particular, the latter does not have to extend the former), a
<span class="math notranslate nohighlight">\(P\)</span>-partition enumerator is the quasisymmetric function
<span class="math notranslate nohighlight">\(\sum_f \prod_{p \in P} x_{f(p)}\)</span>, where the first sum is taken over
all <span class="math notranslate nohighlight">\(P\)</span>-partitions <span class="math notranslate nohighlight">\(f\)</span>.</p>
<p>A <span class="math notranslate nohighlight">\(P\)</span>-partition is a function <span class="math notranslate nohighlight">\(f : P \to \{1,2,3,...\}\)</span> satisfying
the following properties for any two elements <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> of <span class="math notranslate nohighlight">\(P\)</span>
satisfying <span class="math notranslate nohighlight">\(i &lt;_P j\)</span>:</p>
<ul class="simple">
<li><p>if <span class="math notranslate nohighlight">\(i \prec j\)</span> then <span class="math notranslate nohighlight">\(f(i) \leq f(j)\)</span>,</p></li>
<li><p>if <span class="math notranslate nohighlight">\(j \prec i\)</span> then <span class="math notranslate nohighlight">\(f(i) &lt; f(j)\)</span>.</p></li>
</ul>
<p>The optional argument <code class="docutils literal notranslate"><span class="pre">weights</span></code> allows constructing a
generalized (“weighted”) version of the <span class="math notranslate nohighlight">\(P\)</span>-partition enumerator.
Namely, <code class="docutils literal notranslate"><span class="pre">weights</span></code> should be a dictionary whose keys are the
elements of <code class="docutils literal notranslate"><span class="pre">P</span></code>.
Then, the generalized <span class="math notranslate nohighlight">\(P\)</span>-partition enumerator corresponding to
weights <code class="docutils literal notranslate"><span class="pre">weights</span></code> is <span class="math notranslate nohighlight">\(\sum_f \prod_{p \in P} x_{f(p)}^{w(p)}\)</span>,
where the sum is again over all <span class="math notranslate nohighlight">\(P\)</span>-partitions <span class="math notranslate nohighlight">\(f\)</span>. Here,
<span class="math notranslate nohighlight">\(w(p)\)</span> is <code class="docutils literal notranslate"><span class="pre">weights[p]</span></code>. The classical <span class="math notranslate nohighlight">\(P\)</span>-partition enumerator
is the particular case obtained when all <span class="math notranslate nohighlight">\(p\)</span> satisfy <span class="math notranslate nohighlight">\(w(p) = 1\)</span>.</p>
<p>In the language of <a class="reference internal" href="../../../../references/index.html#grinb2016a" id="id24"><span>[Grinb2016a]</span></a>, the generalized <span class="math notranslate nohighlight">\(P\)</span>-partition
enumerator is the quasisymmetric function
<span class="math notranslate nohighlight">\(\Gamma\left(\mathbf{E}, w\right)\)</span>, where <span class="math notranslate nohighlight">\(\mathbf{E}\)</span> is the
special double poset <span class="math notranslate nohighlight">\((P, &lt;_P, \prec)\)</span>, and where
<span class="math notranslate nohighlight">\(w\)</span> is the dictionary <code class="docutils literal notranslate"><span class="pre">weights</span></code> (regarded as a function from
<span class="math notranslate nohighlight">\(P\)</span> to the positive integers).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tup</span></code> – the tuple containing all elements of <span class="math notranslate nohighlight">\(P\)</span> (each of
them exactly once), in the order dictated by the total order
<span class="math notranslate nohighlight">\(\prec\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">R</span></code> – a commutative ring</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">weights</span></code> – (optional) a dictionary of positive integers,
indexed by elements of <span class="math notranslate nohighlight">\(P\)</span>; any missing item will be understood
as <span class="math notranslate nohighlight">\(1\)</span></p></li>
</ul>
<p>OUTPUT:</p>
<p>The <span class="math notranslate nohighlight">\(P\)</span>-partition enumerator of <code class="docutils literal notranslate"><span class="pre">self</span></code> according to <code class="docutils literal notranslate"><span class="pre">tup</span></code> in the
algebra <span class="math notranslate nohighlight">\(QSym\)</span> of quasisymmetric functions over the base ring <span class="math notranslate nohighlight">\(R\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">FP</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">p_partition_enumerator</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">QQ</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">FP</span>
<span class="go">2*M[1, 1, 1, 1] + 2*M[1, 2, 1] + M[2, 1, 1] + M[3, 1]</span>

<span class="gp">sage: </span><span class="n">expansion</span> <span class="o">=</span> <span class="n">FP</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">xs</span> <span class="o">=</span> <span class="n">expansion</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">expansion</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">([</span><span class="n">xs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">*</span><span class="n">xs</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">*</span><span class="n">xs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">*</span><span class="n">xs</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="n">b</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">])</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[],[]])</span>
<span class="gp">sage: </span><span class="n">FP</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">p_partition_enumerator</span><span class="p">((),</span> <span class="n">QQ</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">FP</span>
<span class="go">M[]</span>
</pre></div>
</div>
<p>With the <code class="docutils literal notranslate"><span class="pre">weights</span></code> parameter:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">FP</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">p_partition_enumerator</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">QQ</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">FP</span>
<span class="go">M[1, 2, 1, 1] + M[1, 3, 1] + M[2, 1, 1, 1] + M[2, 2, 1] + M[3, 1, 1] + M[4, 1]</span>
<span class="gp">sage: </span><span class="n">FP</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">p_partition_enumerator</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">QQ</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">FP</span>
<span class="go">M[1, 2, 1, 1] + M[1, 3, 1] + M[2, 1, 1, 1] + M[2, 2, 1] + M[3, 1, 1] + M[4, 1]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">FP</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">p_partition_enumerator</span><span class="p">((</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="n">QQ</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">},</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">FP</span>
<span class="go">M[3, 5, 7] + M[3, 7, 5] + M[3, 12]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">FP</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">p_partition_enumerator</span><span class="p">((</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="n">QQ</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">},</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">FP</span>
<span class="go">M[3, 5, 7] + M[3, 12] + M[5, 3, 7] + M[8, 7]</span>
<span class="gp">sage: </span><span class="n">FP</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">p_partition_enumerator</span><span class="p">((</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">),</span> <span class="n">QQ</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">},</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">FP</span>
<span class="go">M[3, 5, 7] + M[3, 12] + M[5, 3, 7] + M[5, 10] + M[8, 7] + M[15]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.plot">
<span class="sig-name descname"><span class="pre">plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label_elements</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">element_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'acyclic'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cover_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.plot" title="Permalink to this definition">#</a></dt>
<dd><p>Return a Graphic object for the Hasse diagram of the poset.</p>
<p>If the poset is ranked, the plot uses the rank function for
the heights of the elements.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p>Options to change element look:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">element_colors</span></code> - a dictionary where keys are colors and values
are lists of elements</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">element_color</span></code> - a color for elements not set in
<code class="docutils literal notranslate"><span class="pre">element_colors</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">element_shape</span></code> - the shape of elements, like <code class="docutils literal notranslate"><span class="pre">'s'</span></code> for
square; see <a class="reference external" href="https://matplotlib.org/api/markers_api.html">https://matplotlib.org/api/markers_api.html</a> for the list</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">element_size</span></code> (default: 200) - the size of elements</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">label_elements</span></code> (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) - whether to display
element labels</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">element_labels</span></code> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) - a dictionary where keys
are elements and values are labels to show</p></li>
</ul>
</li>
<li><p>Options to change cover relation look:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">cover_colors</span></code> - a dictionary where keys are colors and values
are lists of cover relations given as pairs of elements</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cover_color</span></code> - a color for elements not set in
<code class="docutils literal notranslate"><span class="pre">cover_colors</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cover_style</span></code> - style for cover relations: <code class="docutils literal notranslate"><span class="pre">'solid'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'dashed'</span></code>, <code class="docutils literal notranslate"><span class="pre">'dotted'</span></code> or <code class="docutils literal notranslate"><span class="pre">'dashdot'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cover_labels</span></code> - a dictionary, list or function representing
labels of the covers of the poset. When set to <code class="docutils literal notranslate"><span class="pre">None</span></code> (default)
no label is displayed on the edges of the Hasse Diagram.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cover_labels_background</span></code> - a background color for cover
relations. The default is “white”. To achieve a transparent
background use “transparent”.</p></li>
</ul>
</li>
<li><p>Options to change overall look:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">figsize</span></code> (default: 8) - size of the whole plot</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">title</span></code> - a title for the plot</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fontsize</span></code> - fontsize for the title</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">border</span></code> (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) - whether to draw a border over the
plot</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All options of <a class="reference external" href="../../../../graphs/sage/graphs/generic_graph.html#sage.graphs.generic_graph.GenericGraph.plot" title="(in Graph Theory v9.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GenericGraph.plot</span></code></a> are also available
through this function.</p>
</div>
<p>EXAMPLES:</p>
<p>This function can be used without any parameters:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D12</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DivisorLattice</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D12</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="go">Graphics object consisting of 14 graphics primitives</span>
</pre></div>
</div>
<p>Just the abstract form of the poset; examples of relabeling:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D12</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">label_elements</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">Graphics object consisting of 8 graphics primitives</span>
<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="mi">12</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
<span class="gp">sage: </span><span class="n">D12</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">element_labels</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
<span class="go">Graphics object consisting of 14 graphics primitives</span>
<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span><span class="nb">str</span><span class="p">(</span><span class="n">factor</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">D12</span><span class="p">}</span>
<span class="gp">sage: </span><span class="n">D12</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">element_labels</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
<span class="go">Graphics object consisting of 14 graphics primitives</span>
</pre></div>
</div>
<p>Some settings for coverings:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="p">{(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span> <span class="n">b</span><span class="o">/</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">D12</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()}</span>
<span class="gp">sage: </span><span class="n">D12</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cover_labels</span><span class="o">=</span><span class="n">d</span><span class="p">,</span> <span class="n">cover_color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">cover_style</span><span class="o">=</span><span class="s1">&#39;dotted&#39;</span><span class="p">)</span>
<span class="go">Graphics object consisting of 21 graphics primitives</span>
</pre></div>
</div>
<p>To emphasize some elements and show some options:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">LatticePoset</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">12</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
<span class="gp">....: </span>                  <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">13</span><span class="p">],</span>
<span class="gp">....: </span>                  <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">12</span><span class="p">],</span> <span class="mi">7</span><span class="p">:</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="mi">8</span><span class="p">:</span> <span class="p">[</span><span class="mi">13</span><span class="p">],</span> <span class="mi">9</span><span class="p">:</span> <span class="p">[</span><span class="mi">13</span><span class="p">],</span>
<span class="gp">....: </span>                  <span class="mi">10</span><span class="p">:</span> <span class="p">[</span><span class="mi">12</span><span class="p">],</span> <span class="mi">11</span><span class="p">:</span> <span class="p">[</span><span class="mi">12</span><span class="p">],</span> <span class="mi">12</span><span class="p">:</span> <span class="p">[</span><span class="mi">13</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">frattini_sublattice</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F_internal</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">L</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">border</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">element_shape</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">,</span>
<span class="gp">....: </span>       <span class="n">element_size</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span> <span class="n">element_color</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span>
<span class="gp">....: </span>       <span class="n">element_colors</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;blue&#39;</span><span class="p">:</span> <span class="n">F</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">:</span> <span class="n">L</span><span class="o">.</span><span class="n">double_irreducibles</span><span class="p">()},</span>
<span class="gp">....: </span>       <span class="n">cover_color</span><span class="o">=</span><span class="s1">&#39;lightgray&#39;</span><span class="p">,</span> <span class="n">cover_colors</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;black&#39;</span><span class="p">:</span> <span class="n">F_internal</span><span class="p">},</span>
<span class="gp">....: </span>       <span class="n">title</span><span class="o">=</span><span class="s1">&#39;The Frattini</span><span class="se">\n</span><span class="s1">sublattice in blue&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="go">Graphics object consisting of 39 graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.product">
<span class="sig-name descname"><span class="pre">product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.product" title="Permalink to this definition">#</a></dt>
<dd><p>Return the Cartesian product of the poset with <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>The Cartesian (or ‘direct’) product of <span class="math notranslate nohighlight">\(P\)</span> and
<span class="math notranslate nohighlight">\(Q\)</span> is defined by <span class="math notranslate nohighlight">\((p, q) \le (p', q')\)</span> iff <span class="math notranslate nohighlight">\(p \le p'\)</span>
in <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(q \le q'\)</span> in <span class="math notranslate nohighlight">\(Q\)</span>.</p>
<p>Product of (semi)lattices are returned as a (semi)lattice.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">PQ</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> <span class="p">;</span> <span class="n">PQ</span>
<span class="go">Finite lattice containing 12 elements</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">PQ</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span>
<span class="go">17</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">PQ</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>One can also simply use <span class="math notranslate nohighlight">\(*\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">*</span><span class="n">Q</span>
<span class="go">Finite lattice containing 6 elements</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="cartesian_product.html#sage.combinat.posets.cartesian_product.CartesianProductPoset" title="sage.combinat.posets.cartesian_product.CartesianProductPoset"><code class="xref py py-class docutils literal notranslate"><span class="pre">CartesianProductPoset</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.factor" title="sage.combinat.posets.posets.FinitePoset.factor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">factor()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.promotion">
<span class="sig-name descname"><span class="pre">promotion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.promotion" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the (extended) promotion on the linear extension
of the poset <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">i</span></code> – an integer between <span class="math notranslate nohighlight">\(1\)</span> and <span class="math notranslate nohighlight">\(n\)</span> (default: <span class="math notranslate nohighlight">\(1\)</span>)</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>an isomorphic poset, with the same default linear extension</p></li>
</ul>
<p>The extended promotion is defined on a poset <code class="docutils literal notranslate"><span class="pre">self</span></code> of size
<span class="math notranslate nohighlight">\(n\)</span> by applying the promotion operator <span class="math notranslate nohighlight">\(\tau_i \tau_{i+1}
\cdots \tau_{n-1}\)</span> to the default linear extension <span class="math notranslate nohighlight">\(\pi\)</span> of <code class="docutils literal notranslate"><span class="pre">self</span></code>
(see <a class="reference internal" href="linear_extensions.html#sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.promotion" title="sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.promotion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">promotion()</span></code></a>),
and relabeling <code class="docutils literal notranslate"><span class="pre">self</span></code> accordingly. For more details see <a class="reference internal" href="../../../../references/index.html#stan2009" id="id25"><span>[Stan2009]</span></a>.</p>
<p>When the elements of the poset <code class="docutils literal notranslate"><span class="pre">self</span></code> are labelled by
<span class="math notranslate nohighlight">\(\{1,2,\ldots,n\}\)</span>, the linear extension is the identity, and
<span class="math notranslate nohighlight">\(i=1\)</span>, the above algorithm corresponds to the promotion
operator on posets defined by Schützenberger as
follows. Remove <span class="math notranslate nohighlight">\(1\)</span> from <code class="docutils literal notranslate"><span class="pre">self</span></code> and replace it by the
minimum <span class="math notranslate nohighlight">\(j\)</span> of all labels covering <span class="math notranslate nohighlight">\(1\)</span> in the poset. Then,
remove <span class="math notranslate nohighlight">\(j\)</span> and replace it by the minimum of all labels
covering <span class="math notranslate nohighlight">\(j\)</span>, and so on.  This process ends when a label is a
local maximum. Place the label <span class="math notranslate nohighlight">\(n+1\)</span> at this vertex.  Finally,
decrease all labels by <span class="math notranslate nohighlight">\(1\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]]),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">facade</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">promotion</span><span class="p">()</span>
<span class="go">Finite poset containing 2 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">promotion</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 5, 6, 4, 7]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">promotion</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="n">Q</span>
<span class="go">Finite poset containing 7 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 6], [2, 3], [2, 5], [3, 7], [5, 7], [6, 4]]</span>
</pre></div>
</div>
<p>Note that if one wants to obtain the promotion defined by
Schützenberger’s algorithm directly on the poset, one needs
to make sure the linear extension is the identity:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">with_linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">promotion</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="n">Q</span>
<span class="go">Finite poset containing 7 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 6], [2, 3], [2, 4], [3, 5], [4, 5], [6, 7]]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">promotion</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [4, 7], [5, 7]]</span>
</pre></div>
</div>
<p>Here is an example for a poset not labelled by <span class="math notranslate nohighlight">\(\{1, 2, \ldots, n\}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 5, 6, 10, 15, 30]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [1, 5], [2, 6], [2, 10], [3, 6], [3, 15],</span>
<span class="go"> [5, 10], [5, 15], [6, 30], [10, 30], [15, 30]]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">promotion</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="n">Q</span>
<span class="go">Finite poset containing 8 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [1, 6], [2, 5], [2, 15], [3, 5], [3, 10],</span>
<span class="go"> [5, 30], [6, 10], [6, 15], [10, 30], [15, 30]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extension" title="sage.combinat.posets.posets.FinitePoset.linear_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">linear_extension()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.with_linear_extension" title="sage.combinat.posets.posets.FinitePoset.with_linear_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">with_linear_extension()</span></code></a> and the <code class="docutils literal notranslate"><span class="pre">linear_extension</span></code> option of <a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><code class="xref py py-func docutils literal notranslate"><span class="pre">Poset()</span></code></a></p></li>
<li><p><a class="reference internal" href="linear_extensions.html#sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.promotion" title="sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.promotion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">promotion()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.evacuation" title="sage.combinat.posets.posets.FinitePoset.evacuation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">evacuation()</span></code></a></p></li>
</ul>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li><p>Anne Schilling (2012-02-18)</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.random_linear_extension">
<span class="sig-name descname"><span class="pre">random_linear_extension</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.random_linear_extension" title="Permalink to this definition">#</a></dt>
<dd><p>Return a random linear extension of the poset.</p>
<p>The distribution is not uniform.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">set_random_seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># results are reproduceable</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">random_linear_extension</span><span class="p">()</span>
<span class="go">[0, 2, 8, 1, 9, 4, 5, 10, 6, 12, 14, 13, 3, 7, 11, 15]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.random_maximal_antichain">
<span class="sig-name descname"><span class="pre">random_maximal_antichain</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.random_maximal_antichain" title="Permalink to this definition">#</a></dt>
<dd><p>Return a random maximal antichain of the poset.</p>
<p>The distribution is not uniform.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">set_random_seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># results are reproduceable</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">random_maximal_antichain</span><span class="p">()</span>
<span class="go">[1, 8, 2, 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.random_maximal_chain">
<span class="sig-name descname"><span class="pre">random_maximal_chain</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.random_maximal_chain" title="Permalink to this definition">#</a></dt>
<dd><p>Return a random maximal chain of the poset.</p>
<p>The distribution is not uniform.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">set_random_seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># results are reproduceable</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">random_maximal_chain</span><span class="p">()</span>
<span class="go">[0, 2, 10, 11, 15]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.random_order_ideal">
<span class="sig-name descname"><span class="pre">random_order_ideal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'down'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.random_order_ideal" title="Permalink to this definition">#</a></dt>
<dd><p>Return a random order ideal with uniform probability.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">direction</span></code> – <code class="docutils literal notranslate"><span class="pre">'up'</span></code>, <code class="docutils literal notranslate"><span class="pre">'down'</span></code> or <code class="docutils literal notranslate"><span class="pre">'antichain'</span></code>
(default: <code class="docutils literal notranslate"><span class="pre">'down'</span></code>)</p></li>
</ul>
<p>OUTPUT:</p>
<p>A randomly selected order ideal (or order filter if
<code class="docutils literal notranslate"><span class="pre">direction='up'</span></code>, or antichain if <code class="docutils literal notranslate"><span class="pre">direction='antichain'</span></code>)
where all order ideals have equal probability of occurring.</p>
<p>ALGORITHM:</p>
<p>Uses the coupling from the past algorithm described in <a class="reference internal" href="../../../../references/index.html#propp1997" id="id26"><span>[Propp1997]</span></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">random_order_ideal</span><span class="p">()</span>  <span class="c1"># random</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">random_order_ideal</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="s1">&#39;up&#39;</span><span class="p">)</span>  <span class="c1"># random</span>
<span class="go">[6, 7]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">random_order_ideal</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="s1">&#39;antichain&#39;</span><span class="p">)</span>  <span class="c1"># random</span>
<span class="go">[1, 2]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">TamariLattice</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">random_order_ideal</span><span class="p">(</span><span class="s1">&#39;antichain&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_antichain_of_poset</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">random_order_ideal</span><span class="p">(</span><span class="s1">&#39;up&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_order_filter</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">random_order_ideal</span><span class="p">(</span><span class="s1">&#39;down&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_order_ideal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.random_subposet">
<span class="sig-name descname"><span class="pre">random_subposet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.random_subposet" title="Permalink to this definition">#</a></dt>
<dd><p>Return a random subposet that contains each element with
probability <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">set_random_seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># Results are reproducible</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">random_subposet</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[0, 2], [0, 5], [2, 3], [3, 7], [5, 7]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.rank">
<span class="sig-name descname"><span class="pre">rank</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.rank" title="Permalink to this definition">#</a></dt>
<dd><p>Return the rank of an element <code class="docutils literal notranslate"><span class="pre">element</span></code> in the poset <code class="docutils literal notranslate"><span class="pre">self</span></code>,
or the rank of the poset if <code class="docutils literal notranslate"><span class="pre">element</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>(The rank of a poset is the length of the longest chain of
elements of the poset. This is sometimes called the length of a poset.)</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[]],</span> <span class="n">facade</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[],[]])</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">SymmetricGroupBruhatOrderPoset</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[(</span><span class="n">v</span><span class="p">,</span><span class="n">P</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">P</span><span class="p">]</span>
<span class="go">[(&#39;1234&#39;, 0),</span>
<span class="go"> (&#39;1243&#39;, 1),</span>
<span class="go">...</span>
<span class="go"> (&#39;4312&#39;, 5),</span>
<span class="go"> (&#39;4321&#39;, 6)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.rank_function">
<span class="sig-name descname"><span class="pre">rank_function</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.rank_function" title="Permalink to this definition">#</a></dt>
<dd><p>Return the (normalized) rank function of the poset,
if it exists.</p>
<p>A <em>rank function</em> of a poset <span class="math notranslate nohighlight">\(P\)</span> is a function <span class="math notranslate nohighlight">\(r\)</span>
that maps elements of <span class="math notranslate nohighlight">\(P\)</span> to integers and satisfies:
<span class="math notranslate nohighlight">\(r(x) = r(y) + 1\)</span> if <span class="math notranslate nohighlight">\(x\)</span> covers <span class="math notranslate nohighlight">\(y\)</span>. The function <span class="math notranslate nohighlight">\(r\)</span>
is normalized such that its minimum value on every
connected component of the Hasse diagram of <span class="math notranslate nohighlight">\(P\)</span> is
<span class="math notranslate nohighlight">\(0\)</span>. This determines the function <span class="math notranslate nohighlight">\(r\)</span> uniquely (when
it exists).</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>a lambda function, if the poset admits a rank function</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>, if the poset does not admit a rank function</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]),</span> <span class="n">facade</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rank_function</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">]]),</span> <span class="n">facade</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rank_function</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]]),</span> <span class="n">facade</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">rank_function</span><span class="p">();</span> <span class="n">f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.rees_product">
<span class="sig-name descname"><span class="pre">rees_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.rees_product" title="Permalink to this definition">#</a></dt>
<dd><p>Return the Rees product of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>This is only defined if both posets are graded.</p>
<p>The underlying set is the set of pairs <span class="math notranslate nohighlight">\((p,q)\)</span> in the Cartesian
product such that <span class="math notranslate nohighlight">\(\operatorname{rk}(p) \geq \operatorname{rk}(q)\)</span>.</p>
<p>This operation was defined by Björner and Welker in <a class="reference internal" href="../../../../references/index.html#bjwe2005" id="id27"><span>[BjWe2005]</span></a>.
Other references are <a class="reference internal" href="../../../../references/index.html#mbre2011" id="id28"><span>[MBRe2011]</span></a> and <a class="reference internal" href="../../../../references/index.html#lsw2012" id="id29"><span>[LSW2012]</span></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B3</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B3t</span> <span class="o">=</span> <span class="n">B3</span><span class="o">.</span><span class="n">subposet</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">C3</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">B3t</span><span class="o">.</span><span class="n">rees_product</span><span class="p">(</span><span class="n">C3</span><span class="p">);</span> <span class="n">D</span>
<span class="go">Finite poset containing 12 elements</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">minimal_elements</span><span class="p">())</span>
<span class="go">[(1, 0), (2, 0), (4, 0)]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">maximal_elements</span><span class="p">())</span>
<span class="go">[(7, 0), (7, 1), (7, 2)]</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">with_bounds</span><span class="p">()</span><span class="o">.</span><span class="n">moebius_function</span><span class="p">(</span><span class="s1">&#39;bottom&#39;</span><span class="p">,</span><span class="s1">&#39;top&#39;</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.product" title="sage.combinat.posets.posets.FinitePoset.product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">product()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_product" title="sage.combinat.posets.posets.FinitePoset.ordinal_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ordinal_product()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.star_product" title="sage.combinat.posets.posets.FinitePoset.star_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">star_product()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.relabel">
<span class="sig-name descname"><span class="pre">relabel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">relabeling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.relabel" title="Permalink to this definition">#</a></dt>
<dd><p>Return a copy of this poset with its elements relabeled.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">relabeling</span></code> – a function, dictionary, list or tuple</p></li>
</ul>
<p>The given function or dictionary must map each (non-wrapped)
element of <code class="docutils literal notranslate"><span class="pre">self</span></code> to some distinct object. The given list or tuple
must be made of distinct objects.</p>
<p>When the input is a list or a tuple, the relabeling uses
the total ordering of the elements of the poset given by
<code class="docutils literal notranslate"><span class="pre">list(self)</span></code>.</p>
<p>If no relabeling is given, the poset is relabeled by integers
from <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(n-1\)</span> according to one of its linear extensions. This means
that <span class="math notranslate nohighlight">\(i&lt;j\)</span> as integers whenever <span class="math notranslate nohighlight">\(i&lt;j\)</span> in the relabeled poset.</p>
<p>EXAMPLES:</p>
<p>Relabeling using a function:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [2, 4], [2, 6], [3, 6], [4, 12], [6, 12]]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[2, 3, 4, 5, 7, 13]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[2, 3], [2, 4], [3, 5], [3, 7], [4, 7], [5, 13], [7, 13]]</span>
</pre></div>
</div>
<p>Relabeling using a dictionary:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">facade</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">relabeling</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="o">.</span><span class="n">element</span><span class="p">:</span><span class="n">i</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">P</span><span class="p">)}</span>
<span class="gp">sage: </span><span class="n">relabeling</span>
<span class="go">{1: 0, 2: 1, 3: 2, 4: 3, 6: 4, 12: 5}</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">relabeling</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4, 5]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[0, 1], [0, 2], [1, 3], [1, 4], [2, 4], [3, 5], [4, 5]]</span>
</pre></div>
</div>
<p>Mind the <code class="docutils literal notranslate"><span class="pre">c.element</span></code>; this is because the relabeling is
applied to the elements of the poset without the wrapping.
Thanks to this convention, the same relabeling function can
be used both for facade or non facade posets.</p>
<p>Relabeling using a list:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 4]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[0, 1], [0, 2], [1, 4], [2, 3], [3, 4]]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;abcde&#39;</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[&#39;a&#39;, &#39;b&#39;], [&#39;a&#39;, &#39;c&#39;], [&#39;b&#39;, &#39;e&#39;], [&#39;c&#39;, &#39;d&#39;], [&#39;d&#39;, &#39;e&#39;]]</span>
</pre></div>
</div>
<p>Default behaviour is increasing relabeling:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a2</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">a2</span> <span class="o">*</span> <span class="n">a2</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">relabel</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[0, 1], [0, 2], [1, 3], [2, 3]]</span>
</pre></div>
</div>
<p>Relabeling a (semi)lattice gives a (semi)lattice:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">JoinSemilattice</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Finite join-semilattice containing 2 elements</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As can be seen in the above examples, the default linear
extension of <code class="docutils literal notranslate"><span class="pre">Q</span></code> is that of <code class="docutils literal notranslate"><span class="pre">P</span></code> after relabeling. In
particular, <code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span></code> share the same internal Hasse
diagram.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.relations">
<span class="sig-name descname"><span class="pre">relations</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.relations" title="Permalink to this definition">#</a></dt>
<dd><p>Return the list of all relations of the poset.</p>
<p>A relation is a pair of elements <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> such that <span class="math notranslate nohighlight">\(x \leq y\)</span>
in the poset.</p>
<p>The number of relations is the dimension of the incidence
algebra.</p>
<p>OUTPUT:</p>
<p>A list of pairs (each pair is a list), where the first element
of the pair is less than or equal to the second element.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">relations</span><span class="p">()</span>
<span class="go">[[1, 1], [1, 2], [1, 3], [1, 4], [0, 0], [0, 2], [0, 3],</span>
<span class="go">[0, 4], [2, 2], [2, 3], [2, 4], [3, 3], [3, 4], [4, 4]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_number" title="sage.combinat.posets.posets.FinitePoset.relations_number"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relations_number()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_iterator" title="sage.combinat.posets.posets.FinitePoset.relations_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relations_iterator()</span></code></a></p>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li><p>Rob Beezer (2011-05-04)</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.relations_iterator">
<span class="sig-name descname"><span class="pre">relations_iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.relations_iterator" title="Permalink to this definition">#</a></dt>
<dd><p>Return an iterator for all the relations of the poset.</p>
<p>A relation is a pair of elements <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> such that <span class="math notranslate nohighlight">\(x \leq y\)</span>
in the poset.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">strict</span></code> – a boolean (default <code class="docutils literal notranslate"><span class="pre">False</span></code>) if <code class="docutils literal notranslate"><span class="pre">True</span></code>, returns
an iterator over relations <span class="math notranslate nohighlight">\(x &lt; y\)</span>, excluding all
relations <span class="math notranslate nohighlight">\(x \leq x\)</span>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A generator that produces pairs (each pair is a list), where the
first element of the pair is less than or equal to the second element.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">relations_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">&lt;class &#39;generator&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">([1, 1], [1, 2])</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">relations_iterator</span><span class="p">(</span><span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[[0, 1], [0, 2], [0, 4], [0, 3], [1, 4], [2, 3], [2, 4], [3, 4]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_number" title="sage.combinat.posets.posets.FinitePoset.relations_number"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relations_number()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations" title="sage.combinat.posets.posets.FinitePoset.relations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relations()</span></code></a>.</p>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li><p>Rob Beezer (2011-05-04)</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.relations_number">
<span class="sig-name descname"><span class="pre">relations_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.relations_number" title="Permalink to this definition">#</a></dt>
<dd><p>Return the number of relations in the poset.</p>
<p>A relation is a pair of elements <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> such that <span class="math notranslate nohighlight">\(x\leq y\)</span>
in the poset.</p>
<p>Relations are also often called intervals. The number of
intervals is the dimension of the incidence algebra.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">relations_number</span><span class="p">()</span>
<span class="go">13</span>

<span class="gp">sage: </span><span class="n">posets</span><span class="o">.</span><span class="n">TamariLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">relations_number</span><span class="p">()</span>
<span class="go">68</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_iterator" title="sage.combinat.posets.posets.FinitePoset.relations_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relations_iterator()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations" title="sage.combinat.posets.posets.FinitePoset.relations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relations()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.show">
<span class="sig-name descname"><span class="pre">show</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label_elements</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">element_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cover_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.show" title="Permalink to this definition">#</a></dt>
<dd><p>Displays the Hasse diagram of the poset.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">label_elements</span></code> (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) - whether to display
element labels</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">element_labels</span></code> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) - a dictionary of
element labels</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cover_labels</span></code> - a dictionary, list or function representing labels
of the covers of <code class="docutils literal notranslate"><span class="pre">self</span></code>. When set to <code class="docutils literal notranslate"><span class="pre">None</span></code> (default) no label is
displayed on the edges of the Hasse Diagram.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method also accepts:</p>
<blockquote>
<div><ul class="simple">
<li><p>All options of <a class="reference external" href="../../../../graphs/sage/graphs/generic_graph.html#sage.graphs.generic_graph.GenericGraph.plot" title="(in Graph Theory v9.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GenericGraph.plot</span></code></a></p></li>
<li><p>All options of <a class="reference external" href="../../../../plotting/sage/plot/graphics.html#sage.plot.graphics.Graphics.show" title="(in 2D Graphics v9.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graphics.show</span></code></a></p></li>
</ul>
</div></blockquote>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="p">})</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">label_elements</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">Graphics object consisting of 6 graphics primitives</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">elm_labs</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span><span class="s1">&#39;e&#39;</span><span class="p">}</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">element_labels</span><span class="o">=</span><span class="n">elm_labs</span><span class="p">)</span>
</pre></div>
</div>
<p>One more example with cover labels:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">cover_labels</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.slant_sum">
<span class="sig-name descname"><span class="pre">slant_sum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">element</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_element</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.slant_sum" title="Permalink to this definition">#</a></dt>
<dd><p>Return the slant sum poset of posets <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">p</span></code> by
connecting them with a cover relation <code class="docutils literal notranslate"><span class="pre">(p_element,</span> <span class="pre">element)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The element names of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">p</span></code> must be distinct.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">p</span></code> – the poset used for the slant sum</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">element</span></code> – the element of <code class="docutils literal notranslate"><span class="pre">self</span></code> that is the top of
the new cover relation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p_element</span></code> – the element of <code class="docutils literal notranslate"><span class="pre">p</span></code> that is the bottom of
the new cover relation</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">RibbonPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">)]])</span>
<span class="gp">sage: </span><span class="n">SS</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">slant_sum</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">cr</span> <span class="ow">in</span> <span class="n">SS</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span> <span class="k">for</span> <span class="n">cr</span> <span class="ow">in</span> <span class="n">R</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">cr</span> <span class="ow">in</span> <span class="n">SS</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span> <span class="k">for</span> <span class="n">cr</span> <span class="ow">in</span> <span class="n">H</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">SS</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.sorted">
<span class="sig-name descname"><span class="pre">sorted</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_incomparable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remove_duplicates</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.sorted" title="Permalink to this definition">#</a></dt>
<dd><p>Return the list <span class="math notranslate nohighlight">\(l\)</span> sorted by the poset.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">l</span></code> – a list of elements of the poset</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">allow_incomparable</span></code> – a Boolean. If <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default),
return incomparable elements in some order; if <code class="docutils literal notranslate"><span class="pre">False</span></code>, raise
an error if <code class="docutils literal notranslate"><span class="pre">l</span></code> is not a chain of the poset.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">remove_duplicates</span></code> - a Boolean. If <code class="docutils literal notranslate"><span class="pre">True</span></code>, remove duplicates
from the output list.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DivisorLattice</span><span class="p">(</span><span class="mi">36</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">sorted</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>  <span class="c1"># Random order for 4 and 6</span>
<span class="go">[1, 1, 2, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">sorted</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span> <span class="n">remove_duplicates</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[1, 2, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">sorted</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span> <span class="n">allow_incomparable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: the list contains incomparable elements</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">7</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">6</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">sorted</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>  <span class="c1"># Random order for 1 and 5</span>
<span class="go">[7, 1, 5, 4, 4]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">sorted</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="n">remove_duplicates</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[7, 1, 4]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">sorted</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="n">allow_incomparable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: the list contains incomparable elements</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.spectrum">
<span class="sig-name descname"><span class="pre">spectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.spectrum" title="Permalink to this definition">#</a></dt>
<dd><p>Return the <span class="math notranslate nohighlight">\(a\)</span>-spectrum of this poset.</p>
<p>The <span class="math notranslate nohighlight">\(a\)</span>-spectrum in a poset <span class="math notranslate nohighlight">\(P\)</span> is the list of integers whose
<span class="math notranslate nohighlight">\(i\)</span>-th position contains the number of linear extensions of <span class="math notranslate nohighlight">\(P\)</span>
that have <span class="math notranslate nohighlight">\(a\)</span> in the <span class="math notranslate nohighlight">\(i\)</span>-th location.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">a</span></code> – an element of this poset</p></li>
</ul>
<p>OUTPUT:</p>
<p>The <span class="math notranslate nohighlight">\(a\)</span>-spectrum of this poset, returned as a list.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">spectrum</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[0, 0, 1, 0, 0]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">spectrum</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">[0, 0, 0, 4, 12, 16, 16, 0]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">YoungDiagramPoset</span><span class="p">(</span><span class="n">Partition</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">spectrum</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[0, 8, 6, 2, 0, 0]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">spectrum</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[6, 6, 6, 6]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.star_product">
<span class="sig-name descname"><span class="pre">star_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pairs'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.star_product" title="Permalink to this definition">#</a></dt>
<dd><p>Return a poset isomorphic to the star product of the
poset with <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>Both this poset and <code class="docutils literal notranslate"><span class="pre">other</span></code> are expected to be bounded
and have at least two elements.</p>
<p>Let <span class="math notranslate nohighlight">\(P\)</span> be a poset with top element <span class="math notranslate nohighlight">\(\top_P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> be a poset
with bottom element <span class="math notranslate nohighlight">\(\bot_Q\)</span>. The star product of
<span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> is the ordinal sum of <span class="math notranslate nohighlight">\(P \setminus \top_P\)</span> and
<span class="math notranslate nohighlight">\(Q \setminus \bot_Q\)</span>.</p>
<p>Mathematically, it is only defined when <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> have no
common elements; here we force that by giving them different
names in the resulting poset.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">other</span></code> – a poset.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">labels</span></code> – (defaults to ‘pairs’) If set to ‘pairs’, each
element <code class="docutils literal notranslate"><span class="pre">v</span></code> in this poset will be named <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">v)</span></code> and each
element <code class="docutils literal notranslate"><span class="pre">u</span></code> in <code class="docutils literal notranslate"><span class="pre">other</span></code> will be named <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">u)</span></code> in the
result. If set to ‘integers’, the elements of the result
will be relabeled with consecutive integers.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>This is mostly used to combine two Eulerian posets to third one,
and makes sense for graded posets only:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B2</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B3</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">B2</span><span class="o">.</span><span class="n">star_product</span><span class="p">(</span><span class="n">B3</span><span class="p">);</span> <span class="n">P</span>
<span class="go">Finite poset containing 10 elements</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_eulerian</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We can get elements as pairs or as integers:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ABC</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">XYZ</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">ABC</span><span class="o">.</span><span class="n">star_product</span><span class="p">(</span><span class="n">XYZ</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[(0, &#39;a&#39;), (0, &#39;b&#39;), (1, &#39;y&#39;), (1, &#39;z&#39;)]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">ABC</span><span class="o">.</span><span class="n">star_product</span><span class="p">(</span><span class="n">XYZ</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="s1">&#39;integers&#39;</span><span class="p">))</span>
<span class="go">[0, 1, 2, 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.subposet">
<span class="sig-name descname"><span class="pre">subposet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elements</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.subposet" title="Permalink to this definition">#</a></dt>
<dd><p>Return the poset containing given elements with partial order
induced by this poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">,</span><span class="s1">&#39;e&#39;</span><span class="p">],</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">],</span>
<span class="gp">....: </span>           <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">],</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">subposet</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">]);</span> <span class="n">Q</span>
<span class="go">Finite poset containing 3 elements</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[&#39;b&#39;, &#39;f&#39;], [&#39;a&#39;, &#39;f&#39;]]</span>
</pre></div>
</div>
<p>A subposet of a non-facade poset is again a non-facade poset:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">(</span><span class="n">facade</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">subposet</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">Q</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.top">
<span class="sig-name descname"><span class="pre">top</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.top" title="Permalink to this definition">#</a></dt>
<dd><p>Return the unique maximal element of the poset, if it exists.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="mi">4</span><span class="p">:[],</span><span class="mi">5</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">top</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">top</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_top" title="sage.combinat.posets.posets.FinitePoset.has_top"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_top()</span></code></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.bottom" title="sage.combinat.posets.posets.FinitePoset.bottom"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bottom()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.unwrap">
<span class="sig-name descname"><span class="pre">unwrap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.unwrap" title="Permalink to this definition">#</a></dt>
<dd><p>Return the element <code class="docutils literal notranslate"><span class="pre">element</span></code> of the poset <code class="docutils literal notranslate"><span class="pre">self</span></code> in
unwrapped form.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">element</span></code> – an element of <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">x</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Finite poset containing 4 elements</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Integer Ring</span>
</pre></div>
</div>
<p>For a non facade poset, this is equivalent to using the
<code class="docutils literal notranslate"><span class="pre">.element</span></code> attribute:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">x</span><span class="o">.</span><span class="n">element</span>
<span class="go">True</span>
</pre></div>
</div>
<p>For a facade poset, this does nothing:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">x</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This method is useful in code where we do not know if <code class="docutils literal notranslate"><span class="pre">P</span></code> is
a facade poset or not.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.upper_covers">
<span class="sig-name descname"><span class="pre">upper_covers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.upper_covers" title="Permalink to this definition">#</a></dt>
<dd><p>Return the list of upper covers of the element <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>An upper cover of <span class="math notranslate nohighlight">\(x\)</span> is an element <span class="math notranslate nohighlight">\(y\)</span> such that <span class="math notranslate nohighlight">\(x &lt; y\)</span> and
there is no element <span class="math notranslate nohighlight">\(z\)</span> so that <span class="math notranslate nohighlight">\(x &lt; z &lt; y\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">upper_covers</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[2, 6]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.lower_covers" title="sage.combinat.posets.posets.FinitePoset.lower_covers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lower_covers()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.upper_covers_iterator">
<span class="sig-name descname"><span class="pre">upper_covers_iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.upper_covers_iterator" title="Permalink to this definition">#</a></dt>
<dd><p>Return an iterator over the upper covers of the element <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">upper_covers_iterator</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">&lt;class &#39;generator&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.width">
<span class="sig-name descname"><span class="pre">width</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">certificate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.width" title="Permalink to this definition">#</a></dt>
<dd><p>Return the width of the poset (the size of its longest antichain).</p>
<p>It is computed through a matching in a bipartite graph; see
<a class="reference external" href="https://en.wikipedia.org/wiki/Dilworth%27s_theorem">Wikipedia article Dilworth%27s_theorem</a> for more information. The width is
also called Dilworth number.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">certificate</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) whether to return
a certificate</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">certificate=True</span></code> return <code class="docutils literal notranslate"><span class="pre">(w,</span> <span class="pre">a)</span></code>, where <span class="math notranslate nohighlight">\(w\)</span> is the
width of a poset and <span class="math notranslate nohighlight">\(a\)</span> is an antichain of maximum cardinality.
If <code class="docutils literal notranslate"><span class="pre">certificate=False</span></code> return only width of the poset.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">width</span><span class="p">()</span>
<span class="go">6</span>

<span class="gp">sage: </span><span class="n">w</span><span class="p">,</span> <span class="n">max_achain</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">width</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">max_achain</span><span class="p">)</span>
<span class="go">[3, 5, 6, 9, 10, 12]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.with_bounds">
<span class="sig-name descname"><span class="pre">with_bounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">('bottom',</span> <span class="pre">'top')</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.with_bounds" title="Permalink to this definition">#</a></dt>
<dd><p>Return the poset with bottom and top elements adjoined.</p>
<p>This function adds top and bottom elements to the poset.
It will always add elements, it does not check if the poset
already has a bottom or a top element.</p>
<p>For lattices and semilattices this function returns a lattice.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">labels</span></code> – A pair of elements to use as a bottom and top
element of the poset. Default is strings <code class="docutils literal notranslate"><span class="pre">'bottom'</span></code> and
<code class="docutils literal notranslate"><span class="pre">'top'</span></code>. Either of them can be <code class="docutils literal notranslate"><span class="pre">None</span></code>, and then a new
bottom or top element will not be added.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">trafficsign</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">with_bounds</span><span class="p">();</span> <span class="n">trafficsign</span>
<span class="go">Finite poset containing 5 elements</span>
<span class="gp">sage: </span><span class="n">trafficsign</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[&#39;bottom&#39;, 0, 1, 2, &#39;top&#39;]</span>
<span class="gp">sage: </span><span class="n">trafficsign</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">with_bounds</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">trafficsign</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[-1, 0], [0, 1], [0, 2], [1, -2], [2, -2]]</span>

<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">with_bounds</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[-1, 0], [0, 1], [0, 2]]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>  <span class="c1"># A lattice</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">with_bounds</span><span class="p">()</span>
<span class="go">Finite lattice containing 7 elements</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">(</span><span class="n">facade</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">with_bounds</span><span class="p">()</span>
<span class="go">Finite lattice containing 7 elements</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.without_bounds" title="sage.combinat.posets.posets.FinitePoset.without_bounds"><code class="xref py py-meth docutils literal notranslate"><span class="pre">without_bounds()</span></code></a> for the reverse operation</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.with_linear_extension">
<span class="sig-name descname"><span class="pre">with_linear_extension</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">linear_extension</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.with_linear_extension" title="Permalink to this definition">#</a></dt>
<dd><p>Return a copy of <code class="docutils literal notranslate"><span class="pre">self</span></code> with a different default linear extension.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [2, 4], [2, 6], [3, 6], [4, 12], [6, 12]]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">with_linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">12</span><span class="p">])</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="go">[1, 3, 2, 6, 4, 12]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 3], [1, 2], [3, 6], [2, 6], [2, 4], [6, 12], [4, 12]]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>With the current implementation, this requires relabeling
the internal <a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Graph Theory v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraph</span></code></a> which is <span class="math notranslate nohighlight">\(O(n+m)\)</span>, where <span class="math notranslate nohighlight">\(n\)</span>
is the number of elements and <span class="math notranslate nohighlight">\(m\)</span> the number of cover relations.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.without_bounds">
<span class="sig-name descname"><span class="pre">without_bounds</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.without_bounds" title="Permalink to this definition">#</a></dt>
<dd><p>Return the poset without its top and bottom elements.</p>
<p>This is useful as an input for the method <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_complex" title="sage.combinat.posets.posets.FinitePoset.order_complex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_complex()</span></code></a>.</p>
<p>If there is either no top or no bottom element, this
raises a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">without_bounds</span><span class="p">();</span> <span class="n">Q</span>
<span class="go">Finite poset containing 3 elements</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[2, 3]]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">without_bounds</span><span class="p">();</span> <span class="n">Q</span>
<span class="go">Finite poset containing 3 elements</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.with_bounds" title="sage.combinat.posets.posets.FinitePoset.with_bounds"><code class="xref py py-meth docutils literal notranslate"><span class="pre">with_bounds()</span></code></a> for the reverse operation</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePoset.zeta_polynomial">
<span class="sig-name descname"><span class="pre">zeta_polynomial</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.zeta_polynomial" title="Permalink to this definition">#</a></dt>
<dd><p>Return the zeta polynomial of the poset.</p>
<p>The zeta polynomial of a poset is the unique polynomial <span class="math notranslate nohighlight">\(Z(q)\)</span>
such that for every integer <span class="math notranslate nohighlight">\(m &gt; 1\)</span>, <span class="math notranslate nohighlight">\(Z(m)\)</span> is the number of
weakly increasing sequences <span class="math notranslate nohighlight">\(x_1 \leq x_2 \leq \dots \leq x_{m-1}\)</span>
of elements of the poset.</p>
<p>The polynomial <span class="math notranslate nohighlight">\(Z(q)\)</span> is integral-valued, but generally does not
have integer coefficients. It can be computed as</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[Z(q) = \sum_{k \geq 1} \dbinom{q-2}{k-1} c_k,\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(c_k\)</span> is the number of all chains of length <span class="math notranslate nohighlight">\(k\)</span> in the
poset.</p>
<p>For more information, see section 3.12 of <a class="reference internal" href="../../../../references/index.html#enumcomb1" id="id30"><span>[EnumComb1]</span></a>.</p>
<p>In particular, <span class="math notranslate nohighlight">\(Z(2)\)</span> is the number of vertices and <span class="math notranslate nohighlight">\(Z(3)\)</span> is
the number of intervals.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">zeta_polynomial</span><span class="p">()</span>
<span class="go">q</span>
<span class="gp">sage: </span><span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">zeta_polynomial</span><span class="p">()</span>
<span class="go">1/2*q^2 + 1/2*q</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">zeta_polynomial</span><span class="p">()</span>
<span class="go">1/6*q^3 + q^2 - 1/6*q</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">zeta_polynomial</span><span class="p">()</span>
<span class="go">3/2*q^2 - 1/2*q</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePosets_n">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.combinat.posets.posets.</span></span><span class="sig-name descname"><span class="pre">FinitePosets_n</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePosets_n" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Parents and Elements v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.unique_representation.UniqueRepresentation</span></code></a>, <a class="reference external" href="../../../../structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Parents and Elements v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.parent.Parent</span></code></a></p>
<p>The finite enumerated set of all posets on <span class="math notranslate nohighlight">\(n\)</span> elements, up to an isomorphism.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">P</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span>
<span class="go">[]</span>
<span class="go">[[1, 2]]</span>
<span class="go">[[0, 1], [0, 2]]</span>
<span class="go">[[0, 1], [1, 2]]</span>
<span class="go">[[1, 2], [0, 2]]</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.FinitePosets_n.cardinality">
<span class="sig-name descname"><span class="pre">cardinality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_iterator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.FinitePosets_n.cardinality" title="Permalink to this definition">#</a></dt>
<dd><p>Return the cardinality of this object.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>By default, this returns pre-computed values obtained from
the On-Line Encyclopedia of Integer Sequences (<a class="reference external" href="https://oeis.org/A000112">OEIS sequence A000112</a>).
To override this, pass the argument <code class="docutils literal notranslate"><span class="pre">from_iterator=True</span></code>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cardinality</span><span class="p">(</span><span class="n">from_iterator</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.Poset">
<span class="sig-prename descclassname"><span class="pre">sage.combinat.posets.posets.</span></span><span class="sig-name descname"><span class="pre">Poset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">element_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cover_relations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linear_extension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">category</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">facade</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.Poset" title="Permalink to this definition">#</a></dt>
<dd><p>Construct a finite poset from various forms of input data.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">data</span></code> – different input are accepted by this constructor:</p>
<ol class="arabic">
<li><p>A two-element list or tuple <code class="docutils literal notranslate"><span class="pre">(E,</span> <span class="pre">R)</span></code>, where <code class="docutils literal notranslate"><span class="pre">E</span></code> is a
collection of elements of the poset and <code class="docutils literal notranslate"><span class="pre">R</span></code> is a collection
of relations <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code>, each represented as a two-element
list/tuple/iterable such as <code class="docutils literal notranslate"><span class="pre">[x,</span> <span class="pre">y]</span></code>. The poset is then
the transitive closure of the provided relations. If
<code class="docutils literal notranslate"><span class="pre">cover_relations=True</span></code>, then <code class="docutils literal notranslate"><span class="pre">R</span></code> is assumed to contain
exactly the cover relations of the poset. If <code class="docutils literal notranslate"><span class="pre">E</span></code> is empty,
then <code class="docutils literal notranslate"><span class="pre">E</span></code> is taken to be the set of elements appearing in
the relations <code class="docutils literal notranslate"><span class="pre">R</span></code>.</p></li>
<li><p>A two-element list or tuple <code class="docutils literal notranslate"><span class="pre">(E,</span> <span class="pre">f)</span></code>, where <code class="docutils literal notranslate"><span class="pre">E</span></code> is the set
of elements of the poset and <code class="docutils literal notranslate"><span class="pre">f</span></code> is a function such that,
for any pair <code class="docutils literal notranslate"><span class="pre">x,</span> <span class="pre">y</span></code> of elements of <code class="docutils literal notranslate"><span class="pre">E</span></code>, <code class="docutils literal notranslate"><span class="pre">f(x,</span> <span class="pre">y)</span></code>
returns whether <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code>. If <code class="docutils literal notranslate"><span class="pre">cover_relations=True</span></code>, then
<code class="docutils literal notranslate"><span class="pre">f(x,</span> <span class="pre">y)</span></code> should instead return whether <code class="docutils literal notranslate"><span class="pre">x</span></code> is covered by
<code class="docutils literal notranslate"><span class="pre">y</span></code>.</p></li>
<li><p>A dictionary of upper covers: <code class="docutils literal notranslate"><span class="pre">data[x]</span></code> is
a list of the elements that cover the element <span class="math notranslate nohighlight">\(x\)</span> in the poset.</p></li>
<li><p>A list or tuple of upper covers: <code class="docutils literal notranslate"><span class="pre">data[x]</span></code> is
a list of the elements that cover the element <span class="math notranslate nohighlight">\(x\)</span> in the poset.</p>
<p>If the set of elements is not a set of consecutive integers
starting from zero, then:</p>
<ul class="simple">
<li><p>every element must appear in the data, for example in its own entry.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">data</span></code> must be ordered in the same way as sorted elements.</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If data is a list or tuple of length <span class="math notranslate nohighlight">\(2\)</span>, then it is
handled by the case 2 above.</p>
</div>
</li>
<li><p>An acyclic, loop-free and multi-edge free <code class="docutils literal notranslate"><span class="pre">DiGraph</span></code>. If
<code class="docutils literal notranslate"><span class="pre">cover_relations</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the edges of the
digraph are assumed to correspond to the cover relations of
the poset. Otherwise, the cover relations are computed.</p></li>
<li><p>A previously constructed poset (the poset itself is returned).</p></li>
</ol>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">element_labels</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); an optional list or
dictionary of objects that label the poset elements.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cover_relations</span></code> – a boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether the
data can be assumed to describe a directed acyclic graph whose
arrows are cover relations; otherwise, the cover relations are
first computed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">linear_extension</span></code> – a boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to
use the provided list of elements as default linear extension
for the poset; otherwise a linear extension is computed. If the data
is given as the pair <code class="docutils literal notranslate"><span class="pre">(E,</span> <span class="pre">f)</span></code>, then <code class="docutils literal notranslate"><span class="pre">E</span></code> is taken to be the linear
extension.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">facade</span></code> – a boolean or <code class="docutils literal notranslate"><span class="pre">None</span></code> (default); whether the
<a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Poset()</span></code></a>’s elements should be wrapped to make them aware of the
Poset they belong to.</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">True</span></code>, the <a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Poset()</span></code></a>’s elements are exactly those
given as input.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">False</span></code>, the <a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Poset()</span></code></a>’s elements will become
<code class="xref py py-class docutils literal notranslate"><span class="pre">PosetElement</span></code> objects.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">None</span></code> (default) the expected behaviour is the behaviour
of <code class="docutils literal notranslate"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">True</span></code>, unless the opposite can be deduced from the
context (i.e. for instance if a <a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Poset()</span></code></a> is built from another
<a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Poset()</span></code></a>, itself built with <code class="docutils literal notranslate"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">False</span></code>)</p></li>
</ul>
</li>
</ul>
<p>OUTPUT:</p>
<p><code class="docutils literal notranslate"><span class="pre">FinitePoset</span></code> – an instance of the <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><code class="xref py py-class docutils literal notranslate"><span class="pre">FinitePoset</span></code></a> class.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">category</span></code> is specified, then the poset is created in this
category instead of <a class="reference external" href="../../../../categories/sage/categories/finite_posets.html#sage.categories.finite_posets.FinitePosets" title="(in Category Framework v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">FinitePosets</span></code></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="poset_examples.html#sage.combinat.posets.poset_examples.Posets" title="sage.combinat.posets.poset_examples.Posets"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posets</span></code></a>, <a class="reference external" href="../../../../categories/sage/categories/posets.html#sage.categories.posets.Posets" title="(in Category Framework v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posets</span></code></a>,
<a class="reference external" href="../../../../categories/sage/categories/finite_posets.html#sage.categories.finite_posets.FinitePosets" title="(in Category Framework v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">FinitePosets</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<ol class="arabic">
<li><p>Elements and cover relations:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">elms</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">rels</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">((</span><span class="n">elms</span><span class="p">,</span> <span class="n">rels</span><span class="p">),</span> <span class="n">cover_relations</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">facade</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">Finite poset containing 7 elements</span>
</pre></div>
</div>
<p>Elements and non-cover relations:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">elms</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">rels</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">[</span><span class="n">elms</span><span class="p">,</span><span class="n">rels</span><span class="p">]</span> <span class="p">,</span><span class="n">cover_relations</span><span class="o">=</span><span class="kc">False</span><span class="p">);</span> <span class="n">P</span>
<span class="go">Finite poset containing 4 elements</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [2, 3], [3, 4]]</span>
</pre></div>
</div>
</li>
<li><p>Elements and function: the standard permutations of [1, 2, 3, 4]
with the Bruhat order:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">elms</span> <span class="o">=</span> <span class="n">Permutations</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fcn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">,</span><span class="n">q</span> <span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">bruhat_lequal</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">((</span><span class="n">elms</span><span class="p">,</span> <span class="n">fcn</span><span class="p">))</span>
<span class="go">Finite poset containing 24 elements</span>
</pre></div>
</div>
<p>With a function that identifies the cover relations: the set
partitions of <span class="math notranslate nohighlight">\(\{1, 2, 3\}\)</span> ordered by refinement:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">elms</span> <span class="o">=</span> <span class="n">SetPartitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">fcn</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="kc">False</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">B</span><span class="p">):</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="kc">False</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="kc">True</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">((</span><span class="n">elms</span><span class="p">,</span> <span class="n">fcn</span><span class="p">),</span> <span class="n">cover_relations</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Finite poset containing 5 elements</span>
</pre></div>
</div>
</li>
<li><p>A dictionary of upper covers:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;c&#39;</span><span class="p">:[</span><span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;d&#39;</span><span class="p">:[]})</span>
<span class="go">Finite poset containing 4 elements</span>
</pre></div>
</div>
</li>
<li><p>A list of upper covers, with range(5) as set of vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[]])</span>
<span class="go">Finite poset containing 5 elements</span>
</pre></div>
</div>
<p>A list of upper covers, with letters as vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poset</span><span class="p">([[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span><span class="s2">&quot;b&quot;</span><span class="p">],[</span><span class="s2">&quot;b&quot;</span><span class="p">,</span><span class="s2">&quot;c&quot;</span><span class="p">],[</span><span class="s2">&quot;c&quot;</span><span class="p">]])</span>
<span class="go">Finite poset containing 3 elements</span>
</pre></div>
</div>
<p>A list of upper covers and a dictionary of labels:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">elm_labs</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="s2">&quot;a&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="s2">&quot;b&quot;</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="s2">&quot;c&quot;</span><span class="p">,</span><span class="mi">3</span><span class="p">:</span><span class="s2">&quot;d&quot;</span><span class="p">,</span><span class="mi">4</span><span class="p">:</span><span class="s2">&quot;e&quot;</span><span class="p">}</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[]],</span> <span class="n">elm_labs</span><span class="p">,</span> <span class="n">facade</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[a, b, c, d, e]</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The special case where the argument data is a list or tuple of
length 2 is handled by the case 2. So you cannot use this
method to input a 2-element poset.</p>
</div>
</li>
<li><p>An acyclic DiGraph.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">dag</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">(</span><span class="n">dag</span><span class="p">)</span>
<span class="go">Finite poset containing 6 elements</span>
</pre></div>
</div>
<p>Any directed acyclic graph without loops or multiple edges, as long
as <code class="docutils literal notranslate"><span class="pre">cover_relations=False</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">dig</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">dig</span><span class="o">.</span><span class="n">allows_multiple_edges</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">dig</span><span class="o">.</span><span class="n">allows_loops</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">dig</span><span class="o">.</span><span class="n">transitive_reduction</span><span class="p">()</span> <span class="o">==</span> <span class="n">dig</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">(</span><span class="n">dig</span><span class="p">,</span> <span class="n">cover_relations</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">Finite poset containing 6 elements</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">(</span><span class="n">dig</span><span class="p">,</span> <span class="n">cover_relations</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: Hasse diagram is not transitively reduced</span>
</pre></div>
</div>
</li>
</ol>
<p class="rubric">Default Linear extension</p>
<p>Every poset <span class="math notranslate nohighlight">\(P\)</span> obtained with <code class="docutils literal notranslate"><span class="pre">Poset</span></code> comes equipped with a
default linear extension, which is also used for enumerating
its elements. By default, this linear extension is computed,
and has no particular significance:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 4, 3, 6, 12]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()</span>
<span class="go">[1, 2, 4, 3, 6, 12]</span>
</pre></div>
</div>
<p>You may enforce a specific linear extension using the
<code class="docutils literal notranslate"><span class="pre">linear_extension</span></code> option:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
</pre></div>
</div>
<p>Depending on popular request, <code class="docutils literal notranslate"><span class="pre">Poset</span></code> might eventually get
modified to always use the provided list of elements as
default linear extension, when it is one.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extensions" title="sage.combinat.posets.posets.FinitePoset.linear_extensions"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FinitePoset.linear_extensions()</span></code></a></p>
</div>
<p class="rubric">Facade posets</p>
<p>When <code class="docutils literal notranslate"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">False</span></code>, the elements of a poset are wrapped so as to make
them aware that they belong to that poset:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">({</span><span class="s1">&#39;d&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">],</span><span class="s1">&#39;c&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">]}),</span> <span class="n">facade</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="ow">is</span> <span class="n">P</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This allows for comparing elements according to <span class="math notranslate nohighlight">\(P\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
<p>However, this may have surprising effects:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">my_elements</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">my_elements</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">P</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>and can be annoying when one wants to manipulate the elements of
the poset:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: unsupported operand parent(s) for +: &#39;Finite poset containing 4 elements&#39; and &#39;Finite poset containing 4 elements&#39;</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">element</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">element</span>
<span class="go">&#39;ab&#39;</span>
</pre></div>
</div>
<p>By default, facade posets are constructed instead:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">({</span><span class="s1">&#39;d&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">],</span><span class="s1">&#39;c&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">]}))</span>
</pre></div>
</div>
<p>In this example, the elements of the poset remain plain strings:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">d</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&lt;class &#39;str&#39;&gt;</span>
</pre></div>
</div>
<p>Of course, those strings are not aware of <span class="math notranslate nohighlight">\(P\)</span>. So to compare two
such strings, one needs to query <span class="math notranslate nohighlight">\(P\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>which models the usual mathematical notation <span class="math notranslate nohighlight">\(a &lt;_P b\)</span>.</p>
<p>Most operations seem to still work, but at this point there is no
guarantee whatsoever:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[&#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">principal_order_ideal</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="go">[&#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">principal_order_ideal</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="go">[&#39;d&#39;, &#39;b&#39;]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">principal_order_ideal</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
<span class="go">[&#39;d&#39;]</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Graph Theory v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraph</span></code></a> is used to construct the poset, and the
vertices of a <a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Graph Theory v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraph</span></code></a> are converted to plain Python
<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>’s if they are <a class="reference external" href="../../../../rings_standard/sage/rings/integer.html#sage.rings.integer.Integer" title="(in Standard Commutative Rings v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a>’s:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;class &#39;int&#39;&gt;</span>
</pre></div>
</div>
<p>This is worked around by systematically converting back the
vertices of a poset to <a class="reference external" href="../../../../rings_standard/sage/rings/integer.html#sage.rings.integer.Integer" title="(in Standard Commutative Rings v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a>’s if they are
<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>’s:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span><span class="o">.</span><span class="n">element</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.rings.integer.Integer&#39;&gt;</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">())</span>
<span class="go">&lt;class &#39;sage.rings.integer.Integer&#39;&gt;</span>
</pre></div>
</div>
<p>This may be abusive:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">),</span> <span class="n">facade</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Integer Ring</span>
</pre></div>
</div>
</div>
<p class="rubric">Unique representation</p>
<p>As most parents, <a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poset</span></code></a> have unique representation (see
<a class="reference external" href="../../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Parents and Elements v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueRepresentation</span></code></a>). Namely if two posets are created
from two equal data, then they are not only equal but actually
identical:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">data1</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">]]</span>
<span class="gp">sage: </span><span class="n">data2</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">]]</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">data1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">data2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="o">==</span> <span class="n">P2</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="ow">is</span> <span class="n">P2</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In situations where this behaviour is not desired, one can use the
<code class="docutils literal notranslate"><span class="pre">key</span></code> option:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">data2</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;bar&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="ow">is</span> <span class="n">P2</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="o">==</span> <span class="n">P2</span>
<span class="go">False</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">key</span></code> can be any hashable value and is passed down to
<a class="reference external" href="../../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Parents and Elements v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueRepresentation</span></code></a>. It is otherwise ignored by the
poset constructor.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.combinat.posets.posets.is_poset">
<span class="sig-prename descclassname"><span class="pre">sage.combinat.posets.posets.</span></span><span class="sig-name descname"><span class="pre">is_poset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.posets.posets.is_poset" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if a directed graph is acyclic and transitively
reduced, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.posets.posets</span> <span class="kn">import</span> <span class="n">is_poset</span>
<span class="gp">sage: </span><span class="n">dig</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">is_poset</span><span class="p">(</span><span class="n">dig</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">is_poset</span><span class="p">(</span><span class="n">dig</span><span class="o">.</span><span class="n">transitive_reduction</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="../q_analogues.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title"><span class="math notranslate nohighlight">\(q\)</span>-Analogues</div>
              </div>
              <svg><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="poset_examples.html">
              <svg><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Catalog of posets and lattices</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2005--2022, The Sage Development Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            Contents
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Finite posets</a><ul>
<li><a class="reference internal" href="#list-of-poset-methods">List of Poset methods</a></li>
<li><a class="reference internal" href="#classes-and-functions">Classes and functions</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/scripts/furo.js"></script>
    <script src="../../../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.1/dist/embed-amd.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"ZZ": "\\Bold{Z}", "NN": "\\Bold{N}", "RR": "\\Bold{R}", "CC": "\\Bold{C}", "QQ": "\\Bold{Q}", "QQbar": "\\overline{\\QQ}", "GF": ["\\Bold{F}_{#1}", 1], "Zp": ["\\Bold{Z}_{#1}", 1], "Qp": ["\\Bold{Q}_{#1}", 1], "Zmod": ["\\ZZ/#1\\ZZ", 1], "CDF": "\\Bold{C}", "CIF": "\\Bold{C}", "CLF": "\\Bold{C}", "RDF": "\\Bold{R}", "RIF": "\\Bold{I} \\Bold{R}", "RLF": "\\Bold{R}", "SL": "\\mathrm{SL}", "PSL": "\\mathrm{PSL}", "Bold": ["\\mathbf{#1}", 1]}, "inlineMath": [["$", "$"], ["\\(", "\\)"]], "maxBuffer": 51200, "autoload": {"color": [], "colorv2": ["color"]}}}</script>
    <script defer="defer" src="../../../../_static/mathjax/tex-chtml.js"></script>
    </body>
</html>