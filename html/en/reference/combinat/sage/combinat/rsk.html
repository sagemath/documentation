<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" /><link rel="next" title="Schubert Polynomials" href="schubert_polynomial.html" /><link rel="prev" title="Rooted (Unordered) Trees" href="rooted_tree.html" />

    <meta name="generator" content="sphinx-5.2.3, furo 2022.09.29"/>
        <title>Robinson-Schensted-Knuth correspondence - Combinatorics</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?digest=d81277517bee4d6b0349d71bb2661d4890b5617c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom-furo.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom-jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom-codemirror-monokai.css" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  --color-brand-primary: #0f0fff;
  --color-brand-content: #0f0fff;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">Combinatorics</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><div class="sidebar-scroll"><a class="sidebar-brand" href="../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../../_static/logo_sagemath_black.svg" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../../_static/logo_sagemath_white.svg" alt="Dark Logo"/>
  </div>
  
      <span class="sidebar-brand-text">Sage 10.2 Reference Manual</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-home">
  <div class="sidebar-tree">
    <ul><li class="toctree-l1">
      <a class="reference internal" href="../../index.html">Home - Combinatorics</a>
    </li></ul>
  </div>
</div><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="../../module_list.html">Comprehensive Module List</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="abstract_tree.html">Abstract Recursive Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="affine_permutation.html">Affine Permutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="algebraic_combinatorics.html">Algebraic combinatorics</a></li>
<li class="toctree-l2"><a class="reference internal" href="all.html">Combinatorics</a></li>
<li class="toctree-l2"><a class="reference internal" href="alternating_sign_matrix.html">Alternating Sign Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="backtrack.html">Backtracking</a></li>
<li class="toctree-l2"><a class="reference internal" href="baxter_permutations.html">Baxter permutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="bijectionist.html">A bijectionist’s toolkit</a></li>
<li class="toctree-l2"><a class="reference internal" href="binary_recurrence_sequences.html">Binary Recurrence Sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="binary_tree.html">Binary Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="blob_algebra.html">Blob Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="cartesian_product.html">Cartesian Products</a></li>
<li class="toctree-l2"><a class="reference internal" href="catalog_partitions.html">Enumerated sets of partitions, tableaux, …</a></li>
<li class="toctree-l2"><a class="reference internal" href="chas/all.html">Combinatorial Hopf algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="chas/fsym.html">Poirier-Reutenauer Hopf algebra of standard tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="chas/wqsym.html">Word Quasi-symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="cluster_algebra_quiver/all.html">Cluster algebras and quivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="cluster_algebra_quiver/cluster_seed.html">ClusterSeed</a></li>
<li class="toctree-l2"><a class="reference internal" href="cluster_algebra_quiver/mutation_class.html">mutation_class</a></li>
<li class="toctree-l2"><a class="reference internal" href="cluster_algebra_quiver/mutation_type.html">Helper functions for mutation types of quivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="cluster_algebra_quiver/quiver.html">Quiver</a></li>
<li class="toctree-l2"><a class="reference internal" href="cluster_algebra_quiver/quiver_mutation_type.html">Quiver mutation types</a></li>
<li class="toctree-l2"><a class="reference internal" href="cluster_complex.html">Cluster complex (or generalized dual associahedron)</a></li>
<li class="toctree-l2"><a class="reference internal" href="colored_permutations.html">Colored Permutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="combinat.html">Combinatorial Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="combinat_cython.html">Fast computation of combinatorial functions (Cython + mpz)</a></li>
<li class="toctree-l2"><a class="reference internal" href="combination.html">Combinations</a></li>
<li class="toctree-l2"><a class="reference internal" href="combinatorial_map.html">Combinatorial maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="composition.html">Integer compositions</a></li>
<li class="toctree-l2"><a class="reference internal" href="composition_signed.html">Signed Compositions</a></li>
<li class="toctree-l2"><a class="reference internal" href="composition_tableau.html">Composition Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="constellation.html">Constellations</a></li>
<li class="toctree-l2"><a class="reference internal" href="core.html">Cores</a></li>
<li class="toctree-l2"><a class="reference internal" href="counting.html">Counting</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/affine.html">Affine Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/affine_factorization.html">Affine factorization crystal of type <span class="math notranslate nohighlight">\(A\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/affinization.html">Affinization Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/alcove_path.html">Alcove paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/all.html">Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/bkk_crystals.html">Benkart-Kang-Kashiwara crystals for the general-linear Lie superalgebra</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/catalog.html">Catalog Of Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/catalog_elementary_crystals.html">Catalog Of Elementary Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/catalog_infinity_crystals.html">Catalog Of Crystal Models For <span class="math notranslate nohighlight">\(B(\infty)\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/catalog_kirillov_reshetikhin.html">Catalog Of Crystal Models For Kirillov-Reshetikhin Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/crystals.html">An introduction to crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/direct_sum.html">Direct Sum of Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/elementary_crystals.html">Elementary Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/fast_crystals.html">Fast Rank Two Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/fully_commutative_stable_grothendieck.html">Fully commutative stable Grothendieck crystal</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/generalized_young_walls.html">Crystals of Generalized Young Walls</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/highest_weight_crystals.html">Highest weight crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/induced_structure.html">Induced Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/infinity_crystals.html"><span class="math notranslate nohighlight">\(\mathcal{B}(\infty)\)</span> Crystals of Tableaux in Nonexceptional Types and <span class="math notranslate nohighlight">\(G_2\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/kac_modules.html">Crystals of Kac modules of the general-linear Lie superalgebra</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/kirillov_reshetikhin.html">Kirillov-Reshetikhin Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/kyoto_path_model.html">Kyoto Path Model for Affine Highest Weight Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/letters.html">Crystals of letters</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/littelmann_path.html">Littelmann paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/monomial_crystals.html">Crystals of Modified Nakajima Monomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/multisegments.html">Crystal of Bernstein-Zelevinsky Multisegments</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/mv_polytopes.html">Crystal Of Mirković-Vilonen (MV) Polytopes</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/pbw_crystal.html"><span class="math notranslate nohighlight">\(\mathcal{B}(\infty)\)</span> Crystal Of PBW Monomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/pbw_datum.html">PBW Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/polyhedral_realization.html">Polyhedral Realization of <span class="math notranslate nohighlight">\(B(\infty)\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/spins.html">Spin Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/star_crystal.html">Star-Crystal Structure On <span class="math notranslate nohighlight">\(B(\infty)\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/tensor_product.html">Tensor Products of Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/tensor_product_element.html">Tensor Products of Crystal Elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="cyclic_sieving_phenomenon.html">Cyclic sieving phenomenon</a></li>
<li class="toctree-l2"><a class="reference internal" href="debruijn_sequence.html">De Bruijn sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="degree_sequences.html">Degree sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="derangements.html">Derangements</a></li>
<li class="toctree-l2"><a class="reference internal" href="descent_algebra.html">Descent Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/all.html">Combinatorial designs and incidence structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/bibd.html">Balanced Incomplete Block Designs (BIBD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/resolvable_bibd.html">Resolvable Balanced Incomplete Block Design (RBIBD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/group_divisible_designs.html">Group-Divisible Designs (GDD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/block_design.html">Block designs</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/covering_array.html">Covering Arrays (CA)</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/covering_design.html">Covering designs: coverings of <span class="math notranslate nohighlight">\(t\)</span>-element subsets of a <span class="math notranslate nohighlight">\(v\)</span>-set by <span class="math notranslate nohighlight">\(k\)</span>-sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/database.html">Database of small combinatorial designs</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/design_catalog.html">Catalog of designs</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/designs_pyx.html">Cython functions for combinatorial designs</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/difference_family.html">Difference families</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/difference_matrices.html">Difference Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/evenly_distributed_sets.html">Evenly distributed sets in finite fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/ext_rep.html">External Representations of Block Designs</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/gen_quadrangles_with_spread.html">Database of generalised quadrangles with spread</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/incidence_structures.html">Incidence structures (i.e. hypergraphs, i.e. set systems)</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/latin_squares.html">Mutually Orthogonal Latin Squares (MOLS)</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/orthogonal_arrays.html">Orthogonal arrays (OA)</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/orthogonal_arrays_build_recursive.html">Orthogonal arrays (build recursive constructions)</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/orthogonal_arrays_find_recursive.html">Orthogonal arrays (find recursive constructions)</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/steiner_quadruple_systems.html">Steiner Quadruple Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/subhypergraph_search.html">Hypergraph isomorphic copy search</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/twographs.html">Two-graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="diagram.html">Combinatorial diagrams</a></li>
<li class="toctree-l2"><a class="reference internal" href="diagram_algebras.html">Diagram and Partition Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="dlx.html">Exact Cover Problem via Dancing Links</a></li>
<li class="toctree-l2"><a class="reference internal" href="dyck_word.html">Dyck Words</a></li>
<li class="toctree-l2"><a class="reference internal" href="e_one_star.html">Substitutions over unit cube faces (Rauzy fractals)</a></li>
<li class="toctree-l2"><a class="reference internal" href="enumerated_sets.html">Enumerated sets and combinatorial objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="enumeration_mod_permgroup.html">Tools for enumeration modulo the action of a permutation group</a></li>
<li class="toctree-l2"><a class="reference internal" href="expnums.html">Compute Bell and Uppuluri-Carpenter numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="family.html">Families</a></li>
<li class="toctree-l2"><a class="reference internal" href="fast_vector_partitions.html">Brent Yorgey’s fast algorithm for integer vector (multiset) partitions.</a></li>
<li class="toctree-l2"><a class="reference internal" href="fully_commutative_elements.html">Fully commutative elements of Coxeter groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="finite_state_machine.html">Finite state machines, automata, transducers</a></li>
<li class="toctree-l2"><a class="reference internal" href="finite_state_machine_generators.html">Common Automata and Transducers (Finite State Machines Generators)</a></li>
<li class="toctree-l2"><a class="reference internal" href="fqsym.html">Free Quasi-symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="free_module.html">Free modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="free_dendriform_algebra.html">Free Dendriform Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="free_prelie_algebra.html">Free Pre-Lie Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="fully_packed_loop.html">Fully packed loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="gelfand_tsetlin_patterns.html">Gelfand-Tsetlin Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="graph_path.html">Paths in Directed Acyclic Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="gray_codes.html">Gray codes</a></li>
<li class="toctree-l2"><a class="reference internal" href="growth.html">Growth diagrams and dual graded graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="grossman_larson_algebras.html">Grossman-Larson Hopf Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="hall_polynomial.html">Hall Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="hillman_grassl.html">The Hillman-Grassl correspondence</a></li>
<li class="toctree-l2"><a class="reference internal" href="integer_lists/base.html">Enumerated set of lists of integers with constraints: base classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="integer_lists/lists.html">Enumerated set of lists of integers with constraints: front-end</a></li>
<li class="toctree-l2"><a class="reference internal" href="integer_lists/invlex.html">Enumerated set of lists of integers with constraints, in inverse lexicographic order</a></li>
<li class="toctree-l2"><a class="reference internal" href="integer_matrices.html">Counting, generating, and manipulating non-negative integer matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="integer_vector.html">(Non-negative) Integer vectors</a></li>
<li class="toctree-l2"><a class="reference internal" href="integer_vector_weighted.html">Weighted Integer Vectors</a></li>
<li class="toctree-l2"><a class="reference internal" href="integer_vectors_mod_permgroup.html">Integer vectors modulo the action of a permutation group</a></li>
<li class="toctree-l2"><a class="reference internal" href="interval_posets.html">Tamari Interval-posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="k_tableau.html">Strong and weak tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="kazhdan_lusztig.html">Kazhdan-Lusztig Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="key_polynomial.html">Key polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="knutson_tao_puzzles.html">Knutson-Tao Puzzles</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrices/all.html">Combinatorics on matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrices/dancing_links.html">Dancing Links internal pyx code</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrices/dlxcpp.html">Dancing links C++ wrapper</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrices/hadamard_matrix.html">Hadamard matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrices/latin.html">Latin Squares</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="multiset_partition_into_sets_ordered.html">Ordered Multiset Partitions into Sets and the Minimaj Crystal</a></li>
<li class="toctree-l2"><a class="reference internal" href="ncsf_qsym/all.html">Non-commutative symmetric functions and quasi-symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ncsf_qsym/combinatorics.html">Common combinatorial tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="ncsf_qsym/generic_basis_code.html">Generic code for bases</a></li>
<li class="toctree-l2"><a class="reference internal" href="ncsf_qsym/ncsf.html">Non-Commutative Symmetric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ncsf_qsym/qsym.html">Quasisymmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ncsf_qsym/tutorial.html">Introduction to Quasisymmetric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ncsym/all.html">Symmetric functions in non-commuting variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="ncsym/bases.html">Bases for <span class="math notranslate nohighlight">\(NCSym\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="ncsym/dual.html">Dual Symmetric Functions in Non-Commuting Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="ncsym/ncsym.html">Symmetric Functions in Non-Commuting Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="necklace.html">Necklaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="non_decreasing_parking_function.html">Non-Decreasing Parking Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="nu_dyck_word.html"><span class="math notranslate nohighlight">\(\nu\)</span>-Dyck Words</a></li>
<li class="toctree-l2"><a class="reference internal" href="nu_tamari_lattice.html"><span class="math notranslate nohighlight">\(\nu\)</span>-Tamari lattice</a></li>
<li class="toctree-l2"><a class="reference internal" href="ordered_tree.html">Ordered Rooted Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="output.html">Output functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallelogram_polyomino.html">Parallelogram Polyominoes</a></li>
<li class="toctree-l2"><a class="reference internal" href="parking_functions.html">Parking Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="path_tableaux/catalog.html">Catalog of Path Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="path_tableaux/dyck_path.html">Dyck Paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="path_tableaux/frieze.html">Frieze Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="path_tableaux/path_tableau.html">Path Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="path_tableaux/semistandard.html">Semistandard Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="plane_partition.html">Plane Partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="partition.html">Integer partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="partition_algebra.html">Partition/Diagram Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="partition_kleshchev.html">Kleshchev partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="partition_shifting_algebras.html">Partition Shifting Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="partition_tuple.html">Partition tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="partitions.html">Iterators over the partitions of an integer</a></li>
<li class="toctree-l2"><a class="reference internal" href="perfect_matching.html">Perfect matchings</a></li>
<li class="toctree-l2"><a class="reference internal" href="permutation.html">Permutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="permutation_cython.html">Permutations (Cython file)</a></li>
<li class="toctree-l2"><a class="reference internal" href="posets/all.html">Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="posets/cartesian_product.html">Cartesian products of Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="posets/d_complete.html">D-Complete Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="posets/mobile.html">Mobile posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="posets/elements.html">Elements of posets, lattices, semilattices, etc.</a></li>
<li class="toctree-l2"><a class="reference internal" href="posets/forest.html">Forest Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="posets/hasse_diagram.html">Hasse diagrams of posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="posets/incidence_algebras.html">Incidence Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="posets/lattices.html">Finite lattices and semilattices</a></li>
<li class="toctree-l2"><a class="reference internal" href="posets/linear_extensions.html">Linear Extensions of Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="posets/moebius_algebra.html">Möbius Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="posets/poset_examples.html">Catalog of posets and lattices</a></li>
<li class="toctree-l2"><a class="reference internal" href="posets/posets.html">Finite posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="q_analogues.html"><span class="math notranslate nohighlight">\(q\)</span>-Analogues</a></li>
<li class="toctree-l2"><a class="reference internal" href="q_bernoulli.html"><span class="math notranslate nohighlight">\(q\)</span>-Bernoulli Numbers and Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="quickref.html">Combinatorics quickref</a></li>
<li class="toctree-l2"><a class="reference internal" href="ranker.html">Rankers</a></li>
<li class="toctree-l2"><a class="reference internal" href="recognizable_series.html">Recognizable Series</a></li>
<li class="toctree-l2"><a class="reference internal" href="regular_sequence.html"><span class="math notranslate nohighlight">\(k\)</span>-regular sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="restricted_growth.html">Restricted growth arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="ribbon.html">Ribbons</a></li>
<li class="toctree-l2"><a class="reference internal" href="ribbon_shaped_tableau.html">Ribbon Shaped Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="ribbon_tableau.html">Ribbon Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/all.html">Rigged configurations</a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/bij_abstract_class.html">Abstract classes for the rigged configuration bijections</a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/bij_infinity.html">Bijection between rigged configurations for <span class="math notranslate nohighlight">\(B(\infty)\)</span> and marginally large tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/bij_type_A.html">Bijection classes for type <span class="math notranslate nohighlight">\(A_n^{(1)}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/bij_type_A2_dual.html">Bijection classes for type <span class="math notranslate nohighlight">\(A_{2n}^{(2)\dagger}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/bij_type_A2_even.html">Bijection classes for type <span class="math notranslate nohighlight">\(A_{2n}^{(2)}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/bij_type_A2_odd.html">Bijection classes for type <span class="math notranslate nohighlight">\(A_{2n-1}^{(2)}\)</span>.</a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/bij_type_B.html">Bijection classes for type <span class="math notranslate nohighlight">\(B_n^{(1)}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/bij_type_C.html">Bijection classes for type <span class="math notranslate nohighlight">\(C_n^{(1)}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/bij_type_D.html">Bijection classes for type <span class="math notranslate nohighlight">\(D_n^{(1)}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/bij_type_D_twisted.html">Bijection classes for type <span class="math notranslate nohighlight">\(D_{n+1}^{(2)}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/bij_type_D_tri.html">Bijection classes for type <span class="math notranslate nohighlight">\(D_4^{(3)}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/bijection.html">Bijection between rigged configurations and KR tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/kleber_tree.html">Kleber Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/kr_tableaux.html">Kirillov-Reshetikhin Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/rc_crystal.html">Crystal of Rigged Configurations</a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/rc_infinity.html">Rigged Configurations of <span class="math notranslate nohighlight">\(\mathcal{B}(\infty)\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/rigged_configuration_element.html">Rigged Configuration Elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/rigged_configurations.html">Rigged Configurations</a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/rigged_partition.html">Rigged Partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/tensor_product_kr_tableaux.html">Tensor Product of Kirillov-Reshetikhin Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/tensor_product_kr_tableaux_element.html">Tensor Product of Kirillov-Reshetikhin Tableaux Elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/all.html">Root Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/ambient_space.html">Ambient lattices and ambient spaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/associahedron.html">Associahedron</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/braid_move_calculator.html">Braid Move Calculator</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/braid_orbit.html">Braid Orbit</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/branching_rules.html">Branching Rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/cartan_matrix.html">Cartan matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/cartan_type.html">Cartan types</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/coxeter_group.html">Coxeter Groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/coxeter_matrix.html">Coxeter Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/coxeter_type.html">Coxeter Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/dynkin_diagram.html">Dynkin diagrams</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/hecke_algebra_representation.html">Hecke algebra representations</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/integrable_representations.html">Integrable Representations of Affine Lie Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/non_symmetric_macdonald_polynomials.html">Nonsymmetric Macdonald polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/pieri_factors.html">Pieri Factors</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/plot.html">Tutorial: visualizing root systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/reflection_group_complex.html">Finite complex reflection groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/reflection_group_real.html">Finite real reflection groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/root_lattice_realization_algebras.html">Group algebras of root lattice realizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/root_lattice_realizations.html">Root lattice realizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/root_space.html">Root lattices and root spaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/root_system.html">Root systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_super_A.html">Root system data for super type A</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_A.html">Root system data for type A</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_A_affine.html">Root system data for (untwisted) type A affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_A_infinity.html">Root system data for type A infinity</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_B.html">Root system data for type B</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_BC_affine.html">Root system data for type BC affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_B_affine.html">Root system data for (untwisted) type B affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_C.html">Root system data for type C</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_C_affine.html">Root system data for (untwisted) type C affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_D.html">Root system data for type D</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_D_affine.html">Root system data for (untwisted) type D affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_E.html">Root system data for type E</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_E_affine.html">Root system data for (untwisted) type E affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_F.html">Root system data for type F</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_F_affine.html">Root system data for (untwisted) type F affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_G.html">Root system data for type G</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_G_affine.html">Root system data for (untwisted) type G affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_H.html">Root system data for type H</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_I.html">Root system data for type I</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_Q.html">Root system data for type Q</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_affine.html">Root system data for affine Cartan types</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_dual.html">Root system data for dual Cartan types</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/extended_affine_weyl_group.html">Extended Affine Weyl Groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/fundamental_group.html">Fundamental Group of an Extended Affine Weyl Group</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_folded.html">Root system data for folded Cartan types</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_marked.html">Root system data for Cartan types with marked nodes</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_reducible.html">Root system data for reducible Cartan types</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_relabel.html">Root system data for relabelled Cartan types</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/weight_lattice_realizations.html">Weight lattice realizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/weight_space.html">Weight lattices and weight spaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/weyl_characters.html">Weyl Character Rings</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/weyl_group.html">Weyl Groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="rooted_tree.html">Rooted (Unordered) Trees</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">Robinson-Schensted-Knuth correspondence</a></li>
<li class="toctree-l2"><a class="reference internal" href="schubert_polynomial.html">Schubert Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="set_partition.html">Set Partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="set_partition_iterator.html">Fast set partition iterators</a></li>
<li class="toctree-l2"><a class="reference internal" href="set_partition_ordered.html">Ordered Set Partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/all.html">Symmetric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/character.html">Characters of the symmetric group as bases of the symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/classical.html">Classical symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/dual.html">Generic dual bases symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/elementary.html">Elementary symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/hall_littlewood.html">Hall-Littlewood Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/hecke.html">Hecke Character Basis</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/homogeneous.html">Homogeneous symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/jack.html">Jack Symmetric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/k_dual.html">Quotient of symmetric function space by ideal generated by Hall-Littlewood symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/kfpoly.html">Kostka-Foulkes Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/llt.html">LLT symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/macdonald.html">Macdonald Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/monomial.html">Monomial symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/multiplicative.html">Multiplicative symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/new_kschur.html"><span class="math notranslate nohighlight">\(k\)</span>-Schur Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/ns_macdonald.html">Non-symmetric Macdonald Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/orthogonal.html">Orthogonal Symmetric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/orthotriang.html">Symmetric functions defined by orthogonality and triangularity</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/powersum.html">Power sum symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/schur.html">Schur symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/symplectic.html">Symplectic Symmetric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/sf.html">Symmetric functions, with their multiple realizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/sfa.html">Symmetric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/witt.html">Witt symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="shard_order.html">Shard intersection order</a></li>
<li class="toctree-l2"><a class="reference internal" href="shifted_primed_tableau.html">Shifted primed tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="shuffle.html">Shuffle product of iterables</a></li>
<li class="toctree-l2"><a class="reference internal" href="sidon_sets.html">Sidon sets and their generalizations, Sidon <span class="math notranslate nohighlight">\(g\)</span>-sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="similarity_class_type.html">Similarity class types of matrices with entries in a finite field</a></li>
<li class="toctree-l2"><a class="reference internal" href="sine_gordon.html">sine-Gordon Y-system plotter</a></li>
<li class="toctree-l2"><a class="reference internal" href="six_vertex_model.html">Six Vertex Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="skew_partition.html">Skew Partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="skew_tableau.html">Skew Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="sloane_functions.html">Functions that compute some of the sequences in Sloane’s tables</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/all.html">Combinatorial species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/characteristic_species.html">Characteristic Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/composition_species.html">Composition species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/cycle_species.html">Cycle Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/empty_species.html">Empty Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/functorial_composition_species.html">Functorial composition species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/generating_series.html">Generating Series</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/library.html">Examples of Combinatorial Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/linear_order_species.html">Linear-order Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/misc.html">Miscellaneous Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/partition_species.html">Partition Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/permutation_species.html">Permutation species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/product_species.html">Product species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/recursive_species.html">Recursive Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/set_species.html">Set Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/species.html">Combinatorial Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/structure.html">Species structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/subset_species.html">Subset Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/sum_species.html">Sum species</a></li>
<li class="toctree-l2"><a class="reference internal" href="specht_module.html">Specht Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="subset.html">Subsets</a></li>
<li class="toctree-l2"><a class="reference internal" href="subsets_hereditary.html">Subsets satisfying a hereditary property</a></li>
<li class="toctree-l2"><a class="reference internal" href="subsets_pairwise.html">Subsets whose elements satisfy a predicate pairwise</a></li>
<li class="toctree-l2"><a class="reference internal" href="subword.html">Subwords</a></li>
<li class="toctree-l2"><a class="reference internal" href="subword_complex.html">Subword complex</a></li>
<li class="toctree-l2"><a class="reference internal" href="super_tableau.html">Super Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="superpartition.html">Super Partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="symmetric_group_algebra.html">Symmetric Group Algebra</a></li>
<li class="toctree-l2"><a class="reference internal" href="symmetric_group_representations.html">Representations of the Symmetric Group</a></li>
<li class="toctree-l2"><a class="reference internal" href="t_sequences.html">T-sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="tableau.html">Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="tableau_residues.html">Residue sequences of tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="tableau_tuple.html">TableauTuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="tamari_lattices.html">Generalized Tamari lattices</a></li>
<li class="toctree-l2"><a class="reference internal" href="tiling.html">Tiling Solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="tools.html">Transitive ideal closure tool</a></li>
<li class="toctree-l2"><a class="reference internal" href="triangles_FHM.html">Combinatorial triangles for posets and fans</a></li>
<li class="toctree-l2"><a class="reference internal" href="tuple.html">Tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.html">Introduction to combinatorics in Sage</a></li>
<li class="toctree-l2"><a class="reference internal" href="vector_partition.html">Vector Partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/abstract_word.html">Abstract word (finite or infinite)</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/all.html">Combinatorics on words</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/alphabet.html">Alphabet</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/finite_word.html">Finite word</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/infinite_word.html">Infinite word</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/lyndon_word.html">Lyndon words</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/morphism.html">Word morphisms/substitutions</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/paths.html">Word paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/shuffle_product.html">Shuffle product of words</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/suffix_trees.html">Suffix Tries and Suffix Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/word.html">Word classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/word_char.html">Fast word datatype using an array of unsigned char</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/word_datatypes.html">Datatypes for finite words</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/word_generators.html">Common words</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/word_infinite_datatypes.html">Datatypes for words defined by iterators and callables</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/word_options.html">User-customizable options for words</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/words.html">Set of words</a></li>
<li class="toctree-l2"><a class="reference internal" href="yang_baxter_graph.html">Yang-Baxter Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rings/cfinite_sequence.html">C-Finite Sequences</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="robinson-schensted-knuth-correspondence">
<span id="sage-combinat-rsk"></span><h1>Robinson-Schensted-Knuth correspondence<a class="headerlink" href="#robinson-schensted-knuth-correspondence" title="Permalink to this heading">#</a></h1>
<span class="target" id="module-sage.combinat.rsk"></span><p>AUTHORS:</p>
<ul class="simple">
<li><p>Travis Scrimshaw (2012-12-07): Initial version</p></li>
<li><p>Chaman Agrawal (2019-06-24): Refactoring on the Rule class</p></li>
<li><p>Matthew Lancellotti (2018): initial version of super RSK</p></li>
<li><p>Jianping Pan, Wencin Poh, Anne Schilling (2020-08-31): initial version of RuleStar</p></li>
</ul>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading">#</a></h2>
<p>The Robinson-Schensted-Knuth (RSK) correspondence is most naturally
stated as a bijection between generalized permutations (also known
as two-line arrays, biwords, …) and pairs of semi-standard Young
tableaux <span class="math notranslate nohighlight">\((P, Q)\)</span> of identical shape.</p>
<p>The basic operation in the RSK correspondence is a row insertion
<span class="math notranslate nohighlight">\(P \leftarrow k\)</span> (where <span class="math notranslate nohighlight">\(P\)</span> is a given semi-standard Young tableau,
and <span class="math notranslate nohighlight">\(k\)</span> is an integer). Different insertion algorithms have been
implemented for the RSK correspondence and can be specified as
an argument in the function call.</p>
<p>EXAMPLES:</p>
<p>We can perform RSK and its inverse map on a variety of objects:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">]]);</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">gp</span> <span class="o">=</span> <span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span> <span class="n">gp</span>
<span class="go">[[1, 2, 3, 3], [2, 1, 2, 2]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="o">*</span><span class="n">gp</span><span class="p">)</span> <span class="c1"># RSK of a biword</span>
<span class="go">[[[1, 2, 2], [2]], [[1, 3, 3], [2]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> <span class="c1"># Robinson-Schensted of a word</span>
<span class="go">[[[1, 2, 2, 3], [2], [3]], [[1, 2, 5, 6], [3], [4]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">EG</span><span class="p">)</span> <span class="c1"># Edelman-Greene</span>
<span class="go">[[[1, 2, 3], [2, 3], [3]], [[1, 2, 6], [3, 5], [4]]]</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="s1">&#39;matrix&#39;</span><span class="p">);</span> <span class="n">m</span> <span class="c1"># output as matrix</span>
<span class="go">[0 1]</span>
<span class="go">[1 0]</span>
<span class="go">[0 2]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="c1"># RSK of a matrix</span>
<span class="go">[[[1, 2, 2], [2]], [[1, 3, 3], [2]]]</span>
</pre></div>
</div>
<section id="insertions-currently-available">
<h3>Insertions currently available<a class="headerlink" href="#insertions-currently-available" title="Permalink to this heading">#</a></h3>
<p>The following insertion algorithms for RSK correspondence are currently
available:</p>
<ul class="simple">
<li><p>RSK insertion (<a class="reference internal" href="#sage.combinat.rsk.RuleRSK" title="sage.combinat.rsk.RuleRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleRSK</span></code></a>).</p></li>
<li><p>Edelman-Greene insertion (<a class="reference internal" href="#sage.combinat.rsk.RuleEG" title="sage.combinat.rsk.RuleEG"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleEG</span></code></a>), an algorithm
defined in <a class="reference internal" href="#eg1987" id="id1"><span>[EG1987]</span></a> Definition 6.20 (where it is referred to as
Coxeter-Knuth insertion).</p></li>
<li><p>Hecke RSK algorithm (<a class="reference internal" href="#sage.combinat.rsk.RuleHecke" title="sage.combinat.rsk.RuleHecke"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleHecke</span></code></a>) , defined
using the Hecke insertion studied in <a class="reference internal" href="#bksty06" id="id2"><span>[BKSTY06]</span></a> (but using rows instead
of columns).</p></li>
<li><p>Dual RSK insertion (<a class="reference internal" href="#sage.combinat.rsk.RuleDualRSK" title="sage.combinat.rsk.RuleDualRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleDualRSK</span></code></a>).</p></li>
<li><p>CoRSK insertion (<a class="reference internal" href="#sage.combinat.rsk.RuleCoRSK" title="sage.combinat.rsk.RuleCoRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleCoRSK</span></code></a>), defined in
<a class="reference internal" href="#gr2018v5sol" id="id3"><span>[GR2018v5sol]</span></a>.</p></li>
<li><p>Super RSK insertion (<a class="reference internal" href="#sage.combinat.rsk.RuleSuperRSK" title="sage.combinat.rsk.RuleSuperRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleSuperRSK</span></code></a>), a
combination of row and column insertions defined in <a class="reference internal" href="../../../references/index.html#muth2019" id="id4"><span>[Muth2019]</span></a>.</p></li>
<li><p>Star insertion (<a class="reference internal" href="#sage.combinat.rsk.RuleStar" title="sage.combinat.rsk.RuleStar"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleStar</span></code></a>), defined in <a class="reference internal" href="../../../references/index.html#mpps2020" id="id5"><span>[MPPS2020]</span></a>.</p></li>
</ul>
</section>
<section id="implementing-your-own-insertion-rule">
<h3>Implementing your own insertion rule<a class="headerlink" href="#implementing-your-own-insertion-rule" title="Permalink to this heading">#</a></h3>
<p>The functions <a class="reference internal" href="#sage.combinat.rsk.RSK" title="sage.combinat.rsk.RSK"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK()</span></code></a> and <a class="reference internal" href="#sage.combinat.rsk.RSK_inverse" title="sage.combinat.rsk.RSK_inverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK_inverse()</span></code></a> are written so that it
is easy to implement insertion algorithms you come across in your research.</p>
<p>To implement your own insertion algorithm, you first need to import the
base class for a rule:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">Rule</span>
</pre></div>
</div>
<p>Using the <code class="docutils literal notranslate"><span class="pre">Rule</span></code> class as parent class for your insertion rule,
first implement the insertion and the reverse insertion algorithm
for <a class="reference internal" href="#sage.combinat.rsk.RSK" title="sage.combinat.rsk.RSK"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK()</span></code></a> and <a class="reference internal" href="#sage.combinat.rsk.RSK_inverse" title="sage.combinat.rsk.RSK_inverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK_inverse()</span></code></a> respectively (as methods
<code class="docutils literal notranslate"><span class="pre">forward_rule</span></code> and <code class="docutils literal notranslate"><span class="pre">backward_rule</span></code>). If your insertion algorithm
uses the same forward and backward rules as <code class="docutils literal notranslate"><span class="pre">RuleRSK</span></code>, differing
only in how an entry is inserted into a row, then this is not
necessary, and it suffices to merely implement the
<code class="docutils literal notranslate"><span class="pre">insertion</span></code> and <code class="docutils literal notranslate"><span class="pre">reverse_insertion</span></code> methods.</p>
<p>For more information, see <a class="reference internal" href="#sage.combinat.rsk.Rule" title="sage.combinat.rsk.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rule</span></code></a>.</p>
<p>REFERENCES:</p>
<div role="list" class="citation-list">
<div class="citation" id="knu1970" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Knu1970<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id6">1</a>,<a role="doc-backlink" href="#id23">2</a>)</span>
<p>Donald E. Knuth.
<em>Permutations, matrices, and generalized Young tableaux</em>.
Pacific J. Math. Volume 34, Number 3 (1970), pp. 709-727.
<a class="reference external" href="http://projecteuclid.org/euclid.pjm/1102971948">http://projecteuclid.org/euclid.pjm/1102971948</a></p>
</div>
<div class="citation" id="eg1987" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>EG1987<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id1">1</a>,<a role="doc-backlink" href="#id12">2</a>,<a role="doc-backlink" href="#id13">3</a>,<a role="doc-backlink" href="#id14">4</a>)</span>
<p>Paul Edelman, Curtis Greene.
<em>Balanced Tableaux</em>.
Advances in Mathematics 63 (1987), pp. 42-99.
<a class="reference external" href="https://doi.org/10.1016/0001-8708(87)90063-6">doi:10.1016/0001-8708(87)90063-6</a></p>
</div>
<div class="citation" id="bksty06" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>BKSTY06<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id2">1</a>,<a role="doc-backlink" href="#id15">2</a>,<a role="doc-backlink" href="#id16">3</a>)</span>
<p>A. Buch, A. Kresch, M. Shimozono, H. Tamvakis, and A. Yong.
<em>Stable Grothendieck polynomials and</em> <span class="math notranslate nohighlight">\(K\)</span>-<em>theoretic factor sequences</em>.
Math. Ann. <strong>340</strong> Issue 2, (2008), pp. 359–382.
<a class="reference external" href="https://arxiv.org/abs/math/0601514v1">arXiv math/0601514v1</a>.</p>
</div>
<div class="citation" id="gr2018v5sol" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>GR2018v5sol<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id3">1</a>,<a role="doc-backlink" href="#id9">2</a>,<a role="doc-backlink" href="#id11">3</a>)</span>
<p>Darij Grinberg, Victor Reiner.
<em>Hopf Algebras In Combinatorics</em>,
<a class="reference external" href="https://arxiv.org/abs/1409.8356v5">arXiv 1409.8356v5</a>, available with solutions at
<a class="reference external" href="https://arxiv.org/src/1409.8356v5/anc/HopfComb-v73-with-solutions.pdf">https://arxiv.org/src/1409.8356v5/anc/HopfComb-v73-with-solutions.pdf</a></p>
</div>
</div>
</section>
</section>
<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.rsk.InsertionRules">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.combinat.rsk.</span></span><span class="sig-name descname"><span class="pre">InsertionRules</span></span><a class="headerlink" href="#sage.combinat.rsk.InsertionRules" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Catalog of rules for RSK-like insertion algorithms.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.rsk.InsertionRules.EG">
<span class="sig-name descname"><span class="pre">EG</span></span><a class="headerlink" href="#sage.combinat.rsk.InsertionRules.EG" title="Permalink to this definition">#</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.rsk.RuleEG" title="sage.combinat.rsk.RuleEG"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleEG</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.rsk.InsertionRules.Hecke">
<span class="sig-name descname"><span class="pre">Hecke</span></span><a class="headerlink" href="#sage.combinat.rsk.InsertionRules.Hecke" title="Permalink to this definition">#</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.rsk.RuleHecke" title="sage.combinat.rsk.RuleHecke"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleHecke</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.rsk.InsertionRules.RSK">
<span class="sig-name descname"><span class="pre">RSK</span></span><a class="headerlink" href="#sage.combinat.rsk.InsertionRules.RSK" title="Permalink to this definition">#</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.rsk.RuleRSK" title="sage.combinat.rsk.RuleRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleRSK</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.rsk.InsertionRules.Star">
<span class="sig-name descname"><span class="pre">Star</span></span><a class="headerlink" href="#sage.combinat.rsk.InsertionRules.Star" title="Permalink to this definition">#</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.rsk.RuleStar" title="sage.combinat.rsk.RuleStar"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleStar</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.rsk.InsertionRules.coRSK">
<span class="sig-name descname"><span class="pre">coRSK</span></span><a class="headerlink" href="#sage.combinat.rsk.InsertionRules.coRSK" title="Permalink to this definition">#</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.rsk.RuleCoRSK" title="sage.combinat.rsk.RuleCoRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleCoRSK</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.rsk.InsertionRules.dualRSK">
<span class="sig-name descname"><span class="pre">dualRSK</span></span><a class="headerlink" href="#sage.combinat.rsk.InsertionRules.dualRSK" title="Permalink to this definition">#</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.rsk.RuleDualRSK" title="sage.combinat.rsk.RuleDualRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleDualRSK</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.rsk.InsertionRules.superRSK">
<span class="sig-name descname"><span class="pre">superRSK</span></span><a class="headerlink" href="#sage.combinat.rsk.InsertionRules.superRSK" title="Permalink to this definition">#</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.rsk.RuleSuperRSK" title="sage.combinat.rsk.RuleSuperRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleSuperRSK</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.combinat.rsk.RSK">
<span class="sig-prename descclassname"><span class="pre">sage.combinat.rsk.</span></span><span class="sig-name descname"><span class="pre">RSK</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj1=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj2=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">insertion=&lt;class</span> <span class="pre">'sage.combinat.rsk.RuleRSK'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_standard=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RSK" title="Permalink to this definition">#</a></dt>
<dd><p>Perform the Robinson-Schensted-Knuth (RSK) correspondence.</p>
<p>The Robinson-Schensted-Knuth (RSK) correspondence (also known
as the RSK algorithm) is most naturally stated as a bijection
between generalized permutations (also known as two-line arrays,
biwords, …) and pairs of semi-standard Young tableaux <span class="math notranslate nohighlight">\((P, Q)\)</span>
of identical shape. The tableau <span class="math notranslate nohighlight">\(P\)</span> is known as the insertion
tableau, and <span class="math notranslate nohighlight">\(Q\)</span> is known as the recording tableau.</p>
<p>The basic operation is known as row insertion <span class="math notranslate nohighlight">\(P \leftarrow k\)</span>
(where <span class="math notranslate nohighlight">\(P\)</span> is a given semi-standard Young tableau, and <span class="math notranslate nohighlight">\(k\)</span> is an
integer). Row insertion is a recursive algorithm which starts by
setting <span class="math notranslate nohighlight">\(k_0 = k\)</span>, and in its <span class="math notranslate nohighlight">\(i\)</span>-th step inserts the number <span class="math notranslate nohighlight">\(k_i\)</span>
into the <span class="math notranslate nohighlight">\(i\)</span>-th row of <span class="math notranslate nohighlight">\(P\)</span> (we start counting the rows at <span class="math notranslate nohighlight">\(0\)</span>) by
replacing the first integer greater than <span class="math notranslate nohighlight">\(k_i\)</span> in the row by <span class="math notranslate nohighlight">\(k_i\)</span>
and defines <span class="math notranslate nohighlight">\(k_{i+1}\)</span> as the integer that has been replaced. If no
integer greater than <span class="math notranslate nohighlight">\(k_i\)</span> exists in the <span class="math notranslate nohighlight">\(i\)</span>-th row, then <span class="math notranslate nohighlight">\(k_i\)</span> is
simply appended to the row and the algorithm terminates at this point.</p>
<p>A <em>generalized permutation</em> (or <em>biword</em>) is a list
<span class="math notranslate nohighlight">\(((j_0, k_0), (j_1, k_1), \ldots, (j_{\ell-1}, k_{\ell-1}))\)</span>
of pairs such that the letters <span class="math notranslate nohighlight">\(j_0, j_1, \ldots, j_{\ell-1}\)</span>
are weakly increasing (that is,
<span class="math notranslate nohighlight">\(j_0 \leq j_1 \leq \cdots \leq j_{\ell-1}\)</span>), whereas the letters
<span class="math notranslate nohighlight">\(k_i\)</span> satisfy <span class="math notranslate nohighlight">\(k_i \leq k_{i+1}\)</span> whenever <span class="math notranslate nohighlight">\(j_i = j_{i+1}\)</span>.
The <span class="math notranslate nohighlight">\(\ell\)</span>-tuple <span class="math notranslate nohighlight">\((j_0, j_1, \ldots, j_{\ell-1})\)</span> is called the
<em>top line</em> of this generalized permutation,
whereas the <span class="math notranslate nohighlight">\(\ell\)</span>-tuple <span class="math notranslate nohighlight">\((k_0, k_1, \ldots, k_{\ell-1})\)</span> is
called its <em>bottom line</em>.</p>
<p>Now the RSK algorithm, applied to a generalized permutation
<span class="math notranslate nohighlight">\(p = ((j_0, k_0), (j_1, k_1), \ldots, (j_{\ell-1}, k_{\ell-1}))\)</span>
(encoded as a lexicographically sorted list of pairs) starts by
initializing two semi-standard tableaux <span class="math notranslate nohighlight">\(P_0\)</span> and <span class="math notranslate nohighlight">\(Q_0\)</span> as empty
tableaux. For each nonnegative integer <span class="math notranslate nohighlight">\(t\)</span> starting at <span class="math notranslate nohighlight">\(0\)</span>, take
the pair <span class="math notranslate nohighlight">\((j_t, k_t)\)</span> from <span class="math notranslate nohighlight">\(p\)</span> and set
<span class="math notranslate nohighlight">\(P_{t+1} = P_t \leftarrow k_t\)</span>, and define <span class="math notranslate nohighlight">\(Q_{t+1}\)</span> by adding a
new box filled with <span class="math notranslate nohighlight">\(j_t\)</span> to the tableau <span class="math notranslate nohighlight">\(Q_t\)</span> at the same
location the row insertion on <span class="math notranslate nohighlight">\(P_t\)</span> ended (that is to say, adding
a new box with entry <span class="math notranslate nohighlight">\(j_t\)</span> such that <span class="math notranslate nohighlight">\(P_{t+1}\)</span> and <span class="math notranslate nohighlight">\(Q_{t+1}\)</span> have
the same shape). The iterative process stops when <span class="math notranslate nohighlight">\(t\)</span> reaches the
size of <span class="math notranslate nohighlight">\(p\)</span>, and the pair <span class="math notranslate nohighlight">\((P_t, Q_t)\)</span> at this point is the image
of <span class="math notranslate nohighlight">\(p\)</span> under the Robinson-Schensted-Knuth correspondence.</p>
<p>This correspondence has been introduced in <a class="reference internal" href="#knu1970" id="id6"><span>[Knu1970]</span></a>, where it has
been referred to as “Construction A”.</p>
<p>For more information, see Chapter 7 in <a class="reference internal" href="dyck_word.html#sta-ec2" id="id7"><span>[Sta-EC2]</span></a>.</p>
<p>We also note that integer matrices are in bijection with generalized
permutations. Furthermore, we can convert any word <span class="math notranslate nohighlight">\(w\)</span> (and, in
particular, any permutation) to a generalized permutation by
considering the top row to be <span class="math notranslate nohighlight">\((1, 2, \ldots, n)\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the
length of <span class="math notranslate nohighlight">\(w\)</span>.</p>
<p>The optional argument <code class="docutils literal notranslate"><span class="pre">insertion</span></code> allows to specify an alternative
insertion procedure to be used instead of the standard
Robinson-Schensted-Knuth insertion.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">obj1,</span> <span class="pre">obj2</span></code> – can be one of the following:</p>
<ul>
<li><p>a word in an ordered alphabet (in this case, <code class="docutils literal notranslate"><span class="pre">obj1</span></code> is said
word, and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
<li><p>an integer matrix</p></li>
<li><p>two lists of equal length representing a generalized permutation
(namely, the lists <span class="math notranslate nohighlight">\((j_0, j_1, \ldots, j_{\ell-1})\)</span> and
<span class="math notranslate nohighlight">\((k_0, k_1, \ldots, k_{\ell-1})\)</span> represent the generalized
permutation
<span class="math notranslate nohighlight">\(((j_0, k_0), (j_1, k_1), \ldots, (j_{\ell-1}, k_{\ell-1}))\)</span>)</p></li>
<li><p>any object which has a method <code class="docutils literal notranslate"><span class="pre">_rsk_iter()</span></code> which returns an
iterator over the object represented as generalized permutation or
a pair of lists (in this case, <code class="docutils literal notranslate"><span class="pre">obj1</span></code> is said object,
and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">insertion</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">RSK.rules.RSK</span></code>) the following types
of insertion are currently supported:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.RSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'RSK'</span></code>) – Robinson-Schensted-Knuth
insertion (<a class="reference internal" href="#sage.combinat.rsk.RuleRSK" title="sage.combinat.rsk.RuleRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.EG</span></code> (or <code class="docutils literal notranslate"><span class="pre">'EG'</span></code>) – Edelman-Greene insertion
(only for reduced words of permutations/elements of a type <span class="math notranslate nohighlight">\(A\)</span>
Coxeter group) (<a class="reference internal" href="#sage.combinat.rsk.RuleEG" title="sage.combinat.rsk.RuleEG"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleEG</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.Hecke</span></code> (or <code class="docutils literal notranslate"><span class="pre">'hecke'</span></code>) – Hecke insertion (only
guaranteed for generalized permutations whose top row is strictly
increasing) (<a class="reference internal" href="#sage.combinat.rsk.RuleHecke" title="sage.combinat.rsk.RuleHecke"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleHecke</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.dualRSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'dualRSK'</span></code>) – Dual RSK insertion
(only for strict biwords) (<a class="reference internal" href="#sage.combinat.rsk.RuleDualRSK" title="sage.combinat.rsk.RuleDualRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleDualRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.coRSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'coRSK'</span></code>) – CoRSK insertion (only
for strict cobiwords) (<a class="reference internal" href="#sage.combinat.rsk.RuleCoRSK" title="sage.combinat.rsk.RuleCoRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleCoRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.superRSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'super'</span></code>) – Super RSK insertion (only for
restricted super biwords) (<a class="reference internal" href="#sage.combinat.rsk.RuleSuperRSK" title="sage.combinat.rsk.RuleSuperRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleSuperRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.Star</span></code> (or <code class="docutils literal notranslate"><span class="pre">'Star'</span></code>) – <span class="math notranslate nohighlight">\(\star\)</span>-insertion (only for
fully commutative words in the 0-Hecke monoid)
(<a class="reference internal" href="#sage.combinat.rsk.RuleStar" title="sage.combinat.rsk.RuleStar"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleStar</span></code></a>)</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_standard</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) check if either of the
resulting tableaux is a standard tableau, and if so, typecast it
as such</p></li>
</ul>
<p>For precise information about constraints on the input and output,
as well as the definition of the algorithm (if it is not standard
RSK), see the particular <a class="reference internal" href="#sage.combinat.rsk.Rule" title="sage.combinat.rsk.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rule</span></code></a> class.</p>
<p>EXAMPLES:</p>
<p>If we only input one row, it is understood that the top row
should be <span class="math notranslate nohighlight">\((1, 2, \ldots, n)\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[[[1, 3, 4], [2], [3]], [[1, 2, 4], [3], [5]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">Word</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">[[[1, 3, 4], [2], [3]], [[1, 2, 4], [3], [5]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">Word</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">[[[1, 2, 2, 3, 3], [2, 3], [3]], [[1, 2, 3, 6, 8], [4, 7], [5]]]</span>
</pre></div>
</div>
<p>We can provide a generalized permutation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">[[[1, 1, 2], [2]], [[1, 2, 2], [2]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">Word</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">[[[1, 1, 3], [2], [4]], [[1, 1, 4], [3], [4]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">Word</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">]))</span>
<span class="go">[[[1, 2, 7], [2], [6]], [[1, 3, 4], [3], [4]]]</span>
</pre></div>
</div>
<p>We can provide a matrix:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]]))</span>
<span class="go">[[[1, 1, 2], [2]], [[1, 2, 2], [2]]]</span>
</pre></div>
</div>
<p>We can also provide something looking like a matrix:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="go">[[[1, 1, 2], [2]], [[1, 2, 2], [2]]]</span>
</pre></div>
</div>
<p>There is also <a class="reference internal" href="#sage.combinat.rsk.RSK_inverse" title="sage.combinat.rsk.RSK_inverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK_inverse()</span></code></a> which performs
the inverse of the bijection on a pair of semistandard tableaux. We
note that the inverse function takes 2 separate tableaux as inputs, so
to compose with <a class="reference internal" href="#sage.combinat.rsk.RSK" title="sage.combinat.rsk.RSK"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK()</span></code></a>, we need to use the
python <code class="docutils literal notranslate"><span class="pre">*</span></code> on the output:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="o">*</span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[[1, 2, 2, 2], [2, 1, 1, 2]]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">,</span><span class="n">Q</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
<span class="go">[[1, 2, 2, 2], [2, 1, 1, 2]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.combinat.rsk.RSK_inverse">
<span class="sig-prename descclassname"><span class="pre">sage.combinat.rsk.</span></span><span class="sig-name descname"><span class="pre">RSK_inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output='array'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">insertion=&lt;class</span> <span class="pre">'sage.combinat.rsk.RuleRSK'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RSK_inverse" title="Permalink to this definition">#</a></dt>
<dd><p>Return the generalized permutation corresponding to the pair of
tableaux <span class="math notranslate nohighlight">\((p, q)\)</span> under the inverse of the Robinson-Schensted-Knuth
correspondence.</p>
<p>For more information on the bijection, see <a class="reference internal" href="#sage.combinat.rsk.RSK" title="sage.combinat.rsk.RSK"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK()</span></code></a>.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span></code>, <code class="docutils literal notranslate"><span class="pre">q</span></code> – two semi-standard tableaux of the same shape, or
(in the case when Hecke insertion is used) an increasing tableau and
a set-valued tableau of the same shape (see the note below for the
format of the set-valued tableau)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'array'</span></code>) if <code class="docutils literal notranslate"><span class="pre">q</span></code> is semi-standard:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'array'</span></code> – as a two-line array (i.e. generalized permutation or
biword)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'matrix'</span></code> – as an integer matrix</p></li>
</ul>
<p>and if <code class="docutils literal notranslate"><span class="pre">q</span></code> is standard, we can also have the output:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'word'</span></code> – as a word</p></li>
</ul>
<p>and additionally if <code class="docutils literal notranslate"><span class="pre">p</span></code> is standard, we can also have the output:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'permutation'</span></code> – as a permutation</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">insertion</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">RSK.rules.RSK</span></code>) the insertion algorithm
used in the bijection. Currently the following are supported:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.RSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'RSK'</span></code>) – Robinson-Schensted-Knuth
insertion (<a class="reference internal" href="#sage.combinat.rsk.RuleRSK" title="sage.combinat.rsk.RuleRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.EG</span></code> (or <code class="docutils literal notranslate"><span class="pre">'EG'</span></code>) – Edelman-Greene insertion
(only for reduced words of permutations/elements of a type <span class="math notranslate nohighlight">\(A\)</span>
Coxeter group) (<a class="reference internal" href="#sage.combinat.rsk.RuleEG" title="sage.combinat.rsk.RuleEG"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleEG</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.Hecke</span></code> (or <code class="docutils literal notranslate"><span class="pre">'hecke'</span></code>) – Hecke insertion (only
guaranteed for generalized permutations whose top row is strictly
increasing) (<a class="reference internal" href="#sage.combinat.rsk.RuleHecke" title="sage.combinat.rsk.RuleHecke"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleHecke</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.dualRSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'dualRSK'</span></code>) – Dual RSK insertion
(only for strict biwords) (<a class="reference internal" href="#sage.combinat.rsk.RuleDualRSK" title="sage.combinat.rsk.RuleDualRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleDualRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.coRSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'coRSK'</span></code>) – CoRSK insertion (only
for strict cobiwords) (<a class="reference internal" href="#sage.combinat.rsk.RuleCoRSK" title="sage.combinat.rsk.RuleCoRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleCoRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.superRSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'super'</span></code>) – Super RSK insertion (only for
restricted super biwords) (<a class="reference internal" href="#sage.combinat.rsk.RuleSuperRSK" title="sage.combinat.rsk.RuleSuperRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleSuperRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.Star</span></code> (or <code class="docutils literal notranslate"><span class="pre">'Star'</span></code>) – <span class="math notranslate nohighlight">\(\star\)</span>-insertion (only for
fully commutative words in the 0-Hecke monoid)
(<a class="reference internal" href="#sage.combinat.rsk.RuleStar" title="sage.combinat.rsk.RuleStar"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleStar</span></code></a>)</p></li>
</ul>
</li>
</ul>
<p>For precise information about constraints on the input and
output, see the particular <a class="reference internal" href="#sage.combinat.rsk.Rule" title="sage.combinat.rsk.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rule</span></code></a> class.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the case of Hecke insertion, the input variable <code class="docutils literal notranslate"><span class="pre">q</span></code> should
be a set-valued tableau, encoded as a tableau whose entries are
strictly increasing tuples of positive integers. Each such tuple
encodes the set of its entries.</p>
</div>
<p>EXAMPLES:</p>
<p>If both <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code> are standard:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 4, 5], [1, 4, 5, 3, 2]]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;word&#39;</span><span class="p">)</span>
<span class="go">word: 14532</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;matrix&#39;</span><span class="p">)</span>
<span class="go">[1 0 0 0 0]</span>
<span class="go">[0 0 0 1 0]</span>
<span class="go">[0 0 0 0 1]</span>
<span class="go">[0 0 1 0 0]</span>
<span class="go">[0 1 0 0 0]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">)</span>
<span class="go">[1, 4, 5, 3, 2]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">)</span>
<span class="go">[1, 4, 3, 2, 5]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">)</span>
<span class="go">[1, 2, 5, 4, 3]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">)</span>
<span class="go">[1, 5, 4, 2, 3]</span>
</pre></div>
</div>
<p>If the first tableau is semistandard:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]]);</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">ret</span> <span class="o">=</span> <span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span> <span class="n">ret</span>
<span class="go">[[1, 2, 3, 4], [1, 3, 2, 2]]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="s1">&#39;word&#39;</span><span class="p">)</span>
<span class="go">word: 1322</span>
</pre></div>
</div>
<p>In general:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">]]);</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 3], [2, 1, 2, 2]]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="s1">&#39;matrix&#39;</span><span class="p">)</span>
<span class="go">[0 1]</span>
<span class="go">[1 0]</span>
<span class="go">[0 2]</span>
</pre></div>
</div>
<p>Using Hecke insertion:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">pq</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">Hecke</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="o">*</span><span class="n">pq</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">Hecke</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;list&#39;</span><span class="p">)</span>
<span class="go">[5, 4, 3, 1, 4, 2, 5, 5]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The constructor of <code class="docutils literal notranslate"><span class="pre">Tableau</span></code> accepts not only semistandard
tableaux, but also arbitrary lists that are fillings of a
partition diagram. (And such lists are used, e.g., for the
set-valued tableau <code class="docutils literal notranslate"><span class="pre">q</span></code> that is passed to
<code class="docutils literal notranslate"><span class="pre">RSK_inverse(p,</span> <span class="pre">q,</span> <span class="pre">insertion='hecke')</span></code>.)
The user is responsible for ensuring that the tableaux passed to
<code class="docutils literal notranslate"><span class="pre">RSK_inverse</span></code> are of the right types (semistandard, standard,
increasing, set-valued as needed).</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.rsk.Rule">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.combinat.rsk.</span></span><span class="sig-name descname"><span class="pre">Rule</span></span><a class="headerlink" href="#sage.combinat.rsk.Rule" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Parents and Elements v10.2)"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueRepresentation</span></code></a></p>
<p>Generic base class for an insertion rule for an RSK-type correspondence.</p>
<p>An instance of this class should implement a method
<code class="xref py py-meth docutils literal notranslate"><span class="pre">insertion()</span></code> (which can be applied to a letter <code class="docutils literal notranslate"><span class="pre">j</span></code>
and a list <code class="docutils literal notranslate"><span class="pre">r</span></code>, and modifies <code class="docutils literal notranslate"><span class="pre">r</span></code> in place by “bumping”
<code class="docutils literal notranslate"><span class="pre">j</span></code> into it appropriately; it then returns the bumped-out
entry or <code class="docutils literal notranslate"><span class="pre">None</span></code> if no such entry exists) and a method
<code class="xref py py-meth docutils literal notranslate"><span class="pre">reverse_insertion()</span></code> (which does the same but for reverse
bumping).
It may also implement <code class="xref py py-meth docutils literal notranslate"><span class="pre">_backward_format_output()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">_forward_format_output()</span></code> if the RSK correspondence should
return something other than (semi)standard tableaux (in the
forward direction) and matrices or biwords (in the backward
direction).
The <a class="reference internal" href="#sage.combinat.rsk.Rule.to_pairs" title="sage.combinat.rsk.Rule.to_pairs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_pairs()</span></code></a> method should also be overridden if
the input for the (forward) RSK correspondence is not the
usual kind of biwords (i.e., pairs of two <span class="math notranslate nohighlight">\(n\)</span>-tuples
<span class="math notranslate nohighlight">\([a_1, a_2, \ldots, a_n]\)</span> and <span class="math notranslate nohighlight">\([b_1, b_2, \ldots, b_n]\)</span>
satisfying <span class="math notranslate nohighlight">\((a_1, b_1) \leq (a_2, b_2) \leq \cdots
\leq (a_n, b_n)\)</span> in lexicographic order).
Finally, it <a class="reference internal" href="#sage.combinat.rsk.Rule.forward_rule" title="sage.combinat.rsk.Rule.forward_rule"><code class="xref py py-meth docutils literal notranslate"><span class="pre">forward_rule()</span></code></a> and <a class="reference internal" href="#sage.combinat.rsk.Rule.backward_rule" title="sage.combinat.rsk.Rule.backward_rule"><code class="xref py py-meth docutils literal notranslate"><span class="pre">backward_rule()</span></code></a>
have to be overridden if the overall structure of the
RSK correspondence differs from that of classical RSK (see,
e.g., the case of Hecke insertion, in which a letter bumped
into a row may change a different row).</p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.Rule.backward_rule">
<span class="sig-name descname"><span class="pre">backward_rule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.Rule.backward_rule" title="Permalink to this definition">#</a></dt>
<dd><p>Return the generalized permutation obtained by applying reverse
insertion to a pair of tableaux <code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">q)</span></code>.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span></code>, <code class="docutils literal notranslate"><span class="pre">q</span></code> – two tableaux of the same shape.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'array'</span></code>) if <code class="docutils literal notranslate"><span class="pre">q</span></code> is semi-standard:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'array'</span></code> – as a two-line array (i.e. generalized permutation
or biword)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'matrix'</span></code> – as an integer matrix</p></li>
</ul>
<p>and if <code class="docutils literal notranslate"><span class="pre">q</span></code> is standard, we can also have the output:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'word'</span></code> – as a word</p></li>
</ul>
<p>and additionally if <code class="docutils literal notranslate"><span class="pre">p</span></code> is standard, we can also have the output:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'permutation'</span></code> – as a permutation</p></li>
</ul>
</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleRSK</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RuleRSK</span><span class="p">()</span><span class="o">.</span><span class="n">backward_rule</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;array&#39;</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 4, 5], [3, 3, 2, 4, 1]]</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RuleRSK</span><span class="p">()</span><span class="o">.</span><span class="n">backward_rule</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;array&#39;</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 4, 5], [1, 1, 1, 3, 7]]</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RuleRSK</span><span class="p">()</span><span class="o">.</span><span class="n">backward_rule</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;array&#39;</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 4, 5], [7, 6, 3, 3, 1]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.Rule.forward_rule">
<span class="sig-name descname"><span class="pre">forward_rule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_standard</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.Rule.forward_rule" title="Permalink to this definition">#</a></dt>
<dd><p>Return a pair of tableaux obtained by applying forward
insertion to the generalized permutation <code class="docutils literal notranslate"><span class="pre">[obj1,</span> <span class="pre">obj2]</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">obj1,</span> <span class="pre">obj2</span></code> – can be one of the following ways to
represent a generalized permutation (or, equivalently,
biword):</p>
<ul>
<li><p>two lists <code class="docutils literal notranslate"><span class="pre">obj1</span></code> and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> of equal length,
to be interpreted as the top row and the bottom row of
the biword</p></li>
<li><p>a matrix <code class="docutils literal notranslate"><span class="pre">obj1</span></code> of nonnegative integers, to be
interpreted as the generalized permutation in matrix
form (in this case, <code class="docutils literal notranslate"><span class="pre">obj2</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
<li><p>a word <code class="docutils literal notranslate"><span class="pre">obj1</span></code> in an ordered alphabet, to be
interpreted as the bottom row of the biword (in this
case, <code class="docutils literal notranslate"><span class="pre">obj2</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>; the top row of the biword
is understood to be <span class="math notranslate nohighlight">\((1, 2, \ldots, n)\)</span> by default)</p></li>
<li><p>any object <code class="docutils literal notranslate"><span class="pre">obj1</span></code> which has a method <code class="docutils literal notranslate"><span class="pre">_rsk_iter()</span></code>,
as long as this method returns an iterator yielding
pairs of numbers, which then are interperted as top
entries and bottom entries in the biword (in this case,
<code class="docutils literal notranslate"><span class="pre">obj2</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_standard</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) check if either of the
resulting tableaux is a standard tableau, and if so, typecast it
as such</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) whether to check
that <code class="docutils literal notranslate"><span class="pre">obj1</span></code> and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> actually define a valid
biword</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleRSK</span>
<span class="gp">sage: </span><span class="n">RuleRSK</span><span class="p">()</span><span class="o">.</span><span class="n">forward_rule</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">[[[1, 3, 4], [2], [3]], [[1, 2, 4], [3], [5]]]</span>
<span class="gp">sage: </span><span class="n">RuleRSK</span><span class="p">()</span><span class="o">.</span><span class="n">forward_rule</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">[[[1, 1, 1, 3, 7]], [[1, 2, 3, 4, 5]]]</span>
<span class="gp">sage: </span><span class="n">RuleRSK</span><span class="p">()</span><span class="o">.</span><span class="n">forward_rule</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">[[[1, 3], [3], [6], [7]], [[1, 4], [2], [3], [5]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.Rule.to_pairs">
<span class="sig-name descname"><span class="pre">to_pairs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.Rule.to_pairs" title="Permalink to this definition">#</a></dt>
<dd><p>Given a valid input for the RSK algorithm, such as
two <span class="math notranslate nohighlight">\(n\)</span>-tuples <code class="docutils literal notranslate"><span class="pre">obj1</span></code> <span class="math notranslate nohighlight">\(= [a_1, a_2, \ldots, a_n]\)</span>
and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> <span class="math notranslate nohighlight">\(= [b_1, b_2, \ldots, b_n]\)</span> forming a biword
(i.e., satisfying
<span class="math notranslate nohighlight">\(a_1 \leq a_2 \leq \cdots \leq a_n\)</span>, and if
<span class="math notranslate nohighlight">\(a_i = a_{i+1}\)</span>, then <span class="math notranslate nohighlight">\(b_i \leq b_{i+1}\)</span>),
or a matrix (“generalized permutation”), or a single word,
return the array
<span class="math notranslate nohighlight">\([(a_1, b_1), (a_2, b_2), \ldots, (a_n, b_n)]\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">obj1,</span> <span class="pre">obj2</span></code> – anything representing a biword
(see the doc of <a class="reference internal" href="#sage.combinat.rsk.Rule.forward_rule" title="sage.combinat.rsk.Rule.forward_rule"><code class="xref py py-meth docutils literal notranslate"><span class="pre">forward_rule()</span></code></a> for the
encodings accepted).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) whether to check
that <code class="docutils literal notranslate"><span class="pre">obj1</span></code> and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> actually define a valid
biword.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">Rule</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">Rule</span><span class="p">()</span><span class="o">.</span><span class="n">to_pairs</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[(1, 2), (2, 1), (2, 1), (2, 2)]</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span> <span class="p">;</span> <span class="n">m</span>
<span class="go">[0 1]</span>
<span class="go">[1 0]</span>
<span class="go">[0 2]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">Rule</span><span class="p">()</span><span class="o">.</span><span class="n">to_pairs</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
<span class="go">[(1, 2), (2, 1), (3, 2), (3, 2)]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleCoRSK">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.combinat.rsk.</span></span><span class="sig-name descname"><span class="pre">RuleCoRSK</span></span><a class="headerlink" href="#sage.combinat.rsk.RuleCoRSK" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.combinat.rsk.RuleRSK" title="sage.combinat.rsk.RuleRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleRSK</span></code></a></p>
<p>Rule for coRSK insertion.</p>
<p>CoRSK insertion differs from classical RSK insertion in the
following ways:</p>
<ul class="simple">
<li><p>The input (in terms of biwords) is no longer a biword,
but rather a strict cobiword – i.e., a pair of two lists
<span class="math notranslate nohighlight">\([a_1, a_2, \ldots, a_n]\)</span> and <span class="math notranslate nohighlight">\([b_1, b_2, \ldots, b_n]\)</span> that
satisfy the strict inequalities
<span class="math notranslate nohighlight">\((a_1, b_1) \widetilde{&lt;} (a_2, b_2) \widetilde{&lt;} \cdots
\widetilde{&lt;} (a_n, b_n)\)</span>, where
the binary relation <span class="math notranslate nohighlight">\(\widetilde{&lt;}\)</span> on pairs of integers
is defined by having <span class="math notranslate nohighlight">\((u_1, v_1) \widetilde{&lt;} (u_2, v_2)\)</span>
if and only if either <span class="math notranslate nohighlight">\(u_1 &lt; u_2\)</span> or (<span class="math notranslate nohighlight">\(u_1 = u_2\)</span> and
<span class="math notranslate nohighlight">\(v_1 &gt; v_2\)</span>).
In terms of matrices, this means that the input is not an
arbitrary matrix with nonnegative integer entries, but rather
a <span class="math notranslate nohighlight">\(\{0, 1\}\)</span>-matrix (i.e., a matrix whose entries are <span class="math notranslate nohighlight">\(0\)</span>’s
and <span class="math notranslate nohighlight">\(1\)</span>’s).</p></li>
<li><p>The output still consists of two tableaux <span class="math notranslate nohighlight">\((P, Q)\)</span> of equal
shapes, but rather than both of them being semistandard, now
<span class="math notranslate nohighlight">\(Q\)</span> is row-strict (i.e., its transpose is semistandard) while
<span class="math notranslate nohighlight">\(P\)</span> is semistandard.</p></li>
</ul>
<p>Bumping proceeds in the same way as for RSK insertion.</p>
<p>The RSK and coRSK algorithms agree for permutation matrices.</p>
<p>For more information, see Section A.4 in <a class="reference internal" href="../../../references/index.html#ful1997" id="id8"><span>[Ful1997]</span></a> (specifically,
construction (1d)) or the second solution to Exercise 2.7.12(a) in
<a class="reference internal" href="#gr2018v5sol" id="id9"><span>[GR2018v5sol]</span></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">insertion</span> <span class="o">=</span> <span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">[[[1, 1, 3], [2], [5]], [[1, 2, 3], [4], [5]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">Word</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">insertion</span> <span class="o">=</span> <span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">[[[1, 2, 2, 3, 3], [2, 3], [3]], [[1, 2, 3, 6, 8], [4, 7], [5]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">Word</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span> <span class="n">insertion</span> <span class="o">=</span> <span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">[[[1, 3, 4], [2], [3]], [[1, 2, 4], [3], [5]]]</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">to_matrix</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">to_matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span> <span class="n">insertion</span> <span class="o">=</span> <span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">[[[1, 2, 3], [2], [3]], [[1, 3, 4], [1], [3]]]</span>
</pre></div>
</div>
<p>Using coRSK insertion with a <span class="math notranslate nohighlight">\(\{0, 1\}\)</span>-matrix:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]),</span> <span class="n">insertion</span> <span class="o">=</span> <span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">[[[1], [2]], [[1], [2]]]</span>
</pre></div>
</div>
<p>We can also give it something looking like a matrix:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">insertion</span> <span class="o">=</span> <span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">[[[1], [2]], [[1], [2]]]</span>
</pre></div>
</div>
<p>We can also use the inverse correspondence:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="o">*</span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">....: </span>        <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">),</span><span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">[[1, 2, 2, 2], [2, 3, 2, 1]]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">,</span><span class="n">Q</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span><span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">[[1, 2, 2, 2], [2, 3, 2, 1]]</span>
</pre></div>
</div>
<p>When applied to two standard tableaux, backwards coRSK
insertion behaves identically to the usual backwards RSK
insertion:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 4, 5], [1, 4, 5, 3, 2]]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;word&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">word: 14532</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;matrix&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">[1 0 0 0 0]</span>
<span class="go">[0 0 0 1 0]</span>
<span class="go">[0 0 0 0 1]</span>
<span class="go">[0 0 1 0 0]</span>
<span class="go">[0 1 0 0 0]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">[1, 4, 5, 3, 2]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">[1, 4, 3, 2, 5]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">[1, 2, 5, 4, 3]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">[1, 5, 4, 2, 3]</span>
</pre></div>
</div>
<p>For coRSK, the first tableau is semistandard while the second tableau
is transpose semistandard:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">5</span><span class="p">]]);</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">ret</span> <span class="o">=</span> <span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">);</span> <span class="n">ret</span>
<span class="go">[[1, 2, 3, 4], [1, 5, 2, 2]]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="s1">&#39;word&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">word: 1522</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleCoRSK.backward_rule">
<span class="sig-name descname"><span class="pre">backward_rule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleCoRSK.backward_rule" title="Permalink to this definition">#</a></dt>
<dd><p>Return the strict cobiword obtained by applying reverse
coRSK insertion to a pair of tableaux <code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">q)</span></code>.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span></code>, <code class="docutils literal notranslate"><span class="pre">q</span></code> – two tableaux of the same shape</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'array'</span></code>) if <code class="docutils literal notranslate"><span class="pre">q</span></code> is row-strict:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'array'</span></code> – as a two-line array (i.e. strict cobiword)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'matrix'</span></code> – as a <span class="math notranslate nohighlight">\(\{0, 1\}\)</span>-matrix</p></li>
</ul>
<p>and if <code class="docutils literal notranslate"><span class="pre">q</span></code> is standard, we can have the output:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'word'</span></code> – as a word</p></li>
</ul>
<p>and additionally if <code class="docutils literal notranslate"><span class="pre">p</span></code> is standard, we can also have the output:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'permutation'</span></code> – as a permutation</p></li>
</ul>
</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleCoRSK</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RuleCoRSK</span><span class="p">()</span><span class="o">.</span><span class="n">backward_rule</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;array&#39;</span><span class="p">)</span>
<span class="go">[[1, 1, 2, 4, 4, 5], [4, 2, 1, 3, 1, 2]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleCoRSK.to_pairs">
<span class="sig-name descname"><span class="pre">to_pairs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleCoRSK.to_pairs" title="Permalink to this definition">#</a></dt>
<dd><p>Given a valid input for the coRSK algorithm, such as
two <span class="math notranslate nohighlight">\(n\)</span>-tuples <code class="docutils literal notranslate"><span class="pre">obj1</span></code> <span class="math notranslate nohighlight">\(= [a_1, a_2, \ldots, a_n]\)</span>
and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> <span class="math notranslate nohighlight">\(= [b_1, b_2, \ldots, b_n]\)</span> forming a
strict cobiword (i.e., satisfying
<span class="math notranslate nohighlight">\(a_1 \leq a_2 \leq \cdots \leq a_n\)</span>, and if
<span class="math notranslate nohighlight">\(a_i = a_{i+1}\)</span>, then <span class="math notranslate nohighlight">\(b_i &gt; b_{i+1}\)</span>),
or a <span class="math notranslate nohighlight">\(\{0, 1\}\)</span>-matrix (“rook placement”), or a
single word, return the array
<span class="math notranslate nohighlight">\([(a_1, b_1), (a_2, b_2), \ldots, (a_n, b_n)]\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">obj1,</span> <span class="pre">obj2</span></code> – anything representing a strict
cobiword (see the doc of <code class="xref py py-meth docutils literal notranslate"><span class="pre">forward_rule()</span></code> for
the encodings accepted)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) whether to check
that <code class="docutils literal notranslate"><span class="pre">obj1</span></code> and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> actually define a valid
strict cobiword</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleCoRSK</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">RuleCoRSK</span><span class="p">()</span><span class="o">.</span><span class="n">to_pairs</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="go">[(1, 2), (2, 3), (2, 2), (2, 1)]</span>
<span class="gp">sage: </span><span class="n">RuleCoRSK</span><span class="p">()</span><span class="o">.</span><span class="n">to_pairs</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: invalid strict cobiword</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="p">;</span> <span class="n">m</span>
<span class="go">[0 1]</span>
<span class="go">[1 1]</span>
<span class="go">[0 1]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">RuleCoRSK</span><span class="p">()</span><span class="o">.</span><span class="n">to_pairs</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
<span class="go">[(1, 2), (2, 2), (2, 1), (3, 2)]</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span> <span class="p">;</span> <span class="n">m</span>
<span class="go">[0 1]</span>
<span class="go">[1 0]</span>
<span class="go">[0 2]</span>
<span class="gp">sage: </span><span class="n">RuleCoRSK</span><span class="p">()</span><span class="o">.</span><span class="n">to_pairs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: coRSK requires a {0, 1}-matrix</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleDualRSK">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.combinat.rsk.</span></span><span class="sig-name descname"><span class="pre">RuleDualRSK</span></span><a class="headerlink" href="#sage.combinat.rsk.RuleDualRSK" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.combinat.rsk.Rule" title="sage.combinat.rsk.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rule</span></code></a></p>
<p>Rule for dual RSK insertion.</p>
<p>Dual RSK insertion differs from classical RSK insertion in the
following ways:</p>
<ul class="simple">
<li><p>The input (in terms of biwords) is no longer an arbitrary biword,
but rather a strict biword (i.e., a pair of two lists
<span class="math notranslate nohighlight">\([a_1, a_2, \ldots, a_n]\)</span> and <span class="math notranslate nohighlight">\([b_1, b_2, \ldots, b_n]\)</span> that
satisfy the strict inequalities
<span class="math notranslate nohighlight">\((a_1, b_1) &lt; (a_2, b_2) &lt; \cdots &lt; (a_n, b_n)\)</span> in
lexicographic order).
In terms of matrices, this means that the input is not an
arbitrary matrix with nonnegative integer entries, but rather
a <span class="math notranslate nohighlight">\(\{0, 1\}\)</span>-matrix (i.e., a matrix whose entries are <span class="math notranslate nohighlight">\(0\)</span>’s
and <span class="math notranslate nohighlight">\(1\)</span>’s).</p></li>
<li><p>The output still consists of two tableaux <span class="math notranslate nohighlight">\((P, Q)\)</span> of equal
shapes, but rather than both of them being semistandard, now
<span class="math notranslate nohighlight">\(P\)</span> is row-strict (i.e., its transpose is semistandard) while
<span class="math notranslate nohighlight">\(Q\)</span> is semistandard.</p></li>
<li><p>The main difference is in the way bumping works. Namely,
when a number <span class="math notranslate nohighlight">\(k_i\)</span> is inserted into the <span class="math notranslate nohighlight">\(i\)</span>-th row of <span class="math notranslate nohighlight">\(P\)</span>,
it bumps out the first integer greater <strong>or equal to</strong> <span class="math notranslate nohighlight">\(k_i\)</span>
in this row (rather than greater than <span class="math notranslate nohighlight">\(k_i\)</span>).</p></li>
</ul>
<p>The RSK and dual RSK algorithms agree for permutation matrices.</p>
<p>For more information, see Chapter 7, Section 14 in <a class="reference internal" href="dyck_word.html#sta-ec2" id="id10"><span>[Sta-EC2]</span></a>
(where dual RSK is called <span class="math notranslate nohighlight">\(\mathrm{RSK}^{\ast}\)</span>) or the third
solution to Exercise 2.7.12(a) in <a class="reference internal" href="#gr2018v5sol" id="id11"><span>[GR2018v5sol]</span></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[[[1, 4], [2], [3], [3]], [[1, 4], [2], [3], [5]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">Word</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[[[1, 4], [2], [3], [3]], [[1, 4], [2], [3], [5]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">Word</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[[[1, 2, 3], [2, 3], [2, 3], [3]], [[1, 2, 8], [3, 6], [4, 7], [5]]]</span>
</pre></div>
</div>
<p>Using dual RSK insertion with a strict biword:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[[[1, 2], [1, 3], [2, 4]], [[1, 1], [2, 4], [4, 5]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[[[1, 2, 3], [1, 2], [3], [3]], [[1, 1, 3], [2, 4], [3], [5]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[[[1, 2, 4], [2]], [[1, 2, 2], [2]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">Word</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[[[1, 2, 3], [1], [4]], [[1, 1, 4], [3], [4]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">Word</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">]),</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[[[1, 2, 7], [1], [6]], [[1, 3, 4], [3], [4]]]</span>
</pre></div>
</div>
<p>Using dual RSK insertion with a <span class="math notranslate nohighlight">\(\{0, 1\}\)</span>-matrix:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]),</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[[[1, 2], [2]], [[1, 2], [2]]]</span>
</pre></div>
</div>
<p>We can also give it something looking like a matrix:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[[[1, 2], [2]], [[1, 2], [2]]]</span>
</pre></div>
</div>
<p>Let us now call the inverse correspondence:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="o">*</span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">....: </span>        <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">),</span><span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[[1, 2, 2, 2], [2, 1, 2, 3]]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">,</span><span class="n">Q</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span><span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[[1, 2, 2, 2], [2, 1, 2, 3]]</span>
</pre></div>
</div>
<p>When applied to two standard tableaux, reverse dual RSK
insertion behaves identically to the usual reverse RSK insertion:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 4, 5], [1, 4, 5, 3, 2]]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;word&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">word: 14532</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;matrix&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[1 0 0 0 0]</span>
<span class="go">[0 0 0 1 0]</span>
<span class="go">[0 0 0 0 1]</span>
<span class="go">[0 0 1 0 0]</span>
<span class="go">[0 1 0 0 0]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[1, 4, 5, 3, 2]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[1, 4, 3, 2, 5]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[1, 2, 5, 4, 3]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[1, 5, 4, 2, 3]</span>
</pre></div>
</div>
<p>Let us check that forward and backward dual RSK are mutually
inverse when the first tableau is merely transpose semistandard:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">]]);</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">ret</span> <span class="o">=</span> <span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">);</span> <span class="n">ret</span>
<span class="go">[[1, 2, 3, 4], [1, 2, 1, 2]]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="s1">&#39;word&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">word: 1212</span>
</pre></div>
</div>
<p>In general for dual RSK:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">]]);</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 3], [1, 1, 1, 2]]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="s1">&#39;matrix&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[1 0]</span>
<span class="go">[1 0]</span>
<span class="go">[1 1]</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleDualRSK.insertion">
<span class="sig-name descname"><span class="pre">insertion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleDualRSK.insertion" title="Permalink to this definition">#</a></dt>
<dd><p>Insert the letter <code class="docutils literal notranslate"><span class="pre">j</span></code> from the second row of the biword
into the row <span class="math notranslate nohighlight">\(r\)</span> using dual RSK insertion, if there is
bumping to be done.</p>
<p>The row <span class="math notranslate nohighlight">\(r\)</span> is modified in place if bumping occurs. The bumped-out
entry, if it exists, is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleDualRSK</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="o">=</span> <span class="n">RuleDualRSK</span><span class="p">()</span><span class="o">.</span><span class="n">insertion</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span> <span class="n">j</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">r</span>
<span class="go">[1, 3, 4, 5]</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="o">=</span> <span class="n">RuleDualRSK</span><span class="p">()</span><span class="o">.</span><span class="n">insertion</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span> <span class="n">j</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="n">r</span>
<span class="go">[1, 2, 3, 4, 7]</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="o">=</span> <span class="n">RuleDualRSK</span><span class="p">()</span><span class="o">.</span><span class="n">insertion</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span> <span class="n">j</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">r</span>
<span class="go">[1, 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleDualRSK.reverse_insertion">
<span class="sig-name descname"><span class="pre">reverse_insertion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleDualRSK.reverse_insertion" title="Permalink to this definition">#</a></dt>
<dd><p>Reverse bump the row <code class="docutils literal notranslate"><span class="pre">row</span></code> of the current insertion tableau
with the number <code class="docutils literal notranslate"><span class="pre">x</span></code> using dual RSK insertion.</p>
<p>The row <code class="docutils literal notranslate"><span class="pre">row</span></code> is modified in place. The bumped-out entry
is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleDualRSK</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">RuleDualRSK</span><span class="p">()</span><span class="o">.</span><span class="n">reverse_insertion</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span> <span class="n">r</span>
<span class="go">[1, 2, 4, 6, 7]</span>
<span class="gp">sage: </span><span class="n">x</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">RuleDualRSK</span><span class="p">()</span><span class="o">.</span><span class="n">reverse_insertion</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span> <span class="n">r</span>
<span class="go">[1, 2, 4, 6, 7]</span>
<span class="gp">sage: </span><span class="n">x</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleDualRSK.to_pairs">
<span class="sig-name descname"><span class="pre">to_pairs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleDualRSK.to_pairs" title="Permalink to this definition">#</a></dt>
<dd><p>Given a valid input for the dual RSK algorithm, such as
two <span class="math notranslate nohighlight">\(n\)</span>-tuples <code class="docutils literal notranslate"><span class="pre">obj1</span></code> <span class="math notranslate nohighlight">\(= [a_1, a_2, \ldots, a_n]\)</span>
and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> <span class="math notranslate nohighlight">\(= [b_1, b_2, \ldots, b_n]\)</span> forming a strict
biword (i.e., satisfying <span class="math notranslate nohighlight">\(a_1 \leq a_2 \leq \cdots \leq a_n\)</span>,
and if <span class="math notranslate nohighlight">\(a_i = a_{i+1}\)</span>, then <span class="math notranslate nohighlight">\(b_i &lt; b_{i+1}\)</span>) or a
<span class="math notranslate nohighlight">\(\{0, 1\}\)</span>-matrix (“rook placement”), or a single word, return
the array <span class="math notranslate nohighlight">\([(a_1, b_1), (a_2, b_2), \ldots, (a_n, b_n)]\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">obj1,</span> <span class="pre">obj2</span></code> – anything representing a strict biword
(see the doc of <code class="xref py py-meth docutils literal notranslate"><span class="pre">forward_rule()</span></code> for the
encodings accepted)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) whether to check
that <code class="docutils literal notranslate"><span class="pre">obj1</span></code> and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> actually define a valid
strict biword</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleDualRSK</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">RuleDualRSK</span><span class="p">()</span><span class="o">.</span><span class="n">to_pairs</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
<span class="go">[(1, 2), (2, 1), (2, 2), (2, 3)]</span>
<span class="gp">sage: </span><span class="n">RuleDualRSK</span><span class="p">()</span><span class="o">.</span><span class="n">to_pairs</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: invalid strict biword</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="p">;</span> <span class="n">m</span>
<span class="go">[0 1]</span>
<span class="go">[1 1]</span>
<span class="go">[0 1]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">RuleDualRSK</span><span class="p">()</span><span class="o">.</span><span class="n">to_pairs</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
<span class="go">[(1, 2), (2, 1), (2, 2), (3, 2)]</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span> <span class="p">;</span> <span class="n">m</span>
<span class="go">[0 1]</span>
<span class="go">[1 0]</span>
<span class="go">[0 2]</span>
<span class="gp">sage: </span><span class="n">RuleDualRSK</span><span class="p">()</span><span class="o">.</span><span class="n">to_pairs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: dual RSK requires a {0, 1}-matrix</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleEG">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.combinat.rsk.</span></span><span class="sig-name descname"><span class="pre">RuleEG</span></span><a class="headerlink" href="#sage.combinat.rsk.RuleEG" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.combinat.rsk.Rule" title="sage.combinat.rsk.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rule</span></code></a></p>
<p>Rule for Edelman-Greene insertion.</p>
<p>For a reduced word of a permutation (i.e., an element of a type <span class="math notranslate nohighlight">\(A\)</span>
Coxeter group), one can use Edelman-Greene insertion, an algorithm
defined in <a class="reference internal" href="#eg1987" id="id12"><span>[EG1987]</span></a> Definition 6.20 (where it is referred to as
Coxeter-Knuth insertion). The Edelman-Greene insertion is similar to the
standard row insertion except that (using the notations in
the documentation of <a class="reference internal" href="#sage.combinat.rsk.RSK" title="sage.combinat.rsk.RSK"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK()</span></code></a>) if <span class="math notranslate nohighlight">\(k_i\)</span> and <span class="math notranslate nohighlight">\(k_i + 1\)</span> both
exist in row <span class="math notranslate nohighlight">\(i\)</span>, we <em>only</em> set <span class="math notranslate nohighlight">\(k_{i+1} = k_i + 1\)</span> and continue.</p>
<p>EXAMPLES:</p>
<p>Let us reproduce figure 6.4 in <a class="reference internal" href="#eg1987" id="id13"><span>[EG1987]</span></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">EG</span><span class="p">)</span>
<span class="go">[[[1, 2, 3], [2, 3], [3]], [[1, 2, 6], [3, 5], [4]]]</span>
</pre></div>
</div>
<p>Some more examples:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">pq</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">EG</span><span class="p">);</span> <span class="n">pq</span>
<span class="go">[[[1, 2, 3], [2, 3]], [[1, 3, 4], [2, 5]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">RSK_inverse</span><span class="p">(</span><span class="o">*</span><span class="n">pq</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">EG</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;matrix&#39;</span><span class="p">),</span>
<span class="gp">....: </span>    <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">EG</span><span class="p">)</span>
<span class="go">[[[1, 2, 3], [2, 3]], [[1, 3, 4], [2, 5]]]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="o">*</span><span class="n">pq</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">EG</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 4, 5], [2, 1, 2, 3, 2]]</span>
</pre></div>
</div>
<p>The RSK algorithm (<a class="reference internal" href="#sage.combinat.rsk.RSK" title="sage.combinat.rsk.RSK"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK()</span></code></a>) built using the Edelman-Greene
insertion rule <code class="docutils literal notranslate"><span class="pre">RuleEG</span></code> is a bijection from reduced words of
permutations/elements of a type <span class="math notranslate nohighlight">\(A\)</span> Coxeter group to pairs
consisting of an increasing tableau and a standard tableau
of the same shape (see <a class="reference internal" href="#eg1987" id="id14"><span>[EG1987]</span></a> Theorem 6.25).
The inverse of this bijection is obtained using <a class="reference internal" href="#sage.combinat.rsk.RSK_inverse" title="sage.combinat.rsk.RSK_inverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK_inverse()</span></code></a>.
If the optional parameter <code class="docutils literal notranslate"><span class="pre">output</span> <span class="pre">=</span> <span class="pre">'permutation'</span></code> is set in
<a class="reference internal" href="#sage.combinat.rsk.RSK_inverse" title="sage.combinat.rsk.RSK_inverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK_inverse()</span></code></a>, then the function returns not the
reduced word itself but the permutation (of smallest possible
size) whose reduced word it is (although the order of the
letters is reverse to the usual Sage convention):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">RSK_inverse</span><span class="p">(</span><span class="o">*</span><span class="n">pq</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">EG</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;permutation&#39;</span><span class="p">);</span> <span class="n">w</span>
<span class="go">[4, 3, 1, 2]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="ow">in</span> <span class="n">w</span><span class="o">.</span><span class="n">reduced_words</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleEG.insertion">
<span class="sig-name descname"><span class="pre">insertion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleEG.insertion" title="Permalink to this definition">#</a></dt>
<dd><p>Insert the letter <code class="docutils literal notranslate"><span class="pre">j</span></code> from the second row of the biword
into the row <span class="math notranslate nohighlight">\(r\)</span> using Edelman-Greene insertion,
if there is bumping to be done.</p>
<p>The row <span class="math notranslate nohighlight">\(r\)</span> is modified in place if bumping occurs. The bumped-out
entry, if it exists, is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleEG</span>
<span class="gp">sage: </span><span class="n">qr</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="o">=</span> <span class="n">RuleEG</span><span class="p">()</span><span class="o">.</span><span class="n">insertion</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">qr</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="o">=</span> <span class="n">RuleEG</span><span class="p">()</span><span class="o">.</span><span class="n">insertion</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span> <span class="n">r</span>
<span class="go">[2, 3, 4, 5, 8]</span>
<span class="gp">sage: </span><span class="n">j</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">qr</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="o">=</span> <span class="n">RuleEG</span><span class="p">()</span><span class="o">.</span><span class="n">insertion</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span> <span class="n">r</span>
<span class="go">[2, 3, 3, 5, 8]</span>
<span class="gp">sage: </span><span class="n">j</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleEG.reverse_insertion">
<span class="sig-name descname"><span class="pre">reverse_insertion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleEG.reverse_insertion" title="Permalink to this definition">#</a></dt>
<dd><p>Reverse bump the row <code class="docutils literal notranslate"><span class="pre">row</span></code> of the current insertion tableau
with the number <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>The row <code class="docutils literal notranslate"><span class="pre">row</span></code> is modified in place. The bumped-out entry
is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleEG</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">RuleEG</span><span class="p">()</span><span class="o">.</span><span class="n">reverse_insertion</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span> <span class="n">r</span>
<span class="go">[1, 1, 1, 2, 3, 3]</span>
<span class="gp">sage: </span><span class="n">x</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleHecke">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.combinat.rsk.</span></span><span class="sig-name descname"><span class="pre">RuleHecke</span></span><a class="headerlink" href="#sage.combinat.rsk.RuleHecke" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.combinat.rsk.Rule" title="sage.combinat.rsk.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rule</span></code></a></p>
<p>Rule for Hecke insertion.</p>
<p>The Hecke RSK algorithm is similar to the classical RSK algorithm,
but is defined using the Hecke insertion introduced in in
<a class="reference internal" href="#bksty06" id="id15"><span>[BKSTY06]</span></a> (but using rows instead of columns).
It is not clear in what generality it works; thus, following
<a class="reference internal" href="#bksty06" id="id16"><span>[BKSTY06]</span></a>, we shall assume that our biword <span class="math notranslate nohighlight">\(p\)</span> has top row
<span class="math notranslate nohighlight">\((1, 2, \ldots, n)\)</span> (or, at least, has its top row strictly
increasing).</p>
<p>The Hecke RSK algorithm returns a pair of an increasing tableau
and a set-valued standard tableau. If
<span class="math notranslate nohighlight">\(p = ((j_0, k_0), (j_1, k_1), \ldots, (j_{\ell-1}, k_{\ell-1}))\)</span>,
then the algorithm recursively constructs pairs
<span class="math notranslate nohighlight">\((P_0, Q_0), (P_1, Q_1), \ldots, (P_\ell, Q_\ell)\)</span> of tableaux.
The construction of <span class="math notranslate nohighlight">\(P_{t+1}\)</span> and <span class="math notranslate nohighlight">\(Q_{t+1}\)</span> from <span class="math notranslate nohighlight">\(P_t\)</span>, <span class="math notranslate nohighlight">\(Q_t\)</span>,
<span class="math notranslate nohighlight">\(j_t\)</span> and <span class="math notranslate nohighlight">\(k_t\)</span> proceeds as follows: Set <span class="math notranslate nohighlight">\(i = j_t\)</span>, <span class="math notranslate nohighlight">\(x = k_t\)</span>,
<span class="math notranslate nohighlight">\(P = P_t\)</span> and <span class="math notranslate nohighlight">\(Q = Q_t\)</span>. We are going to insert <span class="math notranslate nohighlight">\(x\)</span> into the
increasing tableau <span class="math notranslate nohighlight">\(P\)</span> and update the set-valued “recording
tableau” <span class="math notranslate nohighlight">\(Q\)</span> accordingly. As in the classical RSK algorithm, we
first insert <span class="math notranslate nohighlight">\(x\)</span> into row <span class="math notranslate nohighlight">\(1\)</span> of <span class="math notranslate nohighlight">\(P\)</span>, then into row <span class="math notranslate nohighlight">\(2\)</span> of the
resulting tableau, and so on, until the construction terminates.
The details are different: Suppose we are inserting <span class="math notranslate nohighlight">\(x\)</span> into
row <span class="math notranslate nohighlight">\(R\)</span> of <span class="math notranslate nohighlight">\(P\)</span>. If (Case 1) there exists an entry <span class="math notranslate nohighlight">\(y\)</span> in row <span class="math notranslate nohighlight">\(R\)</span>
such that <span class="math notranslate nohighlight">\(x &lt; y\)</span>, then let <span class="math notranslate nohighlight">\(y\)</span> be the minimal such entry. We
replace this entry <span class="math notranslate nohighlight">\(y\)</span> with <span class="math notranslate nohighlight">\(x\)</span> if the result is still an
increasing tableau; in either subcase, we then continue
recursively, inserting <span class="math notranslate nohighlight">\(y\)</span> into the next row of <span class="math notranslate nohighlight">\(P\)</span>.
If, on the other hand, (Case 2) no such <span class="math notranslate nohighlight">\(y\)</span> exists, then we
append <span class="math notranslate nohighlight">\(x\)</span> to the end of <span class="math notranslate nohighlight">\(R\)</span> if the result is an increasing
tableau (Subcase 2.1), and otherwise (Subcase 2.2) do nothing.
Furthermore, in Subcase 2.1, we add the box that we have just
filled with <span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(P\)</span> to the shape of <span class="math notranslate nohighlight">\(Q\)</span>, and fill it with
the one-element set <span class="math notranslate nohighlight">\(\{i\}\)</span>. In Subcase 2.2, we find the
bottommost box of the column containing the rightmost box of
row <span class="math notranslate nohighlight">\(R\)</span>, and add <span class="math notranslate nohighlight">\(i\)</span> to the entry of <span class="math notranslate nohighlight">\(Q\)</span> in this box (this
entry is a set, since <span class="math notranslate nohighlight">\(Q\)</span> is set-valued). In either
subcase, we terminate the recursion, and set
<span class="math notranslate nohighlight">\(P_{t+1} = P\)</span> and <span class="math notranslate nohighlight">\(Q_{t+1} = Q\)</span>.</p>
<p>Notice that set-valued tableaux are encoded as tableaux whose
entries are tuples of positive integers; each such tuple is strictly
increasing and encodes a set (namely, the set of its entries).</p>
<p>EXAMPLES:</p>
<p>As an example of Hecke insertion, we reproduce
Example 2.1 in <a class="reference external" href="https://arxiv.org/abs/0801.1319v2">arXiv 0801.1319v2</a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">,</span><span class="n">Q</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">Hecke</span><span class="p">);</span> <span class="p">[</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">]</span>
<span class="go">[[[1, 2, 4, 5], [2, 4, 5], [3, 5], [4], [5]],</span>
<span class="go"> [[(1,), (4,), (5,), (7,)],</span>
<span class="go">  [(2,), (9,), (11, 13)],</span>
<span class="go">  [(3,), (12,)],</span>
<span class="go">  [(6,)],</span>
<span class="go">  [(8, 10)]]]</span>
<span class="gp">sage: </span><span class="n">wp</span> <span class="o">=</span> <span class="n">RSK_inverse</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">Hecke</span><span class="p">,</span>
<span class="gp">....: </span>                   <span class="n">output</span><span class="o">=</span><span class="s1">&#39;list&#39;</span><span class="p">);</span> <span class="n">wp</span>
<span class="go">[5, 4, 1, 3, 4, 2, 5, 1, 2, 1, 4, 2, 4]</span>
<span class="gp">sage: </span><span class="n">wp</span> <span class="o">==</span> <span class="n">w</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleHecke.backward_rule">
<span class="sig-name descname"><span class="pre">backward_rule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleHecke.backward_rule" title="Permalink to this definition">#</a></dt>
<dd><p>Return the generalized permutation obtained by applying reverse
Hecke insertion to a pair of tableaux <code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">q)</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">p</span></code>, <code class="docutils literal notranslate"><span class="pre">q</span></code> – two tableaux of the same shape</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'array'</span></code>) if <code class="docutils literal notranslate"><span class="pre">q</span></code> is semi-standard:</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'array'</span></code> – as a two-line array (i.e. generalized permutation
or biword)</p></li>
</ul>
<p>and if <code class="docutils literal notranslate"><span class="pre">q</span></code> is standard set-valued, we can have the output:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'word'</span></code> – as a word</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'list'</span></code> – as a list</p></li>
</ul>
</div></blockquote>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleHecke</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,)],</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,)],</span> <span class="p">[(</span><span class="mi">5</span><span class="p">,)]])</span>
<span class="gp">sage: </span><span class="n">RuleHecke</span><span class="p">()</span><span class="o">.</span><span class="n">backward_rule</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;array&#39;</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 4, 5], [3, 3, 2, 4, 1]]</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,)],</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,)],</span> <span class="p">[(</span><span class="mi">5</span><span class="p">,)]])</span>
<span class="gp">sage: </span><span class="n">RuleHecke</span><span class="p">()</span><span class="o">.</span><span class="n">backward_rule</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;array&#39;</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: p(=[[1, 4], [2, 3]]) and</span>
<span class="go"> q(=[[(1, 2), (4,)], [(3,)], [(5,)]]) must have the same shape</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleHecke.forward_rule">
<span class="sig-name descname"><span class="pre">forward_rule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_standard</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleHecke.forward_rule" title="Permalink to this definition">#</a></dt>
<dd><p>Return a pair of tableaux obtained by applying Hecke
insertion to the generalized permutation <code class="docutils literal notranslate"><span class="pre">[obj1,</span> <span class="pre">obj2]</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">obj1,</span> <span class="pre">obj2</span></code> – can be one of the following ways to
represent a generalized permutation (or, equivalently,
biword):</p>
<ul>
<li><p>two lists <code class="docutils literal notranslate"><span class="pre">obj1</span></code> and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> of equal length,
to be interpreted as the top row and the bottom row of
the biword</p></li>
<li><p>a word <code class="docutils literal notranslate"><span class="pre">obj1</span></code> in an ordered alphabet, to be
interpreted as the bottom row of the biword (in this
case, <code class="docutils literal notranslate"><span class="pre">obj2</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>; the top row of the biword
is understood to be <span class="math notranslate nohighlight">\((1, 2, \ldots, n)\)</span> by default)</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_standard</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) check if either of the
resulting tableaux is a standard tableau, and if so, typecast it
as such</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleHecke</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">RuleHecke</span><span class="p">()</span><span class="o">.</span><span class="n">forward_rule</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="kc">None</span><span class="p">);</span><span class="n">p</span>
<span class="go">[[1, 4], [2], [3]]</span>
<span class="gp">sage: </span><span class="n">q</span>
<span class="go">[[(1, 2), (4,)], [(3,)], [(5,)]]</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">SemistandardTableau</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">Tableau</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleHecke.insertion">
<span class="sig-name descname"><span class="pre">insertion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleHecke.insertion" title="Permalink to this definition">#</a></dt>
<dd><p>Insert the letter <code class="docutils literal notranslate"><span class="pre">j</span></code> from the second row of the biword
into the row <span class="math notranslate nohighlight">\(r\)</span> of the increasing tableau <span class="math notranslate nohighlight">\(p\)</span> using
Hecke insertion, provided that <span class="math notranslate nohighlight">\(r\)</span> is the <span class="math notranslate nohighlight">\(ir\)</span>-th row
of <span class="math notranslate nohighlight">\(p\)</span>, and provided that there is bumping to be done.</p>
<p>The row <span class="math notranslate nohighlight">\(r\)</span> is modified in place if bumping occurs. The bumped-out
entry, if it exists, is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleHecke</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">bisect</span> <span class="kn">import</span> <span class="n">bisect_right</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span>  <span class="p">[],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">j</span><span class="p">,</span> <span class="n">ir</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">j1</span> <span class="o">=</span> <span class="n">RuleHecke</span><span class="p">()</span><span class="o">.</span><span class="n">insertion</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">ir</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">j1</span> <span class="o">==</span> <span class="n">r</span><span class="p">[</span><span class="n">bisect_right</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleHecke.reverse_insertion">
<span class="sig-name descname"><span class="pre">reverse_insertion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleHecke.reverse_insertion" title="Permalink to this definition">#</a></dt>
<dd><p>Reverse bump the row <code class="docutils literal notranslate"><span class="pre">row</span></code> of the current insertion tableau
<code class="docutils literal notranslate"><span class="pre">p</span></code> with the number <code class="docutils literal notranslate"><span class="pre">x</span></code>, provided that <code class="docutils literal notranslate"><span class="pre">row</span></code> is the
<span class="math notranslate nohighlight">\(i\)</span>-th row of <span class="math notranslate nohighlight">\(p\)</span>.</p>
<p>The row <code class="docutils literal notranslate"><span class="pre">row</span></code> is modified in place. The bumped-out entry
is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleHecke</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">bisect</span> <span class="kn">import</span> <span class="n">bisect_left</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">x1</span> <span class="o">=</span> <span class="n">RuleHecke</span><span class="p">()</span><span class="o">.</span><span class="n">reverse_insertion</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x1</span> <span class="o">==</span> <span class="n">r</span><span class="p">[</span><span class="n">bisect_left</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleRSK">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.combinat.rsk.</span></span><span class="sig-name descname"><span class="pre">RuleRSK</span></span><a class="headerlink" href="#sage.combinat.rsk.RuleRSK" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.combinat.rsk.Rule" title="sage.combinat.rsk.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rule</span></code></a></p>
<p>Rule for the classical Robinson-Schensted-Knuth insertion.</p>
<p>See <a class="reference internal" href="#sage.combinat.rsk.RSK" title="sage.combinat.rsk.RSK"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK()</span></code></a> for the definition of this operation.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">RSK</span><span class="p">)</span>
<span class="go">[[[1, 1, 2], [2]], [[1, 2, 2], [2]]]</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">]]);</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">RSK</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 3], [2, 1, 2, 2]]</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleRSK.insertion">
<span class="sig-name descname"><span class="pre">insertion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleRSK.insertion" title="Permalink to this definition">#</a></dt>
<dd><p>Insert the letter <code class="docutils literal notranslate"><span class="pre">j</span></code> from the second row of the biword
into the row <span class="math notranslate nohighlight">\(r\)</span> using classical Schensted insertion,
if there is bumping to be done.</p>
<p>The row <span class="math notranslate nohighlight">\(r\)</span> is modified in place if bumping occurs. The bumped-out
entry, if it exists, is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleRSK</span>
<span class="gp">sage: </span><span class="n">qr</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="o">=</span> <span class="n">RuleRSK</span><span class="p">()</span><span class="o">.</span><span class="n">insertion</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">qr</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="o">=</span> <span class="n">RuleRSK</span><span class="p">()</span><span class="o">.</span><span class="n">insertion</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">j</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleRSK.reverse_insertion">
<span class="sig-name descname"><span class="pre">reverse_insertion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleRSK.reverse_insertion" title="Permalink to this definition">#</a></dt>
<dd><p>Reverse bump the row <code class="docutils literal notranslate"><span class="pre">row</span></code> of the current insertion tableau
with the number <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>The row <code class="docutils literal notranslate"><span class="pre">row</span></code> is modified in place. The bumped-out entry
is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleRSK</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">RuleRSK</span><span class="p">()</span><span class="o">.</span><span class="n">reverse_insertion</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span> <span class="n">r</span>
<span class="go">[2, 3, 4, 4, 8]</span>
<span class="gp">sage: </span><span class="n">x</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleStar">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.combinat.rsk.</span></span><span class="sig-name descname"><span class="pre">RuleStar</span></span><a class="headerlink" href="#sage.combinat.rsk.RuleStar" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.combinat.rsk.Rule" title="sage.combinat.rsk.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rule</span></code></a></p>
<p>Rule for <span class="math notranslate nohighlight">\(\star\)</span>-insertion.</p>
<p>The <span class="math notranslate nohighlight">\(\star\)</span>-insertion is similar to the classical RSK algorithm
and is defined in <a class="reference internal" href="../../../references/index.html#mpps2020" id="id17"><span>[MPPS2020]</span></a>. The bottom row of the increasing
Hecke biword is a word in the 0-Hecke monoid that is fully
commutative. When inserting a letter <span class="math notranslate nohighlight">\(x\)</span> into a row <span class="math notranslate nohighlight">\(R\)</span>, there
are three cases:</p>
<ul class="simple">
<li><p>Case 1: If <span class="math notranslate nohighlight">\(R\)</span> is empty or <span class="math notranslate nohighlight">\(x &gt; \max(R)\)</span>, append <span class="math notranslate nohighlight">\(x\)</span> to row <span class="math notranslate nohighlight">\(R\)</span>
and terminate.</p></li>
<li><p>Case 2: Otherwise if <span class="math notranslate nohighlight">\(x\)</span> is not in <span class="math notranslate nohighlight">\(R\)</span>, locate the smallest <span class="math notranslate nohighlight">\(y\)</span> in <span class="math notranslate nohighlight">\(R\)</span>
with <span class="math notranslate nohighlight">\(y &gt; x\)</span>. Bump <span class="math notranslate nohighlight">\(y\)</span> with <span class="math notranslate nohighlight">\(x\)</span> and insert <span class="math notranslate nohighlight">\(y\)</span> into the next row.</p></li>
<li><p>Case 3: Otherwise, if <span class="math notranslate nohighlight">\(x\)</span> is in <span class="math notranslate nohighlight">\(R\)</span>, locate the smallest <span class="math notranslate nohighlight">\(y\)</span> in <span class="math notranslate nohighlight">\(R\)</span> with
<span class="math notranslate nohighlight">\(y \leq x\)</span> and interval <span class="math notranslate nohighlight">\([y,x]\)</span> contained in <span class="math notranslate nohighlight">\(R\)</span>. Row <span class="math notranslate nohighlight">\(R\)</span> remains
unchanged and <span class="math notranslate nohighlight">\(y\)</span> is to be inserted into the next row.</p></li>
</ul>
<p>The <span class="math notranslate nohighlight">\(\star\)</span>-insertion returns a pair consisting a conjugate of a
semistandard tableau and a semistandard tableau. It is a bijection from the
collection of all increasing Hecke biwords whose bottom row is a fully
commutative word to pairs (P, Q) of tableaux of the same shape such that
P is conjugate semistandard, Q is semistandard and the row reading word of
P is fully commutative <a class="reference internal" href="../../../references/index.html#mpps2020" id="id18"><span>[MPPS2020]</span></a>.</p>
<p>EXAMPLES:</p>
<p>As an example of <span class="math notranslate nohighlight">\(\star\)</span>-insertion, we reproduce Example 28 in <a class="reference internal" href="../../../references/index.html#mpps2020" id="id19"><span>[MPPS2020]</span></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleStar</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">,</span><span class="n">q</span> <span class="o">=</span> <span class="n">RuleStar</span><span class="p">()</span><span class="o">.</span><span class="n">forward_rule</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="go">  1  2  4  1  1  2</span>
<span class="go">  1  4     2  4</span>
<span class="go">  3        4</span>
<span class="gp">sage: </span><span class="n">line1</span><span class="p">,</span><span class="n">line2</span> <span class="o">=</span> <span class="n">RuleStar</span><span class="p">()</span><span class="o">.</span><span class="n">backward_rule</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">line1</span><span class="p">,</span><span class="n">line2</span>
<span class="go">([1, 1, 2, 2, 4, 4], [1, 3, 2, 4, 2, 4])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;DecreasingHeckeFactorization&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;Star&#39;</span><span class="p">)</span>
<span class="go">(4, 2)()(4, 2)(3, 1)</span>

<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.crystals.fully_commutative_stable_grothendieck</span> <span class="kn">import</span> <span class="n">DecreasingHeckeFactorization</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">DecreasingHeckeFactorization</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="o">*</span><span class="n">RSK</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;Star&#39;</span><span class="p">),</span><span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;Star&#39;</span><span class="p">,</span>
<span class="gp">....: </span>            <span class="n">output</span><span class="o">=</span><span class="s1">&#39;DecreasingHeckeFactorization&#39;</span><span class="p">)</span>
<span class="go">(4, 2)()(4, 2)(3, 1)</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">,</span><span class="n">q</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;Star&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="go">1  2  4  1  1  2</span>
<span class="go">1  4     2  4</span>
<span class="go">3        4</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;Star&#39;</span><span class="p">)</span>
<span class="go">[[1, 1, 2, 2, 4, 4], [1, 3, 2, 4, 2, 4]]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;DecreasingHeckeFactorization&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;Star&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">==</span> <span class="n">h</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When <code class="docutils literal notranslate"><span class="pre">output</span></code> is set to <code class="docutils literal notranslate"><span class="pre">'DecreasingHeckeFactorization'</span></code>, the
inverse of <span class="math notranslate nohighlight">\(\star\)</span>-insertion of <span class="math notranslate nohighlight">\((P,Q)\)</span> returns a decreasing
factorization whose number of factors is the maximum entry of <span class="math notranslate nohighlight">\(Q\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.crystals.fully_commutative_stable_grothendieck</span> <span class="kn">import</span> <span class="n">DecreasingHeckeFactorization</span>
<span class="gp">sage: </span><span class="n">h1</span> <span class="o">=</span> <span class="n">DecreasingHeckeFactorization</span><span class="p">([[],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">]]);</span> <span class="n">h1</span>
<span class="go">()(3, 1)(1)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">,</span><span class="n">Q</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">(</span><span class="n">h1</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;Star&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
<span class="go">  1  3  1  2</span>
<span class="go">  1     2</span>
<span class="gp">sage: </span><span class="n">h2</span> <span class="o">=</span> <span class="n">RSK_inverse</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;Star&#39;</span><span class="p">,</span>
<span class="gp">....: </span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;DecreasingHeckeFactorization&#39;</span><span class="p">);</span> <span class="n">h2</span>
<span class="go">(3, 1)(1)</span>
</pre></div>
</div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleStar.backward_rule">
<span class="sig-name descname"><span class="pre">backward_rule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'array'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleStar.backward_rule" title="Permalink to this definition">#</a></dt>
<dd><p>Return the increasing Hecke biword obtained by applying reverse
<span class="math notranslate nohighlight">\(\star\)</span>-insertion to a pair of tableaux <code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">q)</span></code>.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span></code>, <code class="docutils literal notranslate"><span class="pre">q</span></code> – two tableaux of the same shape, where <code class="docutils literal notranslate"><span class="pre">p</span></code> is the
conjugate of a semistandard tableau, whose reading word is fully
commutative and <code class="docutils literal notranslate"><span class="pre">q</span></code> is a semistandard tableau.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'array'</span></code>) if <code class="docutils literal notranslate"><span class="pre">q</span></code> is semi-standard:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'array'</span></code> – as a two-line array (i.e. generalized permutation
or biword) that is an increasing Hecke biword</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'DecreasingHeckeFactorization'</span></code> – as a decreasing
factorization in the 0-Hecke monoid</p></li>
</ul>
<p>and if <code class="docutils literal notranslate"><span class="pre">q</span></code> is standard:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'word'</span></code> – as a (possibly non-reduced) word in the 0-Hecke
monoid</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When output is ‘DecreasingHeckeFactorization’, the number of factors
in the output is the largest number in <code class="docutils literal notranslate"><span class="pre">obj1</span></code>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleStar</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">,</span><span class="n">q</span> <span class="o">=</span> <span class="n">RuleStar</span><span class="p">()</span><span class="o">.</span><span class="n">forward_rule</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="go">  1  2  4  1  1  2</span>
<span class="go">  1  4     2  4</span>
<span class="go">  3        4</span>
<span class="gp">sage: </span><span class="n">line1</span><span class="p">,</span><span class="n">line2</span> <span class="o">=</span> <span class="n">RuleStar</span><span class="p">()</span><span class="o">.</span><span class="n">backward_rule</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span> <span class="n">line1</span><span class="p">,</span><span class="n">line2</span>
<span class="go">([1, 1, 2, 2, 4, 4], [1, 3, 2, 4, 2, 4])</span>
<span class="gp">sage: </span><span class="n">RuleStar</span><span class="p">()</span><span class="o">.</span><span class="n">backward_rule</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="s1">&#39;DecreasingHeckeFactorization&#39;</span><span class="p">)</span>
<span class="go">(4, 2)()(4, 2)(3, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleStar.forward_rule">
<span class="sig-name descname"><span class="pre">forward_rule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_braid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleStar.forward_rule" title="Permalink to this definition">#</a></dt>
<dd><p>Return a pair of tableaux obtained by applying forward insertion
to the increasing Hecke biword <code class="docutils literal notranslate"><span class="pre">[obj1,</span> <span class="pre">obj2]</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">obj1,</span> <span class="pre">obj2</span></code> – can be one of the following ways to represent a
biword (or, equivalently, an increasing 0-Hecke factorization) that
is fully commutative:</p>
<ul>
<li><p>two lists <code class="docutils literal notranslate"><span class="pre">obj1</span></code> and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> of equal length, to be
interpreted as the top row and the bottom row of the biword.</p></li>
<li><p>a word <code class="docutils literal notranslate"><span class="pre">obj1</span></code> in an ordered alphabet, to be interpreted as
the bottom row of the biword (in this case, <code class="docutils literal notranslate"><span class="pre">obj2</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>;
the top row of the biword is understood to be <span class="math notranslate nohighlight">\((1,2,\ldots,n)\)</span>
by default).</p></li>
<li><p>a DecreasingHeckeFactorization <code class="docutils literal notranslate"><span class="pre">obj1</span></code>, the whose increasing
Hecke biword will be interpreted as the bottom row; the top row is
understood to be the indices of the factors for each letter in
this biword.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_braid</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) indicator to validate that
input is associated to a fully commutative word in the 0-Hecke monoid,
validation is performed if set to <code class="docutils literal notranslate"><span class="pre">True</span></code>; otherwise, this validation
is ignored.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleStar</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">,</span><span class="n">q</span> <span class="o">=</span> <span class="n">RuleStar</span><span class="p">()</span><span class="o">.</span><span class="n">forward_rule</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span> <span class="n">p</span><span class="p">,</span><span class="n">q</span>
<span class="go">([[1, 3], [2, 3], [2]], [[1, 1], [2, 3], [3]])</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">,</span><span class="n">q</span> <span class="o">=</span> <span class="n">RuleStar</span><span class="p">()</span><span class="o">.</span><span class="n">forward_rule</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span> <span class="n">p</span><span class="p">,</span><span class="n">q</span>
<span class="go">([[1, 3], [2, 3], [2]], [[1, 2], [3, 5], [4]])</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">,</span><span class="n">q</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">Star</span><span class="p">);</span> <span class="n">p</span><span class="p">,</span><span class="n">q</span>
<span class="go">([[1, 3], [2, 3], [2]], [[1, 1], [2, 3], [3]])</span>

<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.crystals.fully_commutative_stable_grothendieck</span> <span class="kn">import</span> <span class="n">DecreasingHeckeFactorization</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">DecreasingHeckeFactorization</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">,</span><span class="n">q</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">Star</span><span class="p">);</span> <span class="n">p</span><span class="p">,</span><span class="n">q</span>
<span class="go">([[1, 3], [2, 3], [2]], [[1, 1], [2, 3], [3]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleStar.insertion">
<span class="sig-name descname"><span class="pre">insertion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleStar.insertion" title="Permalink to this definition">#</a></dt>
<dd><p>Insert the letter <code class="docutils literal notranslate"><span class="pre">b</span></code> from the second row of the biword into the row
<code class="docutils literal notranslate"><span class="pre">r</span></code> using <span class="math notranslate nohighlight">\(\star\)</span>-insertion defined in <a class="reference internal" href="../../../references/index.html#mpps2020" id="id20"><span>[MPPS2020]</span></a>.</p>
<p>The row <span class="math notranslate nohighlight">\(r\)</span> is modified in place if bumping occurs and <span class="math notranslate nohighlight">\(b\)</span> is not in
row <span class="math notranslate nohighlight">\(r\)</span>. The bumped-out entry, if it exists, is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleStar</span>
<span class="gp">sage: </span><span class="n">RuleStar</span><span class="p">()</span><span class="o">.</span><span class="n">insertion</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">RuleStar</span><span class="p">()</span><span class="o">.</span><span class="n">insertion</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">RuleStar</span><span class="p">()</span><span class="o">.</span><span class="n">insertion</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleStar.reverse_insertion">
<span class="sig-name descname"><span class="pre">reverse_insertion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleStar.reverse_insertion" title="Permalink to this definition">#</a></dt>
<dd><p>Reverse bump the row <code class="docutils literal notranslate"><span class="pre">r</span></code> of the current insertion tableau <code class="docutils literal notranslate"><span class="pre">p</span></code>
with number <code class="docutils literal notranslate"><span class="pre">x</span></code>, provided that <code class="docutils literal notranslate"><span class="pre">r</span></code> is the <code class="docutils literal notranslate"><span class="pre">i</span></code>-th row of <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p>
<p>The row <code class="docutils literal notranslate"><span class="pre">r</span></code> is modified in place. The bumped-out entry is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleStar</span>
<span class="gp">sage: </span><span class="n">RuleStar</span><span class="p">()</span><span class="o">.</span><span class="n">reverse_insertion</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">RuleStar</span><span class="p">()</span><span class="o">.</span><span class="n">reverse_insertion</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">RuleStar</span><span class="p">()</span><span class="o">.</span><span class="n">reverse_insertion</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleSuperRSK">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.combinat.rsk.</span></span><span class="sig-name descname"><span class="pre">RuleSuperRSK</span></span><a class="headerlink" href="#sage.combinat.rsk.RuleSuperRSK" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.combinat.rsk.RuleRSK" title="sage.combinat.rsk.RuleRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleRSK</span></code></a></p>
<p>Rule for super RSK insertion.</p>
<p>Super RSK is based on <span class="math notranslate nohighlight">\(\epsilon\)</span>-insertion, a combination of
row and column classical RSK insertion.</p>
<p>Super RSK insertion differs from the classical RSK insertion in the
following ways:</p>
<ul class="simple">
<li><p>The input (in terms of biwords) is no longer an arbitrary biword,
but rather a restricted super biword (i.e., a pair of two lists
<span class="math notranslate nohighlight">\([a_1, a_2, \ldots, a_n]\)</span> and <span class="math notranslate nohighlight">\([b_1, b_2, \ldots, b_n]\)</span> that
contains entries with even and odd parity and pairs with mixed
parity entries do not repeat).</p></li>
<li><p>The output still consists of two tableaux <span class="math notranslate nohighlight">\((P, Q)\)</span> of equal
shapes, but rather than both of them being semistandard, now
they are semistandard super tableaux.</p></li>
<li><p>The main difference is in the way bumping works. Instead of having
only row bumping super RSK uses <span class="math notranslate nohighlight">\(\epsilon\)</span>-insertion, a combination
of classical RSK bumping along the rows and a dual RSK like bumping
(i.e. when a number <span class="math notranslate nohighlight">\(k_i\)</span> is inserted into the <span class="math notranslate nohighlight">\(i\)</span>-th row of <span class="math notranslate nohighlight">\(P\)</span>, it
bumps out the first integer greater <strong>or equal to</strong> <span class="math notranslate nohighlight">\(k_i\)</span> in the column)
along the column.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;superRSK&#39;</span><span class="p">)</span>
<span class="go">[[[1]], [[1]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;superRSK&#39;</span><span class="p">)</span>
<span class="go">[[[1, 3]], [[1, 2]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;superRSK&#39;</span><span class="p">)</span>
<span class="go">[[[1, 3], [3&#39;]], [[1, 2], [3]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="s2">&quot;2p&quot;</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;superRSK&#39;</span><span class="p">)</span>
<span class="go">[[[1, 3&#39;, 3], [2&#39;]], [[1&#39;, 1, 2&#39;], [2]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="s2">&quot;1p&quot;</span><span class="p">,</span> <span class="s2">&quot;2p&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">....: </span>    <span class="p">[</span><span class="s2">&quot;1p&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;2p&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;superRSK&#39;</span><span class="p">)</span>
<span class="go">[[[1&#39;, 2, 3&#39;, 3], [1, 3&#39;], [2&#39;], [3&#39;]], [[1&#39;, 2, 3&#39;, 3], [2&#39;, 3&#39;], [2], [3]]]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">SemistandardSuperTableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;3p&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;2p&#39;</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">SemistandardSuperTableau</span><span class="p">([[</span><span class="s1">&#39;1p&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;2p&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">superRSK</span><span class="p">)</span>
<span class="go">[[1&#39;, 1, 2&#39;, 2], [1, 3, 3&#39;, 2&#39;]]</span>
</pre></div>
</div>
<p>We apply super RSK on Example 5.1 in <a class="reference internal" href="../../../references/index.html#muth2019" id="id21"><span>[Muth2019]</span></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="p">,</span><span class="n">Q</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">([</span><span class="s2">&quot;1p&quot;</span><span class="p">,</span> <span class="s2">&quot;2p&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">....: </span>          <span class="p">[</span><span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="s2">&quot;2p&quot;</span><span class="p">,</span> <span class="s2">&quot;1p&quot;</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;superRSK&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
<span class="go">([[1&#39;, 2&#39;, 3&#39;, 3], [1, 2, 3&#39;], [3&#39;]], [[1&#39;, 2, 2, 3&#39;], [2&#39;, 3, 3], [3&#39;]])</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">((</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">))</span>
<span class="go">(  1&#39; 2&#39; 3&#39;  3   1&#39;  2  2 3&#39; )</span>
<span class="go">(   1  2 3&#39;      2&#39;  3  3    )</span>
<span class="go">(  3&#39;         ,  3&#39;          )</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">superRSK</span><span class="p">)</span>
<span class="go">[[1&#39;, 2&#39;, 2, 2, 3&#39;, 3&#39;, 3, 3], [3&#39;, 1, 2, 3, 3&#39;, 3&#39;, 2&#39;, 1&#39;]]</span>
</pre></div>
</div>
<p>Example 6.1 in <a class="reference internal" href="../../../references/index.html#muth2019" id="id22"><span>[Muth2019]</span></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="p">,</span><span class="n">Q</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">([</span><span class="s2">&quot;1p&quot;</span><span class="p">,</span> <span class="s2">&quot;2p&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">....: </span>          <span class="p">[</span><span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="s2">&quot;2p&quot;</span><span class="p">,</span> <span class="s2">&quot;1p&quot;</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;superRSK&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">((</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">))</span>
<span class="go">(  1&#39; 2&#39; 3&#39;  3   1&#39;  2  2 3&#39; )</span>
<span class="go">(   1  2 3&#39;      2&#39;  3  3    )</span>
<span class="go">(  3&#39;         ,  3&#39;          )</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">superRSK</span><span class="p">)</span>
<span class="go">[[1&#39;, 2&#39;, 2, 2, 3&#39;, 3&#39;, 3, 3], [3&#39;, 1, 2, 3, 3&#39;, 3&#39;, 2&#39;, 1&#39;]]</span>

<span class="gp">sage: </span><span class="n">P</span><span class="p">,</span><span class="n">Q</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">([</span><span class="s2">&quot;1p&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;2p&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">....: </span>          <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;2p&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="s2">&quot;1p&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;superRSK&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">((</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">))</span>
<span class="go">(  1&#39;  2  2 3&#39;   1&#39; 2&#39; 3&#39;  3 )</span>
<span class="go">(  2&#39;  3  3       1  2 3&#39;    )</span>
<span class="go">(  3&#39;         ,  3&#39;          )</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">superRSK</span><span class="p">)</span>
<span class="go">[[1&#39;, 1, 2&#39;, 2, 3&#39;, 3&#39;, 3&#39;, 3], [3, 2&#39;, 3, 2, 3&#39;, 3&#39;, 1&#39;, 2]]</span>
</pre></div>
</div>
<p>Let us now call the inverse correspondence:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">....: </span>           <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">superRSK</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">superRSK</span><span class="p">)</span>
<span class="go">[[1, 2, 2, 2], [2, 1, 2, 3]]</span>
</pre></div>
</div>
<p>When applied to two tableaux with only even parity elements, reverse super
RSK insertion behaves identically to the usual reversel RSK insertion:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">RSK</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 4, 5], [1, 4, 5, 3, 2]]</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">SemistandardSuperTableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">SemistandardSuperTableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">superRSK</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 4, 5], [1, 4, 5, 3, 2]]</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleSuperRSK.backward_rule">
<span class="sig-name descname"><span class="pre">backward_rule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'array'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleSuperRSK.backward_rule" title="Permalink to this definition">#</a></dt>
<dd><p>Return the restricted super biword obtained by applying reverse
super RSK insertion to a pair of tableaux <code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">q)</span></code>.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span></code>, <code class="docutils literal notranslate"><span class="pre">q</span></code> – two tableaux of the same shape</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'array'</span></code>) if <code class="docutils literal notranslate"><span class="pre">q</span></code> is row-strict:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'array'</span></code> – as a two-line array (i.e. restricted super biword)</p></li>
</ul>
<p>and if <code class="docutils literal notranslate"><span class="pre">q</span></code> is standard, we can have the output:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'word'</span></code> – as a word</p></li>
</ul>
</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleSuperRSK</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">SemistandardSuperTableau</span><span class="p">([[</span><span class="s1">&#39;1p&#39;</span><span class="p">,</span> <span class="s1">&#39;3p&#39;</span><span class="p">,</span> <span class="s1">&#39;4p&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">SemistandardSuperTableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RuleSuperRSK</span><span class="p">()</span><span class="o">.</span><span class="n">backward_rule</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;array&#39;</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 4, 5], [4&#39;, 3, 3&#39;, 2, 1&#39;]]</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">SemistandardSuperTableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;3p&#39;</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">SemistandardSuperTableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RuleSuperRSK</span><span class="p">()</span><span class="o">.</span><span class="n">backward_rule</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;array&#39;</span><span class="p">)</span>
<span class="go">[[1, 2, 3], [1, 3, 3&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleSuperRSK.forward_rule">
<span class="sig-name descname"><span class="pre">forward_rule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_standard</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleSuperRSK.forward_rule" title="Permalink to this definition">#</a></dt>
<dd><p>Return a pair of tableaux obtained by applying forward
insertion to the restricted super biword <code class="docutils literal notranslate"><span class="pre">[obj1,</span> <span class="pre">obj2]</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">obj1,</span> <span class="pre">obj2</span></code> – can be one of the following ways to
represent a generalized permutation (or, equivalently,
biword):</p>
<ul>
<li><p>two lists <code class="docutils literal notranslate"><span class="pre">obj1</span></code> and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> of equal length,
to be interpreted as the top row and the bottom row of
the biword</p></li>
<li><p>a word <code class="docutils literal notranslate"><span class="pre">obj1</span></code> in an ordered alphabet, to be
interpreted as the bottom row of the biword (in this
case, <code class="docutils literal notranslate"><span class="pre">obj2</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>; the top row of the biword
is understood to be <span class="math notranslate nohighlight">\((1, 2, \ldots, n)\)</span> by default)</p></li>
<li><p>any object <code class="docutils literal notranslate"><span class="pre">obj1</span></code> which has a method <code class="docutils literal notranslate"><span class="pre">_rsk_iter()</span></code>,
as long as this method returns an iterator yielding
pairs of numbers, which then are interperted as top
entries and bottom entries in the biword (in this case,
<code class="docutils literal notranslate"><span class="pre">obj2</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_standard</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) check if either of
the resulting tableaux is a standard super tableau, and if so,
typecast it as such</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) whether to check
that <code class="docutils literal notranslate"><span class="pre">obj1</span></code> and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> actually define a valid
restricted super biword</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleSuperRSK</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">RuleSuperRSK</span><span class="p">()</span><span class="o">.</span><span class="n">forward_rule</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">p</span>
<span class="go">[[1, 3]]</span>
<span class="gp">sage: </span><span class="n">q</span>
<span class="go">[[1, 2]]</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">SemistandardSuperTableau</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">SemistandardSuperTableau</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleSuperRSK.insertion">
<span class="sig-name descname"><span class="pre">insertion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleSuperRSK.insertion" title="Permalink to this definition">#</a></dt>
<dd><p>Insert the letter <code class="docutils literal notranslate"><span class="pre">j</span></code> from the second row of the biword
into the row <code class="docutils literal notranslate"><span class="pre">r</span></code> using dual RSK insertion or classical
Schensted insertion depending on the value of <code class="docutils literal notranslate"><span class="pre">epsilon</span></code>,
if there is bumping to be done.</p>
<p>The row <span class="math notranslate nohighlight">\(r\)</span> is modified in place if bumping occurs. The bumped-out
entry, if it exists, is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleSuperRSK</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">bisect</span> <span class="kn">import</span> <span class="n">bisect_left</span><span class="p">,</span> <span class="n">bisect_right</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">sage: </span><span class="n">j</span><span class="p">,</span> <span class="n">y_pos</span> <span class="o">=</span> <span class="n">RuleSuperRSK</span><span class="p">()</span><span class="o">.</span><span class="n">insertion</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span> <span class="n">r</span>
<span class="go">[1, 3, 3, 3, 3]</span>
<span class="gp">sage: </span><span class="n">j</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">y_pos</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">sage: </span><span class="n">j</span><span class="p">,</span> <span class="n">y_pos</span> <span class="o">=</span> <span class="n">RuleSuperRSK</span><span class="p">()</span><span class="o">.</span><span class="n">insertion</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span> <span class="n">r</span>
<span class="go">[1, 3, 3, 3, 4]</span>
<span class="gp">sage: </span><span class="n">j</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">y_pos</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleSuperRSK.reverse_insertion">
<span class="sig-name descname"><span class="pre">reverse_insertion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleSuperRSK.reverse_insertion" title="Permalink to this definition">#</a></dt>
<dd><p>Reverse bump the row <code class="docutils literal notranslate"><span class="pre">row</span></code> of the current insertion tableau
with the number <code class="docutils literal notranslate"><span class="pre">x</span></code> using dual RSK insertion or classical
Schensted insertion depending on the value of <span class="math notranslate nohighlight">\(epsilon\)</span>.</p>
<p>The row <code class="docutils literal notranslate"><span class="pre">row</span></code> is modified in place. The bumped-out entry
is returned along with the bumped position.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleSuperRSK</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">bisect</span> <span class="kn">import</span> <span class="n">bisect_left</span><span class="p">,</span> <span class="n">bisect_right</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">sage: </span><span class="n">j</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">RuleSuperRSK</span><span class="p">()</span><span class="o">.</span><span class="n">reverse_insertion</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span> <span class="n">r</span>
<span class="go">[2, 3, 3, 3, 4]</span>
<span class="gp">sage: </span><span class="n">j</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">y</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">sage: </span><span class="n">j</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">RuleSuperRSK</span><span class="p">()</span><span class="o">.</span><span class="n">reverse_insertion</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span> <span class="n">r</span>
<span class="go">[3, 3, 3, 3, 4]</span>
<span class="gp">sage: </span><span class="n">j</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">y</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">j</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">RuleSuperRSK</span><span class="p">()</span><span class="o">.</span><span class="n">reverse_insertion</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span> <span class="n">r</span>
<span class="go">[1, 3, 3, 3, 4]</span>
<span class="gp">sage: </span><span class="n">j</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">y</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleSuperRSK.to_pairs">
<span class="sig-name descname"><span class="pre">to_pairs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleSuperRSK.to_pairs" title="Permalink to this definition">#</a></dt>
<dd><p>Given a valid input for the super RSK algorithm, such as
two <span class="math notranslate nohighlight">\(n\)</span>-tuples <code class="docutils literal notranslate"><span class="pre">obj1</span></code> <span class="math notranslate nohighlight">\(= [a_1, a_2, \ldots, a_n]\)</span>
and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> <span class="math notranslate nohighlight">\(= [b_1, b_2, \ldots, b_n]\)</span> forming a restricted
super biword (i.e., entries with even and odd parity and no
repetition of corresponding pairs with mixed parity entries)
return the array <span class="math notranslate nohighlight">\([(a_1, b_1), (a_2, b_2), \ldots, (a_n, b_n)]\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">obj1,</span> <span class="pre">obj2</span></code> – anything representing a restricted super biword
(see the doc of <a class="reference internal" href="#sage.combinat.rsk.RuleSuperRSK.forward_rule" title="sage.combinat.rsk.RuleSuperRSK.forward_rule"><code class="xref py py-meth docutils literal notranslate"><span class="pre">forward_rule()</span></code></a> for the
encodings accepted)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) whether to check
that <code class="docutils literal notranslate"><span class="pre">obj1</span></code> and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> actually define a valid
restricted super biword</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleSuperRSK</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">RuleSuperRSK</span><span class="p">()</span><span class="o">.</span><span class="n">to_pairs</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;1p&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;1p&#39;</span><span class="p">]))</span>
<span class="go">[(2, 1), (1&#39;, 1), (1, 1&#39;)]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">RuleSuperRSK</span><span class="p">()</span><span class="o">.</span><span class="n">to_pairs</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;1p&#39;</span><span class="p">,</span> <span class="s1">&#39;2p&#39;</span><span class="p">]))</span>
<span class="go">[(1&#39;, 1), (1, 1&#39;), (2&#39;, 2&#39;)]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">RuleSuperRSK</span><span class="p">()</span><span class="o">.</span><span class="n">to_pairs</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;1p&#39;</span><span class="p">,</span> <span class="s1">&#39;1p&#39;</span><span class="p">]))</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: invalid restricted superbiword</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.combinat.rsk.robinson_schensted_knuth">
<span class="sig-prename descclassname"><span class="pre">sage.combinat.rsk.</span></span><span class="sig-name descname"><span class="pre">robinson_schensted_knuth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj1=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj2=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">insertion=&lt;class</span> <span class="pre">'sage.combinat.rsk.RuleRSK'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_standard=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.robinson_schensted_knuth" title="Permalink to this definition">#</a></dt>
<dd><p>Perform the Robinson-Schensted-Knuth (RSK) correspondence.</p>
<p>The Robinson-Schensted-Knuth (RSK) correspondence (also known
as the RSK algorithm) is most naturally stated as a bijection
between generalized permutations (also known as two-line arrays,
biwords, …) and pairs of semi-standard Young tableaux <span class="math notranslate nohighlight">\((P, Q)\)</span>
of identical shape. The tableau <span class="math notranslate nohighlight">\(P\)</span> is known as the insertion
tableau, and <span class="math notranslate nohighlight">\(Q\)</span> is known as the recording tableau.</p>
<p>The basic operation is known as row insertion <span class="math notranslate nohighlight">\(P \leftarrow k\)</span>
(where <span class="math notranslate nohighlight">\(P\)</span> is a given semi-standard Young tableau, and <span class="math notranslate nohighlight">\(k\)</span> is an
integer). Row insertion is a recursive algorithm which starts by
setting <span class="math notranslate nohighlight">\(k_0 = k\)</span>, and in its <span class="math notranslate nohighlight">\(i\)</span>-th step inserts the number <span class="math notranslate nohighlight">\(k_i\)</span>
into the <span class="math notranslate nohighlight">\(i\)</span>-th row of <span class="math notranslate nohighlight">\(P\)</span> (we start counting the rows at <span class="math notranslate nohighlight">\(0\)</span>) by
replacing the first integer greater than <span class="math notranslate nohighlight">\(k_i\)</span> in the row by <span class="math notranslate nohighlight">\(k_i\)</span>
and defines <span class="math notranslate nohighlight">\(k_{i+1}\)</span> as the integer that has been replaced. If no
integer greater than <span class="math notranslate nohighlight">\(k_i\)</span> exists in the <span class="math notranslate nohighlight">\(i\)</span>-th row, then <span class="math notranslate nohighlight">\(k_i\)</span> is
simply appended to the row and the algorithm terminates at this point.</p>
<p>A <em>generalized permutation</em> (or <em>biword</em>) is a list
<span class="math notranslate nohighlight">\(((j_0, k_0), (j_1, k_1), \ldots, (j_{\ell-1}, k_{\ell-1}))\)</span>
of pairs such that the letters <span class="math notranslate nohighlight">\(j_0, j_1, \ldots, j_{\ell-1}\)</span>
are weakly increasing (that is,
<span class="math notranslate nohighlight">\(j_0 \leq j_1 \leq \cdots \leq j_{\ell-1}\)</span>), whereas the letters
<span class="math notranslate nohighlight">\(k_i\)</span> satisfy <span class="math notranslate nohighlight">\(k_i \leq k_{i+1}\)</span> whenever <span class="math notranslate nohighlight">\(j_i = j_{i+1}\)</span>.
The <span class="math notranslate nohighlight">\(\ell\)</span>-tuple <span class="math notranslate nohighlight">\((j_0, j_1, \ldots, j_{\ell-1})\)</span> is called the
<em>top line</em> of this generalized permutation,
whereas the <span class="math notranslate nohighlight">\(\ell\)</span>-tuple <span class="math notranslate nohighlight">\((k_0, k_1, \ldots, k_{\ell-1})\)</span> is
called its <em>bottom line</em>.</p>
<p>Now the RSK algorithm, applied to a generalized permutation
<span class="math notranslate nohighlight">\(p = ((j_0, k_0), (j_1, k_1), \ldots, (j_{\ell-1}, k_{\ell-1}))\)</span>
(encoded as a lexicographically sorted list of pairs) starts by
initializing two semi-standard tableaux <span class="math notranslate nohighlight">\(P_0\)</span> and <span class="math notranslate nohighlight">\(Q_0\)</span> as empty
tableaux. For each nonnegative integer <span class="math notranslate nohighlight">\(t\)</span> starting at <span class="math notranslate nohighlight">\(0\)</span>, take
the pair <span class="math notranslate nohighlight">\((j_t, k_t)\)</span> from <span class="math notranslate nohighlight">\(p\)</span> and set
<span class="math notranslate nohighlight">\(P_{t+1} = P_t \leftarrow k_t\)</span>, and define <span class="math notranslate nohighlight">\(Q_{t+1}\)</span> by adding a
new box filled with <span class="math notranslate nohighlight">\(j_t\)</span> to the tableau <span class="math notranslate nohighlight">\(Q_t\)</span> at the same
location the row insertion on <span class="math notranslate nohighlight">\(P_t\)</span> ended (that is to say, adding
a new box with entry <span class="math notranslate nohighlight">\(j_t\)</span> such that <span class="math notranslate nohighlight">\(P_{t+1}\)</span> and <span class="math notranslate nohighlight">\(Q_{t+1}\)</span> have
the same shape). The iterative process stops when <span class="math notranslate nohighlight">\(t\)</span> reaches the
size of <span class="math notranslate nohighlight">\(p\)</span>, and the pair <span class="math notranslate nohighlight">\((P_t, Q_t)\)</span> at this point is the image
of <span class="math notranslate nohighlight">\(p\)</span> under the Robinson-Schensted-Knuth correspondence.</p>
<p>This correspondence has been introduced in <a class="reference internal" href="#knu1970" id="id23"><span>[Knu1970]</span></a>, where it has
been referred to as “Construction A”.</p>
<p>For more information, see Chapter 7 in <a class="reference internal" href="dyck_word.html#sta-ec2" id="id24"><span>[Sta-EC2]</span></a>.</p>
<p>We also note that integer matrices are in bijection with generalized
permutations. Furthermore, we can convert any word <span class="math notranslate nohighlight">\(w\)</span> (and, in
particular, any permutation) to a generalized permutation by
considering the top row to be <span class="math notranslate nohighlight">\((1, 2, \ldots, n)\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the
length of <span class="math notranslate nohighlight">\(w\)</span>.</p>
<p>The optional argument <code class="docutils literal notranslate"><span class="pre">insertion</span></code> allows to specify an alternative
insertion procedure to be used instead of the standard
Robinson-Schensted-Knuth insertion.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">obj1,</span> <span class="pre">obj2</span></code> – can be one of the following:</p>
<ul>
<li><p>a word in an ordered alphabet (in this case, <code class="docutils literal notranslate"><span class="pre">obj1</span></code> is said
word, and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
<li><p>an integer matrix</p></li>
<li><p>two lists of equal length representing a generalized permutation
(namely, the lists <span class="math notranslate nohighlight">\((j_0, j_1, \ldots, j_{\ell-1})\)</span> and
<span class="math notranslate nohighlight">\((k_0, k_1, \ldots, k_{\ell-1})\)</span> represent the generalized
permutation
<span class="math notranslate nohighlight">\(((j_0, k_0), (j_1, k_1), \ldots, (j_{\ell-1}, k_{\ell-1}))\)</span>)</p></li>
<li><p>any object which has a method <code class="docutils literal notranslate"><span class="pre">_rsk_iter()</span></code> which returns an
iterator over the object represented as generalized permutation or
a pair of lists (in this case, <code class="docutils literal notranslate"><span class="pre">obj1</span></code> is said object,
and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">insertion</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">RSK.rules.RSK</span></code>) the following types
of insertion are currently supported:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.RSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'RSK'</span></code>) – Robinson-Schensted-Knuth
insertion (<a class="reference internal" href="#sage.combinat.rsk.RuleRSK" title="sage.combinat.rsk.RuleRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.EG</span></code> (or <code class="docutils literal notranslate"><span class="pre">'EG'</span></code>) – Edelman-Greene insertion
(only for reduced words of permutations/elements of a type <span class="math notranslate nohighlight">\(A\)</span>
Coxeter group) (<a class="reference internal" href="#sage.combinat.rsk.RuleEG" title="sage.combinat.rsk.RuleEG"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleEG</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.Hecke</span></code> (or <code class="docutils literal notranslate"><span class="pre">'hecke'</span></code>) – Hecke insertion (only
guaranteed for generalized permutations whose top row is strictly
increasing) (<a class="reference internal" href="#sage.combinat.rsk.RuleHecke" title="sage.combinat.rsk.RuleHecke"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleHecke</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.dualRSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'dualRSK'</span></code>) – Dual RSK insertion
(only for strict biwords) (<a class="reference internal" href="#sage.combinat.rsk.RuleDualRSK" title="sage.combinat.rsk.RuleDualRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleDualRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.coRSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'coRSK'</span></code>) – CoRSK insertion (only
for strict cobiwords) (<a class="reference internal" href="#sage.combinat.rsk.RuleCoRSK" title="sage.combinat.rsk.RuleCoRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleCoRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.superRSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'super'</span></code>) – Super RSK insertion (only for
restricted super biwords) (<a class="reference internal" href="#sage.combinat.rsk.RuleSuperRSK" title="sage.combinat.rsk.RuleSuperRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleSuperRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.Star</span></code> (or <code class="docutils literal notranslate"><span class="pre">'Star'</span></code>) – <span class="math notranslate nohighlight">\(\star\)</span>-insertion (only for
fully commutative words in the 0-Hecke monoid)
(<a class="reference internal" href="#sage.combinat.rsk.RuleStar" title="sage.combinat.rsk.RuleStar"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleStar</span></code></a>)</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_standard</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) check if either of the
resulting tableaux is a standard tableau, and if so, typecast it
as such</p></li>
</ul>
<p>For precise information about constraints on the input and output,
as well as the definition of the algorithm (if it is not standard
RSK), see the particular <a class="reference internal" href="#sage.combinat.rsk.Rule" title="sage.combinat.rsk.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rule</span></code></a> class.</p>
<p>EXAMPLES:</p>
<p>If we only input one row, it is understood that the top row
should be <span class="math notranslate nohighlight">\((1, 2, \ldots, n)\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[[[1, 3, 4], [2], [3]], [[1, 2, 4], [3], [5]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">Word</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">[[[1, 3, 4], [2], [3]], [[1, 2, 4], [3], [5]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">Word</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">[[[1, 2, 2, 3, 3], [2, 3], [3]], [[1, 2, 3, 6, 8], [4, 7], [5]]]</span>
</pre></div>
</div>
<p>We can provide a generalized permutation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">[[[1, 1, 2], [2]], [[1, 2, 2], [2]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">Word</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">[[[1, 1, 3], [2], [4]], [[1, 1, 4], [3], [4]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">Word</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">]))</span>
<span class="go">[[[1, 2, 7], [2], [6]], [[1, 3, 4], [3], [4]]]</span>
</pre></div>
</div>
<p>We can provide a matrix:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]]))</span>
<span class="go">[[[1, 1, 2], [2]], [[1, 2, 2], [2]]]</span>
</pre></div>
</div>
<p>We can also provide something looking like a matrix:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="go">[[[1, 1, 2], [2]], [[1, 2, 2], [2]]]</span>
</pre></div>
</div>
<p>There is also <a class="reference internal" href="#sage.combinat.rsk.RSK_inverse" title="sage.combinat.rsk.RSK_inverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK_inverse()</span></code></a> which performs
the inverse of the bijection on a pair of semistandard tableaux. We
note that the inverse function takes 2 separate tableaux as inputs, so
to compose with <a class="reference internal" href="#sage.combinat.rsk.RSK" title="sage.combinat.rsk.RSK"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK()</span></code></a>, we need to use the
python <code class="docutils literal notranslate"><span class="pre">*</span></code> on the output:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="o">*</span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[[1, 2, 2, 2], [2, 1, 1, 2]]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">,</span><span class="n">Q</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
<span class="go">[[1, 2, 2, 2], [2, 1, 1, 2]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.combinat.rsk.robinson_schensted_knuth_inverse">
<span class="sig-prename descclassname"><span class="pre">sage.combinat.rsk.</span></span><span class="sig-name descname"><span class="pre">robinson_schensted_knuth_inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output='array'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">insertion=&lt;class</span> <span class="pre">'sage.combinat.rsk.RuleRSK'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.robinson_schensted_knuth_inverse" title="Permalink to this definition">#</a></dt>
<dd><p>Return the generalized permutation corresponding to the pair of
tableaux <span class="math notranslate nohighlight">\((p, q)\)</span> under the inverse of the Robinson-Schensted-Knuth
correspondence.</p>
<p>For more information on the bijection, see <a class="reference internal" href="#sage.combinat.rsk.RSK" title="sage.combinat.rsk.RSK"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK()</span></code></a>.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span></code>, <code class="docutils literal notranslate"><span class="pre">q</span></code> – two semi-standard tableaux of the same shape, or
(in the case when Hecke insertion is used) an increasing tableau and
a set-valued tableau of the same shape (see the note below for the
format of the set-valued tableau)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'array'</span></code>) if <code class="docutils literal notranslate"><span class="pre">q</span></code> is semi-standard:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'array'</span></code> – as a two-line array (i.e. generalized permutation or
biword)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'matrix'</span></code> – as an integer matrix</p></li>
</ul>
<p>and if <code class="docutils literal notranslate"><span class="pre">q</span></code> is standard, we can also have the output:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'word'</span></code> – as a word</p></li>
</ul>
<p>and additionally if <code class="docutils literal notranslate"><span class="pre">p</span></code> is standard, we can also have the output:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'permutation'</span></code> – as a permutation</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">insertion</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">RSK.rules.RSK</span></code>) the insertion algorithm
used in the bijection. Currently the following are supported:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.RSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'RSK'</span></code>) – Robinson-Schensted-Knuth
insertion (<a class="reference internal" href="#sage.combinat.rsk.RuleRSK" title="sage.combinat.rsk.RuleRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.EG</span></code> (or <code class="docutils literal notranslate"><span class="pre">'EG'</span></code>) – Edelman-Greene insertion
(only for reduced words of permutations/elements of a type <span class="math notranslate nohighlight">\(A\)</span>
Coxeter group) (<a class="reference internal" href="#sage.combinat.rsk.RuleEG" title="sage.combinat.rsk.RuleEG"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleEG</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.Hecke</span></code> (or <code class="docutils literal notranslate"><span class="pre">'hecke'</span></code>) – Hecke insertion (only
guaranteed for generalized permutations whose top row is strictly
increasing) (<a class="reference internal" href="#sage.combinat.rsk.RuleHecke" title="sage.combinat.rsk.RuleHecke"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleHecke</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.dualRSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'dualRSK'</span></code>) – Dual RSK insertion
(only for strict biwords) (<a class="reference internal" href="#sage.combinat.rsk.RuleDualRSK" title="sage.combinat.rsk.RuleDualRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleDualRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.coRSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'coRSK'</span></code>) – CoRSK insertion (only
for strict cobiwords) (<a class="reference internal" href="#sage.combinat.rsk.RuleCoRSK" title="sage.combinat.rsk.RuleCoRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleCoRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.superRSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'super'</span></code>) – Super RSK insertion (only for
restricted super biwords) (<a class="reference internal" href="#sage.combinat.rsk.RuleSuperRSK" title="sage.combinat.rsk.RuleSuperRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleSuperRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.Star</span></code> (or <code class="docutils literal notranslate"><span class="pre">'Star'</span></code>) – <span class="math notranslate nohighlight">\(\star\)</span>-insertion (only for
fully commutative words in the 0-Hecke monoid)
(<a class="reference internal" href="#sage.combinat.rsk.RuleStar" title="sage.combinat.rsk.RuleStar"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleStar</span></code></a>)</p></li>
</ul>
</li>
</ul>
<p>For precise information about constraints on the input and
output, see the particular <a class="reference internal" href="#sage.combinat.rsk.Rule" title="sage.combinat.rsk.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rule</span></code></a> class.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the case of Hecke insertion, the input variable <code class="docutils literal notranslate"><span class="pre">q</span></code> should
be a set-valued tableau, encoded as a tableau whose entries are
strictly increasing tuples of positive integers. Each such tuple
encodes the set of its entries.</p>
</div>
<p>EXAMPLES:</p>
<p>If both <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code> are standard:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 4, 5], [1, 4, 5, 3, 2]]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;word&#39;</span><span class="p">)</span>
<span class="go">word: 14532</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;matrix&#39;</span><span class="p">)</span>
<span class="go">[1 0 0 0 0]</span>
<span class="go">[0 0 0 1 0]</span>
<span class="go">[0 0 0 0 1]</span>
<span class="go">[0 0 1 0 0]</span>
<span class="go">[0 1 0 0 0]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">)</span>
<span class="go">[1, 4, 5, 3, 2]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">)</span>
<span class="go">[1, 4, 3, 2, 5]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">)</span>
<span class="go">[1, 2, 5, 4, 3]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">)</span>
<span class="go">[1, 5, 4, 2, 3]</span>
</pre></div>
</div>
<p>If the first tableau is semistandard:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]]);</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">ret</span> <span class="o">=</span> <span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span> <span class="n">ret</span>
<span class="go">[[1, 2, 3, 4], [1, 3, 2, 2]]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="s1">&#39;word&#39;</span><span class="p">)</span>
<span class="go">word: 1322</span>
</pre></div>
</div>
<p>In general:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">]]);</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 3], [2, 1, 2, 2]]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="s1">&#39;matrix&#39;</span><span class="p">)</span>
<span class="go">[0 1]</span>
<span class="go">[1 0]</span>
<span class="go">[0 2]</span>
</pre></div>
</div>
<p>Using Hecke insertion:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">pq</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">Hecke</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="o">*</span><span class="n">pq</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">Hecke</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;list&#39;</span><span class="p">)</span>
<span class="go">[5, 4, 3, 1, 4, 2, 5, 5]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The constructor of <code class="docutils literal notranslate"><span class="pre">Tableau</span></code> accepts not only semistandard
tableaux, but also arbitrary lists that are fillings of a
partition diagram. (And such lists are used, e.g., for the
set-valued tableau <code class="docutils literal notranslate"><span class="pre">q</span></code> that is passed to
<code class="docutils literal notranslate"><span class="pre">RSK_inverse(p,</span> <span class="pre">q,</span> <span class="pre">insertion='hecke')</span></code>.)
The user is responsible for ensuring that the tableaux passed to
<code class="docutils literal notranslate"><span class="pre">RSK_inverse</span></code> are of the right types (semistandard, standard,
increasing, set-valued as needed).</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.combinat.rsk.to_matrix">
<span class="sig-prename descclassname"><span class="pre">sage.combinat.rsk.</span></span><span class="sig-name descname"><span class="pre">to_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.to_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Return the integer matrix corresponding to a two-line array.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code> – the top row of the array</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> – the bottom row of the array</p></li>
</ul>
<p>OUTPUT:</p>
<p>An <span class="math notranslate nohighlight">\(m \times n\)</span>-matrix (where <span class="math notranslate nohighlight">\(m\)</span> and <span class="math notranslate nohighlight">\(n\)</span> are the maximum entries in
<span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(b\)</span> respectively) whose <span class="math notranslate nohighlight">\((i, j)\)</span>-th entry, for any <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>,
is the number of all positions <span class="math notranslate nohighlight">\(k\)</span> satisfying <span class="math notranslate nohighlight">\(t_k = i\)</span> and <span class="math notranslate nohighlight">\(b_k = j\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">to_matrix</span>
<span class="gp">sage: </span><span class="n">to_matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">[0 1 1]</span>
<span class="go">[0 0 0]</span>
<span class="go">[2 0 0]</span>
<span class="go">[0 0 1]</span>
</pre></div>
</div>
</dd></dl>

</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="schubert_polynomial.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Schubert Polynomials</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="rooted_tree.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Rooted (Unordered) Trees</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2005--2023, The Sage Development Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Robinson-Schensted-Knuth correspondence</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a><ul>
<li><a class="reference internal" href="#insertions-currently-available">Insertions currently available</a></li>
<li><a class="reference internal" href="#implementing-your-own-insertion-rule">Implementing your own insertion rule</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.combinat.rsk.InsertionRules"><code class="docutils literal notranslate"><span class="pre">InsertionRules</span></code></a><ul>
<li><a class="reference internal" href="#sage.combinat.rsk.InsertionRules.EG"><code class="docutils literal notranslate"><span class="pre">EG</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.rsk.InsertionRules.Hecke"><code class="docutils literal notranslate"><span class="pre">Hecke</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.rsk.InsertionRules.RSK"><code class="docutils literal notranslate"><span class="pre">RSK</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.rsk.InsertionRules.Star"><code class="docutils literal notranslate"><span class="pre">Star</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.rsk.InsertionRules.coRSK"><code class="docutils literal notranslate"><span class="pre">coRSK</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.rsk.InsertionRules.dualRSK"><code class="docutils literal notranslate"><span class="pre">dualRSK</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.rsk.InsertionRules.superRSK"><code class="docutils literal notranslate"><span class="pre">superRSK</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.combinat.rsk.RSK"><code class="docutils literal notranslate"><span class="pre">RSK()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.rsk.RSK_inverse"><code class="docutils literal notranslate"><span class="pre">RSK_inverse()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.rsk.Rule"><code class="docutils literal notranslate"><span class="pre">Rule</span></code></a><ul>
<li><a class="reference internal" href="#sage.combinat.rsk.Rule.backward_rule"><code class="docutils literal notranslate"><span class="pre">backward_rule()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.rsk.Rule.forward_rule"><code class="docutils literal notranslate"><span class="pre">forward_rule()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.rsk.Rule.to_pairs"><code class="docutils literal notranslate"><span class="pre">to_pairs()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleCoRSK"><code class="docutils literal notranslate"><span class="pre">RuleCoRSK</span></code></a><ul>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleCoRSK.backward_rule"><code class="docutils literal notranslate"><span class="pre">backward_rule()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleCoRSK.to_pairs"><code class="docutils literal notranslate"><span class="pre">to_pairs()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleDualRSK"><code class="docutils literal notranslate"><span class="pre">RuleDualRSK</span></code></a><ul>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleDualRSK.insertion"><code class="docutils literal notranslate"><span class="pre">insertion()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleDualRSK.reverse_insertion"><code class="docutils literal notranslate"><span class="pre">reverse_insertion()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleDualRSK.to_pairs"><code class="docutils literal notranslate"><span class="pre">to_pairs()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleEG"><code class="docutils literal notranslate"><span class="pre">RuleEG</span></code></a><ul>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleEG.insertion"><code class="docutils literal notranslate"><span class="pre">insertion()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleEG.reverse_insertion"><code class="docutils literal notranslate"><span class="pre">reverse_insertion()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleHecke"><code class="docutils literal notranslate"><span class="pre">RuleHecke</span></code></a><ul>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleHecke.backward_rule"><code class="docutils literal notranslate"><span class="pre">backward_rule()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleHecke.forward_rule"><code class="docutils literal notranslate"><span class="pre">forward_rule()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleHecke.insertion"><code class="docutils literal notranslate"><span class="pre">insertion()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleHecke.reverse_insertion"><code class="docutils literal notranslate"><span class="pre">reverse_insertion()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleRSK"><code class="docutils literal notranslate"><span class="pre">RuleRSK</span></code></a><ul>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleRSK.insertion"><code class="docutils literal notranslate"><span class="pre">insertion()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleRSK.reverse_insertion"><code class="docutils literal notranslate"><span class="pre">reverse_insertion()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleStar"><code class="docutils literal notranslate"><span class="pre">RuleStar</span></code></a><ul>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleStar.backward_rule"><code class="docutils literal notranslate"><span class="pre">backward_rule()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleStar.forward_rule"><code class="docutils literal notranslate"><span class="pre">forward_rule()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleStar.insertion"><code class="docutils literal notranslate"><span class="pre">insertion()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleStar.reverse_insertion"><code class="docutils literal notranslate"><span class="pre">reverse_insertion()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleSuperRSK"><code class="docutils literal notranslate"><span class="pre">RuleSuperRSK</span></code></a><ul>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleSuperRSK.backward_rule"><code class="docutils literal notranslate"><span class="pre">backward_rule()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleSuperRSK.forward_rule"><code class="docutils literal notranslate"><span class="pre">forward_rule()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleSuperRSK.insertion"><code class="docutils literal notranslate"><span class="pre">insertion()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleSuperRSK.reverse_insertion"><code class="docutils literal notranslate"><span class="pre">reverse_insertion()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.rsk.RuleSuperRSK.to_pairs"><code class="docutils literal notranslate"><span class="pre">to_pairs()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.combinat.rsk.robinson_schensted_knuth"><code class="docutils literal notranslate"><span class="pre">robinson_schensted_knuth()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.rsk.robinson_schensted_knuth_inverse"><code class="docutils literal notranslate"><span class="pre">robinson_schensted_knuth_inverse()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.rsk.to_matrix"><code class="docutils literal notranslate"><span class="pre">to_matrix()</span></code></a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/scripts/furo.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"ZZ": "\\Bold{Z}", "NN": "\\Bold{N}", "RR": "\\Bold{R}", "CC": "\\Bold{C}", "QQ": "\\Bold{Q}", "QQbar": "\\overline{\\QQ}", "GF": ["\\Bold{F}_{#1}", 1], "Zp": ["\\Bold{Z}_{#1}", 1], "Qp": ["\\Bold{Q}_{#1}", 1], "Zmod": ["\\ZZ/#1\\ZZ", 1], "CDF": "\\Bold{C}", "CIF": "\\Bold{C}", "CLF": "\\Bold{C}", "RDF": "\\Bold{R}", "RIF": "\\Bold{I} \\Bold{R}", "RLF": "\\Bold{R}", "SL": "\\mathrm{SL}", "PSL": "\\mathrm{PSL}", "lcm": "\\mathop{\\operatorname{lcm}}", "Bold": ["\\mathbf{#1}", 1]}, "inlineMath": [["$", "$"], ["\\(", "\\)"]], "maxBuffer": 51200, "autoload": {"color": [], "colorv2": ["color"]}}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    <script src="../../../_static/jupyter-sphinx-furo.js"></script>
    </body>
</html>