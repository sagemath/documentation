
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Orthogonal arrays (build recursive constructions) &#8212; Combinatorics</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sage.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/thebelab.css" />
    
    <script data-url_root="../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
    <script async="async" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="Orthogonal arrays (find recursive constructions)" href="orthogonal_arrays_find_recursive.html" />
    <link rel="prev" title="Orthogonal arrays (OA)" href="orthogonal_arrays.html" />
  <link rel="icon" href="../../../../_static/sageicon.png" type="image/x-icon" />
  <!-- <script src="../../../../_static/thebe.js" type="text/javascript"></script> -->
  <!-- <script src="../../../../_static/thebe-sage.js" type="text/javascript"></script> -->

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="orthogonal_arrays_find_recursive.html" title="Orthogonal arrays (find recursive constructions)"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="orthogonal_arrays.html" title="Orthogonal arrays (OA)"
             accesskey="P">previous</a> |</li>
  <li class="nav-item nav-item-0">
    <a href="http://www.sagemath.org"><img src="../../../../_static/logo_sagemath_black.svg" class="sage-logo" title="Sage Logo"></a>
    
      <a href="../../../../../index.html">Sage 9.6 Documentation</a> &#187;
      
      <a href="../../../../index.html">Reference Manual</a> &#187;
      
      <a href="../../../index.html">Combinatorics</a> &#187;
    
  </li>

          <li class="nav-item nav-item-1"><a href="../../../module_list.html" accesskey="U">Comprehensive Module List</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Orthogonal arrays (build recursive constructions)</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="orthogonal-arrays-build-recursive-constructions">
<span id="sage-combinat-designs-orthogonal-arrays-build-recursive"></span><h1>Orthogonal arrays (build recursive constructions)<a class="headerlink" href="#orthogonal-arrays-build-recursive-constructions" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.combinat.designs.orthogonal_arrays_build_recursive"></span><p>This module implements several constructions of
<a class="reference internal" href="orthogonal_arrays.html#module-sage.combinat.designs.orthogonal_arrays" title="sage.combinat.designs.orthogonal_arrays"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Orthogonal</span> <span class="pre">Arrays</span></code></a>.
As their input can be complex, they all have a counterpart in the
<a class="reference internal" href="orthogonal_arrays_find_recursive.html#module-sage.combinat.designs.orthogonal_arrays_find_recursive" title="sage.combinat.designs.orthogonal_arrays_find_recursive"><code class="xref py py-mod docutils literal notranslate"><span class="pre">orthogonal_arrays_find_recursive</span></code></a> module
that automatically computes it.</p>
<p>All these constructions are automatically queried when the
<a class="reference internal" href="orthogonal_arrays.html#sage.combinat.designs.orthogonal_arrays.orthogonal_array" title="sage.combinat.designs.orthogonal_arrays.orthogonal_array"><code class="xref py py-func docutils literal notranslate"><span class="pre">orthogonal_array()</span></code></a> function is
called.</p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.designs.orthogonal_arrays_build_recursive.construction_3_3" title="sage.combinat.designs.orthogonal_arrays_build_recursive.construction_3_3"><code class="xref py py-func docutils literal notranslate"><span class="pre">construction_3_3()</span></code></a></p></td>
<td><p>Return an <span class="math notranslate nohighlight">\(OA(k,nm+i)\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.designs.orthogonal_arrays_build_recursive.construction_3_4" title="sage.combinat.designs.orthogonal_arrays_build_recursive.construction_3_4"><code class="xref py py-func docutils literal notranslate"><span class="pre">construction_3_4()</span></code></a></p></td>
<td><p>Return a <span class="math notranslate nohighlight">\(OA(k,nm+rs)\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.designs.orthogonal_arrays_build_recursive.construction_3_5" title="sage.combinat.designs.orthogonal_arrays_build_recursive.construction_3_5"><code class="xref py py-func docutils literal notranslate"><span class="pre">construction_3_5()</span></code></a></p></td>
<td><p>Return an <span class="math notranslate nohighlight">\(OA(k,nm+r+s+t)\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.designs.orthogonal_arrays_build_recursive.construction_3_6" title="sage.combinat.designs.orthogonal_arrays_build_recursive.construction_3_6"><code class="xref py py-func docutils literal notranslate"><span class="pre">construction_3_6()</span></code></a></p></td>
<td><p>Return a <span class="math notranslate nohighlight">\(OA(k,nm+i)\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.designs.orthogonal_arrays_build_recursive.construction_q_x" title="sage.combinat.designs.orthogonal_arrays_build_recursive.construction_q_x"><code class="xref py py-func docutils literal notranslate"><span class="pre">construction_q_x()</span></code></a></p></td>
<td><p>Return an <span class="math notranslate nohighlight">\(OA(k,(q-1)*(q-x)+x+2)\)</span> using the <span class="math notranslate nohighlight">\(q-x\)</span> construction.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.designs.orthogonal_arrays_build_recursive.OA_and_oval" title="sage.combinat.designs.orthogonal_arrays_build_recursive.OA_and_oval"><code class="xref py py-func docutils literal notranslate"><span class="pre">OA_and_oval()</span></code></a></p></td>
<td><p>Return a <span class="math notranslate nohighlight">\(OA(q+1,q)\)</span> whose blocks contains <span class="math notranslate nohighlight">\(\leq 2\)</span> zeroes in the last <span class="math notranslate nohighlight">\(q\)</span> columns.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.designs.orthogonal_arrays_build_recursive.thwart_lemma_3_5" title="sage.combinat.designs.orthogonal_arrays_build_recursive.thwart_lemma_3_5"><code class="xref py py-func docutils literal notranslate"><span class="pre">thwart_lemma_3_5()</span></code></a></p></td>
<td><p>Returns an <span class="math notranslate nohighlight">\(OA(k,nm+a+b+c+d)\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.designs.orthogonal_arrays_build_recursive.thwart_lemma_4_1" title="sage.combinat.designs.orthogonal_arrays_build_recursive.thwart_lemma_4_1"><code class="xref py py-func docutils literal notranslate"><span class="pre">thwart_lemma_4_1()</span></code></a></p></td>
<td><p>Returns an <span class="math notranslate nohighlight">\(OA(k,nm+4(n-2))\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.combinat.designs.orthogonal_arrays_build_recursive.three_factor_product" title="sage.combinat.designs.orthogonal_arrays_build_recursive.three_factor_product"><code class="xref py py-func docutils literal notranslate"><span class="pre">three_factor_product()</span></code></a></p></td>
<td><p>Returns an <span class="math notranslate nohighlight">\(OA(k+1,n_1n_2n_3)\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.combinat.designs.orthogonal_arrays_build_recursive.brouwer_separable_design" title="sage.combinat.designs.orthogonal_arrays_build_recursive.brouwer_separable_design"><code class="xref py py-func docutils literal notranslate"><span class="pre">brouwer_separable_design()</span></code></a></p></td>
<td><p>Returns a <span class="math notranslate nohighlight">\(OA(k,t(q^2+q+1)+x)\)</span> using Brouwer’s result on separable designs.</p></td>
</tr>
</tbody>
</table>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="sage.combinat.designs.orthogonal_arrays_build_recursive.OA_and_oval">
<span class="sig-prename descclassname"><span class="pre">sage.combinat.designs.orthogonal_arrays_build_recursive.</span></span><span class="sig-name descname"><span class="pre">OA_and_oval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrality_tolerance</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.designs.orthogonal_arrays_build_recursive.OA_and_oval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <span class="math notranslate nohighlight">\(OA(q+1,q)\)</span> whose blocks contains <span class="math notranslate nohighlight">\(\leq 2\)</span> zeroes in the last <span class="math notranslate nohighlight">\(q\)</span>
columns.</p>
<p>This <span class="math notranslate nohighlight">\(OA\)</span> is build from a projective plane of order <span class="math notranslate nohighlight">\(q\)</span>, in which there
exists an oval <span class="math notranslate nohighlight">\(O\)</span> of size <span class="math notranslate nohighlight">\(q+1\)</span> (i.e. a set of <span class="math notranslate nohighlight">\(q+1\)</span> points no three of
which are [colinear/contained in a common set of the projective plane]).</p>
<p>Removing an element <span class="math notranslate nohighlight">\(x\in O\)</span> and all sets that contain it, we obtain a
<span class="math notranslate nohighlight">\(TD(q+1,q)\)</span> in which <span class="math notranslate nohighlight">\(O\)</span> intersects all columns except one. As <span class="math notranslate nohighlight">\(O\)</span> is an
oval, no block of the <span class="math notranslate nohighlight">\(TD\)</span> intersects it more than twice.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code> – a prime power</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) Specify a Mixed Integer Linear
Programming (MILP) solver to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one
is used. For more information on MILP solvers and which default solver is
used, see the method <a class="reference external" href="../../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Numerical Optimization v9.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code></a> of the class
<a class="reference external" href="../../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Numerical Optimization v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integrality_tolerance</span></code> – parameter for use with MILP solvers over an
inexact base ring; see <a class="reference external" href="../../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.get_values" title="(in Numerical Optimization v9.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram.get_values()</span></code></a>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is called by <a class="reference internal" href="#sage.combinat.designs.orthogonal_arrays_build_recursive.construction_3_6" title="sage.combinat.designs.orthogonal_arrays_build_recursive.construction_3_6"><code class="xref py py-func docutils literal notranslate"><span class="pre">construction_3_6()</span></code></a>, an implementation
of Construction 3.6 from <a class="reference internal" href="orthogonal_arrays_find_recursive.html#ac07" id="id1"><span>[AC07]</span></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.designs.orthogonal_arrays_build_recursive</span> <span class="kn">import</span> <span class="n">OA_and_oval</span>
<span class="gp">sage: </span><span class="n">_</span> <span class="o">=</span> <span class="n">OA_and_oval</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.combinat.designs.orthogonal_arrays_build_recursive.brouwer_separable_design">
<span class="sig-prename descclassname"><span class="pre">sage.combinat.designs.orthogonal_arrays_build_recursive.</span></span><span class="sig-name descname"><span class="pre">brouwer_separable_design</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">explain_construction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.designs.orthogonal_arrays_build_recursive.brouwer_separable_design" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <span class="math notranslate nohighlight">\(OA(k,t(q^2+q+1)+x)\)</span> using Brouwer’s result on separable designs.</p>
<p>This method is an implementation of Brouwer’s construction presented in
<a class="reference internal" href="#brouwer80" id="id2"><span>[Brouwer80]</span></a>. It consists in a systematic application of the usual
transformation from PBD to OA, applied to a specific PBD.</p>
<p><strong>Baer subplanes</strong></p>
<p>When <span class="math notranslate nohighlight">\(q\)</span> is a prime power, the projective plane <span class="math notranslate nohighlight">\(PG(2,q^2)\)</span> can be
partitionned into subplanes <span class="math notranslate nohighlight">\(PG(2,q)\)</span> (called Baer subplanes), giving
<span class="math notranslate nohighlight">\(PG(2,q^2)=B_1\cup \dots\cup B_{q^2-q+1}\)</span>. As a result, every line of the
<span class="math notranslate nohighlight">\(PG(2,q^2)\)</span> intersects one of the subplane on <span class="math notranslate nohighlight">\(q+1\)</span> points and all others on
<span class="math notranslate nohighlight">\(1\)</span> point.</p>
<p>The <span class="math notranslate nohighlight">\(OA\)</span> are built by considering <span class="math notranslate nohighlight">\(B_1\cup\dots\cup B_t\)</span>, for a total of
<span class="math notranslate nohighlight">\(t(q^2+q+1)\)</span> points (to which <span class="math notranslate nohighlight">\(x\)</span> new points are then added). The blocks of
this subdesign belong to two categories:</p>
<ul class="simple">
<li><p>The blocks of size <span class="math notranslate nohighlight">\(t\)</span>: they come from the lines which intersect a
<span class="math notranslate nohighlight">\(B_i\)</span> on <span class="math notranslate nohighlight">\(q+1\)</span> points for some <span class="math notranslate nohighlight">\(i&gt;t\)</span>. The blocks of size <span class="math notranslate nohighlight">\(t\)</span> can be partitionned
into <span class="math notranslate nohighlight">\(q^2-q+t-1\)</span> parallel classes according to their associated subplane <span class="math notranslate nohighlight">\(B_i\)</span>
with <span class="math notranslate nohighlight">\(i&gt;t\)</span>.</p></li>
<li><p>The blocks of size <span class="math notranslate nohighlight">\(q+t\)</span>: those blocks form a symmetric design, as every
point is incident with <span class="math notranslate nohighlight">\(q+t\)</span> of them.</p></li>
</ul>
<p><strong>Constructions</strong></p>
<p>In the following, we write <span class="math notranslate nohighlight">\(N=t(q^2+q+1)+x\)</span>. The code is also heavily
commented, and will clear any doubt.</p>
<ul>
<li><p>i) <span class="math notranslate nohighlight">\(x=0\)</span>: in that case we build a resolvable <span class="math notranslate nohighlight">\(OA(k-1,N)\)</span> that will then be
completed into an <span class="math notranslate nohighlight">\(OA(k,N)\)</span>.</p>
<blockquote>
<div><ul>
<li><p><em>Sets of size</em> <span class="math notranslate nohighlight">\(t\)</span>)</p>
<p>We take the product of each parallel class with the parallel classes
of a resolvable <span class="math notranslate nohighlight">\(OA(k-1,t)-t.OA(k-1,t)\)</span>, yielding new parallel
classes.</p>
</li>
<li><p><em>Sets of size</em> <span class="math notranslate nohighlight">\(q+t\)</span>)</p>
<p>A <span class="math notranslate nohighlight">\(N \times (q+t)\)</span> array is built whose rows are the sets of size
<span class="math notranslate nohighlight">\(q+t\)</span> such that every value appears once per column. For each block of
a <span class="math notranslate nohighlight">\(OA(k-1,q+t)-(q+t).OA(k-1,t)\)</span>, the product with the rows of the
matrix yields a parallel class.</p>
</li>
</ul>
</div></blockquote>
</li>
<li><ol class="lowerroman simple" start="2">
<li><p><span class="math notranslate nohighlight">\(x=q+t\)</span></p></li>
</ol>
<blockquote>
<div><ul>
<li><p><em>Sets of size</em> <span class="math notranslate nohighlight">\(t\)</span>)</p>
<p>Each set of size <span class="math notranslate nohighlight">\(t\)</span> gives a <span class="math notranslate nohighlight">\(OA(k,t)-t.OA(k,1)\)</span>, except if there is
only one parallel class in which case a <span class="math notranslate nohighlight">\(OA(k,t)\)</span> is sufficient.</p>
</li>
<li><p><em>Sets of size</em> <span class="math notranslate nohighlight">\(q+t\)</span>)</p>
<p>A <span class="math notranslate nohighlight">\((N-x) \times (q+t)\)</span> array <span class="math notranslate nohighlight">\(M\)</span> is built whose <span class="math notranslate nohighlight">\(N-x\)</span> rows are the
sets of size <span class="math notranslate nohighlight">\(q+t\)</span> such that every value appears once per column. For
each of the new <span class="math notranslate nohighlight">\(x=q+t\)</span> points <span class="math notranslate nohighlight">\(p_1,\dots,p_{q+t}\)</span> we build a matrix
<span class="math notranslate nohighlight">\(M_i\)</span> obtained from <span class="math notranslate nohighlight">\(M\)</span> by adding a column equal to <span class="math notranslate nohighlight">\((p_i,p_i,p_i\dots
)\)</span>. We add to the OA the product of all rows of the <span class="math notranslate nohighlight">\(M_i\)</span> with the
block of the <span class="math notranslate nohighlight">\(x=q+t\)</span> parallel classes of a resolvable
<span class="math notranslate nohighlight">\(OA(k,t+q+1)-(t+q+1).OA(k,1)\)</span>.</p>
</li>
<li><p><em>Set of size</em> <span class="math notranslate nohighlight">\(x\)</span>) An <span class="math notranslate nohighlight">\(OA(k,x)\)</span></p></li>
</ul>
</div></blockquote>
</li>
<li><ol class="lowerroman simple" start="3">
<li><p><span class="math notranslate nohighlight">\(x = q^2-q+1-t\)</span></p></li>
</ol>
<blockquote>
<div><ul>
<li><p><em>Sets of size</em> <span class="math notranslate nohighlight">\(t\)</span>)</p>
<p>All blocks of the <span class="math notranslate nohighlight">\(i\)</span>-th parallel class are extended with the <span class="math notranslate nohighlight">\(i\)</span>-th
new point. The blocks are then replaced by a <span class="math notranslate nohighlight">\(OA(k,t+1)-(t+1).OA(k,1)\)</span>
or, if there is only one parallel class (i.e. <span class="math notranslate nohighlight">\(x=1\)</span>) by a
<span class="math notranslate nohighlight">\(OA(k,t+1)-OA(k,1)\)</span>.</p>
</li>
<li><p><em>Set of size</em> <span class="math notranslate nohighlight">\(q+t\)</span>)</p>
<p>They are replaced by <span class="math notranslate nohighlight">\(OA(k,q+t)-(q+t).OA(k,1)\)</span>.</p>
</li>
<li><p><em>Set of size</em> <span class="math notranslate nohighlight">\(x\)</span>) An <span class="math notranslate nohighlight">\(OA(k,x)\)</span></p></li>
</ul>
</div></blockquote>
</li>
<li><ol class="lowerroman simple" start="4">
<li><p><span class="math notranslate nohighlight">\(x = q^2+1\)</span></p></li>
</ol>
<blockquote>
<div><ul>
<li><p><em>Sets of size</em> <span class="math notranslate nohighlight">\(t\)</span>)</p>
<p>All blocks of the <span class="math notranslate nohighlight">\(i\)</span>-th parallel class are extended with the <span class="math notranslate nohighlight">\(i\)</span>-th
new point (the other <span class="math notranslate nohighlight">\(x-q-t\)</span> new points are not touched at this
step). The blocks are then replaced by a <span class="math notranslate nohighlight">\(OA(k,t+1)-(t+1).OA(k,1)\)</span> or,
if there is only one parallel class (i.e. <span class="math notranslate nohighlight">\(x=1\)</span>) by a
<span class="math notranslate nohighlight">\(OA(k,t+1)-OA(k,1)\)</span>.</p>
</li>
<li><p><em>Sets of size</em> <span class="math notranslate nohighlight">\(q+t\)</span>) Same as for ii)</p></li>
<li><p><em>Set of size</em> <span class="math notranslate nohighlight">\(x\)</span>) An <span class="math notranslate nohighlight">\(OA(k,x)\)</span></p></li>
</ul>
</div></blockquote>
</li>
<li><ol class="loweralpha simple" start="22">
<li><p><span class="math notranslate nohighlight">\(0&lt;x&lt;q^2-q+1-t\)</span></p></li>
</ol>
<blockquote>
<div><ul>
<li><p><em>Sets of size</em> <span class="math notranslate nohighlight">\(t\)</span>)</p>
<p>The blocks of the first <span class="math notranslate nohighlight">\(x\)</span> parallel class are extended with the <span class="math notranslate nohighlight">\(x\)</span>
new points, and replaced with <span class="math notranslate nohighlight">\(OA(k.t+1)-(t+1).OA(k,1)\)</span> or, if <span class="math notranslate nohighlight">\(x=1\)</span>,
by <span class="math notranslate nohighlight">\(OA(k.t+1)-.OA(k,1)\)</span></p>
<p>The blocks of the other parallel classes are replaced by
<span class="math notranslate nohighlight">\(OA(k,t)-t.OA(k,t)\)</span> or, if there is only one class left, by
<span class="math notranslate nohighlight">\(OA(k,t)-OA(k,t)\)</span></p>
</li>
<li><p><em>Sets of size</em> <span class="math notranslate nohighlight">\(q+t\)</span>)</p>
<p>They are replaced with <span class="math notranslate nohighlight">\(OA(k,q+t)-(q+t).OA(k,1)\)</span>.</p>
</li>
<li><p><em>Set of size</em> <span class="math notranslate nohighlight">\(x\)</span>) An <span class="math notranslate nohighlight">\(OA(k,x)\)</span></p></li>
</ul>
</div></blockquote>
</li>
<li><ol class="lowerroman simple" start="6">
<li><p><span class="math notranslate nohighlight">\(t+q&lt;x&lt;q^2+1\)</span></p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p><em>Sets of size</em> <span class="math notranslate nohighlight">\(t\)</span>) Same as in v) with an <span class="math notranslate nohighlight">\(x\)</span> equal to <span class="math notranslate nohighlight">\(x-q+t\)</span>.</p></li>
<li><p><em>Sets of size</em> <span class="math notranslate nohighlight">\(t\)</span>) Same as in vii)</p></li>
<li><p><em>Set of size</em> <span class="math notranslate nohighlight">\(x\)</span>) An <span class="math notranslate nohighlight">\(OA(k,x)\)</span></p></li>
</ul>
</div></blockquote>
</li>
</ul>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">k,t,q,x</span></code> (integers)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – (boolean) Whether to check that output is correct before
returning it. Set to <code class="docutils literal notranslate"><span class="pre">False</span></code> by default.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> (boolean) – whether to print some information on the
construction and parameters being used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">explain_construction</span></code> (boolean) – return a string describing
the construction.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="orthogonal_arrays_find_recursive.html#sage.combinat.designs.orthogonal_arrays_find_recursive.find_brouwer_separable_design" title="sage.combinat.designs.orthogonal_arrays_find_recursive.find_brouwer_separable_design"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_brouwer_separable_design()</span></code></a></p></li>
</ul>
</div>
<p>REFERENCES:</p>
<dl class="citation">
<dt class="label" id="brouwer80"><span class="brackets"><a class="fn-backref" href="#id2">Brouwer80</a></span></dt>
<dd><p>A Series of Separable Designs with Application to Pairwise Orthogonal Latin Squares,
Andries E. Brouwer,
Vol. 1, n. 1, pp. 39-41,
European Journal of Combinatorics, 1980
<a class="reference external" href="http://www.sciencedirect.com/science/article/pii/S0195669880800199">http://www.sciencedirect.com/science/article/pii/S0195669880800199</a></p>
</dd>
</dl>
<p>EXAMPLES:</p>
<p>Test all possible cases:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.designs.orthogonal_arrays_build_recursive</span> <span class="kn">import</span> <span class="n">brouwer_separable_design</span>
<span class="gp">sage: </span><span class="n">k</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">;</span> <span class="n">_</span><span class="o">=</span><span class="n">brouwer_separable_design</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Case i) with k=4,q=3,t=4,x=0</span>
<span class="gp">sage: </span><span class="n">k</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">;</span> <span class="n">_</span><span class="o">=</span><span class="n">brouwer_separable_design</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="o">+</span><span class="n">q</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Case ii) with k=3,q=3,t=3,x=6,e3=1</span>
<span class="gp">sage: </span><span class="n">k</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">;</span> <span class="n">_</span><span class="o">=</span><span class="n">brouwer_separable_design</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="o">+</span><span class="n">q</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Case ii) with k=3,q=3,t=6,x=9,e3=0</span>
<span class="gp">sage: </span><span class="n">k</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">;</span> <span class="n">_</span><span class="o">=</span><span class="n">brouwer_separable_design</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Case iii) with k=3,q=3,t=6,x=1,e2=0</span>
<span class="gp">sage: </span><span class="n">k</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">;</span> <span class="n">_</span><span class="o">=</span><span class="n">brouwer_separable_design</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Case iii) with k=3,q=4,t=6,x=7,e2=1</span>
<span class="gp">sage: </span><span class="n">k</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">;</span> <span class="n">_</span><span class="o">=</span><span class="n">brouwer_separable_design</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Case iv) with k=3,q=4,t=6,x=17,e4=1</span>
<span class="gp">sage: </span><span class="n">k</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">;</span> <span class="n">_</span><span class="o">=</span><span class="n">brouwer_separable_design</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Case iv) with k=3,q=2,t=2,x=5,e4=0</span>
<span class="gp">sage: </span><span class="n">k</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">;</span> <span class="n">_</span><span class="o">=</span><span class="n">brouwer_separable_design</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Case v) with k=3,q=4,t=7,x=3,e1=1,e2=1</span>
<span class="gp">sage: </span><span class="n">k</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">;</span> <span class="n">_</span><span class="o">=</span><span class="n">brouwer_separable_design</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Case v) with k=3,q=4,t=7,x=1,e1=1,e2=0</span>
<span class="gp">sage: </span><span class="n">k</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">;</span> <span class="n">_</span><span class="o">=</span><span class="n">brouwer_separable_design</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">q</span><span class="o">-</span><span class="n">t</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Case v) with k=3,q=4,t=7,x=5,e1=0,e2=1</span>
<span class="gp">sage: </span><span class="n">k</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">;</span> <span class="n">_</span><span class="o">=</span><span class="n">brouwer_separable_design</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="o">+</span><span class="n">q</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Case vi) with k=5,q=4,t=7,x=14,e3=1,e4=1</span>
<span class="gp">sage: </span><span class="n">k</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">;</span> <span class="n">_</span><span class="o">=</span><span class="n">brouwer_separable_design</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="o">+</span><span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Case vi) with k=5,q=4,t=8,x=13,e3=1,e4=0</span>
<span class="gp">sage: </span><span class="n">k</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">;</span> <span class="n">_</span><span class="o">=</span><span class="n">brouwer_separable_design</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Case vi) with k=5,q=4,t=8,x=16,e3=0,e4=1</span>

<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">designs</span><span class="o">.</span><span class="n">orthogonal_arrays</span><span class="o">.</span><span class="n">explain_construction</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">189</span><span class="p">))</span>
<span class="go">Brouwer&#39;s separable design construction with t=9,q=4,x=0 from:</span>
<span class="go">   Andries E. Brouwer,</span>
<span class="go">   A series of separable designs with application to pairwise orthogonal Latin squares</span>
<span class="go">   Vol. 1, n. 1, pp. 39-41,</span>
<span class="go">   European Journal of Combinatorics, 1980</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.combinat.designs.orthogonal_arrays_build_recursive.construction_3_3">
<span class="sig-prename descclassname"><span class="pre">sage.combinat.designs.orthogonal_arrays_build_recursive.</span></span><span class="sig-name descname"><span class="pre">construction_3_3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">explain_construction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.designs.orthogonal_arrays_build_recursive.construction_3_3" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an <span class="math notranslate nohighlight">\(OA(k,nm+i)\)</span>.</p>
<p>This is Wilson’s construction with <span class="math notranslate nohighlight">\(i\)</span> truncated columns of size 1 and such
that a block <span class="math notranslate nohighlight">\(B_0\)</span> of the incomplete OA intersects all truncated columns. As
a consequence, all other blocks intersect only <span class="math notranslate nohighlight">\(0\)</span> or <span class="math notranslate nohighlight">\(1\)</span> of the last <span class="math notranslate nohighlight">\(i\)</span>
columns. This allow to consider the block <span class="math notranslate nohighlight">\(B_0\)</span> only up to its first <span class="math notranslate nohighlight">\(k\)</span>
coordinates and then use a <span class="math notranslate nohighlight">\(OA(k,i)\)</span> instead of a <span class="math notranslate nohighlight">\(OA(k,m+i) - i.OA(k,1)\)</span>.</p>
<p>This is construction 3.3 from <a class="reference internal" href="orthogonal_arrays_find_recursive.html#ac07" id="id3"><span>[AC07]</span></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">k,n,m,i</span></code> (integers) such that the following designs are available:
<span class="math notranslate nohighlight">\(OA(k,n)\)</span>, <span class="math notranslate nohighlight">\(OA(k,m)\)</span>, <span class="math notranslate nohighlight">\(OA(k,m+1)\)</span>, <span class="math notranslate nohighlight">\(OA(k,r)\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">explain_construction</span></code> (boolean) – return a string describing
the construction.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="orthogonal_arrays_find_recursive.html#sage.combinat.designs.orthogonal_arrays_find_recursive.find_construction_3_3" title="sage.combinat.designs.orthogonal_arrays_find_recursive.find_construction_3_3"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_construction_3_3()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.designs.orthogonal_arrays_find_recursive</span> <span class="kn">import</span> <span class="n">find_construction_3_3</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.designs.orthogonal_arrays_build_recursive</span> <span class="kn">import</span> <span class="n">construction_3_3</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.designs.orthogonal_arrays</span> <span class="kn">import</span> <span class="n">is_orthogonal_array</span>
<span class="gp">sage: </span><span class="n">k</span><span class="o">=</span><span class="mi">11</span><span class="p">;</span><span class="n">n</span><span class="o">=</span><span class="mi">177</span>
<span class="gp">sage: </span><span class="n">is_orthogonal_array</span><span class="p">(</span><span class="n">construction_3_3</span><span class="p">(</span><span class="o">*</span><span class="n">find_construction_3_3</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">)[</span><span class="mi">1</span><span class="p">]),</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">designs</span><span class="o">.</span><span class="n">orthogonal_arrays</span><span class="o">.</span><span class="n">explain_construction</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">91</span><span class="p">))</span>
<span class="go">Construction 3.3 with n=11,m=8,i=3 from:</span>
<span class="go">   Julian R. Abel, Nicholas Cavenagh</span>
<span class="go">   Concerning eight mutually orthogonal latin squares,</span>
<span class="go">   Vol. 15, n.3, pp. 255-261,</span>
<span class="go">   Journal of Combinatorial Designs, 2007</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.combinat.designs.orthogonal_arrays_build_recursive.construction_3_4">
<span class="sig-prename descclassname"><span class="pre">sage.combinat.designs.orthogonal_arrays_build_recursive.</span></span><span class="sig-name descname"><span class="pre">construction_3_4</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">explain_construction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.designs.orthogonal_arrays_build_recursive.construction_3_4" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <span class="math notranslate nohighlight">\(OA(k,nm+rs)\)</span>.</p>
<p>This is Wilson’s construction applied to a truncated <span class="math notranslate nohighlight">\(OA(k+r+1,n)\)</span> with <span class="math notranslate nohighlight">\(r\)</span>
columns of size <span class="math notranslate nohighlight">\(1\)</span> and one column of size <span class="math notranslate nohighlight">\(s\)</span>.</p>
<p>The unique elements of the <span class="math notranslate nohighlight">\(r\)</span> truncated columns are picked so that a block
<span class="math notranslate nohighlight">\(B_0\)</span> contains them all.</p>
<ul class="simple">
<li><p>If there exists an <span class="math notranslate nohighlight">\(OA(k,m+r+1)\)</span> the column of size <span class="math notranslate nohighlight">\(s\)</span> is truncated in
order to intersect <span class="math notranslate nohighlight">\(B_0\)</span>.</p></li>
<li><p>Otherwise, if there exists an <span class="math notranslate nohighlight">\(OA(k,m+r)\)</span>, the last column must not
intersect <span class="math notranslate nohighlight">\(B_0\)</span></p></li>
</ul>
<p>This is construction 3.4 from <a class="reference internal" href="orthogonal_arrays_find_recursive.html#ac07" id="id4"><span>[AC07]</span></a>.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">k,n,m,r,s</span></code> (integers) – we assume that <span class="math notranslate nohighlight">\(s&lt;n\)</span> and <span class="math notranslate nohighlight">\(1\leq r,s\)</span></p>
<p>The following designs must be available: <span class="math notranslate nohighlight">\(OA(k,n)\)</span>, <span class="math notranslate nohighlight">\(OA(k,m)\)</span>,
<span class="math notranslate nohighlight">\(OA(k,m+1)\)</span>, <span class="math notranslate nohighlight">\(OA(k,m+2)\)</span>, <span class="math notranslate nohighlight">\(OA(k,s)\)</span>. Additionally, it requires either a
<span class="math notranslate nohighlight">\(OA(k,m+r)\)</span> or a <span class="math notranslate nohighlight">\(OA(k,m+r+1)\)</span>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">explain_construction</span></code> (boolean) – return a string describing
the construction.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="orthogonal_arrays_find_recursive.html#sage.combinat.designs.orthogonal_arrays_find_recursive.find_construction_3_4" title="sage.combinat.designs.orthogonal_arrays_find_recursive.find_construction_3_4"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_construction_3_4()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.designs.orthogonal_arrays_find_recursive</span> <span class="kn">import</span> <span class="n">find_construction_3_4</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.designs.orthogonal_arrays_build_recursive</span> <span class="kn">import</span> <span class="n">construction_3_4</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.designs.orthogonal_arrays</span> <span class="kn">import</span> <span class="n">is_orthogonal_array</span>
<span class="gp">sage: </span><span class="n">k</span><span class="o">=</span><span class="mi">8</span><span class="p">;</span><span class="n">n</span><span class="o">=</span><span class="mi">196</span>
<span class="gp">sage: </span><span class="n">is_orthogonal_array</span><span class="p">(</span><span class="n">construction_3_4</span><span class="p">(</span><span class="o">*</span><span class="n">find_construction_3_4</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">)[</span><span class="mi">1</span><span class="p">]),</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">designs</span><span class="o">.</span><span class="n">orthogonal_arrays</span><span class="o">.</span><span class="n">explain_construction</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">164</span><span class="p">))</span>
<span class="go">Construction 3.4 with n=23,m=7,r=2,s=1 from:</span>
<span class="go">   Julian R. Abel, Nicholas Cavenagh</span>
<span class="go">   Concerning eight mutually orthogonal latin squares,</span>
<span class="go">   Vol. 15, n.3, pp. 255-261,</span>
<span class="go">   Journal of Combinatorial Designs, 2007</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.combinat.designs.orthogonal_arrays_build_recursive.construction_3_5">
<span class="sig-prename descclassname"><span class="pre">sage.combinat.designs.orthogonal_arrays_build_recursive.</span></span><span class="sig-name descname"><span class="pre">construction_3_5</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">explain_construction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.designs.orthogonal_arrays_build_recursive.construction_3_5" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an <span class="math notranslate nohighlight">\(OA(k,nm+r+s+t)\)</span>.</p>
<p>This is exactly Wilson’s construction with three truncated groups
except we make sure that all blocks have size <span class="math notranslate nohighlight">\(&gt;k\)</span>, so we don’t
need a <span class="math notranslate nohighlight">\(OA(k,m+0)\)</span> but only <span class="math notranslate nohighlight">\(OA(k,m+1)\)</span>, <span class="math notranslate nohighlight">\(OA(k,m+2)\)</span> ,`OA(k,m+3)`.</p>
<p>This is construction 3.5 from <a class="reference internal" href="orthogonal_arrays_find_recursive.html#ac07" id="id5"><span>[AC07]</span></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">k,n,m</span></code> (integers)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">r,s,t</span></code> (integers) – sizes of the three truncated groups,
such that <span class="math notranslate nohighlight">\(r\leq s\)</span> and <span class="math notranslate nohighlight">\((q-r-1)(q-s) \geq (q-s-1)*(q-r)\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">explain_construction</span></code> (boolean) – return a string describing
the construction.</p></li>
</ul>
<p>The following designs must be available : <span class="math notranslate nohighlight">\(OA(k,n)\)</span>, <span class="math notranslate nohighlight">\(OA(k,r)\)</span>, <span class="math notranslate nohighlight">\(OA(k,s)\)</span>,
<span class="math notranslate nohighlight">\(OA(k,t)\)</span>, <span class="math notranslate nohighlight">\(OA(k,m+1)\)</span>, <span class="math notranslate nohighlight">\(OA(k,m+2)\)</span>, <span class="math notranslate nohighlight">\(OA(k,m+3)\)</span>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="orthogonal_arrays_find_recursive.html#sage.combinat.designs.orthogonal_arrays_find_recursive.find_construction_3_5" title="sage.combinat.designs.orthogonal_arrays_find_recursive.find_construction_3_5"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_construction_3_5()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.designs.orthogonal_arrays_find_recursive</span> <span class="kn">import</span> <span class="n">find_construction_3_5</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.designs.orthogonal_arrays_build_recursive</span> <span class="kn">import</span> <span class="n">construction_3_5</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.designs.orthogonal_arrays</span> <span class="kn">import</span> <span class="n">is_orthogonal_array</span>
<span class="gp">sage: </span><span class="n">k</span><span class="o">=</span><span class="mi">8</span><span class="p">;</span><span class="n">n</span><span class="o">=</span><span class="mi">111</span>
<span class="gp">sage: </span><span class="n">is_orthogonal_array</span><span class="p">(</span><span class="n">construction_3_5</span><span class="p">(</span><span class="o">*</span><span class="n">find_construction_3_5</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">)[</span><span class="mi">1</span><span class="p">]),</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">designs</span><span class="o">.</span><span class="n">orthogonal_arrays</span><span class="o">.</span><span class="n">explain_construction</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">90</span><span class="p">))</span>
<span class="go">Construction 3.5 with n=11,m=6,r=8,s=8,t=8 from:</span>
<span class="go">   Julian R. Abel, Nicholas Cavenagh</span>
<span class="go">   Concerning eight mutually orthogonal latin squares,</span>
<span class="go">   Vol. 15, n.3, pp. 255-261,</span>
<span class="go">   Journal of Combinatorial Designs, 2007</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.combinat.designs.orthogonal_arrays_build_recursive.construction_3_6">
<span class="sig-prename descclassname"><span class="pre">sage.combinat.designs.orthogonal_arrays_build_recursive.</span></span><span class="sig-name descname"><span class="pre">construction_3_6</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">explain_construction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.designs.orthogonal_arrays_build_recursive.construction_3_6" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <span class="math notranslate nohighlight">\(OA(k,nm+i)\)</span></p>
<p>This is Wilson’s construction with <span class="math notranslate nohighlight">\(r\)</span> columns of order <span class="math notranslate nohighlight">\(1\)</span>, in which each
block intersects at most two truncated columns. Such a design exists when
<span class="math notranslate nohighlight">\(n\)</span> is a prime power and is returned by <a class="reference internal" href="#sage.combinat.designs.orthogonal_arrays_build_recursive.OA_and_oval" title="sage.combinat.designs.orthogonal_arrays_build_recursive.OA_and_oval"><code class="xref py py-func docutils literal notranslate"><span class="pre">OA_and_oval()</span></code></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">k,n,m,i</span></code> (integers) – <span class="math notranslate nohighlight">\(n\)</span> must be a prime power. The following designs
must be available: <span class="math notranslate nohighlight">\(OA(k+r,q)\)</span>, <span class="math notranslate nohighlight">\(OA(k,m)\)</span>, <span class="math notranslate nohighlight">\(OA(k,m+1)\)</span>, <span class="math notranslate nohighlight">\(OA(k,m+2)\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">explain_construction</span></code> (boolean) – return a string describing
the construction.</p></li>
</ul>
<p>This is construction 3.6 from <a class="reference internal" href="orthogonal_arrays_find_recursive.html#ac07" id="id6"><span>[AC07]</span></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="orthogonal_arrays_find_recursive.html#sage.combinat.designs.orthogonal_arrays_find_recursive.find_construction_3_6" title="sage.combinat.designs.orthogonal_arrays_find_recursive.find_construction_3_6"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_construction_3_6()</span></code></a></p></li>
<li><p><a class="reference internal" href="#sage.combinat.designs.orthogonal_arrays_build_recursive.OA_and_oval" title="sage.combinat.designs.orthogonal_arrays_build_recursive.OA_and_oval"><code class="xref py py-func docutils literal notranslate"><span class="pre">OA_and_oval()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.designs.orthogonal_arrays_find_recursive</span> <span class="kn">import</span> <span class="n">find_construction_3_6</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.designs.orthogonal_arrays_build_recursive</span> <span class="kn">import</span> <span class="n">construction_3_6</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.designs.orthogonal_arrays</span> <span class="kn">import</span> <span class="n">is_orthogonal_array</span>
<span class="gp">sage: </span><span class="n">k</span><span class="o">=</span><span class="mi">8</span><span class="p">;</span><span class="n">n</span><span class="o">=</span><span class="mi">95</span>
<span class="gp">sage: </span><span class="n">is_orthogonal_array</span><span class="p">(</span><span class="n">construction_3_6</span><span class="p">(</span><span class="o">*</span><span class="n">find_construction_3_6</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">)[</span><span class="mi">1</span><span class="p">]),</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">designs</span><span class="o">.</span><span class="n">orthogonal_arrays</span><span class="o">.</span><span class="n">explain_construction</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">756</span><span class="p">))</span>
<span class="go">Construction 3.6 with n=16,m=47,i=4 from:</span>
<span class="go">   Julian R. Abel, Nicholas Cavenagh</span>
<span class="go">   Concerning eight mutually orthogonal latin squares,</span>
<span class="go">   Vol. 15, n.3, pp. 255-261,</span>
<span class="go">   Journal of Combinatorial Designs, 2007</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.combinat.designs.orthogonal_arrays_build_recursive.construction_q_x">
<span class="sig-prename descclassname"><span class="pre">sage.combinat.designs.orthogonal_arrays_build_recursive.</span></span><span class="sig-name descname"><span class="pre">construction_q_x</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">explain_construction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.designs.orthogonal_arrays_build_recursive.construction_q_x" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an <span class="math notranslate nohighlight">\(OA(k,(q-1)*(q-x)+x+2)\)</span> using the <span class="math notranslate nohighlight">\(q-x\)</span> construction.</p>
<p>Let <span class="math notranslate nohighlight">\(v=(q-1)*(q-x)+x+2\)</span>. If there exists a projective plane of order <span class="math notranslate nohighlight">\(q\)</span>
(e.g. when <span class="math notranslate nohighlight">\(q\)</span> is a prime power) and <span class="math notranslate nohighlight">\(0&lt;x&lt;q\)</span> then there exists a
<span class="math notranslate nohighlight">\((v-1,\{q-x-1,q-x+1\})\)</span>-GDD of type <span class="math notranslate nohighlight">\((q-1)^{q-x}(x+1)^1\)</span> (see <a class="reference internal" href="#greig99" id="id7"><span>[Greig99]</span></a> or
Theorem 2.50, section IV.2.3 of <a class="reference internal" href="database.html#designhandbook" id="id8"><span>[DesignHandbook]</span></a>). By adding to the ground
set one point contained in all groups of the GDD, one obtains a
<span class="math notranslate nohighlight">\((v,\{q-x-1,q-x+1,q,x+2\})\)</span>-PBD with exactly one set of size <span class="math notranslate nohighlight">\(x+2\)</span>.</p>
<p>Thus, assuming that we have the following:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(OA(k,q-x-1)-(q-x-1).OA(k,1)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(OA(k,q-x+1)-(q-x+1).OA(k,1)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(OA(k,q)-q.OA(k,1)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(OA(k,x+2)\)</span></p></li>
</ul>
<p>Then we can build from the PBD an <span class="math notranslate nohighlight">\(OA(k,v)\)</span>.</p>
<p>Construction of the PBD (shared by Julian R. Abel):</p>
<blockquote>
<div><p>Start with a resolvable <span class="math notranslate nohighlight">\((q^2,q,1)\)</span>-BIBD and put the points into a <span class="math notranslate nohighlight">\(q\times q\)</span>
array so that rows form a parallel class and columns form another.</p>
<p>Now delete:</p>
<ul class="simple">
<li><p>All <span class="math notranslate nohighlight">\(x(q-1)\)</span> points from the first <span class="math notranslate nohighlight">\(x\)</span> columns and not in the first
row</p></li>
<li><p>All <span class="math notranslate nohighlight">\(q-x\)</span> points in the last <span class="math notranslate nohighlight">\(q-x\)</span> columns AND the first row.</p></li>
</ul>
<p>Then add a point <span class="math notranslate nohighlight">\(p_1\)</span> to the blocks that are rows. Add a second point
<span class="math notranslate nohighlight">\(p_2\)</span> to the <span class="math notranslate nohighlight">\(q-x\)</span> blocks that are columns of size <span class="math notranslate nohighlight">\(q-1\)</span>, plus the first
row of size <span class="math notranslate nohighlight">\(x+1\)</span>.</p>
</div></blockquote>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">k,q,x</span></code> – integers such that <span class="math notranslate nohighlight">\(0&lt;x&lt;q\)</span> and such that Sage can build:</p>
<blockquote>
<div><ul class="simple">
<li><p>A projective plane of order <span class="math notranslate nohighlight">\(q\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(OA(k,q-x-1)-(q-x-1).OA(k,1)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(OA(k,q-x+1)-(q-x+1).OA(k,1)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(OA(k,q)-q.OA(k,1)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(OA(k,x+2)\)</span></p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – (boolean) Whether to check that output is correct before
returning it. As this is expected to be useless (but we are cautious
guys), you may want to disable it whenever you want speed. Set to
<code class="docutils literal notranslate"><span class="pre">True</span></code> by default.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">explain_construction</span></code> (boolean) – return a string describing
the construction.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="orthogonal_arrays_find_recursive.html#sage.combinat.designs.orthogonal_arrays_find_recursive.find_q_x" title="sage.combinat.designs.orthogonal_arrays_find_recursive.find_q_x"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_q_x()</span></code></a></p></li>
<li><p><a class="reference internal" href="block_design.html#sage.combinat.designs.block_design.projective_plane" title="sage.combinat.designs.block_design.projective_plane"><code class="xref py py-func docutils literal notranslate"><span class="pre">projective_plane()</span></code></a></p></li>
<li><p><a class="reference internal" href="orthogonal_arrays.html#sage.combinat.designs.orthogonal_arrays.orthogonal_array" title="sage.combinat.designs.orthogonal_arrays.orthogonal_array"><code class="xref py py-func docutils literal notranslate"><span class="pre">orthogonal_array()</span></code></a></p></li>
<li><p><a class="reference internal" href="orthogonal_arrays.html#sage.combinat.designs.orthogonal_arrays.OA_from_PBD" title="sage.combinat.designs.orthogonal_arrays.OA_from_PBD"><code class="xref py py-func docutils literal notranslate"><span class="pre">OA_from_PBD()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.designs.orthogonal_arrays_build_recursive</span> <span class="kn">import</span> <span class="n">construction_q_x</span>
<span class="gp">sage: </span><span class="n">_</span> <span class="o">=</span> <span class="n">construction_q_x</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>

<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">designs</span><span class="o">.</span><span class="n">orthogonal_arrays</span><span class="o">.</span><span class="n">explain_construction</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">158</span><span class="p">))</span>
<span class="go">(q-x)-construction with q=16,x=6 from:</span>
<span class="go">   Malcolm Greig,</span>
<span class="go">   Designs from projective planes and PBD bases,</span>
<span class="go">   vol. 7, num. 5, pp. 341--374,</span>
<span class="go">   Journal of Combinatorial Designs, 1999</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<dl class="citation">
<dt class="label" id="greig99"><span class="brackets"><a class="fn-backref" href="#id7">Greig99</a></span></dt>
<dd><p>Designs from projective planes and PBD bases
Malcolm Greig
Journal of Combinatorial Designs
vol. 7, num. 5, pp. 341–374
1999</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.combinat.designs.orthogonal_arrays_build_recursive.three_factor_product">
<span class="sig-prename descclassname"><span class="pre">sage.combinat.designs.orthogonal_arrays_build_recursive.</span></span><span class="sig-name descname"><span class="pre">three_factor_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">explain_construction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.designs.orthogonal_arrays_build_recursive.three_factor_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an <span class="math notranslate nohighlight">\(OA(k+1,n_1n_2n_3)\)</span></p>
<p>The three factor product construction from <a class="reference internal" href="#dukesling14" id="id9"><span>[DukesLing14]</span></a> does the following:</p>
<blockquote>
<div><p>If <span class="math notranslate nohighlight">\(n_1\leq n_2\leq n_3\)</span> are such that there exists an
<span class="math notranslate nohighlight">\(OA(k,n_1)\)</span>, <span class="math notranslate nohighlight">\(OA(k+1,n_2)\)</span> and <span class="math notranslate nohighlight">\(OA(k+1,n_3)\)</span>, then there exists a
<span class="math notranslate nohighlight">\(OA(k+1,n_1n_2n_3)\)</span>.</p>
</div></blockquote>
<p>It works with a modified product of orthogonal arrays (<a class="reference internal" href="#rees93" id="id10"><span>[Rees93]</span></a>, <a class="reference internal" href="#rees00" id="id11"><span>[Rees00]</span></a>)
which keeps track of parallel classes in the <span class="math notranslate nohighlight">\(OA\)</span> (the definition is given
for transversal designs).</p>
<blockquote>
<div><p>A subset of blocks in an <span class="math notranslate nohighlight">\(TD(k,n)\)</span> is called a <span class="math notranslate nohighlight">\(c\)</span>-parallel class if
every point is covered exactly <span class="math notranslate nohighlight">\(c\)</span> times. A 1-parallel class is a
parallel class.</p>
</div></blockquote>
<p>The modified product:</p>
<blockquote>
<div><p>If there exists an <span class="math notranslate nohighlight">\(OA(k,n_1)\)</span>, and if there exists an <span class="math notranslate nohighlight">\(OA(k,n_2)\)</span> whose
blocks are partitionned into <span class="math notranslate nohighlight">\(s\)</span> <span class="math notranslate nohighlight">\(n_1\)</span>-parallel classes and <span class="math notranslate nohighlight">\(n_2-sn_1\)</span>
parallel classes, then there exists an <span class="math notranslate nohighlight">\(OA(k,n_1n_2)\)</span> whose blocks can
be partitionned into <span class="math notranslate nohighlight">\(sn_1^2\)</span> parallel classes and
<span class="math notranslate nohighlight">\((n_1n_2-sn_1^2)/n_1=n_2-sn_1\)</span> <span class="math notranslate nohighlight">\(n_1\)</span>-parallel classes.</p>
<p>Proof:</p>
<ul>
<li><p>The product of the blocks of a parallel class with an <span class="math notranslate nohighlight">\(OA(k,n_1)\)</span>
yields an <span class="math notranslate nohighlight">\(n_1\)</span>-parallel class of an <span class="math notranslate nohighlight">\(OA(k,n_1n_2)\)</span>.</p></li>
<li><p>The product of the blocks of a <span class="math notranslate nohighlight">\(n_1\)</span>-parallel class of <span class="math notranslate nohighlight">\(OA(k,n_2)\)</span>
with an <span class="math notranslate nohighlight">\(OA(k,n_1)\)</span> can be done in such a way that it yields <span class="math notranslate nohighlight">\(n_1n_2\)</span>
parallel classes of <span class="math notranslate nohighlight">\(OA(k,n_1n_2)\)</span>. Those classes cover exactly the
pairs that would have been covered with the usual product.</p>
<p>This can be achieved by simple cyclic permutations. Let us build the
product of the <span class="math notranslate nohighlight">\(n_1\)</span>-parallel class <span class="math notranslate nohighlight">\(\mathcal P\subseteq OA(k,n_2)\)</span>
with <span class="math notranslate nohighlight">\(OA(k,n_1)\)</span>: when computing the product of <span class="math notranslate nohighlight">\(P\in\mathcal P\)</span> with
<span class="math notranslate nohighlight">\(B^1\in OA(k,n_1)\)</span> the <span class="math notranslate nohighlight">\(i\)</span>-th coordinate should not be <span class="math notranslate nohighlight">\((B^1_i,P_i)\)</span>
but <span class="math notranslate nohighlight">\((B^1_i+r,P_i)\)</span> (the sum is mod <span class="math notranslate nohighlight">\(n_1\)</span>) where <span class="math notranslate nohighlight">\(r\)</span> is the number of
blocks of <span class="math notranslate nohighlight">\(\mathcal P\)</span> we have already processed whose <span class="math notranslate nohighlight">\(i\)</span>-th
coordinate is equal to <span class="math notranslate nohighlight">\(P_i\)</span> (note that <span class="math notranslate nohighlight">\(r&lt; n_1\)</span> as <span class="math notranslate nohighlight">\(\mathcal P\)</span> is
<span class="math notranslate nohighlight">\(n_1\)</span>-parallel).</p>
</li>
</ul>
</div></blockquote>
<p>With these tools, one can obtain the designs promised by the three factors
construction applied to <span class="math notranslate nohighlight">\(k,n_1,n_2,n_3\)</span> (thanks to Julian R. Abel’s help):</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Let <span class="math notranslate nohighlight">\(s\)</span> be the largest integer <span class="math notranslate nohighlight">\(\leq n_3/n_1\)</span>. Apply the product
construction to <span class="math notranslate nohighlight">\(OA(k,n_1)\)</span> and a resolvable <span class="math notranslate nohighlight">\(OA(k,n_3)\)</span> whose blocks
are partitionned into <span class="math notranslate nohighlight">\(s\)</span> <span class="math notranslate nohighlight">\(n_1\)</span>-parallel classes and <span class="math notranslate nohighlight">\(n_3-sn_1\)</span>
parallel classes. It results in a <span class="math notranslate nohighlight">\(OA(k,n_1n_3)\)</span> partitionned into
<span class="math notranslate nohighlight">\(sn_1^2\)</span> parallel classes plus <span class="math notranslate nohighlight">\((n_1n_3-sn_1^2)/n_1=n_3-sn_1\)</span>
<span class="math notranslate nohighlight">\(n_1\)</span>-parallel classes.</p></li>
<li><p>Add <span class="math notranslate nohighlight">\(n_3-n_1\)</span> parallel classes to every <span class="math notranslate nohighlight">\(n_1\)</span>-parallel class to turn
them into <span class="math notranslate nohighlight">\(n_3\)</span>-parallel classes. Apply the product construction to
this partitionned <span class="math notranslate nohighlight">\(OA(k,n_1n_3)\)</span> with a resolvable <span class="math notranslate nohighlight">\(OA(k,n_2)\)</span>.</p></li>
<li><p>As <span class="math notranslate nohighlight">\(OA(k,n_2)\)</span> is resolvable, the <span class="math notranslate nohighlight">\(n_2\)</span>-parallel classes of
<span class="math notranslate nohighlight">\(OA(k,n_1n_2n_3)\)</span> are actually the union of <span class="math notranslate nohighlight">\(n_2\)</span> parallel classes,
thus the <span class="math notranslate nohighlight">\(OA(k,n_1n_2n_3)\)</span> is resolvable and can be turned into an
<span class="math notranslate nohighlight">\(OA(k+1,n_1n_2n_3)\)</span></p></li>
</ol>
</div></blockquote>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">k,n1,n2,n3</span></code> (integers)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – (boolean) Whether to check that everything is going smoothly
while the design is being built. It is disabled by default, as the
constructor of orthogonal arrays checks the final design anyway.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">explain_construction</span></code> (boolean) – return a string describing
the construction.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="orthogonal_arrays_find_recursive.html#sage.combinat.designs.orthogonal_arrays_find_recursive.find_three_factor_product" title="sage.combinat.designs.orthogonal_arrays_find_recursive.find_three_factor_product"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_three_factor_product()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.designs.designs_pyx</span> <span class="kn">import</span> <span class="n">is_orthogonal_array</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.designs.orthogonal_arrays_build_recursive</span> <span class="kn">import</span> <span class="n">three_factor_product</span>

<span class="gp">sage: </span><span class="n">OA</span> <span class="o">=</span> <span class="n">three_factor_product</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">is_orthogonal_array</span><span class="p">(</span><span class="n">OA</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">OA</span> <span class="o">=</span> <span class="n">three_factor_product</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">is_orthogonal_array</span><span class="p">(</span><span class="n">OA</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">60</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">OA</span> <span class="o">=</span> <span class="n">three_factor_product</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">is_orthogonal_array</span><span class="p">(</span><span class="n">OA</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">140</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">OA</span> <span class="o">=</span> <span class="n">three_factor_product</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span> <span class="c1"># long time</span>
<span class="gp">sage: </span><span class="n">is_orthogonal_array</span><span class="p">(</span><span class="n">OA</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">8</span><span class="o">*</span><span class="mi">9</span><span class="o">*</span><span class="mi">9</span><span class="p">)</span>   <span class="c1"># long time</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">designs</span><span class="o">.</span><span class="n">orthogonal_arrays</span><span class="o">.</span><span class="n">explain_construction</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">648</span><span class="p">))</span>
<span class="go">Three-factor product with n=8.9.9 from:</span>
<span class="go">   Peter J. Dukes, Alan C.H. Ling,</span>
<span class="go">   A three-factor product construction for mutually orthogonal latin squares,</span>
<span class="go">   https://arxiv.org/abs/1401.1466</span>
</pre></div>
</div>
<p>REFERENCE:</p>
<dl class="citation">
<dt class="label" id="dukesling14"><span class="brackets"><a class="fn-backref" href="#id9">DukesLing14</a></span></dt>
<dd><p>A three-factor product construction for mutually orthogonal latin squares,
Peter J. Dukes, Alan C.H. Ling,
<a class="reference external" href="https://arxiv.org/abs/1401.1466">arXiv 1401.1466</a></p>
</dd>
<dt class="label" id="rees00"><span class="brackets"><a class="fn-backref" href="#id11">Rees00</a></span></dt>
<dd><p>Truncated Transversal Designs: A New Lower Bound on the Number of Idempotent MOLS of Side,
Rolf S. Rees,
Journal of Combinatorial Theory, Series A 90.2 (2000): 257-266.</p>
</dd>
<dt class="label" id="rees93"><span class="brackets"><a class="fn-backref" href="#id10">Rees93</a></span></dt>
<dd><p>Two new direct product-type constructions for resolvable group-divisible designs,
Rolf S. Rees,
Journal of Combinatorial Designs 1.1 (1993): 15-26.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.combinat.designs.orthogonal_arrays_build_recursive.thwart_lemma_3_5">
<span class="sig-prename descclassname"><span class="pre">sage.combinat.designs.orthogonal_arrays_build_recursive.</span></span><span class="sig-name descname"><span class="pre">thwart_lemma_3_5</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">complement</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">explain_construction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.designs.orthogonal_arrays_build_recursive.thwart_lemma_3_5" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an <span class="math notranslate nohighlight">\(OA(k,nm+a+b+c+d)\)</span></p>
<p><em>(When `d=0`)</em></p>
<p>According to <a class="reference internal" href="#thwarts" id="id12"><span>[Thwarts]</span></a> when <span class="math notranslate nohighlight">\(n\)</span> is a prime power and <span class="math notranslate nohighlight">\(a+b+c\leq n+1\)</span>, one
can build an <span class="math notranslate nohighlight">\(OA(k+3,n)\)</span> with three truncated columns of sizes <span class="math notranslate nohighlight">\(a,b,c\)</span> in
such a way that all blocks have size <span class="math notranslate nohighlight">\(\leq k+2\)</span>.</p>
<p>(in order to build a <span class="math notranslate nohighlight">\(OA(k,nm+a+b+c)\)</span> the following designs must also exist:
<span class="math notranslate nohighlight">\(OA(k,a)\)</span>, <span class="math notranslate nohighlight">\(OA(k,b)\)</span>, <span class="math notranslate nohighlight">\(OA(k,c)\)</span>, <span class="math notranslate nohighlight">\(OA(k,m+0)\)</span>, <span class="math notranslate nohighlight">\(OA(k,m+1)\)</span>, <span class="math notranslate nohighlight">\(OA(k,m+2)\)</span>)</p>
<p>Considering the complement of each truncated column, it is also possible to
build an <span class="math notranslate nohighlight">\(OA(k+3,n)\)</span> with three truncated columns of sizes <span class="math notranslate nohighlight">\(a,b,c\)</span> in such a
way that all blocks have size <span class="math notranslate nohighlight">\(&gt;k\)</span> whenever <span class="math notranslate nohighlight">\((n-a)+(n-b)+(n-c)\leq n+1\)</span>.</p>
<p>(in order to build a <span class="math notranslate nohighlight">\(OA(k,nm+a+b+c)\)</span> the following designs must also exist:
<span class="math notranslate nohighlight">\(OA(k,a)\)</span>, <span class="math notranslate nohighlight">\(OA(k,b)\)</span>, <span class="math notranslate nohighlight">\(OA(k,c)\)</span>, <span class="math notranslate nohighlight">\(OA(k,m+1)\)</span>, <span class="math notranslate nohighlight">\(OA(k,m+2)\)</span>, <span class="math notranslate nohighlight">\(OA(k,m+3)\)</span>)</p>
<p>Here is the proof of Lemma 3.5 from <a class="reference internal" href="#thwarts" id="id13"><span>[Thwarts]</span></a> enriched with explanations
from Julian R. Abel:</p>
<blockquote>
<div><p>For any prime power <span class="math notranslate nohighlight">\(n\)</span> one can build <span class="math notranslate nohighlight">\(k-1\)</span> MOLS by associating to every
nonzero <span class="math notranslate nohighlight">\(x\in \mathbb F_n\)</span> the latin square:</p>
<div class="math notranslate nohighlight">
\[M_x(i,j) = i+x*j \text{ where }i,j\in \mathbb F_n\]</div>
<p>In particular <span class="math notranslate nohighlight">\(M_1(i,j)=i+j\)</span>, whose <span class="math notranslate nohighlight">\(n\)</span> columns and lines are indexed by
the elements of <span class="math notranslate nohighlight">\(\mathbb F_n\)</span>. If we order the elements of <span class="math notranslate nohighlight">\(\mathbb F_n\)</span>
as <span class="math notranslate nohighlight">\(0,1,...,n-1,x+0,...,x+n-1,x^2+0,...\)</span> and reorder the columns
and lines of <span class="math notranslate nohighlight">\(M_1\)</span> accordingly, the top-left <span class="math notranslate nohighlight">\(a\times b\)</span> squares
contains at most <span class="math notranslate nohighlight">\(a+b-1\)</span> distinct symbols.</p>
</div></blockquote>
<p><em>(When</em> <span class="math notranslate nohighlight">\(d\neq 0\)</span> <em>)</em></p>
<p>If there exists an <span class="math notranslate nohighlight">\(OA(k+3,n)\)</span> with three truncated columns of sizes <span class="math notranslate nohighlight">\(a,b,c\)</span>
in such a way that all blocks have size <span class="math notranslate nohighlight">\(\leq k+2\)</span>, by truncating
arbitrarily another column to size <span class="math notranslate nohighlight">\(d\)</span> one obtains an <span class="math notranslate nohighlight">\(OA\)</span> with 4 truncated
columns whose blocks miss at least one value. Thus, following the proof
again one can build an <span class="math notranslate nohighlight">\(OA(k+4)\)</span> with four truncated columns of sizes
<span class="math notranslate nohighlight">\(a,b,c,d\)</span> with blocks of size <span class="math notranslate nohighlight">\(\leq k+3\)</span>.</p>
<p>(in order to build a <span class="math notranslate nohighlight">\(OA(k,nm+a+b+c+d)\)</span> the following designs must also
exist: <span class="math notranslate nohighlight">\(OA(k,a)\)</span>, <span class="math notranslate nohighlight">\(OA(k,b)\)</span>, <span class="math notranslate nohighlight">\(OA(k,c)\)</span>, <span class="math notranslate nohighlight">\(OA(k,d)\)</span>, <span class="math notranslate nohighlight">\(OA(k,m+0)\)</span>, <span class="math notranslate nohighlight">\(OA(k,m+1)\)</span>,
<span class="math notranslate nohighlight">\(OA(k,m+2)\)</span>, <span class="math notranslate nohighlight">\(OA(k,m+3)\)</span>)</p>
<p>As before, this also shows that one can build an <span class="math notranslate nohighlight">\(OA(k+4,n)\)</span> with four
truncated columns of sizes <span class="math notranslate nohighlight">\(a,b,c,d\)</span> in such a way that all blocks have size
<span class="math notranslate nohighlight">\(&gt;k\)</span> whenever <span class="math notranslate nohighlight">\((n-a)+(n-b)+(n-c)\leq n+1\)</span></p>
<p>(in order to build a <span class="math notranslate nohighlight">\(OA(k,nm+a+b+c+d)\)</span> the following designs must also
exist: <span class="math notranslate nohighlight">\(OA(k,n-a)\)</span>, <span class="math notranslate nohighlight">\(OA(k,n-b)\)</span>, <span class="math notranslate nohighlight">\(OA(k,n-c)\)</span>, <span class="math notranslate nohighlight">\(OA(k,d)\)</span>, <span class="math notranslate nohighlight">\(OA(k,m+1)\)</span>,
<span class="math notranslate nohighlight">\(OA(k,m+2)\)</span>, <span class="math notranslate nohighlight">\(OA(k,m+3)\)</span>, <span class="math notranslate nohighlight">\(OA(k,m+4)\)</span>)</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">k,n,m,a,b,c,d</span></code> – integers which must satisfy the constraints above. In
particular, <span class="math notranslate nohighlight">\(a+b+c\leq n+1\)</span> must hold. By default, <span class="math notranslate nohighlight">\(d=0\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">complement</span></code> (boolean) – whether to complement the sets, i.e. follow
the <span class="math notranslate nohighlight">\(n-a,n-b,n-c\)</span> variant described above.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">explain_construction</span></code> (boolean) – return a string describing
the construction.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="orthogonal_arrays_find_recursive.html#sage.combinat.designs.orthogonal_arrays_find_recursive.find_thwart_lemma_3_5" title="sage.combinat.designs.orthogonal_arrays_find_recursive.find_thwart_lemma_3_5"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_thwart_lemma_3_5()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.designs.orthogonal_arrays_build_recursive</span> <span class="kn">import</span> <span class="n">thwart_lemma_3_5</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.designs.designs_pyx</span> <span class="kn">import</span> <span class="n">is_orthogonal_array</span>
<span class="gp">sage: </span><span class="n">OA</span> <span class="o">=</span> <span class="n">thwart_lemma_3_5</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">is_orthogonal_array</span><span class="p">(</span><span class="n">OA</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">23</span><span class="o">*</span><span class="mi">7</span><span class="o">+</span><span class="mi">5</span><span class="o">+</span><span class="mi">7</span><span class="o">+</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">designs</span><span class="o">.</span><span class="n">orthogonal_arrays</span><span class="o">.</span><span class="n">explain_construction</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">408</span><span class="p">))</span>
<span class="go">Lemma 4.1 with n=13,m=28 from:</span>
<span class="go">   Charles J.Colbourn, Jeffrey H. Dinitz, Mieczyslaw Wojtas,</span>
<span class="go">   Thwarts in transversal designs,</span>
<span class="go">   Designs, Codes and Cryptography 5, no. 3 (1995): 189-197.</span>
</pre></div>
</div>
<p>With sets of parameters from <a class="reference internal" href="#thwarts" id="id14"><span>[Thwarts]</span></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">....: </span>   <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">78</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">....: </span>   <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">208</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">....: </span>   <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">208</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">....: </span>   <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">78</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">....: </span>   <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">79</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>                                       <span class="c1"># not tested -- too long</span>
<span class="gp">....: </span>    <span class="n">OA</span> <span class="o">=</span> <span class="n">thwart_lemma_3_5</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">complement</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>      <span class="c1"># not tested -- too long</span>
<span class="gp">....: </span>    <span class="k">assert</span> <span class="n">is_orthogonal_array</span><span class="p">(</span><span class="n">OA</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="o">*</span><span class="n">m</span><span class="o">+</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="o">+</span><span class="n">d</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># not tested -- too long</span>

<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">designs</span><span class="o">.</span><span class="n">orthogonal_arrays</span><span class="o">.</span><span class="n">explain_construction</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">1046</span><span class="p">))</span>
<span class="go">Lemma 3.5 with n=13,m=79,a=9,b=1,c=0,d=9 from:</span>
<span class="go">   Charles J.Colbourn, Jeffrey H. Dinitz, Mieczyslaw Wojtas,</span>
<span class="go">   Thwarts in transversal designs,</span>
<span class="go">   Designs, Codes and Cryptography 5, no. 3 (1995): 189-197.</span>
</pre></div>
</div>
<p>REFERENCE:</p>
<dl class="citation">
<dt class="label" id="thwarts"><span class="brackets">Thwarts</span><span class="fn-backref">(<a href="#id12">1</a>,<a href="#id13">2</a>,<a href="#id14">3</a>,<a href="#id15">4</a>)</span></dt>
<dd><p>Thwarts in transversal designs
Charles J.Colbourn, Jeffrey H. Dinitz, Mieczyslaw Wojtas.
Designs, Codes and Cryptography 5, no. 3 (1995): 189-197.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.combinat.designs.orthogonal_arrays_build_recursive.thwart_lemma_4_1">
<span class="sig-prename descclassname"><span class="pre">sage.combinat.designs.orthogonal_arrays_build_recursive.</span></span><span class="sig-name descname"><span class="pre">thwart_lemma_4_1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">explain_construction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.designs.orthogonal_arrays_build_recursive.thwart_lemma_4_1" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an <span class="math notranslate nohighlight">\(OA(k,nm+4(n-2))\)</span>.</p>
<p>Implements Lemma 4.1 from <a class="reference internal" href="#thwarts" id="id15"><span>[Thwarts]</span></a>.</p>
<blockquote>
<div><p>If <span class="math notranslate nohighlight">\(n\equiv 0,1\pmod{3}\)</span> is a prime power, then there exists a truncated
<span class="math notranslate nohighlight">\(OA(n+1,n)\)</span> whose last four columns have size <span class="math notranslate nohighlight">\(n-2\)</span> and intersect every
block on <span class="math notranslate nohighlight">\(1,3\)</span> or <span class="math notranslate nohighlight">\(4\)</span> values. Consequently, if there exists an
<span class="math notranslate nohighlight">\(OA(k,m+1)\)</span>, <span class="math notranslate nohighlight">\(OA(k,m+3)\)</span>, <span class="math notranslate nohighlight">\(OA(k,m+4)\)</span> and a <span class="math notranslate nohighlight">\(OA(k,n-2)\)</span> then there
exists an <span class="math notranslate nohighlight">\(OA(k,nm+4(n-2)\)</span></p>
<p>Proof: form the transversal design by removing one point of the
<span class="math notranslate nohighlight">\(AG(2,3)\)</span> (Affine Geometry) contained in the Desarguesian Projective
Plane <span class="math notranslate nohighlight">\(PG(2,n)\)</span>.</p>
</div></blockquote>
<p>The affine geometry on 9 points contained in the projective geometry
<span class="math notranslate nohighlight">\(PG(2,n)\)</span> is given explicitly in <a class="reference internal" href="#os64" id="id16"><span>[OS64]</span></a> (Thanks to Julian R. Abel for
finding the reference!).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">k,n,m</span></code> (integers)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">explain_construction</span></code> (boolean) – return a string describing
the construction.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="orthogonal_arrays_find_recursive.html#sage.combinat.designs.orthogonal_arrays_find_recursive.find_thwart_lemma_4_1" title="sage.combinat.designs.orthogonal_arrays_find_recursive.find_thwart_lemma_4_1"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_thwart_lemma_4_1()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">designs</span><span class="o">.</span><span class="n">orthogonal_arrays</span><span class="o">.</span><span class="n">explain_construction</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">408</span><span class="p">))</span>
<span class="go">Lemma 4.1 with n=13,m=28 from:</span>
<span class="go">   Charles J.Colbourn, Jeffrey H. Dinitz, Mieczyslaw Wojtas,</span>
<span class="go">   Thwarts in transversal designs,</span>
<span class="go">   Designs, Codes and Cryptography 5, no. 3 (1995): 189-197.</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<dl class="citation">
<dt class="label" id="os64"><span class="brackets"><a class="fn-backref" href="#id16">OS64</a></span></dt>
<dd><p>Finite projective planes with affine subplanes,
T. G. Ostrom and F. A. Sherk.
Canad. Math. Bull vol7 num.4 (1964)</p>
</dd>
</dl>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Orthogonal arrays (build recursive constructions)</a><ul>
<li><a class="reference internal" href="#functions">Functions</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="orthogonal_arrays.html"
                          title="previous chapter">Orthogonal arrays (OA)</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="orthogonal_arrays_find_recursive.html"
                          title="next chapter">Orthogonal arrays (find recursive constructions)</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/sage/combinat/designs/orthogonal_arrays_build_recursive.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="orthogonal_arrays_find_recursive.html" title="Orthogonal arrays (find recursive constructions)"
             >next</a> |</li>
        <li class="right" >
          <a href="orthogonal_arrays.html" title="Orthogonal arrays (OA)"
             >previous</a> |</li>
  <li class="nav-item nav-item-0">
    <a href="http://www.sagemath.org"><img src="../../../../_static/logo_sagemath_black.svg" class="sage-logo" title="Sage Logo"></a>
    
      <a href="../../../../../index.html">Sage 9.6 Documentation</a> &#187;
      
      <a href="../../../../index.html">Reference Manual</a> &#187;
      
      <a href="../../../index.html">Combinatorics</a> &#187;
    
  </li>

          <li class="nav-item nav-item-1"><a href="../../../module_list.html" >Comprehensive Module List</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Orthogonal arrays (build recursive constructions)</a></li> 
      </ul>
    </div>
  
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2022, The Sage Development Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* The sidebar toggle adapts its height to the bodywrapper height. */
    const resizeObserver = new ResizeObserver(entries => {
        tog.height(bod.height());
    });
    resizeObserver.observe(bod[0]);

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
  </script>
  <script type="text/javascript">
/* detex the document title by removing "\(", "\)", "\", "$" */
document.title = document.title.replace(/\\\(/g, '').replace(/\\\)/g, '').replace(/\\/g, '').replace(/\$/g, '');
  </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>